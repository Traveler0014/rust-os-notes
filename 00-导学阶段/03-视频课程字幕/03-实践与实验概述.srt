1
00:02:01,160 --> 00:02:04,740
后面还提了一些建议 也有很多同学

2
00:02:06,800 --> 00:02:12,640
这个调研委员会就是问了一下上学期的

3
00:02:12,640 --> 00:02:14,600
不是咱们这一届 咱们这一届正在上

4
00:02:14,600 --> 00:02:16,560
应该是上上学期 春季学期

5
00:02:16,560 --> 00:02:20,080
去年春季学期的一些同学的一些反馈

6
00:02:20,080 --> 00:02:22,580
包括我也看到咱北做了个调查问卷

7
00:02:22,580 --> 00:02:24,400
为什么要上这门课

8
00:02:26,400 --> 00:02:27,760
其实就是在于这门课

9
00:02:27,760 --> 00:02:34,580
我们一直说,我上编译课的时候也说,这是计算机系的专业核心课程,我上

10
00:02:34,580 --> 00:02:38,240
超级统课也说,这是计算机系的专业核心课程,大家听了都听烦了。

11
00:02:39,520 --> 00:02:46,520
但是为什么它是计算机系的核心课程?这个大家想了没有?如果你是老师,你怎么来

12
00:02:46,520 --> 00:02:47,660
回答这个为什么?

13
00:02:48,140 --> 00:03:01,900
主持人:"这是一个问题。有同学愿意回答吗?这是我期望上课的一种交

14
00:03:01,900 --> 00:03:09,480
互方式,不是说为难同学。你们觉得为什么呢?还是觉得你们也觉得根本就不算是核

15
00:03:09,480 --> 00:03:17,020
心课程?我抽一个我还认识,上编译课我还比较熟。这个分就赔了。

16
00:03:18,020 --> 00:03:23,960
我觉得首先定义上,我们叫核心,就是咱们计算机科学技术系啊,不是那个就是什么

17
00:03:23,960 --> 00:03:29,360
比如说像是什么这个叫什么某些就奇怪的组织啊,什么那些什么编程学校那

18
00:03:29,360 --> 00:03:34,000
种就是让你三个月学会扎那种东西,作为一个学计算机的同学,我觉得

19
00:03:34,000 --> 00:03:39,480
啊,就是咱们这个计算机的底层的东西,咱们都要学会,就是这个程序,咱

20
00:03:39,480 --> 00:03:44,260
们不能只知道程序怎么运行的,而知道程序本身,它这个底下是什么东西,它

21
00:03:44,260 --> 00:03:47,000
连到硬件之间的桥挡是什么,首先第一层,

22
00:04:17,000 --> 00:04:22,420
就你拿一台计算机,这个计算机摆在这儿,你把这里面的编辑器去

23
00:04:22,420 --> 00:04:26,180
掉,你觉得这里面的程序能够生成出执行程序吗?

24
00:04:26,240 --> 00:04:31,160
这是第一个。你把超级种去掉,这个计算机还能work吗?你把组成员里面

25
00:04:31,160 --> 00:04:37,060
的CPU去掉,它还能work吗?如果它不能work,它就不是核心,如果它不能work,它就是

26
00:04:37,060 --> 00:04:37,520
核心。

27
00:04:37,520 --> 00:04:43,600
如果以这个观点来衡量的话,那我们可以觉得好像既然你学专业学专业学专

28
00:04:43,600 --> 00:04:48,960
业学专业学专业学专业学专业学专业学专业学专业学专业

29
00:04:48,960 --> 00:04:48,980
学专业学专业学专业学专业学专业学专业学专业学专业学

30
00:04:48,980 --> 00:04:49,060
专业学专业学专业学专业学专业学专业学专业学专业学专

31
00:04:49,060 --> 00:04:58,240
业学专业学专业学专业学专业学专业学专业学专业学专业

32
00:04:58,240 --> 00:05:06,420
学专业学专业学专业学专业学专

33
00:05:37,420 --> 00:05:40,900
目的实际上也在于老师讲得比较嗨的时候

34
00:05:40,900 --> 00:05:43,080
其实你们可能没听懂

35
00:05:43,080 --> 00:05:45,900
或者你们确实有些还有一些不太清楚的地方

36
00:05:45,900 --> 00:05:48,120
但又不好意思问 那怎么办呢

37
00:05:48,120 --> 00:05:50,040
其实最有效的办法就是当场问

38
00:05:50,040 --> 00:05:53,260
我觉得当场问 简单的问题我当场回答

39
00:05:53,260 --> 00:05:54,820
复杂的问题我们课后回答

40
00:05:54,820 --> 00:05:57,340
或者在下方课的时候我还要做一些补充

41
00:05:57,340 --> 00:06:00,040
这个我觉得是一种更有效率的学习方式

42
00:06:00,040 --> 00:06:04,240
所以我鼓励 也是跟这个课资委沟通

43
00:07:04,840 --> 00:07:09,000
好 这一块我就有一个开场

44
00:07:10,520 --> 00:07:14,560
好 在讲今天这堂课之前 我还是稍微回顾一下

45
00:07:14,560 --> 00:07:19,840
之前我们上的课 之前上的课就是第一讲 讲了这个降价机的一个概论

46
00:07:19,840 --> 00:07:24,980
这里面其实很重要一点在于 你知道这个超级档并不是一成不变的

47
00:07:24,980 --> 00:07:30,060
很厉害这一点 它其实是在一个随着历史的发展 它一直在变化

48
00:07:30,560 --> 00:07:35,020
这个变化使得它的知识点其实也在变化,或者你们要掌握的东西也在变

49
00:07:35,020 --> 00:07:36,060
化。这是一个。

50
00:07:36,060 --> 00:07:40,800
第二个,你要去理解的是,这个超级桶它是一个普大软件,所以它会涉及到一个

51
00:07:40,800 --> 00:07:41,580
架构设计问题。

52
00:07:42,120 --> 00:07:45,280
对于一个算法而言,很难说我要去涉及一个软件架构。

53
00:07:45,740 --> 00:07:51,020
但对于OS而言,因为它比较庞大,所以你要去考虑一个组织结构问题。

54
00:07:51,320 --> 00:07:57,040
所以这是在超级桶的结构这一块和architecture这一块,你要去了解。

55
00:07:57,760 --> 00:08:00,660
第三个 我觉得我们第一堂讲的时候

56
00:08:00,660 --> 00:08:03,160
就让大家试试所谓的Unix Linux

57
00:08:03,160 --> 00:08:05,920
其实更多的是让大家知道

58
00:08:06,700 --> 00:08:10,220
最基本的那些程序 小程序 应用程序

59
00:08:10,680 --> 00:08:13,380
它已经体现了OS要干的事情

60
00:08:14,440 --> 00:08:17,640
所以你是站在一个使用者的角度去理解OS

61
00:08:17,640 --> 00:08:22,140
这是我们第一堂课 想给大家讲一内容

62
00:08:22,140 --> 00:08:25,840
我们第二堂课 第二堂课讲第二节

63
00:08:25,840 --> 00:08:33,160
没讲完,我们今天会讲完,然后还会讲第三条。第二条讲什么呢?就是讲理论联系

64
00:08:33,160 --> 00:08:39,000
实践,或者应该叫实践来指导原理或者指导理论。

65
00:08:39,520 --> 00:08:47,540
我们就会介绍一下我们会给大家在政论课中会涉及到的一些OS,你可能不是

66
00:08:47,540 --> 00:08:52,360
从头写,但你至少知道怎么去写,写出各种各样的OS。

67
00:10:22,360 --> 00:10:26,780
我们三节课就可以 所以这个其实是可以的

68
00:10:26,780 --> 00:10:29,320
这个我觉得是完全没有问题 所以可以看到

69
00:10:29,320 --> 00:10:32,920
OS并不像大家想象中那么庞大复杂

70
00:10:32,920 --> 00:10:36,360
OS就是为了满足应用需求存在的一个系统软件而已

71
00:10:38,640 --> 00:10:46,840
好 这是对上堂课的简单的一个总结

72
00:10:46,840 --> 00:10:50,760
然后我再讲完这我再问一下

73
00:10:50,760 --> 00:10:52,060
就是回顾一下

74
00:10:52,860 --> 00:10:54,780
第一是我总结 第二我想提一些小问题

75
00:10:54,780 --> 00:11:01,160
这样能够让大家对你们之前的内容还有点印象

76
00:11:01,160 --> 00:11:02,840
这样才能更好理解这堂课的内容

77
00:11:03,340 --> 00:11:06,980
第一个问题是 比如说在这里面我说Compiler和OS

78
00:11:06,980 --> 00:11:11,840
我的问题是Compiler和OS他们之间要达到什么样的一些共识

79
00:11:12,420 --> 00:11:16,620
通过你了解这个第二节或者你还有点回忆的话

80
00:11:16,620 --> 00:11:17,820
他们的共识是什么

81
00:11:17,820 --> 00:11:19,940
他们在某些事情上达到共识

82
00:11:50,640 --> 00:11:52,800
关于系统调用的接口

83
00:11:52,800 --> 00:11:57,540
错 我直接说错 说错了也没什么关系

84
00:11:57,540 --> 00:12:01,860
因为系统调用编辑器根本不用去理解系统调用

85
00:12:01,860 --> 00:12:03,540
你看我们写编辑器的时候

86
00:12:03,540 --> 00:12:06,220
大家都上过编辑器课 编译员课 做了那么多实验

87
00:12:06,220 --> 00:12:08,860
什么时候要去了解系统调用了 没有

88
00:12:09,500 --> 00:12:14,080
所以系统调用不是编辑器和操作系统的共识

89
00:12:14,080 --> 00:12:24,060
主持人:"子令集是他们俩的base,就是我们组成原理,是编译和操作系

90
00:12:24,060 --> 00:12:30,320
统的一个base子令集。但是子令集没有同性同,那个子令集太存在了,也是正

91
00:12:30,320 --> 00:12:38,140
常可以work的。所以子令集也不是他们的共识。什么是他们的共识?"

92
00:12:38,980 --> 00:12:45,080
你们还是在于要去理解这个Compiler到底干了啥。

93
00:12:45,580 --> 00:12:48,860
它在生成那些指令的时候,还生成了一个很重要的信息。

94
00:12:49,460 --> 00:12:56,200
每个指令和每个数据的地址,地址是OS和Compiler之间的一个共

95
00:12:56,200 --> 00:12:57,140
识。

96
00:12:58,260 --> 00:13:03,100
大家想想,我Compiler生成了一个大代码,这个代码在哪儿执行,它其实定

97
00:13:03,100 --> 00:13:03,400
好了。

98
00:13:03,400 --> 00:13:05,320
OIS要加整个代码去执行

99
00:13:05,320 --> 00:13:07,760
一定要放到那个同样的地址空间去执行

100
00:13:07,760 --> 00:13:10,500
是吧 这是他们的共识

101
00:13:10,500 --> 00:13:11,400
OK 所以

102
00:13:12,560 --> 00:13:14,060
听课和回答问题

103
00:13:14,060 --> 00:13:15,100
也是不一样的

104
00:13:15,100 --> 00:13:17,200
就是你听完课也不一定回答不了问题

105
00:13:17,200 --> 00:13:19,880
需要你去理解

106
00:13:19,880 --> 00:13:20,940
而不是背

107
00:13:20,940 --> 00:13:23,760
背没有用 这是我想强调的

108
00:13:23,760 --> 00:13:25,060
第二点

109
00:13:25,060 --> 00:13:27,960
第二个问题是硬件和软件的关系问题

110
00:13:29,260 --> 00:13:30,060
就是我们

111
00:13:30,060 --> 00:13:31,620
这里面没有用真实硬件

112
00:13:31,620 --> 00:13:39,760
但是我们也用了一个模拟器 qme来代替我们的硬件来启动os

113
00:13:41,700 --> 00:13:51,100
我想问的是 qme启动之后硬件做了啥事就能够让os起起来

114
00:13:56,080 --> 00:13:58,060
这个问题我觉得应该听清楚了

115
00:13:58,060 --> 00:14:00,000
这位同学能回答一下吗

116
00:14:07,140 --> 00:14:14,080
就是硬件启动之后,它怎么怎么就能够让OS启动,怎么就跑到OS启动,就

117
00:14:14,080 --> 00:14:17,860
加电了一下之后,怎么就OS就启起来了,就跟你开机一样,你现在开机很正

118
00:14:17,860 --> 00:14:22,600
常,我开了机这个窗户就启起来了,但实际上就是我们说你要去理解计判

119
00:14:22,600 --> 00:14:28,820
机,就是我觉得上这么一课就是其实就是在理解计判机,所以我就问你这个问题,你身为

120
00:14:28,820 --> 00:14:31,600
计判机器的同学,你应该能回答这个问题,但是你要去理解计判机,就是我觉得

121
00:14:31,600 --> 00:14:31,600
上这么一课就是其实就是在理解计判机,所以我就问你这个问题,你身为计判机

122
00:14:31,600 --> 00:14:31,600
器的同学,你应该能回答这个问题,但是你要去理解计判机,就是我觉得上这么一

123
00:14:31,600 --> 00:14:31,600
课就是

124
00:14:31,600 --> 00:14:39,740
飞机上的一些同学咱们不在乎,回答不了是吗?没关系,你看完我说的

125
00:14:39,740 --> 00:14:43,420
问题,大家答错了是很好的事情,这样至少我可以帮大家回答。

126
00:14:46,340 --> 00:14:51,940
我们说QML里面,其实它模拟了一块ROM,大家学的组成员里面都应

127
00:14:51,940 --> 00:14:57,020
该知道ROM是什么东西,ROM里面放的是一段数据,那段数据也是一段

128
00:14:57,020 --> 00:14:57,480
代码。

129
00:15:27,560 --> 00:15:35,600
但这个其实如果再细化,你会发现我们的硬件和 OS 中间还有一个东西

130
00:15:35,600 --> 00:15:37,420
我们称之为 Bootloader

131
00:15:37,420 --> 00:15:39,120
Bootloader 来加这个 OS

132
00:15:39,120 --> 00:15:45,440
其实我们并没有说那个 Room 里面那一小段指令里面直接跳到 OS 的 CSE 去

133
00:15:45,440 --> 00:15:45,640
没有

134
00:15:46,180 --> 00:15:49,520
它跳到了我们叫 BIOS,差不多叫 BIOS

135
00:15:49,520 --> 00:15:51,880
然后我们这边叫 SBI,RESPI 就是 SBI

136
00:15:51,880 --> 00:15:53,480
那块 Bootloader 里面去

137
00:15:53,480 --> 00:15:55,440
那里面会去执行

138
00:15:55,440 --> 00:16:00,360
那个Botloader是一段软件,那个软件会完成进一步的处理化之后,最

139
00:16:00,360 --> 00:16:08,580
后会有一个降,降到OMS的入口地址,也意味着Botloader和Qme

140
00:16:08,580 --> 00:16:12,740
o或者我们的硬件有一个共识,硬件它知道跳哪儿去,下着Botloader的

141
00:16:12,740 --> 00:16:17,840
一个骑士地址,他们这个骑士地址也是,这个地址就很重要,地址有一个共识,B

142
00:16:17,840 --> 00:16:22,540
otloader和OS之间也有共识,因为Botloader需要跳到OS去执行。

143
00:16:23,620 --> 00:16:30,460
这预先他们之间达成的共识,这共识使得Bootloader可以跳到OS上

144
00:16:30,460 --> 00:16:31,780
去执行。

145
00:16:32,500 --> 00:16:37,740
所以你看我讲这些其实都在于,你要说知道之后其实也不算啥,就在于你知

146
00:16:37,740 --> 00:16:37,980
不知道。

147
00:16:39,480 --> 00:16:45,180
有一点你要知道就是我们在讲Compiler OS还有CPU,

148
00:16:45,180 --> 00:16:52,620
其实在讲一些对他们那些更深层次的或者更全面的一个理解

149
00:16:52,620 --> 00:16:54,700
而不是说集中在那一点

150
00:16:54,700 --> 00:16:57,540
你光到的CPU其实你也不知道怎么把外置提起来

151
00:16:58,380 --> 00:16:59,580
就这个基本道理

152
00:17:00,900 --> 00:17:08,440
好 那我大致花了一点时间给大家回顾了一下这个内容

153
00:17:08,440 --> 00:17:13,160
也让大家再去理解一下我们要讲的内容到底要达成什么效果

154
00:17:13,160 --> 00:17:14,860
我们接下来看看第四节

155
00:17:16,540 --> 00:17:17,620
第四节干啥

156
00:17:17,620 --> 00:17:20,720
第四节是偏实践

157
00:17:20,720 --> 00:17:24,960
通过实践更好地理解

158
00:17:25,460 --> 00:17:26,600
我们的OS

159
00:17:26,600 --> 00:17:28,760
一个简单的OS 立不OS怎么回事

160
00:17:30,000 --> 00:17:35,100
这里面大致的要讲的内容还是比较多的

161
00:17:35,100 --> 00:17:36,860
就有一个OS的目标

162
00:17:36,860 --> 00:17:37,880
他要干啥

163
00:17:39,400 --> 00:17:40,720
知道要干啥之后

164
00:17:41,280 --> 00:17:42,600
他解什么样的问题

165
00:17:42,600 --> 00:17:48,480
然后就我为了解决问题,我有什么样的一个总体的设计思路,然后这种设计

166
00:17:48,480 --> 00:17:50,780
思路是不是以前有过,所以有历史背景。

167
00:17:51,320 --> 00:17:55,140
然后还讲具体操作步骤和这个具体的软件设计,就是Design,看我们怎么去

168
00:17:55,140 --> 00:17:57,500
Design这个LibreOS,这是我们要干的事情。

169
00:17:58,560 --> 00:18:01,720
先看第一个,听话目标,就是我们要做OS了。

170
00:18:01,720 --> 00:18:08,840
所谓做OS其实把它放在一个更广义的角度来说

171
00:18:08,840 --> 00:18:12,720
我们就是要给我们的应用程序提供一套更方便的指令环境

172
00:18:13,400 --> 00:18:15,100
这个指令环境的词第一次出现

173
00:18:15,100 --> 00:18:21,720
这也是我从咱们这个课之尾得到的一个反馈

174
00:18:22,240 --> 00:18:25,020
就是超系统的这个概念特别多

175
00:18:26,040 --> 00:18:29,080
这是符合计算机这个方向的一个特点

176
00:18:29,080 --> 00:18:30,160
喜欢造新词

177
00:18:30,160 --> 00:18:36,120
就你看到就像你经常造星辰的大数据、小数据、云计算、海军算、湖

178
00:18:36,120 --> 00:18:37,180
计算什么都有

179
00:18:37,860 --> 00:18:42,780
这种东西,我理解造星辰我们尽量控制星辰

180
00:18:42,780 --> 00:18:44,900
我们这些评论都还是尽量的有限一点

181
00:18:44,900 --> 00:18:50,160
这样使得大家在理解这个问题上不会特别的麻烦

182
00:18:50,160 --> 00:18:51,240
想不到这是一个

183
00:18:51,240 --> 00:18:55,020
第二个,这个定义尽量会有一个解释

184
00:18:55,020 --> 00:18:58,100
不光是给了一个,比如我一开始做PBG的时候

185
00:19:28,460 --> 00:19:30,140
先给职业环境给了一个定义

186
00:19:30,140 --> 00:19:31,000
职业环境是什么意思呢

187
00:19:31,000 --> 00:19:33,360
这负责给旗上执行的软件

188
00:19:33,360 --> 00:19:36,540
提供相应的公共和资源的多层次软硬件系统

189
00:19:37,260 --> 00:19:39,500
所以这些环境包含了软件和硬件

190
00:19:39,500 --> 00:19:41,260
当然你在这个软件系统里面

191
00:19:41,780 --> 00:19:43,760
你会重点关注一下

192
00:19:43,760 --> 00:19:47,160
对于我们比如说我们这个Lib OS二元

193
00:19:47,160 --> 00:19:48,700
你看这里面画的图很简单

194
00:19:48,700 --> 00:19:49,980
这个上面跑了个APP

195
00:19:49,980 --> 00:19:52,360
那么这个OS是做一个Lib存在的

196
00:19:52,360 --> 00:19:55,540
那意味着在这种情况下

197
00:19:55,540 --> 00:19:57,400
这个APP它所需要的职业环境

198
00:19:57,400 --> 00:20:00,000
其实包含了底下的一个处理器

199
00:20:00,000 --> 00:20:03,040
Numeric IO 中间一层的OS

200
00:20:03,040 --> 00:20:06,900
然后在上面是APP 这是原理

201
00:20:06,900 --> 00:20:09,640
一旦你要落到一个具体实现去的话

202
00:20:09,640 --> 00:20:13,500
你会发现可能会比这个抽象的结构图

203
00:20:13,500 --> 00:20:15,280
还要再详细一点

204
00:20:15,280 --> 00:20:19,380
因为发现在OS之下可能还有一个东西

205
00:20:19,880 --> 00:20:21,880
建立这个环节要达到什么样的目标

206
00:20:21,880 --> 00:20:25,460
就是要让应用和硬件隔离

207
00:20:25,460 --> 00:20:26,800
我们在应用前应用的时候

208
00:20:27,420 --> 00:20:31,660
我们一直认为,应用程序员和系统程序员一个最大的区别在于,应用程

209
00:20:31,660 --> 00:20:34,980
序员开发起来更加简洁,他不需要考虑那么多底层的细节。

210
00:20:35,100 --> 00:20:40,940
作为系统程序员,他需要考虑底层的系统细节。我们是牺牲自己,服务

211
00:20:40,940 --> 00:20:43,360
应用,服务应用开发者。

212
00:20:43,540 --> 00:20:49,060
这也是为什么应用开发者数量巨大的原因,系统开发者数量少的原因。这样公

213
00:20:49,060 --> 00:20:51,200
司也是不一样的,这是可以理解的。

214
00:20:51,200 --> 00:20:56,800
所以在这里面,我们要让应用和硬件隔离,

215
00:20:57,060 --> 00:21:00,600
减化应用访问硬件的复杂度和难度,这就是我们要达的目标。

216
00:21:01,600 --> 00:21:03,560
为了完成这个目标,我们要去设计一个OS。

217
00:21:05,620 --> 00:21:07,580
但这个目标,同学也有进化的目标。

218
00:21:08,140 --> 00:21:09,660
你们学的时候你们要干啥?

219
00:21:09,980 --> 00:21:14,660
证明给出了你们听完这两讲之后要达的目标。

220
00:21:15,120 --> 00:21:16,460
你们能够会……

221
00:21:16,460 --> 00:21:20,500
我理解是上这段课之前,你们大部分同学不会的,所以我在列出来。

222
00:21:21,200 --> 00:21:23,560
会编写编译运行逻辑程序

223
00:21:23,560 --> 00:21:25,280
直接跑到逻辑上 底下没有OS

224
00:21:25,280 --> 00:21:26,900
因为你们写的就是OS

225
00:21:26,900 --> 00:21:29,320
第二个懂得逻辑程序的函数调用

226
00:21:30,500 --> 00:21:32,420
为什么说函数调用你们都会

227
00:21:32,420 --> 00:21:34,680
你们很简单都很清楚

228
00:21:34,680 --> 00:21:36,940
经常写随便写个算法都会有函数调用

229
00:21:36,940 --> 00:21:38,240
为什么还是去懂

230
00:21:38,240 --> 00:21:39,740
不用去懂

231
00:21:39,740 --> 00:21:42,420
你需要理解逻辑程序是在汇编集

232
00:21:42,420 --> 00:21:45,600
机器集去理解函数调用怎么回事

233
00:21:45,600 --> 00:21:49,120
为此你需要去看懂汇编代码

234
00:21:49,120 --> 00:21:50,320
汇编代码也分两类

235
00:21:50,320 --> 00:21:51,680
一类是直接是对应到的

236
00:21:51,680 --> 00:21:55,540
我们说汇边代码直接对应到的是机器码

237
00:21:55,540 --> 00:21:57,300
就一条汇边代码就一条机器码

238
00:21:57,300 --> 00:21:58,660
但其实还有很多情况下

239
00:21:58,660 --> 00:22:00,980
一个汇边代码对应的不是一个机器码

240
00:22:00,980 --> 00:22:02,920
它是一个尾代码对应了好几条机器码

241
00:22:03,920 --> 00:22:06,060
这一点大家学边缘理理的时候

242
00:22:06,060 --> 00:22:08,720
你们仅仅是停留在汇边代码这一类的

243
00:22:08,720 --> 00:22:11,960
你会发现离OS的需求还差了一点

244
00:22:11,960 --> 00:22:14,400
所以通过OS的需求之后你会更清楚

245
00:22:14,940 --> 00:22:16,920
底层的机器要干啥

246
00:22:18,360 --> 00:22:26,340
还有初步看懂类型汇编,这是另外一个要求,你要懂得高级语言和低级语

247
00:22:26,340 --> 00:22:31,700
言它能够混合在一起编程,这种也是很少在你们现在写义务程序里面

248
00:22:31,700 --> 00:22:35,720
很少碰到的,很少我们没听说过Python里面写汇编程序,这比较

249
00:22:35,720 --> 00:22:35,840
少。

250
00:22:35,840 --> 00:22:38,600
但在我们写OS里面,这种情况经常出现

251
00:22:38,600 --> 00:22:41,300
所以你要知道怎么去把两者有机的结合起来

252
00:22:41,300 --> 00:22:42,700
也是一种能力的体现

253
00:22:42,700 --> 00:22:44,840
然后突破理解SBI调用

254
00:22:45,540 --> 00:22:47,060
我还不知道SBI是啥

255
00:22:47,560 --> 00:22:50,040
但看起来都是一些耗子一些事情

256
00:22:50,040 --> 00:22:53,160
感觉大家觉得好像我就知道这些东西

257
00:22:53,160 --> 00:22:55,040
好像有啥用的,没啥用

258
00:22:55,800 --> 00:22:57,700
还是有用的,至少你懂这些知识的时候

259
00:22:57,700 --> 00:23:00,440
你会写一个超级统,叫做3A统超级统

260
00:23:30,900 --> 00:23:35,760
对,这就是我想大家能够知道的,其实大家还是不知道的。

261
00:23:36,320 --> 00:23:43,540
对,API是Application Programming或者Program Interface,应用编程接口。

262
00:23:43,840 --> 00:23:49,840
所以你写那个什么print,write,那就是函数,函数就是应用编程接口。

263
00:23:50,660 --> 00:23:52,420
所以大家写应用程序都是知道的。

264
00:23:52,540 --> 00:23:58,200
那ABI可能知道的人少一点了,因为那个B呢,A和I没错。

265
00:25:28,280 --> 00:25:30,900
它位于中间 但它计算下面就是硬件

266
00:25:31,580 --> 00:25:34,480
但你学了这个课之后你会发现

267
00:25:34,480 --> 00:25:38,480
有的时候它不是软件的最底层 底下还有一层软件

268
00:25:38,480 --> 00:25:40,860
就是那层SBI 为什么呢

269
00:25:40,860 --> 00:25:43,420
这后面我们会进一步展开去讲解

270
00:25:44,840 --> 00:25:46,720
所以我想说是你学了这个课之后

271
00:25:46,720 --> 00:25:48,320
你对计算机有深刻的认识

272
00:25:48,320 --> 00:25:50,360
回到这么一个idea

273
00:25:50,360 --> 00:25:53,640
好了 我们知道我们的课程目标

274
00:25:53,640 --> 00:25:55,200
和同学要达到的目标之后

275
00:25:55,200 --> 00:25:57,280
我们看看我们的总理思路是什么

276
00:26:00,260 --> 00:26:04,300
如果简单的看,和我们写用程序一样的,你要写一条代码能够通过编

277
00:26:04,300 --> 00:26:11,780
译,然后能够运行起来,只是这条代码比较特殊,都是逻辑程序。

278
00:26:11,860 --> 00:26:19,900
逻辑程序就是Biometric Machine,逻辑程序的话就是底下没有OS,这就是逻辑程序,

279
00:26:19,940 --> 00:26:21,100
简单的可以这么来理解。

280
00:26:51,100 --> 00:26:52,440
这个时候需要考虑

281
00:26:52,440 --> 00:26:55,420
第三个运行,运行也一样,像是地址空间问题

282
00:26:55,420 --> 00:26:57,460
那你这个地址放在哪儿

283
00:26:57,460 --> 00:27:05,080
其实需要去和我们的 compiler 和我们底层支持 OS 的 bootloader 要达成一个共识

284
00:27:05,080 --> 00:27:07,320
这个地址需要去理解

285
00:27:07,320 --> 00:27:11,260
同时,应用程序在执行之前,它一定有处置化的过程

286
00:27:11,260 --> 00:27:13,840
这个处置化也需要我们去考虑

287
00:27:13,840 --> 00:27:19,220
这就使得我们考虑的问题会比写一般的应用程序要多不少

288
00:27:19,220 --> 00:27:23,420
这就是我们其实这一节要动员讲的类似

289
00:27:23,420 --> 00:27:28,560
然后看看 我们想的这些问题好像看起来非常的原始

290
00:27:28,560 --> 00:27:31,200
但其实这就是我们第一代OS

291
00:27:31,200 --> 00:27:36,880
照八经是第一代OS的一个实际的情况

292
00:27:36,880 --> 00:27:41,720
第一代OS 大家都知道第一台计算机好像号称是

293
00:27:41,720 --> 00:27:43,540
Aniac计算机

294
00:27:43,540 --> 00:27:48,100
但其实现在说第一台计算机也不在美国 在欧洲

295
00:27:48,100 --> 00:27:49,780
这个也是一样

296
00:27:50,220 --> 00:27:51,440
说它第一个OS

297
00:27:51,440 --> 00:27:54,860
至少被Wikipedia定义为是第一个OS里面

298
00:27:54,860 --> 00:27:56,800
也是欧洲的 英国的

299
00:27:56,800 --> 00:27:59,580
英国的一个餐饮业的公司

300
00:27:59,580 --> 00:28:03,040
联合剑桥大学一起造了台计算机

301
00:28:03,040 --> 00:28:04,760
然后在上面给它写个OS

302
00:28:04,760 --> 00:28:06,600
Layout 1

303
00:28:06,600 --> 00:28:08,240
所以Layout 1这样它是软硬件系统

304
00:28:08,240 --> 00:28:09,020
它说混在一起

305
00:28:09,020 --> 00:28:10,100
它没叫OS这个名字

306
00:28:10,100 --> 00:28:11,520
但是其实它就是一个OS

307
00:28:11,520 --> 00:28:14,400
它的设计思路就是一个LibreOS的思路

308
00:28:14,400 --> 00:28:19,300
你看那这边这个图是它这个计算机的一个电路板

309
00:28:19,300 --> 00:28:20,540
有点像三叶虫一样

310
00:28:22,640 --> 00:28:26,200
那么在这里面它就当时的硬件

311
00:28:26,200 --> 00:28:27,460
如果大家来历史的话

312
00:28:27,460 --> 00:28:30,040
当时的硬件其实它的记存器的设计

313
00:28:30,040 --> 00:28:32,920
它的指令的设计都还不是很完备

314
00:28:32,920 --> 00:28:35,600
所以在这种不完美的情况下

315
00:28:35,600 --> 00:28:38,680
就发现实现一个函数调用都是比较困难的

316
00:28:38,680 --> 00:28:40,520
这里面的函数调用和这个子程序是一个概念

317
00:28:41,240 --> 00:28:44,520
所以当时参加这个NSARC这个项目的那个

318
00:28:45,300 --> 00:28:47,160
好像我记得当他是研究员还是学生

319
00:28:47,160 --> 00:28:49,260
他发明了一个子程序的概念

320
00:28:49,260 --> 00:28:51,560
能够在当时比较底层

321
00:28:51,560 --> 00:28:53,200
低级的一个计算机系统里面

322
00:28:53,200 --> 00:28:55,000
能够实现函数调整

323
00:28:55,000 --> 00:28:57,280
从而可以在这个

324
00:28:57,280 --> 00:28:59,200
nil计算机上开发大量的

325
00:28:59,200 --> 00:29:00,520
基于这种技术的

326
00:29:01,120 --> 00:29:03,580
系统子程序库就是函数库

327
00:29:03,580 --> 00:29:05,720
形成了最早的计算机

328
00:29:05,720 --> 00:29:06,520
系统的原型

329
00:29:06,520 --> 00:29:08,520
这种把称之为在

330
00:29:09,380 --> 00:29:14,680
四九年到五一年的过程开发过程中的第一个超级组所说的

331
00:29:15,460 --> 00:29:16,420
这是这一块

332
00:29:16,420 --> 00:29:18,620
这一块虽然是历史

333
00:29:18,620 --> 00:29:22,580
但其实并不意味着历史到现在不存在了

334
00:29:22,580 --> 00:29:26,640
现在的很多的一些简单的RTOS

335
00:29:26,640 --> 00:29:28,840
或者说面向专用领域的RTOS

336
00:29:28,840 --> 00:29:30,640
Real-time的Operating System

337
00:29:30,640 --> 00:29:32,940
或者叫Embedded Operating System就嵌入超级组

338
00:29:32,940 --> 00:29:34,400
那么就是这种设计思路

339
00:29:34,400 --> 00:29:35,680
它就是一个函数库

340
00:29:35,680 --> 00:29:39,560
所以它现在依然有它很大的一个办法空间

341
00:29:40,620 --> 00:29:45,560
这是关于历史的一个简单介绍

342
00:29:46,240 --> 00:29:48,180
第三个讲一下实践步骤

343
00:29:48,180 --> 00:29:52,340
这个实践步骤其实就是建好开发环境

344
00:29:52,340 --> 00:29:53,320
我已经提到了

345
00:29:53,320 --> 00:29:55,680
我不知道是不是大家都已经建了开发环境

346
00:29:55,680 --> 00:29:59,940
在你的机器上已经建好开发环境了

347
00:29:59,940 --> 00:30:02,080
我觉得像这位红衣服同学肯定已经没建好

348
00:30:02,080 --> 00:30:04,220
如果你拿的是一个Pad的本的话

349
00:30:04,220 --> 00:30:05,960
我不觉得派的轮胎能够跑起来

350
00:30:06,360 --> 00:30:07,300
你认识派的吗

351
00:30:11,000 --> 00:30:11,740
不是这个本

352
00:30:15,480 --> 00:30:17,060
那我理解错了

353
00:30:17,060 --> 00:30:19,300
我还以为你在他们建立一个开发环境

354
00:30:19,300 --> 00:30:20,220
那比较厉害

355
00:30:22,280 --> 00:30:23,440
但也不是不可能

356
00:30:23,440 --> 00:30:26,760
其实我们就拿了一个类似于数位派的小板子

357
00:30:26,760 --> 00:30:27,680
那就是一台接线机

358
00:30:27,680 --> 00:30:29,000
我可以在他们跑个电竞池

359
00:30:29,000 --> 00:30:30,320
然后接好开发环境

360
00:30:30,320 --> 00:30:31,260
是没问题的

361
00:30:31,260 --> 00:30:32,320
只是性能慢一点而已

362
00:31:02,320 --> 00:31:10,000
服务完成输出,输出和关机没有输入,然后在这过程中,我们其实要去理解

363
00:31:10,000 --> 00:31:10,380
什么呢?

364
00:31:11,780 --> 00:31:16,160
就是通过这个操作步骤,就要理解运行程序的内存空间和占。

365
00:31:16,440 --> 00:31:22,320
你发现我们这里面设计到的就是一些软件和硬件的一个要打交道的地方,

366
00:31:22,480 --> 00:31:24,620
特别是对Memory的一个使用问题。

367
00:31:25,780 --> 00:31:32,140
这给了一个大致的步骤,就是从哪取测试,就LibreOS这个例子

368
00:31:32,140 --> 00:31:37,300
我们说3A从LibreOS,很简单就是Git,大家都会用Git,然后再Make一下就可以

369
00:31:37,300 --> 00:31:38,360
跑起来了

370
00:31:39,460 --> 00:31:44,840
这是它跑开的效果,就是我就不同意了,至少你能看出来

371
00:31:44,840 --> 00:31:47,980
从这里面我们已经能看到一些眉目或者一些名堂了

372
00:31:49,260 --> 00:31:52,900
这个Hello World是我们应用程序的主体

373
00:31:52,900 --> 00:31:55,020
就是要打印一个字幕串

374
00:31:55,020 --> 00:31:56,740
在hello world之上

375
00:31:56,740 --> 00:31:59,760
你会发现它有一个什么叫Rust SBI的output

376
00:31:59,760 --> 00:32:01,600
这像是我们的bootloader

377
00:32:01,600 --> 00:32:04,460
它启动了我们这个OS

378
00:32:04,460 --> 00:32:05,900
就是绑着这个应用程序的OS

379
00:32:06,780 --> 00:32:08,280
然后这个应用程序

380
00:32:08,280 --> 00:32:09,980
除了打这个hello world之外

381
00:32:09,980 --> 00:32:11,520
我们的OS 我们的LibOS

382
00:32:11,520 --> 00:32:13,900
也打印了一系列的系统级的信息

383
00:32:13,900 --> 00:32:15,460
跟这个应用程序本身相关的

384
00:32:15,460 --> 00:32:18,900
比如说它的代码段在什么位置

385
00:32:19,740 --> 00:32:21,740
它的数据段在什么位置

386
00:32:22,360 --> 00:32:25,260
还有一个叫BSS段 后面会解释什么叫BSS

387
00:32:25,260 --> 00:32:28,740
就是把一些这个程序在内存中运行的时候的

388
00:32:28,740 --> 00:32:31,740
它的一些布局给打出来了

389
00:32:33,040 --> 00:32:35,920
最后还打了一个shutdown就是关机

390
00:32:35,920 --> 00:32:38,740
这是OS 干完事的时候才要干这个事情关机

391
00:32:39,980 --> 00:32:42,340
OK 这就是一个大致的执行结果

392
00:32:42,340 --> 00:32:45,860
如果大家有兴趣可以去试一下

393
00:32:45,860 --> 00:32:50,560
我想问一下有多少同学没有试过

394
00:32:50,560 --> 00:32:52,560
举下手看看 没有试过的可以举下手

395
00:32:55,160 --> 00:32:57,740
这又说明咱们这边很厉害啊 都试过

396
00:32:58,120 --> 00:33:00,380
这我不知道是 如果都试过了 非常好

397
00:33:00,380 --> 00:33:01,440
那我们可以讲得快一点

398
00:33:03,580 --> 00:33:06,100
好 那我们看看怎么来写这个OS

399
00:33:07,020 --> 00:33:10,660
了解一下 虽然是一个100多行的弹码

400
00:33:10,660 --> 00:33:13,820
但它也是比一般的算法还是这个弹码量要大一点

401
00:33:13,820 --> 00:33:15,300
结构也稍微复杂一点

402
00:33:15,300 --> 00:33:17,700
所以我们要看一下这个结构怎么来设计

403
00:33:17,700 --> 00:33:20,540
因为发现在你把这个OS下来之后

404
00:33:20,540 --> 00:33:27,380
发现它有两部分组成,第一部分是Bootloader,这部分我们不需要学员掌握,我们

405
00:33:27,380 --> 00:33:30,500
知道有这个存在,知道它有什么样的功能就行了。

406
00:33:31,720 --> 00:33:38,960
这个Bootloader是一个大三的本格上写的,它是华中科技大学的一个

407
00:33:38,960 --> 00:33:39,580
学生。

408
00:33:40,600 --> 00:33:47,240
在它大二暑假的时候,参加了一个OS夏令仪,然后它的一个成果就是RUST SBI,

409
00:33:47,660 --> 00:33:48,980
一个学生,蒋周琪。

410
00:33:51,720 --> 00:33:57,320
我觉得也不是竞争机专业,叫做网络安全专业,这个很不错的一个同学,就是他

411
00:33:57,320 --> 00:33:58,980
把这个写出来之后,我们就直接用上了。

412
00:33:59,640 --> 00:34:04,120
有了这个Bootloader之后,我们的重点在哪,写OS,Bootloader会加的这个

413
00:34:04,120 --> 00:34:04,360
OS。

414
00:34:04,880 --> 00:34:12,680
这个OS虽然是用的是Rust,我一直想说,我这里面想强调一点,也许这里面有

415
00:34:12,680 --> 00:34:16,220
很多同学没有用Rust来写OS,没关系。

416
00:34:16,220 --> 00:34:21,420
你把这里面讲解的就当成一个背景知识,我也不会讲那么detail的交搭组

417
00:34:21,420 --> 00:34:23,400
织编程,而是讲一个设计思路。

418
00:34:23,780 --> 00:34:29,160
所以这种设计思路和C和RUST没有太大的关系,当然不可避免的会涉

419
00:34:29,160 --> 00:34:31,940
及到一些RUST的一些术语等等,但我尽量会避免。

420
00:34:32,940 --> 00:34:41,500
所以发现,这也是昨天来自于咱们这个客资委的一个建议,我在这里面是把

421
00:34:41,500 --> 00:34:43,840
RUST的代码当成伪代码来给大家讲解,

422
00:34:43,840 --> 00:34:49,520
但是既是伟大,可能也会看不懂,觉得语法比较复杂等等。

423
00:34:49,740 --> 00:34:54,260
所以我会加足够的注释,使得你理解这个含义就行了。

424
00:34:54,520 --> 00:34:57,240
你不需要去理解它的语法,你理解它的含义。

425
00:34:57,640 --> 00:35:04,640
如果你觉得哪地方写得不够的话,给克志伟反映一下,这样我们可以去改进。

426
00:35:04,840 --> 00:35:07,980
我们希望是在不停的迭代和改进中的。

427
00:35:09,060 --> 00:35:11,620
好,你会发现在这个OS里面,它重点干了什么事呢?

428
00:35:11,620 --> 00:35:14,240
它那个应用程序的主体是在man函数里面

429
00:35:14,240 --> 00:35:15,520
这通常我们写应用程序也是一样

430
00:35:15,520 --> 00:35:16,700
写个man函数

431
00:35:16,700 --> 00:35:18,040
或者叫man.rs

432
00:35:18,040 --> 00:35:20,100
它是内核应用的主体

433
00:35:20,100 --> 00:35:22,020
然后为了能够支持那种应用跑起来

434
00:35:22,020 --> 00:35:27,660
你会发现它会建立一套支持print的一套酷

435
00:35:28,100 --> 00:35:29,620
它用print要打印

436
00:35:29,620 --> 00:35:32,060
这里面这个print包含了两大部分

437
00:35:32,060 --> 00:35:35,600
一部分是它本身的print的一个

438
00:35:35,600 --> 00:35:37,260
就大致上也是一样一个print

439
00:35:37,260 --> 00:35:38,800
这里面有类似一样的一个print

440
00:35:38,800 --> 00:35:40,540
它的一个大致的一个实验细节

441
00:35:40,540 --> 00:35:45,780
怎么去把一些数字变成字符串,变成字符串之后,

442
00:35:45,920 --> 00:35:53,020
最后是通过SBI,就是我们说的Cybervisor的Binary Interface,

443
00:35:53,820 --> 00:35:57,860
发出基于这个接口的一个请求,让底下的Bootloader,

444
00:35:57,940 --> 00:36:01,820
就是我们说的RUS SBI,帮我们去完成字符串的显示,

445
00:36:02,020 --> 00:36:03,160
通过串口显示出来。

446
00:36:03,480 --> 00:36:06,140
这是它的一个大致的过程,这是一部分。

447
00:36:07,300 --> 00:36:15,400
第二一部分,你会发现这里面有汇编,这个entry,我们叫entry.asm,这干什么呢?

448
00:36:15,480 --> 00:36:20,020
这是启动的时候一段代码,我们通常写应用程序的时候,启动就是从MAT开始。

449
00:36:20,500 --> 00:36:26,980
但其实在MAT之前,还有一段代码是完成对这个指引环境的促使化。

450
00:36:27,280 --> 00:36:30,000
这个指引环境,我前面已经提到什么叫指引环境。指引环境干什么呢?

451
00:36:30,000 --> 00:36:37,200
要把站给设置好,要把相应的一些Data段给处置化好

452
00:36:38,100 --> 00:36:41,660
干好这些之后,你才能够去执行MAT,才能够完成后续的那些工作

453
00:36:44,020 --> 00:36:47,220
这是整体的一个架构,其实有几个文件组成

454
00:36:47,220 --> 00:36:50,820
主体,就是应用程序主体只是一两张蛋嘛

455
00:36:50,820 --> 00:36:57,120
但实际上为了支持一两张蛋嘛,你还有启动部分和服务部分,两大部分的

456
00:36:57,120 --> 00:36:57,600
支撑

457
00:36:59,900 --> 00:37:05,280
这个大致的结构就讲到这 然后第二个讲怎么去定制内存布局 我们说

458
00:37:05,280 --> 00:37:06,600
其实他们的共识在内存

459
00:37:11,160 --> 00:37:16,120
这种图在编译课 在大家程序设计也许都会碰到过这种图

460
00:37:16,120 --> 00:37:22,020
这种图就是站在应用程序的角度 大家去理解它的应用程序在内存

461
00:37:22,020 --> 00:37:23,380
中的一个大致的一个布局

462
00:37:23,380 --> 00:37:26,280
这已经比较detail了 一般写Python程序

463
00:37:26,280 --> 00:37:30,260
写Java程序 看不到这种图 看这种图也是错的

464
00:37:30,980 --> 00:37:33,300
但是你写C程序 写RUS程序

465
00:37:33,300 --> 00:37:34,980
基本上就是要有这么一个结构

466
00:37:34,980 --> 00:37:38,080
这个结构里面会看出来 你整个应用程序在应用工业中

467
00:37:38,080 --> 00:37:44,040
会有所谓的代码段和数据段

468
00:37:44,040 --> 00:37:47,620
我们编辑器会把代码段的其实地址会设置好

469
00:37:47,620 --> 00:37:49,140
数据段的其实地址会设置好

470
00:37:49,140 --> 00:37:52,620
我们OS会基于它们之间达成共识 把它加到类型中去

471
00:37:52,620 --> 00:37:54,480
这就是我们一个大字的一个结构

472
00:37:54,480 --> 00:37:56,060
但在这个结构里面

473
00:37:56,060 --> 00:38:00,260
有两块区域是我们的

474
00:38:00,260 --> 00:38:01,920
有一块区域是我们的

475
00:38:01,920 --> 00:38:04,100
在这里面写的一块区域是我们的编辑

476
00:38:04,100 --> 00:38:05,560
没有涉及到的东西

477
00:38:05,560 --> 00:38:06,220
那一块

478
00:38:07,640 --> 00:38:08,820
有一块方框

479
00:38:09,600 --> 00:38:10,820
大家能看出来吗

480
00:38:16,480 --> 00:38:17,200
这个地方

481
00:38:17,200 --> 00:38:25,200
HIP,多一,多一这个东西其实是编辑没有搞的事情

482
00:38:25,200 --> 00:38:31,640
那谁在搞,是我们的底层的酷和OS在帮助我们来做这个事情

483
00:38:31,640 --> 00:38:35,660
就执行环境中的底层有一个系统酷,比如说C对STI是Leap C

484
00:38:35,660 --> 00:38:38,040
对Rust而言看一个Rust的一个STD酷

485
00:38:38,040 --> 00:38:43,300
它会帮我们去完成对这个空间的运行时的动态管理

486
00:38:43,300 --> 00:38:44,760
编辑看不到

487
00:38:46,720 --> 00:38:52,380
这里面的BSS名字叫做BSS,BSS其实是一个非常古老的一个术语,叫B

488
00:38:52,380 --> 00:38:53,660
lock Started by Symbol。

489
00:38:54,020 --> 00:38:59,180
当时iPyBam在制造它的机器的时候,给它的程序里面定义好的一块

490
00:38:59,180 --> 00:39:00,820
区域专门写了这么一个名字。

491
00:39:00,920 --> 00:39:05,400
这个名字有个特点,这个名字里面对那段放置的数据是程序中未

492
00:39:05,400 --> 00:39:08,680
初始化的全局变量,这叫BSS。

493
00:39:09,380 --> 00:39:15,680
这一块大家想想,C原理面怎么写出一段没有处置化的全局别呢?

494
00:39:19,980 --> 00:39:25,760
很简单,就前面有个inter-A封号,这就没处置化。说inter-A等于

495
00:39:25,760 --> 00:39:27,540
0封号,那就是处置化的全局别。

496
00:39:28,720 --> 00:39:31,740
处置化的全局别放在什么?放在Data专页,这里面有个Data专页,这是

497
00:39:31,740 --> 00:39:32,480
处置化的。

498
00:39:32,480 --> 00:39:37,600
没速度化的,放在,这里面列出,应该有一个,对,放在这儿,BSS段。

499
00:39:38,700 --> 00:39:44,040
那C为什么要这么来设计呢?简单啊,我少写了一个等于0,这是它灵活性

500
00:39:44,040 --> 00:39:45,100
的体现,简洁性的体现。

501
00:39:45,160 --> 00:39:50,160
但是RUS不允许,你给一个变量一定要有一个速度化的值,你如果没有速度化

502
00:39:50,160 --> 00:39:51,720
的值,那就是unsafe,就是不安全。

503
00:39:52,860 --> 00:39:57,080
这是他们的区别,就是RUS比较严谨一点。

504
00:39:58,000 --> 00:40:03,760
第二个,这个BSS段属于静态内存分配还是动态内存分配?

505
00:40:03,920 --> 00:40:07,800
静态内存分配就是说,在运行之前就已经分配好了,叫静态内存分配。

506
00:40:08,140 --> 00:40:12,880
动态内存分配是运行之后才分配的空间,叫动态内存分配。

507
00:40:13,040 --> 00:40:15,680
请问这个BSS算静态还是动态?

508
00:40:20,500 --> 00:40:28,980
因为它编辑前都已经确定了,这里面唯一的动态是hip。当然,你会发现,在

509
00:40:28,980 --> 00:40:39,480
运营过程中,这个stack比较特殊,它的其实例子是站底,但是它随着函数

510
00:40:39,480 --> 00:40:43,200
的调整,它不停地在动态的变化,这是stack的一个特点。

511
00:40:43,200 --> 00:40:54,580
就是它兼有静态和动态的一个属性。但是这个text会扩大和缩小吗?不会。如果你

512
00:40:54,580 --> 00:40:56,820
写的是正规的代码,是不会的。

513
00:40:58,400 --> 00:41:03,320
但是你如果写的是木马或者病毒,那是会的,因为它会扩展它的代码段,增加

514
00:41:03,320 --> 00:41:03,920
到新的内容。

515
00:41:04,640 --> 00:41:10,540
这种事情OS也会干,但OS用在好的地方,但超级统治病毒是用在坏地方,

516
00:41:10,580 --> 00:41:13,200
这是对于一个事情的一个良好的看法。

517
00:41:13,280 --> 00:41:20,580
但我们通常意义上来说,这个态势是不变的。所以你会发现,我一直给大家

518
00:41:20,580 --> 00:41:26,800
强调一点,超级统不是数学,它是一个工程,是人写的代码。

519
00:41:27,800 --> 00:41:32,520
所以人写人的这种灵活性使得它里面的定义很难是有一个唯一

520
00:41:32,520 --> 00:41:34,160
的一个精确的一个解释

521
00:41:34,160 --> 00:41:36,800
它会随着情况的变化而变化

522
00:41:37,760 --> 00:41:38,620
好,这个Data段

523
00:41:38,620 --> 00:41:42,360
Data段是用来专门放置一个粗组化的全局变量,是Data段

524
00:41:42,360 --> 00:41:47,220
它也是属于近代分配的,因为前面我们在写成绩的时候编系帮我们搞好

525
00:41:47,220 --> 00:41:53,240
Test是放代码的,而且还有一个特点,它是纸读的

526
00:41:56,600 --> 00:42:00,280
我们编辑在生成的时候会说这块tax的区域是属于指读区域

527
00:42:00,280 --> 00:42:03,480
这个我们OS也认 会认为这块区域是指读的

528
00:42:03,480 --> 00:42:07,900
但是OS会把它当成数据来处理

529
00:42:07,900 --> 00:42:08,860
大家想为什么

530
00:42:09,740 --> 00:42:14,780
因为它需要把这段tax的这段数据

531
00:42:14,780 --> 00:42:17,180
所谓tax的数据从一个地方拷到另一个地方去

532
00:42:17,180 --> 00:42:19,980
这拷贝的过程就是一种不是指读 就在写

533
00:42:20,700 --> 00:42:22,240
所以在写完之后

534
00:42:22,240 --> 00:42:24,920
写好了之后 放行动位置之后 它会把它视成纸图

535
00:42:24,920 --> 00:42:26,360
这是我们Y字要干的事情

536
00:42:27,960 --> 00:42:28,280
堆

537
00:42:28,280 --> 00:42:30,000
堆是动态分配的内存段

538
00:42:30,000 --> 00:42:33,040
可以动态的扩张或者减少

539
00:42:33,040 --> 00:42:36,040
我们调Mailup的时候就会动态的添加二堆上去

540
00:42:36,040 --> 00:42:38,600
调Free 这是C来写的

541
00:42:39,600 --> 00:42:42,400
就是这两个函数可以帮助我们把内存

542
00:42:42,400 --> 00:42:44,800
动态的添加二堆上去核冲 堆上去释放

543
00:42:44,800 --> 00:42:46,120
所以它就是动态变化的过程

544
00:42:49,020 --> 00:42:55,120
占 占有时候我们称之为堆占 更精确的说法就是step 就是一个字 占

545
00:42:55,900 --> 00:43:01,120
堆是hip 这是用户存放程序临时创建的局务变量用到的

546
00:43:02,700 --> 00:43:07,960
那堆和占它都是用来存变量的 动态存变量的 它们的区别在什么

547
00:43:07,960 --> 00:43:08,460
地方

548
00:43:08,460 --> 00:43:11,500
它们最大的区别在于性能的理解上面

549
00:44:46,840 --> 00:44:49,500
我这样讲是不是太细了 这样讲我觉得我

550
00:44:51,680 --> 00:44:53,600
好 大家先休息一下

551
00:44:54,840 --> 00:44:58,520
这是想解答大家觉得老师讲的没听懂的问题

552
00:44:58,520 --> 00:45:01,000
我知道是不是讲得太细了

553
00:45:01,000 --> 00:45:02,680
如果大家觉得特别的简单

554
00:45:02,680 --> 00:45:06,100
我建议大家直接回宿舍自己看书就行

555
00:45:06,100 --> 00:45:08,380
自己做实验看书没必要听这么高

556
00:45:08,380 --> 00:45:11,340
尤其是做大实验的同学 完全没必要听这么考

557
00:45:11,340 --> 00:45:13,740
你直接就回去把大实验早点做完

558
00:45:16,620 --> 00:45:20,720
然后就可以达个高分 就非常happy的就过了

559
00:45:44,840 --> 00:45:47,100
这个错了

560
00:50:07,820 --> 00:50:14,460
管理的数据类型是哪种类型的?是那种size在编译的时候无法判断

561
00:50:14,460 --> 00:50:19,700
大小的类型,所以这种无法判断大小的一些结构它适合放在嘴里

562
00:50:19,700 --> 00:50:20,660
面,不是放在栈里面。

563
00:50:20,700 --> 00:50:27,860
如果要放在栈里面,它一定要知道大小,因为这个栈的指令,就是我进入内核里

564
00:50:27,860 --> 00:50:31,860
面,要进入大盘数里面,我要去升级,挂局域空间,初学的时候要把局域

565
00:50:31,860 --> 00:50:34,480
空间释放掉,这个指令是我们编辑生成的。

566
00:50:34,480 --> 00:50:39,460
所以编辑器一定要在编辑手上知道这个Size固定是多少,如果它不知道固定是多少

567
00:50:39,460 --> 00:50:40,700
的话,那就没法去错。

568
00:50:41,060 --> 00:50:49,600
所以这种运行时才知道这个大小的数据或者数据框,它是需要我们通过放

569
00:50:49,600 --> 00:50:52,220
的堆来管理的,保证一定灵活性。

570
00:50:52,260 --> 00:50:57,820
这是灵活性和性能的一个折衷,取决于你这个应用的需求。

571
00:51:02,600 --> 00:51:07,240
然后这个站我们把这个站其实从这个意义上来看

572
00:51:07,700 --> 00:51:11,200
站开始什么 看成是一个临时数据的存放区域

573
00:51:11,200 --> 00:51:14,500
这个数据它的size是很清楚的

574
00:51:14,500 --> 00:51:16,600
很重要的size是多少次 很清楚

575
00:51:16,600 --> 00:51:20,720
那我们和OS编程和应用编程的区别在哪里

576
00:51:20,720 --> 00:51:25,880
OS编程需要理解站上的物理结构和机器级的内容

577
00:51:25,880 --> 00:51:31,500
所谓机械人物就要理解计程器,你要站在组成员里,交给你们计程

578
00:51:31,500 --> 00:51:37,520
器那个level,去理解我们这个站,这样才能够更好地知道这个站是什么组织的。

579
00:51:37,520 --> 00:51:39,880
而在我们写应用程序,其实不需要了解这些细节。

580
00:51:43,080 --> 00:51:47,100
有同学说我只是为了了解而了解吗?不是的,因为最后你要去构造站,你要

581
00:51:47,100 --> 00:51:47,840
去改造站。

582
00:51:48,160 --> 00:51:52,360
如果你不了解细节的话,当你改造的时候就会出错,所以只有了解细节才知道怎么

583
00:51:52,360 --> 00:51:52,780
去改。

584
00:51:54,520 --> 00:51:59,340
这是一个问题 我们先说两种全球变量 说了局部变量 那Static是什么变

585
00:51:59,340 --> 00:52:00,620
量 叫静态变量

586
00:52:00,620 --> 00:52:08,380
这静态变量位于这里面在哪个区域 静态变量

587
00:52:10,360 --> 00:52:17,740
对 取决于它有没有数字化 它如果有数字化了 它会放在Data段

588
00:52:17,740 --> 00:52:24,200
如果没有数字的话 它可能会放在编译程序上

589
00:52:24,200 --> 00:52:27,740
这是一个基本的一个理解

590
00:52:28,840 --> 00:52:30,860
OK 这个是一个小问题了

591
00:52:33,120 --> 00:52:35,080
好 那我们再讲一下怎么去

592
00:52:35,080 --> 00:52:36,580
我们要写这个LibreOS

593
00:52:36,580 --> 00:52:38,980
我们要去定制这个类型空间

594
00:52:38,980 --> 00:52:40,580
不像我们用程序不用管

595
00:52:40,580 --> 00:52:43,580
因为用程序是我们的编译器

596
00:52:43,580 --> 00:52:45,900
缺少定好一个类型空间布局

597
00:52:45,900 --> 00:52:48,080
所以基于那个共性的就行了

598
00:52:48,080 --> 00:52:51,280
但你要现在写的话就需要去定制了

599
00:52:51,280 --> 00:52:54,720
用编辑还不足以去代替OS

600
00:52:54,720 --> 00:52:56,800
所以我们现在要写的是OS

601
00:52:56,800 --> 00:52:59,780
你会发现我们会有一个专门的一个讲解

602
00:53:00,340 --> 00:53:02,140
有朋友可能看到我没看过

603
00:53:02,140 --> 00:53:04,360
这是给linker用的

604
00:53:04,360 --> 00:53:07,780
linker我们说编译器 汇编器

605
00:53:07,780 --> 00:53:09,340
还有一个叫做链接器

606
00:53:09,340 --> 00:53:10,480
linker是链接器

607
00:53:10,480 --> 00:53:13,780
它会完成最终的地址的组装

608
00:53:13,780 --> 00:53:15,280
我们说大编辑器或者叫

609
00:53:15,280 --> 00:53:17,600
就是广义的编辑器里面包含这三部分

610
00:53:17,600 --> 00:53:20,080
Compiler,Assembler和Linker

611
00:53:20,080 --> 00:53:22,420
我们现在说的是Linker需要的一个文件

612
00:53:22,420 --> 00:53:24,140
这个文件里面会很明确地指出来

613
00:53:24,140 --> 00:53:26,680
我们这个OS写的这个OS

614
00:53:26,680 --> 00:53:28,840
我们这个OS其实和应用是捆在一起的

615
00:53:28,840 --> 00:53:29,960
它是一个程序

616
00:53:29,960 --> 00:53:32,440
这个程序70地址在这个地址

617
00:53:32,440 --> 00:53:36,240
那这个地址是给我们编辑器看的

618
00:53:36,240 --> 00:53:39,160
也是给谁看的

619
00:53:39,160 --> 00:53:41,420
谁要知道这个地址802

620
00:53:41,800 --> 00:53:42,820
后面5个0

621
00:53:44,500 --> 00:53:47,260
对 人家说的对啊 还要给Bootloader知道

622
00:53:48,060 --> 00:53:51,420
Bootloader会跳到那个地方去执行

623
00:53:52,320 --> 00:53:57,500
同时也要给 还有一个软件也需要知道

624
00:53:57,500 --> 00:53:58,980
QML也需要知道

625
00:53:59,500 --> 00:54:03,320
QML要把你生成的OS的Emic要放到这个地方去

626
00:54:04,200 --> 00:54:05,920
所以Bootloader要知道 QML要知道

627
00:54:06,680 --> 00:54:08,920
然后后面就是我们说的在这后面依次放

628
00:54:09,380 --> 00:54:11,740
Test段、Data段等等就放到后面

629
00:54:12,300 --> 00:54:13,820
还有一个BSS段 OK

630
00:54:16,060 --> 00:54:19,260
这是这一块的一个布局

631
00:54:20,040 --> 00:54:21,620
就是我们调linker之后

632
00:54:21,620 --> 00:54:23,340
会根据我们写好这个脚本

633
00:54:23,340 --> 00:54:27,020
来帮我们生成正确的地址的这个程序

634
00:54:27,020 --> 00:54:27,740
就我们这个os

635
00:54:30,160 --> 00:54:32,120
好 那生成这个程序

636
00:54:32,120 --> 00:54:33,380
大家知道生成是一个

637
00:54:33,380 --> 00:54:35,080
我们前面上台讲过

638
00:54:35,080 --> 00:54:37,120
是一个elf格制的程序

639
00:54:37,120 --> 00:54:39,160
但其实我们的bootloader

640
00:54:39,160 --> 00:54:39,960
在加载的时候

641
00:55:11,040 --> 00:55:15,400
Object Coding的方式,这个软件会帮我们干这个事情

642
00:55:15,400 --> 00:55:19,500
生成一堆Binary进项之后,其实它已经没有任何文件的信息了

643
00:55:19,500 --> 00:55:25,100
它只是一些指令,就是我们说的Text段、Data段那些数据和指令

644
00:55:25,100 --> 00:55:31,340
然后这个指令呢,这是我们说的把这个信息去掉的一个公众

645
00:55:31,920 --> 00:55:36,800
这个指令最终会被我们的QML放到他们去执行

646
00:55:36,800 --> 00:55:39,680
这就是一个制造二金字进项的一个命令

647
00:55:39,960 --> 00:55:42,980
这是RUST的 如果把这个RUST的减化去掉的话

648
00:55:42,980 --> 00:55:44,820
就是我们C的

649
00:55:44,820 --> 00:55:47,420
你用CGC生成的那个OS的话

650
00:55:47,420 --> 00:55:50,360
其实它一样可以生成一个OS.bin

651
00:55:50,360 --> 00:55:53,380
你可以很简单的看它的格式

652
00:55:53,380 --> 00:55:55,480
用另外一个工具叫File

653
00:55:55,480 --> 00:55:57,920
名字叫File F-I-L-E 文件

654
00:55:57,920 --> 00:55:59,060
这是一个程序

655
00:55:59,060 --> 00:56:00,320
这个程序可以check

656
00:56:00,320 --> 00:56:04,640
这个不同的文件它的性质是什么

657
00:56:04,640 --> 00:56:06,600
比如说你File 空格

658
00:56:06,600 --> 00:56:07,780
这个东西OS的话

659
00:56:07,780 --> 00:56:10,480
你会发现它是查到这个ALP合适文件

660
00:56:10,480 --> 00:56:12,700
但如果查这个文件OSPIN的话

661
00:56:12,700 --> 00:56:13,940
它说是一段data

662
00:56:14,960 --> 00:56:18,320
其实是包含了代码段数据段的OS

663
00:56:21,040 --> 00:56:23,660
我们要去验证启动过程

664
00:56:24,820 --> 00:56:30,940
其实也就是说你要用QMU和GDP配合在一起来做一个分析

665
00:56:30,940 --> 00:56:32,280
这也是我们出过这种题

666
00:56:32,280 --> 00:56:33,700
就是希望大家能够知道

667
00:56:34,060 --> 00:56:39,700
你怎么能够去理解QML启动那一块

668
00:56:39,700 --> 00:56:42,120
我们上一堂课不是讲QML启动吗

669
00:56:42,120 --> 00:56:46,660
这里面给出了一个大致的一个简单的一个表示

670
00:56:46,660 --> 00:56:50,980
这个表示可以看出来是通过QML和GDB配合在一块来做的事情

671
00:56:51,460 --> 00:56:54,480
为什么要配合呢 是在于QML代表的计算机

672
00:56:54,480 --> 00:56:56,780
GDB代表的是调试工具

673
00:56:56,780 --> 00:56:59,400
那计算机和调试工具之间一定要有某种协议

674
00:56:59,400 --> 00:57:02,780
来帮助 一起来调试这个跑在上面的程序

675
00:57:02,780 --> 00:57:08,160
你会发现这Cube里面,它有两个特殊的参数,这个-小s和-大

676
00:57:08,160 --> 00:57:08,960
s

677
00:57:08,960 --> 00:57:14,360
这两个参数是说这个机器一开始就停下来

678
00:57:14,860 --> 00:57:20,480
这个机器就相当于是加电之后,到它第一条指令执行的时候

679
00:57:20,480 --> 00:57:24,160
就是在那个所谓的那个ROM执行的第一条指令的地方就停下来

680
00:57:24,160 --> 00:57:26,960
等待GDB的接管,干这么一个事情

681
00:57:26,960 --> 00:57:29,760
然后你在这里面 这是一个叫做

682
00:57:30,680 --> 00:57:33,060
riskv64 on loan ELF gdb

683
00:57:33,060 --> 00:57:35,960
这是一个就是能够去识别

684
00:57:37,580 --> 00:57:42,640
ELF文件和RISC-V指令的一个gdb

685
00:57:42,640 --> 00:57:44,020
所以它是这么一个gdb

686
00:57:44,020 --> 00:57:47,180
这个gdb会执行一系列的操作

687
00:57:47,180 --> 00:57:48,860
比如第一个操作 file

688
00:57:48,860 --> 00:57:51,740
就把那个ELF格式的OS文件给加下去

689
00:57:51,740 --> 00:57:54,940
这个文件里面有很多的符号信息

690
00:57:54,940 --> 00:58:01,360
那我们可以根据它的位置,就是机器的指令的位置能够反编辑出来

691
00:58:01,360 --> 00:58:06,080
是它对应的那个C缘是哪一个位置,或者是RAST缘哪个位置。

692
00:58:06,400 --> 00:58:09,520
然后这个是设置它的体结构是这个RV RISC-V64。

693
00:58:10,300 --> 00:58:13,840
然后建立链接就是这个Target Remote Local Host 1234,

694
00:58:14,140 --> 00:58:19,080
就是在这里面和这个QML建立了一个链接,通过这一步来建立链接。

695
00:58:20,160 --> 00:58:22,740
因为在QML里面欠了一个GDP Server,

696
00:58:23,540 --> 00:58:28,120
他们之间通过串口或者网络来和GDB连在一起,来完成调试功能。

697
00:58:28,260 --> 00:58:30,840
所以你发现,因为它一启动之后就停下来了,

698
00:58:31,420 --> 00:58:34,880
所以你这里面GDB一旦跟它建立联系之后,它也会停下来,

699
00:58:35,040 --> 00:58:39,660
指出当前的机器,就是QNAP模拟的那台沃尔特讯,停在什么地方?

700
00:58:41,400 --> 00:58:47,280
0x1000这个位置,大家回顾一下我们上一堂课讲的QNAP的云大马的时候,

701
00:58:47,860 --> 00:58:49,700
它那个room的其实例子就是0x1000。

702
00:58:50,560 --> 00:58:53,600
这就可以对上 它就从那个地方开始执行

703
00:58:54,400 --> 00:58:57,060
OK 这个就大致给大家讲一下就行了

704
00:58:57,500 --> 00:58:59,820
好 那接下来是讲这个

705
00:58:59,820 --> 00:59:03,880
我们希望大家能够理解得比较充分的这个函数调用

706
00:59:03,880 --> 00:59:05,700
怎么去支持函数调用

707
00:59:06,880 --> 00:59:09,200
这里面讲几个地方 第一个是简单的概述

708
00:59:09,200 --> 00:59:12,320
第二个是call return为指令

709
00:59:12,320 --> 00:59:14,700
第三个是函数调用规范 第四个是

710
00:59:14,700 --> 00:59:16,840
LibOS处理化 怎么来支持函数调用

711
00:59:25,800 --> 00:59:35,680
所以我们可以看看,这个应该可以打开了,当时我们学的时候,就比如上一期,几个月前,

712
00:59:36,160 --> 00:59:44,500
不是那些年啊,是几个月,那些个月,大家学的这个stage9,和step9,还有印象

713
00:59:44,500 --> 00:59:49,680
吗?函数,太深了印象,啊,有太深的印象是吧,为什么呀,这个是什么,这个是什么,

714
00:59:49,680 --> 00:59:49,680
这个是什么,这个是什么,这个是什么,这个是什么,这个是什么,这个是什么,这个是什么,这个是什么,

715
01:01:19,680 --> 01:01:28,900
但是我们回头来看看 这里面我们写了一个保存上下文和恢复上下文

716
01:01:28,900 --> 01:01:33,480
大家还有印象我们的编译器怎么去保存这个函数上下文和恢复函数上

717
01:01:33,480 --> 01:01:37,000
下文的吗

718
01:01:37,000 --> 01:01:41,580
如果大家还有印象的话 发现我们涉及到简化的一个方法

719
01:01:41,580 --> 01:01:45,360
所有的需要保存和恢复的 技能器要保存和恢复

720
01:01:45,360 --> 01:01:50,480
第二是我所有的这些参数全的话内存里面通过内存来传递 是吧

721
01:01:50,480 --> 01:01:53,840
如果大家还有印象的话 这是我们的方法

722
01:01:53,840 --> 01:01:58,940
但这个方法是我们写的编译器 不是我们的工业级的编译器

723
01:01:58,940 --> 01:02:00,680
比如说RAST或者GSC

724
01:02:00,680 --> 01:02:04,680
如果是RAST和GSC 它除了考虑功能的自制性之外

725
01:02:04,680 --> 01:02:06,920
还需要考虑一点性能

726
01:02:06,920 --> 01:02:11,780
所以它的参数传递 它的保存与恢复这些事情

727
01:02:11,780 --> 01:02:19,680
会比我们更加注重性了,它会用计程器来传,而不会用我们的内存来

728
01:02:19,680 --> 01:02:20,460
传,这是第一个。

729
01:02:20,460 --> 01:02:27,880
第二个,这个return和call,它其实只是我们的汇边代码。进一步说,它叫汇边的

730
01:02:27,880 --> 01:02:28,440
伟代码。

731
01:02:29,140 --> 01:02:34,320
伟代码的意思就是,它其实不是真正的机器码。你会发现,对于return而言,

732
01:02:34,520 --> 01:02:38,800
它其实对应的这个基本的机器指令是JLR,就是计程器的跳转。

733
01:02:39,640 --> 01:02:44,800
什么意思就是,就跳到X1这个技能器里面放的那个地址

734
01:02:46,240 --> 01:02:49,880
OK,X1就叫RA,也叫RA技能器,RA什么意思,Return Address

735
01:02:49,880 --> 01:02:54,900
这个这么一个简称,X1就是X0到X31这么一个编号

736
01:02:54,900 --> 01:02:57,900
那这个Core什么意思呢,Core实际上是由两条指令组成的

737
01:02:57,900 --> 01:03:01,060
AUIPC和JALR

738
01:03:01,060 --> 01:03:07,080
又出现了AUIPC,这是一个沉寂的然后比较痛苦的一个指令

739
01:03:07,080 --> 01:03:08,820
那所有直接把这一段抄下来

740
01:03:08,820 --> 01:03:10,320
这样大家可以读起来比较顺利

741
01:03:11,220 --> 01:03:16,080
AUIPC add upper立即数 to PC

742
01:03:16,080 --> 01:03:18,700
就是把这个立即数的上半部分

743
01:03:18,700 --> 01:03:21,560
什么上半部分 高20位放到PC里面去

744
01:03:23,040 --> 01:03:26,300
这里面就是用来构造PC相对的地址

745
01:03:26,300 --> 01:03:28,800
就是它offset 这就是offset

746
01:03:28,800 --> 01:03:31,240
使用的是U型立即数 无符号的立即数

747
01:03:31,240 --> 01:03:33,380
AUIPC以D12位补0

748
01:03:33,380 --> 01:03:38,100
高20位是U型移速的方式形成一个32位的偏移

749
01:03:38,100 --> 01:03:39,840
然后和PC相加

750
01:03:39,840 --> 01:03:42,880
最后把结果存到X1里面去

751
01:03:42,880 --> 01:03:46,560
需要注意这边还有一条就是最后把结果存到了

752
01:03:46,560 --> 01:03:48,220
X1 这存在哪儿存的

753
01:03:48,220 --> 01:03:50,760
是在jaur这条指令

754
01:03:50,760 --> 01:03:53,380
会 我看

755
01:03:54,180 --> 01:03:55,460
X6写错了

756
01:03:56,120 --> 01:03:56,920
第二个bug

757
01:03:56,920 --> 01:03:59,160
应该存到X6里面去

758
01:03:59,160 --> 01:04:00,680
但通关之后

759
01:04:00,680 --> 01:04:02,440
这是存的是一个高20位

760
01:04:02,440 --> 01:04:11,440
所以它还会把X6的内容和Offset的第一十二位合在一起

761
01:04:12,320 --> 01:04:13,840
再放到X1里面去

762
01:04:13,840 --> 01:04:19,960
实际上干的事情就是把返回地址就是ReturnedDress

763
01:04:19,960 --> 01:04:22,940
保存在了X1截成器里面

764
01:04:22,940 --> 01:04:24,100
既然它保存在这里面了之后

765
01:04:24,100 --> 01:04:26,040
你看这为什么ReturnedDress是X1呢

766
01:04:26,040 --> 01:04:29,520
这保存了自然可以去给你这个地址来返回

767
01:04:29,520 --> 01:04:31,880
这就是它的一个配对的操作

768
01:04:33,520 --> 01:04:39,060
有同学说这个指令我已经忘了,那你就看一下,我专门给了一个快速入门的

769
01:04:39,060 --> 01:04:43,960
RESPAC汇编的文档,它里面包含了各种为止令,这样大家在看为

770
01:04:43,960 --> 01:04:47,740
止令的时候就更清楚它到底对应的机器码是什么。

771
01:04:48,380 --> 01:04:54,700
因为我还是说 我们会对它这里面的继承器集进行一系列的操作

772
01:04:54,700 --> 01:04:59,480
所以你需要去理解它这一层面的基本指令的情况

773
01:04:59,480 --> 01:05:01,640
而不是微指令的情况 微指令还不够

774
01:05:01,640 --> 01:05:04,540
这就是我们操作系统和编译系的一个区别

775
01:05:07,080 --> 01:05:10,540
说白了就是说 我们要理解这个韩束代用的核心是

776
01:05:10,540 --> 01:05:13,740
在韩束代用时通过靠微指令保存了返回地址

777
01:05:14,540 --> 01:05:17,800
然后通过Return指令来跳回去

778
01:05:17,800 --> 01:05:19,740
根据RA跳回去就OK了

779
01:05:20,540 --> 01:05:21,740
接下来的问题就在于

780
01:05:22,580 --> 01:05:24,200
你第一次函数调用是这样的

781
01:05:24,200 --> 01:05:26,200
第二次函数调用的时候RA就被冲掉了

782
01:05:26,200 --> 01:05:28,380
基因器只有一份 并没有多份

783
01:05:28,380 --> 01:05:31,920
所以一定会有一个把RA要放到某一个地方

784
01:05:31,920 --> 01:05:34,140
内存的某一个地方去存下来的一个过程

785
01:05:34,140 --> 01:05:37,840
这就是我们后面要讲到的就是

786
01:05:39,160 --> 01:05:41,760
函数调用规范里面定的东西

787
01:05:41,760 --> 01:05:49,480
或者叫,这为什么叫,其实谈不上是规范,规范叫spec,这种规范,但其实它更

788
01:05:49,480 --> 01:05:54,620
多的这种convention是约定,我觉得用约定的词更好一点,约定实际上它是

789
01:05:54,620 --> 01:06:00,980
一个,不是一个很,要追求所谓的正确性,你怎么定,只要大家追求一个共识就

790
01:06:00,980 --> 01:06:06,300
行,或者共识更清楚,那这里面,在这函数调用的这个约定里面呢,我们需要理

791
01:06:06,300 --> 01:06:07,620
解参数怎么传递,

792
01:06:07,620 --> 01:06:12,960
反而是怎么传递,战争怎么构建,函数结构怎么来设计的一个问题,这一块

793
01:06:12,960 --> 01:06:19,420
函数结构其实和我们的编译里面生成的那个函数是很类似的,但是细

794
01:06:19,420 --> 01:06:24,480
节上面有所不同,因为你的参数不一样,所以你这个细节也就不一样了。

795
01:06:24,480 --> 01:06:29,260
我们可以看到这里面需要去理解这个输入传输和反馈制怎么团队的

796
01:06:29,820 --> 01:06:34,340
然后你所谓的这个函数调用的上下文 又穿了一个词叫context

797
01:06:34,340 --> 01:06:38,060
所谓上下文就是当前的运行的一个状态的保存也恢复

798
01:06:38,060 --> 01:06:43,340
就是这个上下文 我们说的上下文更多是站在机器的角度 而不是站

799
01:06:43,340 --> 01:06:44,260
在编译角度

800
01:06:44,260 --> 01:06:48,980
在编译角度你看到的是一些变量 在机器角度看到的是一些集成器和内存

801
01:06:49,420 --> 01:06:51,260
这是不一样的 它特别底层

802
01:06:54,140 --> 01:06:59,920
所以我们在计程器这里看到了有一系列的计程器是属于调用者保存的,

803
01:06:59,980 --> 01:07:02,320
而另一系列的计程器是属于被调用者保存的。

804
01:07:03,440 --> 01:07:10,980
这是一个约定,它目的是让符合这个约定的程序可以正确地运行,这里面给

805
01:07:10,980 --> 01:07:13,120
出了一系列计程器的保存回复。

806
01:07:13,120 --> 01:07:21,320
然后返回值是放在RA或者叫做A0继承器,A0是X1,它有不同的

807
01:07:21,320 --> 01:07:28,680
这种,基于它不同的这种场景用的一些团用的一些术语,就是X系列的,

808
01:07:28,720 --> 01:07:35,260
A系列的,还有一些是,就是我们说的RA这种更通俗的一些解释,一些表示。

809
01:07:35,260 --> 01:07:37,200
这里面我们给出来的是

810
01:07:37,200 --> 01:07:38,760
因为我们是Archive64

811
01:07:38,760 --> 01:07:40,420
如果我们返回的只是64位的话

812
01:07:40,420 --> 01:07:41,840
只要用一个A0就可以了

813
01:07:41,840 --> 01:07:47,220
这是一个关于调用参数和返回值的一个理解

814
01:07:47,220 --> 01:07:51,020
随着它的运行 你会看到它是这么一个结构

815
01:07:51,020 --> 01:07:53,140
这个大家都很好理解 就是

816
01:07:53,140 --> 01:07:55,400
有一层一层的站 组成的

817
01:07:55,400 --> 01:07:56,940
这个站我们称之为战争

818
01:07:56,940 --> 01:07:59,840
这个战争里面保存了这个函数

819
01:07:59,840 --> 01:08:04,960
能够正常执行和正常返回所需要的一些信息

820
01:08:04,960 --> 01:08:08,320
放在类存里面的 站的类存里面的

821
01:08:08,320 --> 01:08:15,960
那这个战争里面 你会看到基本的结构有几个

822
01:08:16,980 --> 01:08:19,880
首先是返回地址 Retail address这一块

823
01:08:19,880 --> 01:08:25,920
返回地址是有的 第二个 战争它本身形成一个链

824
01:08:25,920 --> 01:08:29,220
这个链 大家还有印象 边也讲过这个链

825
01:08:29,220 --> 01:08:31,560
这个动态链 这个动态链形成了之后

826
01:08:31,560 --> 01:08:33,820
我们就可以通过我们的GDP

827
01:08:33,820 --> 01:08:38,800
能够把这个函数代表的关系给很简单的,很方便地展示出来。

828
01:08:39,440 --> 01:08:45,320
这是一个辅助我们去更好地理解程序的行为的一个很好的东西。

829
01:08:45,340 --> 01:08:49,740
所以它叫GFramePointer来建立好的一个链。

830
01:08:50,000 --> 01:08:51,820
所以在previous FP放在这个地方。

831
01:08:52,620 --> 01:08:56,620
然后还有就是SafeRegister,就是保存的计程器,

832
01:08:56,680 --> 01:08:58,720
就是Color和Colly的保存计程器。

833
01:08:58,720 --> 01:09:05,880
然后再一下是所谓的local变量,这些就形成了所谓的一个战争,你看,它的

834
01:09:05,880 --> 01:09:16,660
战的底部是这个frame pointer,当前的frame pointer,它的头部是stack pointer,这个区域形成

835
01:09:16,660 --> 01:09:28,580
了一个战争。

836
01:09:28,580 --> 01:09:31,520
我们的工业级编写来做,而不是我们自己写的编写来做。

837
01:09:32,300 --> 01:09:36,760
所以你要用一个GTC也好,用这个RUSC也好,它都可以帮我们把这个东西建

838
01:09:36,760 --> 01:09:37,000
好。

839
01:09:37,620 --> 01:09:43,500
我们需要的是理解这个结构,因为我们会去改这个结构,所以你就要去理解它。

840
01:09:46,520 --> 01:09:53,660
OK,这个已经说过了,就是SP和FP形成了一个战争的头和尾。这里面的内容

841
01:09:53,660 --> 01:09:54,800
我也说过了。

842
01:09:56,500 --> 01:10:01,900
那这里面讲了就是当返回return指令执行的时候

843
01:10:01,900 --> 01:10:02,860
我们说回指令执行的时候

844
01:10:02,860 --> 01:10:04,920
下面的尾代码实验会调整这个站

845
01:10:04,920 --> 01:10:08,320
因为我们说它这个站它会回收回去

846
01:10:08,320 --> 01:10:11,840
很简单就sp等于fp加上entry size

847
01:10:11,840 --> 01:10:13,960
这就完成了一个回收

848
01:10:13,960 --> 01:10:14,980
这非常简单

849
01:10:15,680 --> 01:10:17,960
然后pc复制给re继承器

850
01:10:18,320 --> 01:10:20,680
这样它re继承器把它传给这个pc之后呢

851
01:10:20,680 --> 01:10:24,500
就可以回到它的color的下一条地址

852
01:10:24,500 --> 01:10:29,780
这就是我们说这个调用的时候需要做的事情

853
01:10:30,280 --> 01:10:32,740
好 那这个函数题 我们再看一下函数题

854
01:10:33,340 --> 01:10:34,900
函数题的话你会看到

855
01:10:34,900 --> 01:10:38,300
这其实和我们这个调用规范或者调用的一个约定

856
01:10:38,820 --> 01:10:40,300
是很有紧密关系的

857
01:10:41,820 --> 01:10:46,840
它会有一个前面这个部分我们叫做序言或者前言

858
01:10:46,840 --> 01:10:49,700
Prologo 还有一个收尾

859
01:10:50,660 --> 01:10:53,480
由这两部分来形成的一块区域

860
01:10:53,480 --> 01:10:55,260
中间是实际的函数体

861
01:10:55,260 --> 01:10:58,940
而这两块区域其实都是我们编系生成的

862
01:10:58,940 --> 01:11:00,820
和你的代码没有直接的关系

863
01:11:00,820 --> 01:11:03,360
但有了这两块区域之后

864
01:11:03,360 --> 01:11:06,020
你才能够看到在函数内

865
01:11:06,020 --> 01:11:08,240
给这个九倍量分配空间

866
01:11:08,240 --> 01:11:09,700
把相应的这个RA

867
01:11:09,700 --> 01:11:12,280
比如说RA存到一个固定的位置

868
01:11:12,280 --> 01:11:14,000
战争的固定位置

869
01:11:14,000 --> 01:11:15,340
从而可以实现函数牵套

870
01:11:15,340 --> 01:11:16,680
就函数可以调函数

871
01:11:16,680 --> 01:11:18,340
而不会把以前的防疫地理冲掉

872
01:11:18,340 --> 01:11:19,820
那在最后的时候

873
01:11:19,820 --> 01:11:23,200
你会看到这里面会恢复这个

874
01:11:23,200 --> 01:11:25,340
根据这个

875
01:11:25,340 --> 01:11:26,160
在哪儿

876
01:11:26,160 --> 01:11:28,000
这应该下面还有点东西

877
01:11:28,000 --> 01:11:28,540
对

878
01:11:28,540 --> 01:11:32,480
会根据这个RA的值来返回

879
01:11:32,480 --> 01:11:32,900
你看

880
01:11:33,680 --> 01:11:37,920
就把这个SP里面的战争里面存的内容放到RA里面去

881
01:11:37,920 --> 01:11:40,120
然后再add这个

882
01:11:40,120 --> 01:11:42,640
add这个箱子就是把战给清掉了

883
01:11:42,640 --> 01:11:44,120
把这个战给消掉

884
01:11:44,120 --> 01:11:45,300
然后再return就回去了

885
01:11:45,300 --> 01:11:46,620
这是一个函数

886
01:11:48,640 --> 01:11:53,960
好,那这也是一个函数的实现,就是我们说这里面会看这个函数里面会掉另外

887
01:11:53,960 --> 01:11:54,780
一个函数。

888
01:11:55,420 --> 01:12:01,160
这个函数里面就是,这是一个函数名sum then double,然后掉了一个sum2。

889
01:12:02,220 --> 01:12:08,200
然后这里面是call一个sum2,把这个去言和收尾给去掉了。

890
01:12:08,460 --> 01:12:13,140
那这段代码和上一段代码看起来就是更精锻的代码。

891
01:12:13,140 --> 01:12:18,200
有朋友说 其实如果我就是这么一个程序的话

892
01:12:18,200 --> 01:12:22,200
我其实这个操作没有意义

893
01:12:22,200 --> 01:12:24,840
可以优化掉 我们编辑给它优化掉

894
01:12:24,840 --> 01:12:30,860
得到这么一个操作 请问是不是可以做到这样

895
01:12:30,860 --> 01:12:35,140
关于什么样的问题呢 第二代 我开始提问题了

896
01:12:37,980 --> 01:12:40,940
前面生成了一个编辑生成

897
01:14:15,240 --> 01:14:21,160
我们现在已经掌握了怎么去在机器这个级别去理解这个

898
01:14:21,160 --> 01:14:24,460
这样我们就想想我们怎么去写LibOS

899
01:14:24,880 --> 01:14:26,760
写LibOS最主要是完成数字化

900
01:14:26,760 --> 01:14:32,500
print那个东西其实和print本身的那个组织

901
01:14:32,500 --> 01:14:34,240
其实和OS的关系不大

902
01:14:34,240 --> 01:14:37,300
写应用程序也不写但是关系大的

903
01:14:37,300 --> 01:14:40,920
就是你怎么去完成一个手动的或者叫做

904
01:15:10,980 --> 01:15:12,360
这个地址

905
01:15:12,360 --> 01:15:18,180
这个global start 简号 start 代表的是一个全局的一个函数名

906
01:15:18,180 --> 01:15:19,080
这是一个函数

907
01:15:19,700 --> 01:15:20,760
这是这么一个

908
01:15:20,760 --> 01:15:27,880
所以意味着我如果那个 bootloader 要跳到这个 0x802 5.0 的话

909
01:15:27,880 --> 01:15:29,320
那实际上跳到这个地方来

910
01:15:29,320 --> 01:15:30,920
从这条语句开始执行

911
01:15:31,860 --> 01:15:34,280
这条语句你看它也用到了汇边母的 call

912
01:15:34,280 --> 01:15:36,060
但是在 call 之前

913
01:15:36,060 --> 01:15:38,820
需要注意在 call 之前它做了很重要的事情

914
01:15:38,820 --> 01:15:44,180
LASP Boots Stack Top,什么意思?建立站

915
01:15:45,740 --> 01:15:49,700
我们前面只是在对站空间来进行一个调整

916
01:15:49,700 --> 01:15:52,500
但是我并没有讲建立站

917
01:15:52,500 --> 01:15:54,880
建立站的过程,我们编系帮不了我们

918
01:15:55,620 --> 01:15:57,580
这需要我们OS自己去建立

919
01:15:57,580 --> 01:16:00,280
所以在这里面,我建立好一个站空间

920
01:16:00,280 --> 01:16:04,180
站空间多大呢?你看,倒着看

921
01:16:04,180 --> 01:16:08,020
这是高地址,这个Boots Stack Top高地址

922
01:16:08,020 --> 01:16:11,300
而这个boost-stack是那个站底

923
01:16:11,300 --> 01:16:20,020
也意味着这个站空间它建立了一个64k byte的一个站空间

924
01:16:21,500 --> 01:16:26,100
那么从这个地址一直到这个地方那都是给站用的

925
01:16:26,100 --> 01:16:29,900
那意味着如果你这个站由于你的谈判量太多了

926
01:16:29,900 --> 01:16:32,420
超过64k 那就会出现什么情况

927
01:16:34,440 --> 01:16:37,640
死机 不会吧 没这么严重

928
01:17:08,020 --> 01:17:13,020
因为它不是每次都同线,我们超级桶里面很大一部分bug

929
01:17:13,020 --> 01:17:17,160
就像你们写实验的时候,你发现很大一部分bug,很难调的bug

930
01:17:17,160 --> 01:17:22,080
一大类是叫memory related bug,占就是一类

931
01:17:22,080 --> 01:17:25,140
我们现在因为没有堆,所以你还碰的是占的bug

932
01:17:25,140 --> 01:17:30,120
还有一类是堆的bug,还有一类是叫并发的bug

933
01:17:30,120 --> 01:17:33,100
就是memory related bug和所谓的concurrency bug

934
01:17:33,100 --> 01:17:34,760
是你们会碰到的挑战

935
01:17:34,760 --> 01:17:39,040
而这类问题也是在你们写应用程序的时候很难碰到

936
01:17:39,040 --> 01:17:42,960
因为我们的Python我们的Java帮我们把Memory管得特别好

937
01:17:43,320 --> 01:17:44,640
你不需要考虑这个问题

938
01:17:44,640 --> 01:17:47,620
但是你写OS的时候你都要考虑

939
01:17:47,620 --> 01:17:51,700
这带来最大的灵活性 也带来非常容易引起你的bug

940
01:17:53,380 --> 01:17:55,840
好 这就是建立站 我讲明白了

941
01:17:55,840 --> 01:17:58,240
要清楚这个过程

942
01:17:58,860 --> 01:17:59,980
对应的就是这一点

943
01:17:59,980 --> 01:18:03,820
这个BSS里面 我们其实把这个站放在BSS里面

944
01:18:03,820 --> 01:18:04,980
看这里面有个BSS stack

945
01:18:05,540 --> 01:18:07,660
这里面有个说放在这个section里面

946
01:18:07,660 --> 01:18:08,900
这个BSS stack

947
01:18:10,200 --> 01:18:13,260
所以这是它的一个位置

948
01:18:13,260 --> 01:18:15,720
它会在link的时候 会把这个变成一个

949
01:18:15,720 --> 01:18:18,740
把这个变成一个具体的一个地址

950
01:18:20,240 --> 01:18:23,080
好 假设我们建好站了

951
01:18:23,080 --> 01:18:24,140
第二步应该是call

952
01:18:24,140 --> 01:18:26,900
就是它是call lastman

953
01:18:27,340 --> 01:18:34,620
就实际上意味着它完成了从汇编代码到RAP或者C代码的一个跳

954
01:18:34,620 --> 01:18:36,140
或者还是调用

955
01:18:36,140 --> 01:18:42,300
这就是一个汇编码和C码的混合编程技术

956
01:18:42,300 --> 01:18:48,760
在这个编程技术里面 其实我们看到的我们的这个Color

957
01:18:48,760 --> 01:18:51,660
Ruliba Starter也就是Color了 一个函数的话

958
01:18:51,660 --> 01:18:55,660
这Color其实并没有完全遵循我们刚才说的call convention

959
01:18:59,420 --> 01:19:11,760
它不需要保存它所谓的Color需要保存的计程器,它不会回来了,不会回到

960
01:19:11,760 --> 01:19:15,620
这个Color之后的一条语句,所以它不需要保存,它可以简化。

961
01:19:16,240 --> 01:19:21,240
但如果在Rustman里面再掉一个函数的话,那我们编辑会帮我们干这个事情的,

962
01:19:21,240 --> 01:19:22,200
因为它已经高级语言了。

963
01:19:22,220 --> 01:19:25,640
到高级语言之后,我们的编辑帮我们干了很多事情。

964
01:20:56,140 --> 01:21:02,920
所以它这个地址编辑是知道的,同样也有一个And EBS在后面可以看到,LOD

965
01:21:02,920 --> 01:21:03,720
里面可以查到。

966
01:21:04,500 --> 01:21:09,640
LOD里面定义的变量在这里面都可以用,所以你可以根据这个歧视地址和

967
01:21:09,640 --> 01:21:13,660
结束地址把它做了一个写零的操作。

968
01:21:13,900 --> 01:21:21,680
这里面打了一个write,你不用理解这个复杂的语法是啥,干的事就是把这段

969
01:21:21,680 --> 01:21:22,760
空间清零。

970
01:21:22,760 --> 01:21:27,500
如果大家想理解的话,就看看Rust的书就行了。不想理解,直接忽略,看注释就

971
01:21:27,500 --> 01:21:27,760
行。

972
01:21:33,420 --> 01:21:39,080
它只是为了声明的方便。这也是一样,这是语法问题。大家看不懂语法,直接看

973
01:21:39,080 --> 01:21:39,440
注释。

974
01:21:39,740 --> 01:21:44,520
如果没注释,觉得看不懂,那就问老师。我觉得老师会把这个补上,尽量使大家能

975
01:21:44,520 --> 01:21:45,140
够看明白。

976
01:21:47,260 --> 01:21:53,120
好,那输出化过程就结束了,你看我们建立了站,轻而便利的,这我们刚

977
01:21:53,120 --> 01:21:55,820
刚最主要两个事情,这样你就可以执行了。

978
01:21:55,920 --> 01:22:02,700
至于那个print怎么去构造,那个不在我们的必须找的范围之内,你知道它能够

979
01:22:02,700 --> 01:22:03,740
支持函数调用就OK。

980
01:22:03,740 --> 01:22:11,440
最后一个,我们前面说到的就是你这个SBI其实是需要了解的

981
01:22:11,440 --> 01:22:14,960
因为我们想说一点就是OS之下还有软件

982
01:22:14,960 --> 01:22:24,980
至少对于RES5而言,它其实OS运行的不是最底层的软件

983
01:22:24,980 --> 01:22:31,360
那么OS为什么不是最底层,在于RES5有一个设计的思路

984
01:22:31,360 --> 01:22:37,340
在他的思路认为,OS之下应该存在两层软件,比如说可以存在一个虚拟

985
01:22:37,340 --> 01:22:37,740
机,

986
01:22:38,080 --> 01:22:45,660
大家用的这个什么,我不知道,在PC上可以装,像我这装了一个WSL2,

987
01:22:46,000 --> 01:22:50,460
那就是一个虚拟机,OS运行在这个虚拟机上,WSL2也是一个虚拟机。

988
01:22:51,340 --> 01:22:55,760
还有一层是说,我底下还有一个bootloader,bootloader也是一个底层软件,

989
01:22:55,900 --> 01:23:00,540
它可以给我们OS提供服务,它提供服务的目的是让我们OS更简单。

990
01:23:01,440 --> 01:23:08,760
底层都是为上层服务的,一旦底层提供了所谓的print这个支持之后,我的

991
01:23:08,760 --> 01:23:14,380
OS就不用写了,专门针对print的一些driver,底层帮我写了,这可以降低复杂

992
01:23:14,380 --> 01:23:14,580
度。

993
01:23:14,680 --> 01:23:21,320
那是不是这个是必须的?不是。作为OS而言,它其实也可以写个driver,直接去控制物理

994
01:23:21,320 --> 01:23:21,660
硬件。

995
01:23:22,420 --> 01:23:25,260
这是实验思路问题 我现在说的简单

996
01:23:25,260 --> 01:23:30,400
我就把这一块Driver去掉 我直接就是让SBI这个软件帮我们来做

997
01:23:30,400 --> 01:23:35,840
既然要帮我们来做 他们这里也有一套调用和被调用的一套关系

998
01:23:35,840 --> 01:23:37,980
这个关系称作SBI的服务接口

999
01:23:37,980 --> 01:23:40,460
这个是配上所谓的supervisor binary interface

1000
01:23:40,900 --> 01:23:43,820
为什么叫supervisor呢 就是我要给supervisor提供服务

1001
01:23:43,820 --> 01:23:45,740
这个supervisor指的是OS

1002
01:23:46,180 --> 01:23:49,420
那它这个和我们后面讲的系统调用是类似的

1003
01:23:50,700 --> 01:23:52,700
就是汤雄给应用提供一层服务

1004
01:23:52,700 --> 01:23:55,520
那是叫做ABI或者叫Disco

1005
01:23:56,720 --> 01:23:59,820
那么SBI给OS提供服务叫做SBI

1006
01:23:59,820 --> 01:24:01,920
就是这么一层软件

1007
01:24:01,920 --> 01:24:03,600
知道这个就行了

1008
01:24:03,600 --> 01:24:07,380
至于这个SBI调用约定

1009
01:24:07,380 --> 01:24:12,020
实际上也是体现在他一套定好的一个说法

1010
01:24:12,020 --> 01:24:15,260
比如说我要给所有这些SBI的服务编个号

1011
01:24:15,260 --> 01:24:17,280
对于这里面来说我们其他不用管了

1012
01:24:17,280 --> 01:24:17,840
就看这儿

1013
01:24:17,840 --> 01:24:22,080
有一个SBI push chart就是要输出一个字符

1014
01:24:22,080 --> 01:24:24,520
它提供的这个符号比较底层

1015
01:24:24,520 --> 01:24:26,660
它不像我们的超级种给我们的应用提供图是

1016
01:24:26,660 --> 01:24:28,860
输出一个字符串 这边更基本

1017
01:24:28,860 --> 01:24:32,060
我输出一个字符 大家知道加一个循环就变成输出字符串

1018
01:24:32,060 --> 01:24:35,660
这是我们OS实现过程 这是一个标识

1019
01:24:35,660 --> 01:24:40,400
另外我除了把这个传信之外 我还要到底传哪个字符

1020
01:24:40,400 --> 01:24:43,680
所以像这个witch是编号

1021
01:24:43,680 --> 01:24:46,340
然后你传的第一个参数

1022
01:24:46,340 --> 01:24:50,680
就是哪个字符会证明ARG0会给它传进去

1023
01:24:50,680 --> 01:24:53,280
然后最后还有反馈值表明成功失败

1024
01:24:53,280 --> 01:24:59,200
这就是我们说超级统发出的SBI Core的一个结构

1025
01:24:59,200 --> 01:25:01,040
这个结构是一个内嵌汇编

1026
01:25:01,040 --> 01:25:02,260
这我讲到了

1027
01:25:02,260 --> 01:25:06,240
你会发现我们在MOS里面有几个地方不多

1028
01:25:06,240 --> 01:25:10,300
大约两三个地方会有内嵌汇编

1029
01:25:10,300 --> 01:25:12,400
这个内嵌汇编只为了写得方便

1030
01:25:12,400 --> 01:25:19,960
我直接在这个Rust和C语言里面写上一段汇编来帮助我们来完成一个

1031
01:25:19,960 --> 01:25:22,000
直接用高级语言无法完成的事情

1032
01:25:24,840 --> 01:25:25,520
就是这个

1033
01:25:25,520 --> 01:25:30,160
那我想问一下 高级语言虽然无法表示 但是我们编辑器需要把它再翻译出来吗

1034
01:25:31,740 --> 01:25:33,350
我们编辑器会需要去理解它吗

1035
01:25:35,760 --> 01:25:36,800
大家学Compiler

1036
01:25:38,420 --> 01:25:40,820
至少你们写的编辑器不需要理解 是吧

1037
01:25:40,820 --> 01:25:44,600
因为你们写的编辑里面其实不需要嵌入Assembler的一些

1038
01:25:44,600 --> 01:25:46,260
不需要去理解这个汇编

1039
01:25:47,080 --> 01:25:48,900
那这一块就可以理解为是一个展开

1040
01:25:48,900 --> 01:25:52,240
总之这一段汇编会变成一条指令

1041
01:25:52,240 --> 01:25:54,100
这条指令就是一个e-code

1042
01:25:54,100 --> 01:25:56,400
在这个e-code执行之前

1043
01:25:56,400 --> 01:26:00,020
它会把这些计算器的内容复制给

1044
01:26:00,020 --> 01:26:03,300
就把这些参数的内容复制给这个一系列计算器

1045
01:26:03,300 --> 01:26:04,720
从而完成参数的传递

1046
01:26:04,720 --> 01:26:06,460
就类似于大家写的

1047
01:26:06,460 --> 01:26:07,820
他们partner里面那个call一样

1048
01:26:07,820 --> 01:26:09,060
call里面不是有很多参数吗

1049
01:26:09,060 --> 01:26:10,060
这就是参数

1050
01:26:10,060 --> 01:26:13,140
它一样的,只是它定位到更底层的系统器而已

1051
01:26:13,920 --> 01:26:18,040
OK,有了这个之后我们就可以完成一个调用了

1052
01:26:18,040 --> 01:26:20,340
SDI Core,但是为了更方便

1053
01:26:20,340 --> 01:26:23,360
我们会用一个函数来表示,比如ConsolePoolChart

1054
01:26:23,360 --> 01:26:28,660
这样使得我们在内核里面写出更简单的一个调用关系

1055
01:26:28,660 --> 01:26:32,460
这种封装其实在我们的C里面也是大量存在的

1056
01:26:32,460 --> 01:26:36,480
我们很少让应用开发者或者上层开发者

1057
01:26:36,480 --> 01:26:38,260
直接写到这个level的东西

1058
01:26:38,260 --> 01:26:39,780
这个level我最好把它封装起来

1059
01:26:39,780 --> 01:26:41,180
通过这种方式来实现

1060
01:26:42,200 --> 01:26:43,940
那么其实对于我们的 Rust 而言

1061
01:26:43,940 --> 01:26:46,120
它其实光这个风格还就是不够简单

1062
01:26:46,120 --> 01:26:48,920
它专门写了一个非常简单的一个红

1063
01:26:48,920 --> 01:26:52,020
叫 println 这个感单号这个红

1064
01:26:52,020 --> 01:26:53,540
带感单号代表这个红

1065
01:26:53,540 --> 01:26:55,980
这个红和我们 C 语言的红是一个概念

1066
01:26:55,980 --> 01:26:59,680
目的就是把一个函数式的东西给它展开

1067
01:26:59,680 --> 01:27:01,100
变成一堆代码

1068
01:27:01,660 --> 01:27:03,920
只是这个红相当于说比 C 语言

1069
01:27:03,920 --> 01:27:07,840
有更严格的语法语意的检查

1070
01:27:17,240 --> 01:27:20,780
就能够把这个机器给关掉

1071
01:27:20,780 --> 01:27:22,880
我们这边的机器只能是QML这个机器

1072
01:27:22,880 --> 01:27:25,920
那它通过这个系统可以让它Shutdown就是关机

1073
01:27:25,920 --> 01:27:27,780
从而可以让QML退出

1074
01:27:27,780 --> 01:27:31,680
这是两个我们在LibreOS里面会碰到的两个SBI的调优

1075
01:27:33,440 --> 01:27:34,080
OK 好

1076
01:27:34,440 --> 01:27:37,820
那为什么要关机是有可能你这程序执行完毕了就关机

1077
01:27:37,820 --> 01:27:42,160
或者是你这个程序有Bug 它会Panic

1078
01:27:42,160 --> 01:27:48,020
对于我们的C源来说 我们没有这个Panic的知识

1079
01:27:48,020 --> 01:27:52,640
它错了可能就是交给我们的QML去探断了

1080
01:27:52,640 --> 01:27:55,420
但这里面如果错了的话 只要OS能检查出来

1081
01:27:55,420 --> 01:27:56,620
它就会Panic

1082
01:27:56,620 --> 01:28:01,760
后面我们会有例子 来非常自然地去接受这个Panic的操作

1083
01:28:01,760 --> 01:28:03,180
来把相应的信息打出来

1084
01:28:04,060 --> 01:28:07,100
Panic最后会掉这个下档 你看这个掉下档

1085
01:28:07,100 --> 01:28:12,840
从而说在你程序出错,会报一堆信息之后,比较优雅地退出,而

1086
01:28:12,840 --> 01:28:20,660
不是啥也没有就退出了,这是一个写RUST的底层程序也需要提供的一个支持,

1087
01:28:20,800 --> 01:28:22,060
叫写出这个panic handler。

1088
01:28:25,040 --> 01:28:30,360
这是最后运行结果,但这个结果没有panic,我只是硬调了一个panic,让它能

1089
01:28:30,360 --> 01:28:33,840
够消耽卖信。这是大致的一个执行过程。

1090
01:28:35,140 --> 01:28:39,860
OK 那我就把Lecture2给讲完了

1091
01:28:39,860 --> 01:28:41,520
那最后稍微再总结一下

1092
01:28:41,520 --> 01:28:44,280
你们学完Lecture2之后要掌握什么知识

1093
01:28:44,280 --> 01:28:46,360
就是你会理解

1094
01:28:46,360 --> 01:28:47,360
我们讲Lecture2的时候

1095
01:28:47,360 --> 01:28:51,060
其实非常简要和overview的给大家介绍了

1096
01:28:51,060 --> 01:28:54,980
我们将会去构造的各种OS的实践中

1097
01:28:54,980 --> 01:28:55,980
需要掌握知识点

1098
01:28:55,980 --> 01:28:58,340
这个知识点包含了原理级的知识点

1099
01:28:58,340 --> 01:29:00,380
和你具体去做design的时候

1100
01:29:00,380 --> 01:29:02,240
会碰到的一些知识点

1101
01:29:02,240 --> 01:29:04,160
就是理论联系实际

1102
01:29:04,160 --> 01:29:05,420
第二个呢

1103
01:29:05,420 --> 01:29:06,980
其实需要去大家去理解

1104
01:29:06,980 --> 01:29:08,000
你上的不是OS

1105
01:29:08,000 --> 01:29:10,980
你上的是一个计算机的理解的课

1106
01:29:10,980 --> 01:29:13,960
所以你会去时不时的去跟Compiler打交道

1107
01:29:13,960 --> 01:29:15,840
时不时的和我们的这个Machine

1108
01:29:15,840 --> 01:29:18,480
CPU、Memory、Io打交道

1109
01:29:18,480 --> 01:29:20,040
你要去综合的理解这个东西

1110
01:29:20,040 --> 01:29:22,080
才能更好地掌握OSM的课

1111
01:29:22,080 --> 01:29:23,500
第三个稍微细节点

1112
01:29:23,500 --> 01:29:25,640
知道从机器启动到应用

1113
01:29:25,640 --> 01:29:27,300
成立打印出支付串的过程

1114
01:29:27,300 --> 01:29:28,880
其实我大致说了

1115
01:29:28,880 --> 01:29:31,100
我觉得后续还会碰到这种情况

1116
01:29:31,100 --> 01:29:33,500
我们还会去进一步去理解

1117
01:29:33,500 --> 01:29:40,640
这一点也是一种深入力的计算机运行的一个知识

1118
01:29:40,640 --> 01:29:43,220
最后你还能够动手去写一个三叶虫OS

1119
01:29:43,600 --> 01:29:46,340
我相信你写这个OS之后大家都看不懂是啥

1120
01:29:46,340 --> 01:29:48,940
你要问飞机算机技术专业 他不知道你写了啥

1121
01:29:50,180 --> 01:29:53,680
但是你会知道你能够写裸机程序了

1122
01:29:53,680 --> 01:29:58,380
这一点我觉得是制造上完这几节课之后

1123
01:29:58,380 --> 01:30:00,300
你们应该具备的能力

1124
01:30:01,680 --> 01:30:06,780
OK 好 这就把Lecture 2给大家讲完了

1125
01:30:07,300 --> 01:30:11,300
我们接下来看一下有问题吗

1126
01:30:12,860 --> 01:30:14,100
没问题 没问题

1127
01:30:14,100 --> 01:30:18,720
我们就讲下一个OS P处理超级统

1128
01:30:18,720 --> 01:30:21,760
基于特天级的隔离和P处理超级统

1129
01:30:21,760 --> 01:30:25,000
这个超级统比上一个超级统又进化了一下

1130
01:30:25,000 --> 01:30:28,680
但讲这个进化之前我们需要去从两个角度

1131
01:30:28,680 --> 01:30:34,080
来从一个更抽象的角度来理解硬件和软件

1132
01:30:34,080 --> 01:30:37,040
还有一个是从Risk5来深入理解

1133
01:30:37,040 --> 01:30:39,140
从超级角度来深入理解Risk5

1134
01:30:39,140 --> 01:30:41,820
第三个就是讲怎么去实现这个P处理操作

1135
01:30:42,720 --> 01:30:47,080
这是我们的第三讲的内容

1136
01:30:47,760 --> 01:30:49,480
先从第一节开始

1137
01:30:49,480 --> 01:30:55,600
第一节是一个非常高的维度来看这个资源机系统

1138
01:31:00,500 --> 01:31:04,960
那超级懂事位于硬件和应用之间,那我们需要去理解他们的关系。

1139
01:31:05,300 --> 01:31:12,440
所以这里面会进一步的去讲解,就是我们这一节会进一步讲解OS和应

1140
01:31:12,440 --> 01:31:15,000
用的关系,以及隔离。

1141
01:31:15,380 --> 01:31:21,480
这也是我们重点要去强调的,就是隔离是啥,isolation是干啥,为什么要隔离,什么

1142
01:31:21,480 --> 01:31:23,440
是隔离,隔离的方法有哪些。

1143
01:31:24,500 --> 01:31:26,850
这是这一节要去大学了解的东西

1144
01:31:28,960 --> 01:31:30,680
GNG OS和应验的关系

1145
01:31:30,680 --> 01:31:35,160
这个我想大家在不同的课上都应该或多或少的接触过

1146
01:31:35,160 --> 01:31:37,160
所以我和这一块稍微会快一点

1147
01:31:40,280 --> 01:31:43,580
首先GNG系统这里面给出了一个非常抽象的概念

1148
01:31:43,580 --> 01:31:44,920
这来自于Brookly的一个定义

1149
01:31:44,920 --> 01:31:46,500
Brookly CS152这种课

1150
01:31:46,500 --> 01:31:48,240
它给了一个GNG系统的定义

1151
01:31:48,240 --> 01:31:49,580
叫Computer Architecture

1152
01:31:49,580 --> 01:31:51,100
是一种抽象人质的设计

1153
01:31:51,100 --> 01:31:55,180
用于实现有效使用现有制造技术的细节处理应用

1154
01:31:55,180 --> 01:31:59,340
其实一看着 讲基本基础系统还是要去服务这个应用

1155
01:32:00,120 --> 01:32:01,800
只是它站在一个非常高的层次

1156
01:32:01,800 --> 01:32:05,760
就是你这个从上到下都是为了能够支持应用

1157
01:32:05,760 --> 01:32:06,800
这一点我是很赞成

1158
01:32:06,800 --> 01:32:10,520
就是我们造系统不是为了造系统而是为了支持应用

1159
01:32:11,160 --> 01:32:15,280
但中间这一层其实非常的多

1160
01:32:16,000 --> 01:32:25,560
我们看到的这里面从物理,到工艺,到电路,到所谓的

1161
01:32:25,560 --> 01:32:34,220
你们做到的就是在Micro architecture和Wirelog这个level来写处理器

1162
01:32:34,220 --> 01:32:38,500
再往上设计指令集给我们的超级桶和我们的程序去用

1163
01:32:38,500 --> 01:32:43,220
再往上就是我们的高级语言,再往上算法,再往上应用

1164
01:32:43,220 --> 01:32:47,860
这么多层次有了之后,我们才能够去支持应用

1165
01:32:47,860 --> 01:32:53,700
那我们很多的非计算机系的同学呢,他学计算机怎么学呢

1166
01:32:53,700 --> 01:32:58,280
从上到下学,就是先学怎么写应用,然后了解几个算法

1167
01:32:58,280 --> 01:33:02,180
会掉库,ok了,基本上就可以写应用程序了

1168
01:33:02,180 --> 01:33:05,860
但是我们计算机系的同学呢,是上下结合

1169
01:33:05,860 --> 01:33:08,220
既从上往下走,也从下往上走

1170
01:33:08,220 --> 01:33:10,900
但是不会涉及到物理学,物理学可能有点

1171
01:33:10,900 --> 01:33:15,700
刚才有个同学问量子物理,量子力学,那个问题我觉得就比较难回答

1172
01:33:15,700 --> 01:33:18,520
量子力学至少在目前来说我不太懂

1173
01:33:18,520 --> 01:33:22,560
所以很难给出一个量子力学是不是我们计算机器必须掌握的东西的一个

1174
01:33:22,560 --> 01:33:23,060
评价

1175
01:33:24,700 --> 01:33:25,140
不一样

1176
01:33:26,080 --> 01:33:26,440
OK

1177
01:33:27,140 --> 01:33:32,280
那另一门Bokeh的课叫CS61C,这也是很有名的一门课

1178
01:33:32,280 --> 01:33:38,580
给出了其实我们作为计算机器的同学应该要去掌握的一些内容

1179
01:33:38,580 --> 01:33:41,900
这里面我们看到了有组成员里有编译 有抄剧的

1180
01:33:44,900 --> 01:33:48,920
这是一个CSVOLC重点奖的内容

1181
01:33:48,920 --> 01:33:55,420
在这里面 除了说讲软硬件的一个关系之外

1182
01:33:55,420 --> 01:33:57,220
很重要一点讲一个边界

1183
01:33:57,220 --> 01:34:00,620
大家不要对它有很粗的一个这个东西

1184
01:34:01,520 --> 01:34:03,180
边界 边界是什么

1185
01:34:03,900 --> 01:34:06,820
边界就是双方之间的一个隔离带

1186
01:34:06,820 --> 01:34:08,280
你越界了就有问题

1187
01:34:08,280 --> 01:34:15,220
最近越界的东西比较多,大家能够理解。越界就会产生一些很大的问题,我们

1188
01:34:15,220 --> 01:34:24,060
不能越界。软件就干软件的事,硬件干硬件的事,他们需要的是合作,不是硬

1189
01:34:24,060 --> 01:34:25,220
件干软件的事干硬件的事。

1190
01:34:25,220 --> 01:34:33,000
这有问题。我们说的硬件和软件,它们的界限在哪里?它们的硬件和

1191
01:34:33,000 --> 01:34:40,460
软件,就是指令集、继承器,一个代表数据,一个代表控制。这两个是它们

1192
01:34:40,460 --> 01:34:41,260
的界限。

1193
01:34:46,860 --> 01:34:47,920
好,大家休息一下。

1194
01:39:25,220 --> 01:39:27,640
其实做的东西都差不多

1195
01:39:27,640 --> 01:39:29,780
就是双前面来的都差不多

1196
01:39:29,780 --> 01:39:31,360
就看我这写了哪个

1197
01:39:31,360 --> 01:39:32,680
就有哪个脉绳

1198
01:39:32,680 --> 01:39:33,760
一边是快的

1199
01:39:33,760 --> 01:39:35,720
一边是远的

1200
01:39:58,100 --> 01:40:05,360
好 我们开始上课 这里面讲到了指令集和计程器

1201
01:40:06,540 --> 01:40:09,320
其实硬件和OS的边界不光是硬件和OS的边界

1202
01:40:09,320 --> 01:40:11,840
是硬件和我们的Compiler的边界

1203
01:40:11,840 --> 01:40:15,300
我们Compiler其实也生成了指令集和计程器这个level

1204
01:40:15,300 --> 01:40:19,220
通过这个方式我们的Compiler和OS可以

1205
01:40:19,220 --> 01:40:22,740
这种类型的软件可以和我们的硬件合在一起

1206
01:40:22,740 --> 01:40:26,740
来完成非常有趣或者非常强大的一些事情

1207
01:40:27,380 --> 01:40:29,480
但是我们的Compiler

1208
01:40:29,480 --> 01:40:31,520
我们的OS并不能控制到我们硬件

1209
01:40:31,520 --> 01:40:33,480
或者说操控到我们硬件内部细节

1210
01:40:33,480 --> 01:40:35,060
比如说我们的流水线

1211
01:40:35,060 --> 01:40:38,560
那些中间几级我们其实没法去做管理和控制

1212
01:40:38,560 --> 01:40:41,840
只有我们硬件做了非常重要的一些设计

1213
01:40:41,840 --> 01:40:43,440
使得不太可能做到这种事情

1214
01:40:43,440 --> 01:40:44,080
怎么能做到

1215
01:40:44,080 --> 01:40:45,560
除非你提供相应的指令

1216
01:40:45,560 --> 01:40:47,140
你这样没做指令我们就没法去做

1217
01:40:47,140 --> 01:40:49,380
这就是一个界限

1218
01:40:49,380 --> 01:40:53,720
界限有这么一个界定

1219
01:40:53,720 --> 01:40:56,560
但这个界定里面还有一层界限

1220
01:40:56,560 --> 01:40:59,920
实际上是对硬件的虚拟和抽象

1221
01:40:59,920 --> 01:41:02,280
就比如说我们的process memory

1222
01:41:02,280 --> 01:41:04,300
就是地址空间或者我们的file system

1223
01:41:04,300 --> 01:41:07,800
那这一层所谓的虚拟和抽象

1224
01:41:07,800 --> 01:41:09,860
它某种程度上来说也是增加了一层

1225
01:41:10,620 --> 01:41:13,860
但增加这一层是建立在和硬件的一个规则吗

1226
01:41:14,220 --> 01:41:17,100
不是 这一层更多的是说对硬件的一个抽象表示

1227
01:41:17,100 --> 01:41:20,460
这个表述是为了给我们的应用提供服务

1228
01:41:20,460 --> 01:41:23,980
所以它更多的是对应用的一层接口

1229
01:41:24,460 --> 01:41:27,420
大家需要讲的是这一块

1230
01:41:28,740 --> 01:41:32,840
那你可以看到这是我们通常在组成员里

1231
01:41:32,840 --> 01:41:34,980
或在我们的OS里面经常用到的一幅图

1232
01:41:34,980 --> 01:41:36,180
就是Win5的一个架构图

1233
01:41:36,680 --> 01:41:38,100
在这个架构图里面

1234
01:41:40,400 --> 01:41:46,300
大家觉得哪一块和我们的OS有直接的关系吗

1235
01:41:48,200 --> 01:41:49,300
能看出来吗

1236
01:41:53,760 --> 01:41:55,760
OS有 而应用程序没有

1237
01:41:55,760 --> 01:41:58,480
这比较特殊的 就是专门是针对OS的

1238
01:41:59,000 --> 01:42:03,640
能看出来吗

1239
01:42:06,400 --> 01:42:09,320
没有 所以这幅图其实更适合于组成原理

1240
01:42:09,320 --> 01:42:13,820
因为它其实了解就是怎么去让一条指令指引起来

1241
01:42:15,680 --> 01:42:21,180
但是管理和控制这个计算机的那些指令,在这里面没有体现,所以你看不出来,

1242
01:42:21,740 --> 01:42:27,100
所以这个图有点不是特别的恰当,但我没找到更好的图能够把这个展现

1243
01:42:27,100 --> 01:42:28,780
出来,只是给大家介绍一下。

1244
01:42:30,740 --> 01:42:36,880
那我们的OS在这里面把它进步抽象出来,其实有一个硬件抽象层,是向下做

1245
01:42:36,880 --> 01:42:42,200
了一个封装,但所有这一层面都不是我们说的那个跟硬件临的face。

1246
01:43:12,220 --> 01:43:15,480
OS做一个封装抽象虚拟化

1247
01:43:16,280 --> 01:43:18,680
这一层关系 不是说隔离的关系

1248
01:43:20,040 --> 01:43:22,680
好 第二个就讲这个OS和应用的关系

1249
01:43:22,680 --> 01:43:24,920
OS和应用关系是OS要给应用提供服务

1250
01:43:24,920 --> 01:43:28,380
这是它的非常重要的目标

1251
01:43:29,160 --> 01:43:32,520
第一要提供服务 第二还需要这个应用

1252
01:43:32,520 --> 01:43:34,720
不要太干扰我 不要破坏我

1253
01:43:34,720 --> 01:43:36,140
所以它有一层所谓系统交用

1254
01:43:36,140 --> 01:43:39,320
这层交用既完成了服务 也完成了隔离

1255
01:43:39,940 --> 01:43:41,280
第三个还有Memory

1256
01:43:41,680 --> 01:43:43,320
那光有性能量可能还不够

1257
01:43:43,320 --> 01:43:46,220
我们在地址空间上也要做一种隔离

1258
01:43:46,220 --> 01:43:47,660
所以有个Memory Layout

1259
01:43:48,360 --> 01:43:50,880
所以这个是我们学习理解OS和应用的关系

1260
01:43:51,800 --> 01:43:53,120
那这边看出来

1261
01:43:53,700 --> 01:43:57,960
其实后面就是我们这个Lecture 3

1262
01:43:57,960 --> 01:44:01,260
重点讲的就是这个特权级

1263
01:44:01,700 --> 01:44:03,280
你看到一个用户态、类合态

1264
01:44:04,860 --> 01:44:07,220
我觉得超勇这门课会重点讲这两个态

1265
01:44:07,220 --> 01:44:09,380
但其他的课可能会讲得少一点

1266
01:44:09,380 --> 01:44:12,900
组成原理课老师 我不知道讲过内核碳吗

1267
01:44:15,540 --> 01:44:18,120
讲一点 证明他重视程度不够

1268
01:44:18,120 --> 01:44:21,980
我们是一直给陈康主讲 让他多讲两碗

1269
01:44:23,040 --> 01:44:26,080
他总是讲特别少 没办法

1270
01:44:27,120 --> 01:44:34,220
有时候让一个老师改变是很困难的

1271
01:44:34,220 --> 01:44:35,260
这个确实是这样的

1272
01:44:35,260 --> 01:44:37,440
因为大家如果了解历史的话

1273
01:44:37,440 --> 01:44:39,680
咱们在组成员里一课以前讲的处理器是什么

1274
01:44:40,980 --> 01:44:41,920
大家有印象吗

1275
01:44:42,540 --> 01:44:43,900
你们是学习你们不知道

1276
01:44:43,900 --> 01:44:45,340
你们是用的RES5

1277
01:44:45,340 --> 01:44:46,640
一直用的MIPS

1278
01:44:47,200 --> 01:44:49,360
我跟向老师从18年开始讲

1279
01:44:49,360 --> 01:44:52,720
一直讲到2021年才讲通让他们用RES5

1280
01:44:52,720 --> 01:44:54,880
你说这个确实比较困难

1281
01:44:58,180 --> 01:44:58,540
然后

1282
01:44:59,920 --> 01:45:02,980
这个系统调用这一块就是我说这一层interface

1283
01:45:02,980 --> 01:45:06,960
这层interface就是需要所谓的interface

1284
01:45:07,780 --> 01:45:13,080
如果没有所谓的内阁态用户态这种概念的话,它的弹出带偶没区别,但

1285
01:45:13,080 --> 01:45:19,760
有了这个概念之后,这个系统的用户态就不是弹出带偶了,它有更严

1286
01:45:19,760 --> 01:45:23,960
格的安全的设置,这就是一个考虑。

1287
01:45:23,960 --> 01:45:29,020
而这种用母态内革态其实不是软件定的,这是硬件定的。

1288
01:45:29,060 --> 01:45:34,520
某种程度上来说,硬件比软件在这种隔离性上可以做得更好,

1289
01:45:35,020 --> 01:45:40,420
存靠软件做不到。所以这个是软硬合作,但是是base在硬件基础上。

1290
01:45:40,560 --> 01:45:44,940
硬件不提供这种用母态内革态的话,某种软件很难做到所谓的

1291
01:45:44,940 --> 01:45:45,740
隔离。

1292
01:46:00,280 --> 01:46:06,320
我们可以在应用程序中直接调用内核的函数吗

1293
01:46:06,320 --> 01:46:10,500
我们可以在内核中使用应用程序的函数吗

1294
01:46:11,520 --> 01:46:13,560
大家先回答后两个问题简单点

1295
01:46:13,560 --> 01:46:15,000
这就是yes和no的问题

1296
01:46:15,000 --> 01:46:15,720
那个发生什么样的问题

1297
01:46:15,720 --> 01:46:18,720
我感觉还说得多一点,你同学能说一下吗?

1298
01:46:23,420 --> 01:46:25,920
因为大家已经上堂课已经会写OIS了,

1299
01:46:28,080 --> 01:46:32,720
所以如果基于上堂课的Lib OS,我们的应用程序可以直接这样内核的来说

1300
01:46:32,720 --> 01:46:33,020
吗?

1301
01:46:35,720 --> 01:46:43,220
肯定不能直接内核,确定制作,或者按期,刚听完了课,所以改变学生观念很

1302
01:46:43,220 --> 01:46:43,800
困难。

1303
01:46:45,720 --> 01:46:51,760
上堂课我讲的是,LibOS也是OS,没错吧。那个OS是以酷的形式存在的,

1304
01:46:52,400 --> 01:46:56,500
那我当然可以用程序,我觉得这个print,大家知道print是LibOS的其中一个函数,

1305
01:46:56,900 --> 01:47:02,900
它可以这样,你们要站在发展的角度看问题,不要想到现在的OS,你要想到我们当

1306
01:47:02,900 --> 01:47:03,400
前的OS。

1307
01:47:04,280 --> 01:47:09,220
在我们上堂课的生成OS里面,那个OS里面,应用程序可以直接调到内核

1308
01:47:09,220 --> 01:47:13,220
的函数,它们是一体的,我们称之为LibOS,它们是一体的。

1309
01:47:14,320 --> 01:47:18,320
这种情况是可以的 但是这种情况会有问题 我们会讲什么

1310
01:47:18,320 --> 01:47:22,220
第二个 内阁中可以使用应用程序的盘子 第二样吗

1311
01:47:22,740 --> 01:47:26,480
你要有个前提 如果是基于Linux OS 可以

1312
01:47:27,100 --> 01:47:30,460
好 那我问一下 那基于现在Linux可以吗

1313
01:47:30,460 --> 01:47:33,280
基于现在Windows可以吗

1314
01:47:36,040 --> 01:47:38,360
不行吗 我觉得是可以的

1315
01:47:38,840 --> 01:47:41,060
这就是又让大家跳了一个空颜

1316
01:47:42,840 --> 01:47:46,500
所以你们要好好学这门课 才能避免回答不了这些问题

1317
01:47:46,920 --> 01:47:50,900
但是我们再稍微讲复杂点 看这个REIT干的是什么事

1318
01:47:50,900 --> 01:47:54,920
应该还有一块 还把这个好处讲一讲

1319
01:47:55,340 --> 01:47:56,900
我想跳了下一页

1320
01:47:56,900 --> 01:48:00,620
函数量和性能量比起来 它函数量的特征就是快

1321
01:48:01,040 --> 01:48:05,060
因为它没有那么多安全检查 所以性能和安全是一个矛盾

1322
01:48:05,060 --> 01:48:08,920
这个大家需要注意 坏处就是不安全

1323
01:48:08,920 --> 01:48:16,140
这其实就是好坏的一个矛盾了。但是我们有了这个系统调用之后,这个后面会

1324
01:48:16,140 --> 01:48:17,500
讲,我这边只是列一下。

1325
01:48:17,860 --> 01:48:22,040
这个RAID系统调用之后,它可以帮助我们在某种程度上避免应用程

1326
01:48:22,040 --> 01:48:23,100
序破坏我们的OS。

1327
01:48:25,040 --> 01:48:30,180
那光是指令集的帮助还不够,我们还有一种情况下是,我们前面已经看到了,

1328
01:48:30,260 --> 01:48:33,420
我即使不执行什么特殊的指令,

1329
01:48:33,420 --> 01:48:36,520
但是我如果不停的调用函数

1330
01:48:36,520 --> 01:48:38,780
比如说大家已经看到前面我举个例子

1331
01:48:39,760 --> 01:48:41,940
就是我建立了一个占空间

1332
01:48:41,940 --> 01:48:43,500
然后OS建好了占空间

1333
01:48:44,040 --> 01:48:45,920
然后跳到应用程序去执行

1334
01:48:45,920 --> 01:48:47,340
如果应用程序我写的应用程序

1335
01:48:47,340 --> 01:48:50,020
不停地规调用

1336
01:48:50,020 --> 01:48:51,880
那很容易就会把占空间给冲掉

1337
01:48:51,880 --> 01:48:54,320
从而把OS的空间给冲掉 是吧

1338
01:48:54,320 --> 01:48:57,380
虽然你给说了这块区域是应用程序的

1339
01:48:57,380 --> 01:48:59,040
上一块区域是OS的

1340
01:48:59,040 --> 01:49:01,620
但由于我的应用程序我可以随便写

1341
01:49:01,620 --> 01:49:06,280
所以它还是可以把你的内核空间给冲掉

1342
01:49:06,280 --> 01:49:07,980
让你的内核崩溃

1343
01:49:07,980 --> 01:49:09,640
所以这个memory layout

1344
01:49:09,640 --> 01:49:12,080
光靠编辑器是不够的

1345
01:49:12,080 --> 01:49:13,260
光靠OS是不够的

1346
01:49:13,260 --> 01:49:15,740
我们还应该有种机制能够帮助我们来做隔离

1347
01:49:16,580 --> 01:49:17,760
这个大家都学过

1348
01:49:17,760 --> 01:49:19,160
这是主持人李克讲的

1349
01:49:19,160 --> 01:49:20,980
也花一定时间讲的那个

1350
01:49:20,980 --> 01:49:23,100
页表机制什么虚存机制

1351
01:49:23,100 --> 01:49:24,900
这里面我会把它真正用起来

1352
01:49:26,300 --> 01:49:27,840
所以我们看到

1353
01:49:28,800 --> 01:49:30,160
我们现在的OS

1354
01:50:30,160 --> 01:50:32,860
没问题 先冲一下电脑

1355
01:50:54,220 --> 01:50:57,120
OK 这是边界

1356
01:50:57,480 --> 01:51:02,940
好,那其实我们已经看到了,就是在控制上要做隔离,要在内容上做隔离,这

1357
01:51:02,940 --> 01:51:04,040
也是为什么要隔离的原因

1358
01:51:04,040 --> 01:51:08,220
其实要防止应用程序破坏OS,应用程序破坏其他应用程序,这是我们

1359
01:51:08,220 --> 01:51:08,860
要干的事情

1360
01:51:09,480 --> 01:51:14,240
那如果不去做这些事情的话,那我们就会出现大量的这种安全隐患

1361
01:51:14,240 --> 01:51:18,540
什么恶意程序,病毒木马,bug等等,都会导致你的机器不可用

1362
01:51:20,220 --> 01:51:20,820
这是问题

1363
01:51:22,120 --> 01:51:25,660
那大家说我们应用程序其实都不是这么写的,我们写得很规矩

1364
01:51:25,660 --> 01:51:26,860
那只是一部分人

1365
01:51:26,860 --> 01:51:28,580
但还有一部分人可能写的就不是很规矩

1366
01:51:28,580 --> 01:51:30,220
而且我们的程序也可能有bug

1367
01:51:30,220 --> 01:51:33,660
这种无意性的bug也很导致没有保护

1368
01:51:33,660 --> 01:51:35,140
没有安全保护的硬件

1369
01:51:35,140 --> 01:51:37,500
没有保护的这个基因系统会崩溃

1370
01:51:39,760 --> 01:51:42,360
所以我们需要隔离

1371
01:51:42,360 --> 01:51:43,380
我们需要隔离

1372
01:51:44,080 --> 01:51:45,060
什么叫隔离

1373
01:51:46,460 --> 01:51:48,340
这个词非常通俗的词

1374
01:51:48,340 --> 01:51:50,280
但是我们要用在我们这个context里面

1375
01:51:50,280 --> 01:51:53,480
我们要用在OS课里面来讲这个隔离

1376
01:51:53,480 --> 01:51:55,020
我们给出了一个定义

1377
01:51:55,020 --> 01:51:59,120
在这个定义 我们的定义就是比较个性化的定义

1378
01:51:59,120 --> 01:52:01,780
并不一定是那么的得到大家的认可

1379
01:52:01,780 --> 01:52:04,600
就我说的就是相当于是教书书上没有

1380
01:52:04,600 --> 01:52:05,260
隔离什么意思

1381
01:52:05,260 --> 01:52:08,200
超级统统的应用不会影响或破坏其他应用

1382
01:52:08,200 --> 01:52:09,840
或超级统统的正常执行或信息泄漏

1383
01:52:09,840 --> 01:52:10,540
这就叫隔离

1384
01:52:11,520 --> 01:52:14,380
我们站在控制和数据的角度来

1385
01:52:14,380 --> 01:52:16,220
给隔离做了一个定义

1386
01:52:16,220 --> 01:52:17,780
就不要干扰别人

1387
01:52:17,780 --> 01:52:19,180
隔离的本质是什么呢

1388
01:52:19,800 --> 01:52:22,360
隔离本质在需要交换信息和共享资源

1389
01:52:22,360 --> 01:52:23,780
那样才会出现隔离

1390
01:52:23,780 --> 01:52:28,580
隔离是要分开 但我们的OS要给我们的应用提供服务

1391
01:52:28,580 --> 01:52:32,680
你还不光 如果彻底都隔开了 那你服务也提供不了

1392
01:52:32,680 --> 01:52:36,220
所以我们要保证在提供服务的情况下 还有一定的安全性

1393
01:52:36,220 --> 01:52:41,200
这是隔离的一个本质 隔离并不意味着彻底的不共享

1394
01:52:41,200 --> 01:52:47,340
我们还要提供服务 提供数据 这一点大家对隔离要有正确的认识

1395
01:52:48,360 --> 01:52:51,220
既然要说隔离 我们要建立边界

1396
01:52:51,220 --> 01:52:54,560
Boundary 这个边界决定了各自的势力范围

1397
01:52:54,560 --> 01:52:58,580
跨界有风险 共享资源也有风险

1398
01:52:58,580 --> 01:53:01,780
所以我们要有严格的这种共享机制的一个约束

1399
01:53:03,040 --> 01:53:06,640
这是隔离 那我们隔离的对象是谁 应用程序

1400
01:53:06,640 --> 01:53:09,760
在这里我们相信自己 但不相信你 应用程序

1401
01:53:09,760 --> 01:53:12,700
就是意味着系统程序员对应用程序员是有一种

1402
01:53:12,700 --> 01:53:15,920
天然的一种不好的态度

1403
01:53:17,160 --> 01:53:19,720
隔离的方法 基于软件的隔离

1404
01:54:49,840 --> 01:54:53,500
所以我们通过这种业宝机制 我们进一步划分了所谓的用户地址

1405
01:54:53,500 --> 01:54:54,680
空间和内核地址空间

1406
01:54:56,620 --> 01:55:00,720
这个也在后面会进一步展开 这里面重点讲的是这个特权级的机制

1407
01:55:01,020 --> 01:55:03,620
第三个其实还有一个 时间的隔离

1408
01:55:04,420 --> 01:55:08,240
什么叫时间隔离 既然我们的机器只有制划一个程序 那没什么问题

1409
01:55:08,240 --> 01:55:10,020
那这个一个程序不在机器就行了

1410
01:55:10,840 --> 01:55:14,060
但是我们现在我们的计算机里面跑了N个程序

1411
01:55:14,060 --> 01:55:18,240
那如果一个程序要一直站在这个CPU去执行的话 其他程序就没有执行的

1412
01:55:18,240 --> 01:55:18,940
机会了

1413
01:55:18,940 --> 01:55:23,920
所以你一定要有种方法来避免这个应用程序死战的不放CPU这个情况

1414
01:55:23,920 --> 01:55:25,600
我们通过什么呢 中断

1415
01:55:26,240 --> 01:55:29,440
这个也是主持人讲过的 只是我们把它用在这个地方

1416
01:55:29,440 --> 01:55:35,640
主持人也讲中断 更多的是讲我们要去高效地去响应Device的请

1417
01:55:35,640 --> 01:55:35,940
求

1418
01:55:36,520 --> 01:55:40,660
这里面我们讲的是用在隔离 就是对于某一种机制

1419
01:55:40,660 --> 01:55:43,880
我们需要有多种的应用方式 它不是只有一种

1420
01:55:44,300 --> 01:55:47,440
它可以随时打断正在执行的用家程序

1421
01:55:47,440 --> 01:55:52,300
从而获得控制权 从而可以对APP进行时间上的维度的控制

1422
01:55:52,300 --> 01:55:53,240
这是三类

1423
01:55:54,080 --> 01:55:59,440
讲这三类 我们重点 这次Lecture主要讲这个 对控制的隔离

1424
01:56:01,200 --> 01:56:03,180
还有一个对破坏隔离的处理

1425
01:56:03,180 --> 01:56:08,160
就是你一旦破坏了这种隔离 控制 数据 时间

1426
01:56:08,160 --> 01:56:10,100
那么怎么来处理 异常

1427
01:56:10,100 --> 01:56:12,580
这个是中断处理 还有一个是异常处理

1428
01:56:42,580 --> 01:56:45,440
但其实我们是说想讲的是 如果越了那个映射

1429
01:56:45,440 --> 01:56:47,200
或者映射不存在 要出现什么情况

1430
01:56:47,960 --> 01:56:50,140
就是程序出现异常了 我们就要去管理

1431
01:56:50,800 --> 01:56:51,940
这是我们要去考虑的

1432
01:56:51,940 --> 01:56:53,940
就是这个地址空间更多的是站在

1433
01:56:53,940 --> 01:56:55,880
在这个地方我们讲的是安全

1434
01:56:55,880 --> 01:56:58,340
通过这个虚存来保证安全性

1435
01:56:58,340 --> 01:57:00,760
这是大家都见过的一个表

1436
01:57:02,560 --> 01:57:06,360
你看这种不同颜色代表了不同的实行单元

1437
01:57:06,360 --> 01:57:07,420
比如应用程序或者超级桶

1438
01:57:07,420 --> 01:57:08,640
比如最底下是超级桶

1439
01:57:08,640 --> 01:57:11,820
那你这里面程序想访问这边的地址空间的话

1440
01:57:11,820 --> 01:57:21,020
直接回报处,同理也是一样,这个程序,比如这个黄色的想访问绿色的地址

1441
01:57:21,020 --> 01:57:21,820
空间

1442
01:57:25,220 --> 01:57:28,580
其实我们的业表机制直接做了限制,你防不了

1443
01:57:30,140 --> 01:57:35,660
好,那么特权级这一块呢,有哪些叫特权

1444
01:57:35,660 --> 01:57:40,420
我们这边对特权的理解是说,它能对建议机系统进行管控,这叫

1445
01:57:40,420 --> 01:57:40,880
特权

1446
01:57:41,240 --> 01:57:43,980
比如说虾档、机器这一种特权

1447
01:57:43,980 --> 01:57:48,700
我改变这个进程或者程序的执行的地层间

1448
01:57:48,700 --> 01:57:49,920
这叫特权

1449
01:57:49,920 --> 01:57:51,360
这都是一些特权质疑

1450
01:57:51,360 --> 01:57:54,700
这些操作我们需要只按我们的OS

1451
01:57:54,700 --> 01:57:56,440
自己写的OS才能够去把控

1452
01:57:56,440 --> 01:57:59,660
应用程序不能去访问它

1453
01:57:59,660 --> 01:58:01,900
那对于处理器而言

1454
01:58:01,900 --> 01:58:03,000
它至少要支持

1455
01:58:03,000 --> 01:58:04,800
为了能够所谓完成这种特权体的隔绝

1456
01:58:04,800 --> 01:58:06,180
至少要支持两类

1457
01:58:06,180 --> 01:58:07,000
两类特权体

1458
01:58:07,000 --> 01:58:08,820
一个叫类合态 一个叫用户态

1459
01:58:08,820 --> 01:58:10,340
类合态专门执行超级统

1460
01:58:10,340 --> 01:58:12,240
用户台专门执行应用程序

1461
01:58:12,240 --> 01:58:15,620
这就是我们对处理器的要求

1462
01:58:15,620 --> 01:58:18,760
那我们现在的处理器

1463
01:58:18,760 --> 01:58:20,620
重要的处理器都有类似的用户台

1464
01:58:20,620 --> 01:58:24,900
这个用重要的车可能不太恰当

1465
01:58:24,900 --> 01:58:29,460
应该说如果要支持类似于像Windows Unix

1466
01:58:29,460 --> 01:58:31,480
这样的槽底统达处理器

1467
01:58:31,480 --> 01:58:33,820
它需要有这个类似用户台区分

1468
01:58:35,340 --> 01:58:37,200
这个是稍微说一下

1469
01:58:38,720 --> 01:58:41,980
然后处理器要能够,CPU要支持中端异常的处理

1470
01:58:41,980 --> 01:58:45,520
才能够对这种非法行为进行及时的响应

1471
01:58:45,520 --> 01:58:49,760
比如说打断占用CPU的,一直占用CPU的应用程序

1472
01:58:49,760 --> 01:58:53,620
让这个处理应用程序执行直接死掉,把他care掉

1473
01:58:53,620 --> 01:58:55,980
这都是我们超级统来去干的事情

1474
01:58:55,980 --> 01:58:59,280
但你能干的事情的前提是在于我们的硬件能及时响应

1475
01:58:59,280 --> 01:59:00,800
把控制权交给我们的OS

1476
01:59:02,780 --> 01:59:06,540
好,那超级统来干这个事情的那段代码

1477
01:59:06,540 --> 01:59:09,040
我们一般称之为中断处理程序

1478
01:59:09,040 --> 01:59:10,920
叫做Interrupt Handler

1479
01:59:10,920 --> 01:59:14,520
或者叫做Exception Handler来完成处理

1480
01:59:14,520 --> 01:59:19,820
对于中断和对于硬件在系列上是有不一样的

1481
01:59:19,820 --> 01:59:24,120
中断是从外设传过来的是一种异步的情况

1482
01:59:24,120 --> 01:59:27,420
而对于异常而言它是一种同步的情况

1483
01:59:27,420 --> 01:59:30,360
在这个中断我们这里面重点关注的

1484
01:59:30,360 --> 01:59:32,120
跟安全相关的主要是Timer

1485
01:59:32,120 --> 01:59:36,400
通过Timer能够保证避免应用程序死占CPU不放

1486
01:59:36,400 --> 01:59:39,340
这在我们的下一讲会专门提到这个问题

1487
01:59:42,280 --> 01:59:43,940
好 那简单小解一下

1488
01:59:43,940 --> 01:59:45,540
这个是给大家一个overview

1489
01:59:45,540 --> 01:59:48,560
你们知道就是说我们的应用程序是不可信的

1490
01:59:48,560 --> 01:59:51,380
我们的超级统其实是需要和我们硬件

1491
01:59:51,380 --> 01:59:53,380
和我们应用程序之间建立一些边界

1492
01:59:53,380 --> 01:59:56,560
这个边界不是为了纯粹的只是做了隔离

1493
01:59:56,560 --> 01:59:58,420
他们在还要相互协同起来

1494
01:59:58,420 --> 02:00:01,080
来完成各种各样的丰富的功能

1495
02:00:01,760 --> 02:00:05,380
所以接口边界他们两者是一个东西

1496
02:00:05,380 --> 02:00:14,400
但他们干了两件事情,一个是商业经营合作共享,另一个是商业经营合作

1497
02:00:14,400 --> 02:00:15,600
共享,另一个是商业经营合作共享,另一个是商业经营合作共享,另

1498
02:00:15,600 --> 02:00:15,600
一个是商业经营合作共享,另一个是商业经营合作共享,另一个是商

1499
02:00:15,600 --> 02:00:15,600
业经营合作共享,另一个是商业经营合作共享,另一个是商业经营

1500
02:00:15,600 --> 02:00:15,600
合作共享,另一个是商业经营合作共享,另一个是商业经营合作共

1501
02:00:15,600 --> 02:00:15,600
享,另一个是商业经营合作共享,另一个是商业经营合作共享,另一个

1502
02:00:15,600 --> 02:00:23,840
是商业经营合作共享,另一个是商业经营合作共享,另一个是商业

1503
02:00:23,840 --> 02:00:30,080
经

1504
02:00:30,800 --> 02:00:36,520
更加的针对Risk 5来讲这个细节

1505
02:00:36,520 --> 02:00:38,080
因为讲这个细节在于

1506
02:00:38,620 --> 02:00:39,740
有了这些知识之后

1507
02:00:39,740 --> 02:00:41,560
你就能够设计一个P2D操作

1508
02:00:41,560 --> 02:00:43,220
能够完成隔离

1509
02:00:43,220 --> 02:00:45,080
能够完成基于特先级的隔离

1510
02:00:47,140 --> 02:00:48,920
这里面主要目标

1511
02:00:50,100 --> 02:00:53,580
了解Risk 5的特先级和硬件隔离方式

1512
02:00:53,580 --> 02:00:57,240
理解它的所谓的M mode和S mode的基本特征

1513
02:00:57,240 --> 02:00:59,420
以及OS怎么利用这两个特征

1514
02:01:59,540 --> 02:02:02,420
就是我们要去掌握画面的话,也是比较复杂的。

1515
02:02:03,900 --> 02:02:08,820
那Risk 5呢,它上一上还不够成功,但是在教学上很成功。

1516
02:02:08,920 --> 02:02:15,800
因为它来自于学校,学校要设计一种处理器,第一要简单、灵活,这样才

1517
02:02:15,800 --> 02:02:17,220
能让学生认可。

1518
02:02:17,500 --> 02:02:21,000
如果太复杂的话,那没有人认可了。

1519
02:02:21,160 --> 02:02:24,560
那同学就说了,MIPS也足够简单,为啥不选MIPS?

1520
02:02:24,560 --> 02:02:26,360
这是刘老师问我的一句话

1521
02:02:27,600 --> 02:02:28,660
我先把这个说

1522
02:02:29,600 --> 02:02:30,840
大家可以稍微看一下

1523
02:02:30,840 --> 02:02:33,260
就是从比较掌握这个硬件来说

1524
02:02:33,260 --> 02:02:36,820
你会发现X86的硬件规范手册有几千页

1525
02:02:36,820 --> 02:02:37,760
R也有几千页

1526
02:02:37,760 --> 02:02:38,920
但Risk 5只有几百页

1527
02:02:39,960 --> 02:02:41,880
是差不多少了一个数量级

1528
02:02:42,400 --> 02:02:44,280
这就使得你可以比较短的时间内

1529
02:02:44,280 --> 02:02:46,120
去对Risk 5有一个比较深入的了解

1530
02:02:46,700 --> 02:02:48,700
而且大家应该上过的主持人的课

1531
02:02:48,700 --> 02:02:50,720
应该会对Risk 5有一个清楚的了解

1532
02:02:50,720 --> 02:02:51,980
我觉得是OK的

1533
02:02:51,980 --> 02:02:54,360
特别是你免上过X86汇编

1534
02:02:54,360 --> 02:02:56,820
你会发现RISC-V会员比差不多会员要简单很多

1535
02:02:56,820 --> 02:02:57,160
是吧

1536
02:02:58,760 --> 02:03:00,080
那为什么不选MIPS

1537
02:03:00,700 --> 02:03:02,960
因为MIPS其实是需要升级的

1538
02:03:02,960 --> 02:03:04,660
做MIPS的人也是做RISC-V的人

1539
02:03:05,220 --> 02:03:06,460
他如果再做MIPS的话

1540
02:03:06,460 --> 02:03:08,020
他没有一个提升

1541
02:03:08,020 --> 02:03:10,400
他需要创造新的东西

1542
02:03:10,880 --> 02:03:13,060
那MIPS的一些太简化的东西

1543
02:03:13,060 --> 02:03:15,040
在RISC-V里面做了改进

1544
02:03:15,040 --> 02:03:16,580
所以我们如果去理解

1545
02:03:16,580 --> 02:03:18,260
站在软件角度来看

1546
02:03:18,260 --> 02:03:19,820
这个MIPS和RISC-V的区别

1547
02:03:19,820 --> 02:03:22,660
会发现RISC-V对软件更友好

1548
02:03:23,280 --> 02:03:25,460
MIPS对软件还不够友好

1549
02:03:26,340 --> 02:03:28,760
简单的延迟槽的设计大家应该知道

1550
02:03:29,980 --> 02:03:31,260
很没必要吧

1551
02:03:32,960 --> 02:03:35,460
OK 好 这个简单过一下

1552
02:03:35,460 --> 02:03:38,080
接下来我们讲Risk 5的系统模式

1553
02:03:38,080 --> 02:03:39,240
就是系统编程

1554
02:03:40,020 --> 02:03:42,640
会有概述和CSR信任器的一个介绍

1555
02:03:42,640 --> 02:03:43,820
先讲模式这样的编程

1556
02:03:45,640 --> 02:03:46,980
这是一堆术语

1557
02:03:48,740 --> 02:03:49,920
还有吗 没有

1558
02:03:50,380 --> 02:03:53,980
这个术语也是来自于学生和老师的一个建议

1559
02:03:53,980 --> 02:03:56,300
就是我们这里面如果本来没这一页

1560
02:03:56,300 --> 02:03:58,440
如果直接给大家讲这一页一堆短语的话

1561
02:03:58,440 --> 02:03:59,740
大家也记不住是啥

1562
02:03:59,740 --> 02:04:00,960
所以先把这个给出来

1563
02:04:00,960 --> 02:04:02,260
大家能够稍微过一下

1564
02:04:02,260 --> 02:04:04,900
你看这里面已经出现了我们提到过的执行环境

1565
02:04:04,900 --> 02:04:06,180
有几种执行环境

1566
02:04:06,180 --> 02:04:08,520
就是应用程序跑的叫应用执行环境AEE

1567
02:04:09,160 --> 02:04:12,380
有方式系统跑的叫做SEE

1568
02:04:12,380 --> 02:04:14,760
那么AEE需要ABI的支持

1569
02:04:14,760 --> 02:04:17,200
需要超级我们通过ABI来提供这种所谓的接口

1570
02:04:17,200 --> 02:04:18,560
来提供现在的服务

1571
02:04:19,080 --> 02:04:24,020
那么SE要SBI的支持 要底下的RUS SBI或者其他的Bootloader

1572
02:04:24,020 --> 02:04:28,000
来提供支持 所以叫SBI 这是它的一个词的一个简称

1573
02:04:28,000 --> 02:04:30,100
那么HyperWire呢 实际上指的是

1574
02:04:30,100 --> 02:04:33,080
也是现在很流行的一类在数据中心里面存在的

1575
02:04:33,080 --> 02:04:35,540
就是我跑了个训练机 训练机这样跑N个超系统

1576
02:04:35,540 --> 02:04:38,180
所以它称之为HyperWire叫训练机管理程序

1577
02:04:38,820 --> 02:04:43,180
那么既然是训练机 那么训练机往下

1578
02:04:43,180 --> 02:04:46,480
它也需要有一个我们说的那个Bootloader SBI的管理

1579
02:04:46,480 --> 02:04:50,260
所以它叫HBI,就是它专门支持HiveWire的这些功能

1580
02:04:50,660 --> 02:04:54,640
它支持的功能一定是和HBI有一定的不同,它是HBI

1581
02:04:54,640 --> 02:04:56,560
它的指令环境是HEE

1582
02:04:56,560 --> 02:05:02,540
所以看起来虽然很多,但其实你是要了解EE和BI就OK

1583
02:05:02,540 --> 02:05:05,080
其他只是在不同场景上的一个变化而已

1584
02:05:07,340 --> 02:05:11,480
这个图我觉得主程原理应该老师也都提过

1585
02:05:11,480 --> 02:05:14,700
这就是我们Risk 5硬件架构的一个设计

1586
02:05:15,080 --> 02:05:16,720
它设计成了不同的架构

1587
02:05:16,720 --> 02:05:18,840
这种架构会实现不同的特选级

1588
02:05:18,840 --> 02:05:20,260
这里就出现特选级了

1589
02:05:20,800 --> 02:05:23,380
这里面我们至少经常看到的就是U mode

1590
02:05:23,380 --> 02:05:25,680
S mode 还有M mode

1591
02:05:25,680 --> 02:05:30,000
这个H mode相当于是现在还没有完全的实现出来

1592
02:05:30,000 --> 02:05:32,520
至少我们现在还没有一个处理器

1593
02:05:32,520 --> 02:05:34,960
实际的属于人家的处理器有这个支持

1594
02:05:34,960 --> 02:05:39,040
但是QMU已经把HiveWire这个mode也实现了

1595
02:05:39,040 --> 02:05:41,380
如果大家感兴趣可以去尝试一下

1596
02:05:41,380 --> 02:05:44,820
这样 正是一个问题

1597
02:05:46,360 --> 02:05:47,740
为什么要有这四种模式

1598
02:05:47,740 --> 02:05:48,980
它们的区别和联系是什么

1599
02:05:50,140 --> 02:05:52,940
我想问一下这是硬件的内容吗

1600
02:05:52,940 --> 02:05:53,660
硬件的设计

1601
02:05:54,600 --> 02:05:56,820
我们的组成园里老师怎么给大家介绍

1602
02:05:56,820 --> 02:05:58,740
如果你们提了这个问题的话

1603
02:05:58,740 --> 02:06:02,560
我想问一下刘老师和陆老师还有陈老师

1604
02:06:02,560 --> 02:06:03,840
这三位老师怎么解释的

1605
02:06:03,840 --> 02:06:04,820
你们应该都或多或少

1606
02:06:04,820 --> 02:06:06,460
总有一个老师上你们的课

1607
02:06:07,640 --> 02:06:08,460
怎么解释呢

1608
02:06:09,640 --> 02:06:10,540
为什么要有这种模式

1609
02:06:40,580 --> 02:06:45,540
然后呢,所以我需要Machine Mode加U Mode就够了。

1610
02:06:48,980 --> 02:06:50,400
那我还需要S Mode吗?

1611
02:06:53,980 --> 02:06:55,200
S Mode不是必须的是吧?

1612
02:06:58,580 --> 02:07:04,540
OK,这体现了每个Mode有它每个Mode的一个需求。

1613
02:07:06,920 --> 02:07:10,280
我可以不要U Mode,不要S Mode,只有一个M Mode。

1614
02:07:10,540 --> 02:07:17,520
可以,哪种场景需要呢,没错啊,其实取决于应用需求

1615
02:07:17,520 --> 02:07:22,420
X86里面它也有四种模式,零到三,它有四种模式

1616
02:07:22,420 --> 02:07:26,840
但是我不可能设计出一个X86只有零模式,没有

1617
02:07:27,760 --> 02:07:31,540
ARM也是一样,但RISC-V在架构设计上来说提供了什么

1618
02:07:31,540 --> 02:07:36,160
灵活性和阻隔性,它看到了现在的应用是非常广泛的

1619
02:07:36,160 --> 02:07:41,100
但是它并不认为用一种处理器来包打天下是一种合理的设计

1620
02:07:41,100 --> 02:07:43,160
所以它把这个模式给它做了区分

1621
02:07:43,160 --> 02:07:46,140
你可以根据你的应用需求来定制你的处理器

1622
02:07:46,140 --> 02:07:51,200
这是RigFi里面非常重要的一个设计理念

1623
02:07:51,200 --> 02:07:56,980
如果这样的话,那意味着它可以设计出只有M mode的处理器

1624
02:07:56,980 --> 02:07:59,400
或者是只有U加M mode的处理器

1625
02:07:59,400 --> 02:08:03,160
那么这种应用场景我们说的切入式场景,大家说得很对

1626
02:08:04,180 --> 02:08:07,500
S-mode如果加个S-mode,肯定会增加复杂性。S-mode增加

1627
02:08:07,500 --> 02:08:08,260
什么复杂性?

1628
02:08:09,100 --> 02:08:18,080
所以现代衰情。你们要理解现代的含义,现代意味着复杂。

1629
02:08:18,460 --> 02:08:23,100
复杂意味着它要跑很多程序,跑很多程序意味着它要做隔离,它需要

1630
02:08:23,100 --> 02:08:25,020
有内存级的隔离。

1631
02:08:26,840 --> 02:08:32,920
要有MMU,要有页表,但是你这个M mode我其实不需要,我们程序很简单,嵌入

1632
02:08:32,920 --> 02:08:36,060
式系统里面跑不了一两个程序,但是不需要这种,像这种特限机就行了,

1633
02:08:36,500 --> 02:08:38,260
或者一个非常简单的内存管理就行了。

1634
02:08:38,620 --> 02:08:42,500
但你要有S mode的话,我可以增加复杂性,这种复杂性我可以设计出专门

1635
02:08:42,500 --> 02:08:47,720
针对跑现代超级统的,支持多应用程序的这种处理器。

1636
02:08:48,180 --> 02:08:53,280
这就是我们现在说的那个,我们给大家做实验的QMode里面跑的,或者什么KR

1637
02:08:53,280 --> 02:08:59,560
10啊,哪吒啊,这些处理器,它就需要去有SMode,是灵活性导致的,

1638
02:08:59,800 --> 02:09:02,800
它们区别是有,灵活性也是有,还有联系在哪呢?

1639
02:09:03,120 --> 02:09:09,060
一个是搭在另一个技术之上的,就是你的Mode就保这个最小级,最基本的功

1640
02:09:09,060 --> 02:09:13,660
能放在Mode,但你要增加一点点功能,比如说我要增加对页表的支持,我要加

1641
02:09:13,660 --> 02:09:14,480
个SMode。

1642
02:09:14,480 --> 02:09:20,340
我如果要加一个对虚拟机的支持,我还要加一个H-Mode,你可以根据你的应

1643
02:09:20,340 --> 02:09:24,480
用需求来设计出不同的处理器,这是RISC-V很重要的一个特点,这是为什么

1644
02:09:24,480 --> 02:09:26,160
要有四种Mode的一个设计。

1645
02:09:27,280 --> 02:09:33,020
那我们这里面,第二个问题就是我们这里面讲的其实是USM会设计到这三个M

1646
02:09:33,020 --> 02:09:39,620
ode,但是核心的还是S-Mode,也意味着我们针对的是现代的处理器和

1647
02:09:39,620 --> 02:09:41,060
现代的应用来给大家讲。

1648
02:09:41,680 --> 02:09:43,260
如果真是讲OS的话

1649
02:09:43,260 --> 02:09:45,320
其实很多RTOS不需要

1650
02:09:45,320 --> 02:09:48,140
就是超级统和invented OS不需要页面

1651
02:09:48,140 --> 02:09:49,180
它就跑在这种

1652
02:09:49,180 --> 02:09:50,240
我们说这种模式下

1653
02:09:50,240 --> 02:09:54,080
就是只有U和M这种构图就够了

1654
02:09:54,080 --> 02:09:55,060
它也叫超级统

1655
02:09:55,060 --> 02:09:57,520
但它少了一块

1656
02:09:58,480 --> 02:09:59,980
好 第二个叫系统编程

1657
02:09:59,980 --> 02:10:02,940
系统编程是或者系统模式

1658
02:10:02,940 --> 02:10:06,120
所谓系统模式就是跟系统编程相关的Rev5模式

1659
02:10:06,120 --> 02:10:07,360
又多了系统编程

1660
02:10:07,360 --> 02:10:08,000
系统编程什么意思

1661
02:10:08,000 --> 02:10:10,660
系统编程是跟本科程相关的软件编程

1662
02:10:10,660 --> 02:10:13,280
跟once相关,我们说并不是os,为什么呢?

1663
02:10:13,340 --> 02:10:20,500
系统编程其实不光是说可能,它会涉及到上面一点的酷,系统酷,这也是需要

1664
02:10:20,500 --> 02:10:20,800
去了解。

1665
02:10:20,900 --> 02:10:27,500
为什么大家看到前面我要给那个跑的应用程序要建立什么那个站,需要给它建立

1666
02:10:27,500 --> 02:10:31,440
站的空间,需要给它清BSS,这些不一定要在内核里面实现,

1667
02:10:31,520 --> 02:10:36,020
可以在用户上实现,但它也是属于系统编程,它需要去支持一个通用的一个

1668
02:10:36,020 --> 02:10:37,880
应用的一个需求,这就是系统编程。

1669
02:10:39,480 --> 02:10:46,340
好 这一块我们重点其实是在讲这种架构下的

1670
02:10:46,340 --> 02:10:49,000
一种Risk 5的一个系统模式

1671
02:10:49,000 --> 02:10:50,940
这个就给大家简单说一下

1672
02:10:50,940 --> 02:10:53,340
前面已经解释了这些术语

1673
02:10:55,080 --> 02:10:58,040
这种模式会涉及到特圈级模式

1674
02:10:58,040 --> 02:11:05,460
特圈级主要讲的是supervisor mode和user mode这两类

1675
02:11:05,460 --> 02:11:12,620
所以我们前面提到的就是前面这个上一节讲到的这个用户它其实叫user mode

1676
02:11:12,620 --> 02:11:15,120
而kernel mode指的就是这里面说的supervisor mode

1677
02:11:15,120 --> 02:11:17,460
它把supervisor定义为os 就是kernel

1678
02:11:18,560 --> 02:11:21,020
好 那么既然在kernel里面 那么kernel里面的操线

1679
02:11:21,020 --> 02:11:22,580
我们就应该具有强大的应用控制了

1680
02:11:22,580 --> 02:11:24,820
所以我们的在s mode下

1681
02:11:24,820 --> 02:11:27,540
我们处理器要给我们os提供足够的支持

1682
02:11:27,540 --> 02:11:29,860
这个支持后面会看到有哪些支持

1683
02:11:32,280 --> 02:11:36,980
这只回答那个问题,就是应用需求的变化会需要灵活的硬件构造,所以我们

1684
02:11:36,980 --> 02:11:39,860
会有四种方式,而且可以组合。

1685
02:11:43,720 --> 02:11:47,620
那U-MODE干什么事情?U-MODE跑应用程序,它运行的指令

1686
02:11:47,620 --> 02:11:52,180
是非特写的指令,它不能指引特写指令。

1687
02:11:52,180 --> 02:11:55,180
既然不能执行特性的指令,它能完成的就是你们现在

1688
02:11:56,300 --> 02:11:59,620
大部分同学去组成原理去设计的那些指令,就是应该是非特性的

1689
02:11:59,620 --> 02:12:00,240
指令

1690
02:12:00,240 --> 02:12:03,980
除非你们要去设计到一些 CSR 的操作,那个后面会讲

1691
02:12:04,780 --> 02:12:09,040
就是组成原理可能讲的更多的是这种基于非特性的模式下的这种

1692
02:12:09,040 --> 02:12:10,180
处理器的构造

1693
02:12:11,800 --> 02:12:16,820
但是我们 4S 课要去讲 S mode,特性的模式,Privilege mode

1694
02:12:16,820 --> 02:12:20,300
这个 mode 下,它实际上是能够执行一些特殊的指令

1695
02:12:20,300 --> 02:12:24,220
和操作,能够去管控,可以管控计算机。

1696
02:12:24,600 --> 02:12:27,360
而这些指令,它不是简单地为了计算,

1697
02:12:27,460 --> 02:12:30,020
而不是为了我们支持应用而做的,

1698
02:12:30,020 --> 02:12:33,380
而是为了能够去管理计算机而设计的。

1699
02:12:33,460 --> 02:12:35,140
这是属于特权指令。

1700
02:12:35,360 --> 02:12:38,280
那这个H mode是为了管什么呢?管OS。

1701
02:12:38,860 --> 02:12:41,400
所以它也有一些特殊的操作,

1702
02:12:41,620 --> 02:12:44,060
是为了方便管理OS的。

1703
02:12:45,240 --> 02:12:48,280
还有一个M mode,是为了管上面所有软件。

1704
02:12:49,040 --> 02:12:53,660
就是它可以只管U,也可以只管S,也可以只管H。

1705
02:12:55,080 --> 02:13:01,760
这就是这个M mode它虽然它上面支持得多,但是它只维持一个最小的核心。

1706
02:13:02,020 --> 02:13:07,720
刚才有人说得很对,这个M mode里面跑的软件是非常小小的,非常安全的。

1707
02:13:08,340 --> 02:13:11,080
这样越底层的责任越大,它越要安全。

1708
02:13:11,940 --> 02:13:13,420
责任大不意味着能力强。

1709
02:13:14,120 --> 02:13:17,620
这还是不一样,就是有时候责任大的能力也强,其实在这个里面不是这样。

1710
02:13:17,620 --> 02:13:22,000
它管不了页表 但它能管物理类层

1711
02:13:22,000 --> 02:13:24,920
所以你上面既是有页表 它要破坏也是

1712
02:13:24,920 --> 02:13:26,720
想要破坏也是很容易破坏掉

1713
02:13:26,720 --> 02:13:29,780
它不是用那个物理虚存的限制

1714
02:13:30,780 --> 02:13:36,500
所以这个Mode是一个特殊的一块软件

1715
02:13:36,500 --> 02:13:38,820
我们这里面不会去设计它的实现

1716
02:13:38,820 --> 02:13:44,200
我们只是知道说Mode完成了对OS的一个启动加载

1717
02:13:44,200 --> 02:13:47,120
完成了对OS的一些基本服务的支持

1718
02:13:47,120 --> 02:13:48,600
基本上有这一点就够了

1719
02:13:50,680 --> 02:13:55,440
如果只有M mode 我可以设计出蓝牙耳机

1720
02:13:56,060 --> 02:13:58,500
如果只有U架M 可以设计一个电视遥控器

1721
02:13:58,500 --> 02:14:02,040
如果三个都有 可以设计出一个USM 可以设计一个手机

1722
02:14:02,660 --> 02:14:05,880
如果再加上H mode 我可以设计出处理中心的服务器的处理器

1723
02:14:07,620 --> 02:14:09,320
这就是它灵活组合的一个特点

1724
02:14:14,840 --> 02:14:23,320
我们重点是这个USM这三种模式,重点讲的是S,但你要理解的是USM。

1725
02:14:26,460 --> 02:14:34,140
那我们再回头理解一下特先级,其实每一个特先级,就是每一级它都是为不同

1726
02:14:34,140 --> 02:14:36,860
的软件提供的一种保护机制,大家需要注意。

1727
02:14:36,860 --> 02:14:41,700
在这里面,同样一个处理器,当它位于不同的特权级的时候,

1728
02:14:42,240 --> 02:14:48,640
那么它所有的特权都是由你的CPU设计的时候就限定好的。

1729
02:14:49,420 --> 02:14:53,900
而这里面限定的还可以做一定的调整,这个调整就通过CSR来进行配

1730
02:14:53,900 --> 02:14:54,180
置。

1731
02:14:54,420 --> 02:15:01,360
CSR就是Control,控制状态技能器来管理的。

1732
02:15:01,380 --> 02:15:05,220
而这个技能器是一类特殊的技能器。

1733
02:15:05,220 --> 02:15:10,040
通常我们说通用,比如说X0到X31,这是通用系统器

1734
02:15:10,040 --> 02:15:15,540
但这类系统器是这个之外的,它叫CSR系统器

1735
02:15:15,540 --> 02:15:19,440
那么这个系统器和我们系统的管理和控制非常相关

1736
02:15:19,440 --> 02:15:24,360
所以这类系统器,绝大多数这类系统器都不是我们的应用程序可以访

1737
02:15:24,360 --> 02:15:25,020
问的

1738
02:15:25,020 --> 02:15:26,800
一旦访问这些系统器就会产生异常

1739
02:15:26,800 --> 02:15:32,420
但是我们处于S mode下的超系统,它可以访问这里面的大部分系统器

1740
02:16:05,220 --> 02:16:10,920
比如说我们的应用程序就是需要得到显示字幕创,最终这个显示字幕创

1741
02:16:10,920 --> 02:16:14,440
是要通过外设来输出的,无论是创果还是显示器。

1742
02:16:15,320 --> 02:16:18,800
那你既然不让我去碰这些东西,我怎么能够支持呢?

1743
02:16:19,020 --> 02:16:27,400
所以这一层隔离,它一定还有一个通道能够跨越这个特性集,我们应用程序

1744
02:16:27,400 --> 02:16:29,460
一定要有一个方法能够跨越这个特性集来搞。

1745
02:16:29,460 --> 02:16:37,260
这靠什么?靠ABI中的一个或者几个特殊的指令,可以帮我们跨越特研机。

1746
02:16:38,440 --> 02:16:43,540
跨越之后,第一,好处在于,我应用程序写得很简单了,我只要给一个

1747
02:16:43,540 --> 02:16:46,880
函数,只要表现出一个函数就可以帮我跑去print。

1748
02:16:47,720 --> 02:16:55,120
但其实细节也隐藏了,这样符合我们魔化编程的设计思路,同时也保

1749
02:16:55,120 --> 02:16:55,700
证了安全性。

1750
02:16:55,700 --> 02:17:01,660
所以这种方式就是一种有限的共享,来实现这种所谓的隔离

1751
02:17:05,140 --> 02:17:10,180
另外一点,我们的OS通过这几层的保护,还可以支持多个应用,多道运行

1752
02:17:10,860 --> 02:17:15,280
这一点不是靠硬件,是靠我们OS的设计

1753
02:17:15,280 --> 02:17:19,640
我们OS既然我们可以访问CSR集团器,可以管理控制机器

1754
02:17:19,640 --> 02:17:23,600
那我们自然就可以设计出非常灵活的一些方法和机制

1755
02:17:23,600 --> 02:17:25,440
让这个切换机系统更加高效

1756
02:17:25,440 --> 02:17:27,680
这就是多道程序执行的一个特点

1757
02:17:29,920 --> 02:17:30,280
OK

1758
02:17:31,860 --> 02:17:32,220
好

1759
02:17:32,220 --> 02:17:34,020
这里面给出了这个编号

1760
02:17:34,020 --> 02:17:34,840
就是执行环境

1761
02:17:34,840 --> 02:17:37,000
就是ADP OS VMM BIOS

1762
02:17:37,000 --> 02:17:39,080
VMM的含义是Watch Machine Monitor

1763
02:17:39,080 --> 02:17:40,500
就是我们是Hypervisor的意思

1764
02:17:40,500 --> 02:17:42,760
就是支持跑OS的一个底层软件

1765
02:17:43,620 --> 02:17:45,920
那么他们这些跨特讯机怎么来跨

1766
02:17:45,920 --> 02:17:46,920
这里面给了一些例子

1767
02:17:46,920 --> 02:17:50,000
比如说ADP执行一个这个Eco这条指令

1768
02:17:51,280 --> 02:17:52,420
执行Eco这条指令

1769
02:17:52,420 --> 02:17:56,780
就可以跨到下一级 下一个高层级

1770
02:17:56,780 --> 02:18:01,550
比如说这里面APD可以直接从U-Type到S-Type

1771
02:18:02,500 --> 02:18:06,100
那我想问一下这个在应用程序执行这个E-Core

1772
02:18:06,100 --> 02:18:07,360
它能跨到这儿来吗

1773
02:18:07,360 --> 02:18:08,900
跨到这个M-Type去吗

1774
02:18:12,360 --> 02:18:14,520
我是不是要让你们思考一下

1775
02:18:14,520 --> 02:18:16,100
光是听不思考的话

1776
02:18:16,100 --> 02:18:18,340
大脑容易僵化 可以吗

1777
02:18:48,780 --> 02:18:56,140
你缺一个解释,你这样解释的合理,说不能也是对的,说能也是对的,取决于

1778
02:18:56,140 --> 02:18:58,720
你的context,比如说上下文。

1779
02:18:59,180 --> 02:19:05,220
如果我这个处理器是U加M这种组合的处理器,那么U执行一个E扣,

1780
02:19:05,260 --> 02:19:06,940
它就回到的是M太。

1781
02:19:07,580 --> 02:19:16,260
如果这个处理器是USM,且这个M把它这个,对,USM这种情况下,那么这个U执行

1782
02:19:16,260 --> 02:19:17,620
一个E扣,回到的是S太。

1783
02:20:47,840 --> 02:20:51,140
我就不让它去执行特性操作,时间的隔离

1784
02:20:51,140 --> 02:20:54,720
通过设置这个中段来完成时间的隔离

1785
02:20:54,720 --> 02:21:00,360
然后再通过设置地址空间建立页表来完成数据的隔离

1786
02:21:00,360 --> 02:21:05,720
这就是,其实这三类都是跟设置CSR相关的

1787
02:21:05,720 --> 02:21:07,440
我们都是通过设置CSR来完成

1788
02:21:08,160 --> 02:21:10,880
这也是一个我觉得Risk 5设计的

1789
02:21:10,880 --> 02:21:12,740
这种所谓的经验指令集的一个设计特点

1790
02:21:12,740 --> 02:21:15,360
它并没有增加指令集的个数

1791
02:21:15,360 --> 02:21:19,040
而是增加了一些对 CSR 指令集的

1792
02:21:19,040 --> 02:21:20,680
有限的一些访问的指令

1793
02:21:20,680 --> 02:21:22,300
大概三四条指令

1794
02:21:22,300 --> 02:21:24,440
它是靠 CSR 的一个复杂性

1795
02:21:24,440 --> 02:21:28,900
来完成了这个管理的复杂性的一个设置

1796
02:21:30,200 --> 02:21:33,360
好 那我这个 RISC-V 的系统模式

1797
02:21:33,360 --> 02:21:35,440
我就给大家简单介绍完毕

1798
02:21:35,980 --> 02:21:36,560
有问题吗

1799
02:21:38,620 --> 02:21:41,000
好 没有问题 我们就讲编程了

1800
02:21:41,860 --> 02:21:44,020
既然有了硬件 我们要开始软件编程

1801
02:21:44,020 --> 02:21:48,560
大家在讲这个系统编程的过程中,你还会发现不停地跟这个意念打

1802
02:21:48,560 --> 02:21:51,020
交道,大部分是跟CSR打交道。

1803
02:21:52,540 --> 02:21:55,300
所以你会更进一步去了解CSR技能机。

1804
02:21:58,580 --> 02:22:02,580
我觉得反正主程原理应该讲CSR技能机讲得不多,所以我这边稍微,根

1805
02:22:02,580 --> 02:22:04,680
据情况来,会稍微展开一点讲。

1806
02:22:06,720 --> 02:22:09,860
那这个系统编程呢 就是特别在OS这个level

1807
02:22:09,860 --> 02:22:13,700
它需要去做 我们前面讲这个超系统干了一些重要的事情

1808
02:22:13,700 --> 02:22:18,860
进程管理 进程调路 中端硬盘处理 还有什么内存管理等等

1809
02:22:18,860 --> 02:22:24,240
所有这些东西都需要去执行一些特权级的操作 或者系统级的一些操作

1810
02:22:24,240 --> 02:22:27,500
而这些操作呢 第一 应用程序不能执行

1811
02:22:27,500 --> 02:22:30,400
第二呢 它要执行呢 它需要我们的硬件支持

1812
02:22:30,400 --> 02:22:32,560
这个硬件支持就是对控制CSR来完成

1813
02:22:34,720 --> 02:22:37,180
所以我们要知道这些 CSR 其实有不同的功能

1814
02:22:40,860 --> 02:22:44,760
好 那么在进一步讲 CSR 之前

1815
02:22:44,760 --> 02:22:50,940
我们回过头来再按照 USM 或者 UMS 这个 Mode

1816
02:22:50,940 --> 02:22:54,240
来讲讲在这不同层面上怎么去编程

1817
02:22:54,240 --> 02:22:55,840
比如说我在 U Mode 里面

1818
02:22:57,660 --> 02:23:01,160
我要直接去得到系统级的一些资源

1819
02:23:01,160 --> 02:23:02,960
或者得到系统级的服务怎么办

1820
02:23:02,960 --> 02:23:04,040
我们说系统标用

1821
02:23:04,040 --> 02:23:07,440
那现在要怎么来做,X86怎么做的

1822
02:23:08,600 --> 02:23:12,880
想想,有印象吗?你们学过X86会员啊,我还没记错的话

1823
02:23:12,880 --> 02:23:14,840
张文慧老师应该给大家怎么介绍的

1824
02:23:17,260 --> 02:23:19,440
可能大家说记不住那条指令了,稍微

1825
02:23:20,840 --> 02:23:25,700
它有它的指令,它也有通过Intel 80来完成这种所谓的转通段

1826
02:23:25,700 --> 02:23:28,800
这种方式来总之会从用户台到内核台

1827
02:23:28,800 --> 02:23:32,420
总有一个特定的指令,或者是特定的一个方式

1828
02:23:32,420 --> 02:23:35,740
那我们在Risk5而言,它就是一条特殊的指令,叫ECore。

1829
02:23:36,040 --> 02:23:40,940
从这条指令就可以实现从用台到内核台的切换。

1830
02:23:41,120 --> 02:23:44,680
一旦到内核台之后,我们的OS要做一系列的安全检查,

1831
02:23:44,860 --> 02:23:48,980
确保这个ECore没有什么威胁,才会做进一步的一些操作。

1832
02:23:56,640 --> 02:24:01,080
这也是一个建议,后面有大量的一些比较枯燥的一些内容。

1833
02:24:03,040 --> 02:24:09,760
所以我也是得到了,我上课比较僵化,所以需要大家给一些反馈,我才能够知道改

1834
02:24:09,760 --> 02:24:10,260
进。

1835
02:24:10,520 --> 02:24:14,960
像这里面就是大家说先要讲一下粒子,有了粒子之后才更好地去展示

1836
02:24:14,960 --> 02:24:21,780
整个讲后面的U、M、S之间怎么交互的,他们准备怎么去控制的。

1837
02:24:21,800 --> 02:24:25,200
那我给了一个小粒子,就是在用户台打印Hello World的小粒子。

1838
02:24:25,720 --> 02:24:30,280
这个小粒子不需要超级统,或者只需要LibreOS这个level的超级统就OK了。

1839
02:24:31,280 --> 02:24:33,920
有了这个之后呢

1840
02:24:33,920 --> 02:24:36,520
我们看到我们这里面展现出来

1841
02:24:36,520 --> 02:24:37,960
在用户下打印Hello World

1842
02:24:38,920 --> 02:24:40,400
就是我们前面提了个问题

1843
02:24:47,540 --> 02:24:50,840
好 没讲完 下堂课继续

1844
02:24:50,840 --> 02:24:52,900
我相信经过这堂课讲完

1845
02:24:52,900 --> 02:24:54,700
至少大家会编LibreOS

1846
02:24:55,200 --> 02:24:56,320
这个批处理来下一步

1847
02:24:56,320 --> 02:24:57,520
但LibreOS应该会编

1848
02:24:57,520 --> 02:25:02,080
所以客户一定要去做一下练习 做一下实验

1849
02:25:02,080 --> 02:25:04,000
好 下课

1850
02:25:31,140 --> 02:25:34,500
你们不是没有学习相机干论吗

1851
02:25:34,500 --> 02:25:37,260
其实学习干论 其实学习干论讲这个

1852
02:25:37,260 --> 02:25:39,800
讲这个 有其他的

