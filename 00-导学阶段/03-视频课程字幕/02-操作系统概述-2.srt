1
00:00:58,240 --> 00:00:59,980
好 我们开始上课了

2
00:01:05,860 --> 00:01:10,100
首先 简单回顾一下上档课的内容

3
00:01:10,100 --> 00:01:13,040
还有一些稍微有一些更新

4
00:01:13,040 --> 00:01:16,380
大家可以看一看

5
00:01:16,380 --> 00:01:17,920
比如在

6
00:01:18,540 --> 00:01:21,480
不是 应该是较字

7
00:01:21,480 --> 00:01:25,820
Actually Easy

8
00:01:27,520 --> 00:01:29,300
就是 我再简单说一下

9
00:01:29,300 --> 00:01:29,960
朋友们的问题

10
00:01:29,960 --> 00:01:32,920
就是基本上我们都是所有的信息都是要不然在

11
00:01:33,420 --> 00:01:36,660
基本上我们都会在网络学单上放一会

12
00:01:36,660 --> 00:01:41,460
然后还有一些因为可能会有些更新

13
00:01:41,460 --> 00:01:43,660
就是更新的及时更新的话

14
00:01:43,660 --> 00:01:46,140
每次在网络学单上重传其实效率比较低

15
00:01:46,140 --> 00:01:49,920
所以我们就直接放在这个网页上

16
00:01:49,920 --> 00:01:51,420
这样大家看起来会方便一点

17
00:01:51,420 --> 00:01:55,200
直接往网页就可以包括在线的slides

18
00:01:56,140 --> 00:01:58,100
然后实践的参考书

19
00:01:58,560 --> 00:02:01,320
以及后续 这也更新了一下 上一堂课还没有更新

20
00:02:01,320 --> 00:02:05,300
这一堂课就是 我们也是后面更新的 就是我们的助教

21
00:02:07,360 --> 00:02:09,900
咦 这个是什么声音 这么醒

22
00:02:22,260 --> 00:02:30,000
其实我们的实验也都是除了在我们的清华的Git server里面之外,也会放

23
00:02:30,000 --> 00:02:34,120
在这上面,使得大家用起来更加方便一些。

24
00:02:35,260 --> 00:02:39,800
当然我们这个实验这一块,我们的助教还是在抓紧,

25
00:03:09,820 --> 00:03:16,140
需要的课程上完之后,也意味着这个实验的开始的一个阶段,基本上就是这么

26
00:03:16,140 --> 00:03:18,780
一个过程。

27
00:03:20,160 --> 00:03:23,860
好,当然也可以提前做,所以我希望我们的助教能够尽快地把这个实验部分放在

28
00:03:23,860 --> 00:03:28,080
上去,实际上有些同学呢,通过自学的方式能够比较快速地把

29
00:03:28,080 --> 00:03:28,740
这个学完。

30
00:03:29,860 --> 00:03:32,260
好 这是这一个

31
00:03:32,260 --> 00:03:36,360
第二个是我们上的那个讲

32
00:03:37,240 --> 00:03:38,580
就是再回顾一下

33
00:03:39,380 --> 00:03:40,940
就是第二讲什么是超级系统

34
00:03:40,940 --> 00:03:43,400
这一块给大家做了一个简单的介绍

35
00:03:43,400 --> 00:03:45,560
关于超级系统的定义

36
00:03:45,560 --> 00:03:48,200
以及操作系统的抽象

37
00:03:48,200 --> 00:03:50,680
这里面包括这三个很重要的抽象

38
00:03:50,680 --> 00:03:54,660
还有就是我们后面讲到的它的特征

39
00:03:54,660 --> 00:03:56,320
我现在只是简单的回顾一下

40
00:03:56,320 --> 00:03:59,840
就是可以看到对于这个抽象来说

41
00:03:59,840 --> 00:04:02,440
我们看到的CPU对应的进程

42
00:04:02,440 --> 00:04:05,540
磁盘或者我们的存储设备对应的文件

43
00:04:05,540 --> 00:04:07,700
然后我们的内存对应的地址空间

44
00:04:07,700 --> 00:04:09,600
当然这里面我们并没有深入展开讲

45
00:04:10,000 --> 00:04:14,120
我们希望是同学一开始就可能看了个大概

46
00:04:14,860 --> 00:04:16,240
也最多是把它背下来

47
00:04:16,240 --> 00:04:18,160
但我这背下来其实理解的并不是很深刻

48
00:04:18,160 --> 00:04:20,600
我们希望后面的实验和通过大家的练习

49
00:04:20,600 --> 00:04:22,000
能够对它有更深刻的理解

50
00:04:23,440 --> 00:04:24,860
那么这个特征也是一样

51
00:04:24,860 --> 00:04:29,140
其实光讲这个特征其实还是比较字面上的

52
00:04:29,680 --> 00:04:33,520
那我觉得我也希望同学也能够通过这种实践

53
00:04:33,520 --> 00:04:36,040
这个实践不一定说非要去写内容的实践

54
00:04:36,040 --> 00:04:39,280
那些应用程序它也能够体会到这里面的

55
00:04:39,280 --> 00:04:42,620
操作系统所具有这种并发共享虚拟异步的特征

56
00:04:42,620 --> 00:04:46,760
这是让大家就是有个印象

57
00:04:46,760 --> 00:04:47,980
这是这一块

58
00:04:49,160 --> 00:04:52,480
然后讲这个历史演变的时候

59
00:04:53,060 --> 00:04:55,200
其实需要注意的就是一点就是

60
00:04:55,200 --> 00:04:56,480
你可以看到

61
00:04:56,480 --> 00:04:58,780
操作系统并不是一开始就已经

62
00:04:58,780 --> 00:05:00,460
设计到我们现在这个样子了

63
00:05:00,460 --> 00:05:01,900
它有一个发展有一个过程

64
00:05:01,900 --> 00:05:05,060
这个过程的变化是由于我们的

65
00:05:05,060 --> 00:05:06,140
硬件的变化

66
00:05:06,140 --> 00:05:09,200
我们的应用的需求的变化导致的

67
00:05:09,200 --> 00:05:10,780
所以它也是一个螺旋上升

68
00:05:10,780 --> 00:05:13,780
甚至在某些地方还有下降的一个过程

69
00:05:13,780 --> 00:05:15,900
包括我们说在

70
00:05:16,560 --> 00:05:18,720
讲到比如下降个人电脑的时候

71
00:05:18,720 --> 00:05:19,640
其实早期的个人电脑

72
00:05:19,640 --> 00:05:21,840
其实它的OS是很弱的

73
00:05:21,840 --> 00:05:23,800
跟以前比起来反而更加弱

74
00:05:23,800 --> 00:05:25,180
那这就是这些所谓的下降度

75
00:05:25,180 --> 00:05:26,980
但是它确实满足当时的需求

76
00:05:26,980 --> 00:05:30,340
这就是一些发展的过程

77
00:05:30,340 --> 00:05:31,700
希望大家能够对它有一个理解

78
00:05:31,700 --> 00:05:33,560
就是为什么OS会变

79
00:05:33,560 --> 00:05:35,320
这个要清楚

80
00:05:36,560 --> 00:05:39,340
然后后面也讲了一些常规的OS

81
00:05:41,760 --> 00:05:46,240
这就是我们说的就是上堂课的一个简单的回顾

82
00:05:46,240 --> 00:05:52,620
那其实我觉得是通过一些题目

83
00:05:52,620 --> 00:05:56,380
可能更容易去把这个事情给说清楚

84
00:05:57,320 --> 00:05:59,300
首先我这边列了一些题目

85
00:05:59,300 --> 00:06:01,780
这些题目我其实也如果有朋友愿意答

86
00:06:01,780 --> 00:06:02,420
当然更好了

87
00:06:02,420 --> 00:06:04,540
如果不愿意答就我来回答

88
00:06:04,540 --> 00:06:05,400
有愿意回答吗

89
00:06:05,400 --> 00:06:06,300
第一个就是什么是超级统

90
00:06:09,200 --> 00:06:10,860
我看大家都很清楚

91
00:06:10,860 --> 00:06:11,660
应该什么是超级统

92
00:06:11,660 --> 00:06:16,660
超线统就是管理应用 管理硬件的一个软件

93
00:06:16,660 --> 00:06:18,120
它这个称之为系统软件

94
00:06:18,120 --> 00:06:20,460
所以我们会界定它是哪种软件

95
00:06:20,460 --> 00:06:21,400
它的作用是什么

96
00:06:21,400 --> 00:06:23,820
但是我们并不会给出像1加1等于2

97
00:06:23,820 --> 00:06:25,360
这么一个很明确的数学的一个定义

98
00:06:25,360 --> 00:06:26,420
没有那么严格的定义

99
00:06:26,420 --> 00:06:27,480
所以它会随着

100
00:06:27,480 --> 00:06:29,940
因为发现我们这堂课讲超线统的时候

101
00:06:29,940 --> 00:06:34,400
它的很多的一些特征其实在某些阶段

102
00:06:34,400 --> 00:06:35,480
比如说在做实验1的时候

103
00:06:35,480 --> 00:06:36,580
在实验2的时候可能没有

104
00:06:36,580 --> 00:06:38,500
在实验3 实验4才会有

105
00:06:38,500 --> 00:06:41,340
那么这些特征其实也是在变化的

106
00:06:41,340 --> 00:06:47,260
那它不变是什么呢 不变就是应对应用的需求和应对硬件的需求

107
00:06:47,260 --> 00:06:51,460
管理硬件和管理应用 这两方面是要不变的一方面

108
00:06:51,460 --> 00:06:55,560
所以它的目标是什么 就是向上给应用提供服务

109
00:06:55,560 --> 00:07:01,120
向下管理硬件 从而可以让我们的应用更方便地使用整个交易机

110
00:07:01,120 --> 00:07:01,640
系统

111
00:07:01,640 --> 00:07:03,340
这就是我们的目标

112
00:07:04,420 --> 00:07:10,020
好 那第二个 面向服务器的超级统计

113
00:07:10,020 --> 00:07:13,640
面向手机的超级统计在功能上有什么异同

114
00:07:13,640 --> 00:07:18,820
因为大家都有手机 你说有没有服务器 没有服务器

115
00:07:18,820 --> 00:07:20,560
但是你们其实都用过服务器

116
00:07:20,560 --> 00:07:23,640
你们访问 browser 的时候 browser 的后端就是服务器

117
00:07:25,760 --> 00:07:30,140
所以这个异同在哪呢 其实在功能上的异同其实就会

118
00:07:31,740 --> 00:07:35,820
我的理解就是取决于还是一样 站在需求的角度来考虑

119
00:07:35,820 --> 00:07:40,060
比如说你用手机的时候 你很强调这所谓的体验

120
00:07:40,480 --> 00:07:44,320
它的流畅度 应用性 人机交互这一块非常强调

121
00:07:44,320 --> 00:07:47,940
但server的时候 你就根本看不到server 没法接触到server

122
00:07:47,940 --> 00:07:51,400
所以这人机交互这一块其实就是server所忽视的

123
00:07:51,400 --> 00:07:55,120
它也不重视 所以甚至很多在server上的开发

124
00:07:55,480 --> 00:07:58,120
它就是命理行的方式 它不需要有图形界面

125
00:07:58,120 --> 00:08:00,160
然后把这个程序开发好之后

126
00:08:00,160 --> 00:08:02,020
把这个丢在服务器上跑就行了

127
00:08:02,020 --> 00:08:05,440
这就是很类似我们早期的大型机的

128
00:08:05,440 --> 00:08:07,120
应用程序的一个特点

129
00:08:08,020 --> 00:08:11,580
那对于这种功能上我只说了一点了

130
00:08:11,940 --> 00:08:13,800
其实我只给大家起个影子

131
00:08:13,800 --> 00:08:17,020
就是希望大家能够在课后

132
00:08:17,020 --> 00:08:19,200
你要能够去主动去思考

133
00:08:19,200 --> 00:08:21,140
这里面到底还有什么样的一些不同

134
00:08:25,680 --> 00:08:26,400
这是这个

135
00:08:26,400 --> 00:08:30,620
第三个 比如说对于超级系统的组成

136
00:08:30,620 --> 00:08:37,280
我们说手机和桌面是否应该包含网络乱契

137
00:08:37,280 --> 00:08:38,640
要取决于应用

138
00:08:38,640 --> 00:08:43,820
我们现在绝大部分应用都离不了网络

139
00:08:43,820 --> 00:08:45,720
如果你的超级统没有网络

140
00:08:46,420 --> 00:08:47,780
没有TCPIP协议站

141
00:08:47,780 --> 00:08:49,820
那你的 browser 没什么意义

142
00:08:49,820 --> 00:08:53,640
但是如果说你超级统有一个TCPIP协议站

143
00:08:53,640 --> 00:08:55,560
甚至在上层的系统软件层面

144
00:08:55,560 --> 00:08:58,200
这个库里面还有HTTP这些协议的话

145
00:08:58,200 --> 00:09:00,440
那么它其实已经具备了这个所谓的

146
00:09:00,440 --> 00:09:02,680
Browser所运行的一个基本的功能

147
00:09:02,680 --> 00:09:08,820
再加我们的这个桌面或者手机

148
00:09:08,820 --> 00:09:13,440
还有比较方便的 比较易用的这种图形界面

149
00:09:13,440 --> 00:09:16,360
就是它的界面层面也会成为一个

150
00:09:16,360 --> 00:09:18,200
支撑它所需要的一个东西

151
00:09:18,640 --> 00:09:20,820
所以这Browser就网络暖器

152
00:09:20,820 --> 00:09:22,760
它已经成了一个就是说

153
00:09:22,760 --> 00:09:24,820
它所需要的功能都已经存在

154
00:09:24,820 --> 00:09:28,960
但它本身的应用需求其实也是一样的

155
00:09:28,960 --> 00:09:30,360
当大家用得多了之后

156
00:09:30,360 --> 00:09:31,960
自然才能操作系统的一部分

157
00:09:31,960 --> 00:09:33,780
在20年前或者30年

158
00:09:33,780 --> 00:09:35,460
应该是在30年前

159
00:09:35,460 --> 00:09:36,740
30年前的时候

160
00:09:36,740 --> 00:09:39,720
我们还说browser不是操作系统的一部分

161
00:09:39,720 --> 00:09:40,860
但到现在

162
00:09:41,960 --> 00:09:43,740
到现在我们的通用操作系统

163
00:09:43,740 --> 00:09:45,120
当然也分操作系统也分类型

164
00:09:45,120 --> 00:09:46,460
通用操作系统比如我们的桌面手机

165
00:09:46,460 --> 00:09:47,500
就算是通用操作系统

166
00:09:47,500 --> 00:09:49,000
对于这种操作系统而言

167
00:09:49,000 --> 00:09:51,980
我们的browser已经成了一个标配

168
00:09:51,980 --> 00:09:54,020
因为它是我们操作系统的一部分了

169
00:09:54,020 --> 00:10:00,000
所以你要解释 按照我们看前面说的 在不同的历史时期

170
00:10:00,000 --> 00:10:05,380
在不同的阶段 这个超系统的组成是有变化的 其实要理解这一点

171
00:10:07,800 --> 00:10:09,140
我们再看第四个

172
00:10:11,280 --> 00:10:15,020
操作系统的核心抽象有哪些 其实我们刚才已经看到了这三个

173
00:10:16,120 --> 00:10:20,560
进程 文件 还有地址空间

174
00:10:20,560 --> 00:10:23,720
这三个 反正说起来就这么几个字吧

175
00:11:24,020 --> 00:11:27,340
与应用程序之间通过什么来进行相互操作和数据交换

176
00:11:29,100 --> 00:11:32,020
这里面说的户操作 其实更多的是

177
00:11:33,020 --> 00:11:37,440
我们的应用发布请求 我们的OS来负责响应这个请求

178
00:11:37,440 --> 00:11:40,980
其实单向的 并没有说我们OS要发出一个请求

179
00:11:40,980 --> 00:11:42,060
让我们应用去响应

180
00:11:43,020 --> 00:11:46,040
所以这个户其实单向的 并不是一个双向的

181
00:11:46,040 --> 00:11:48,420
这是一个可能的表述上面不够严谨

182
00:11:49,100 --> 00:11:50,640
但数据是双向的

183
00:11:50,640 --> 00:11:55,020
我们可能会把数据从应用的地址空间

184
00:11:55,020 --> 00:11:57,620
传给内核疫情的内核去处理

185
00:11:57,620 --> 00:11:59,860
也有可能内核处理这些信息之后

186
00:11:59,860 --> 00:12:02,720
会把这些数据从内核地址空间

187
00:12:02,720 --> 00:12:05,540
向上传给应用地址空间 这个是双向

188
00:12:06,140 --> 00:12:09,420
所以你要理解 从控制层面上来说

189
00:12:09,420 --> 00:12:13,120
OS是接收应用程序的服务 它是单向的

190
00:12:13,120 --> 00:12:16,040
但是从数据传输来说 它是双向的

191
00:12:16,040 --> 00:12:20,560
这一点我觉得大家需要去理解一下

192
00:12:21,460 --> 00:12:24,000
好 第六个是什么 第六个是超级能的特征

193
00:12:25,680 --> 00:12:29,780
那个其实还是需要背一下

194
00:12:29,780 --> 00:12:33,780
这个背一下呢 我看在哪儿

195
00:12:33,780 --> 00:12:34,200
有不对

196
00:12:39,860 --> 00:12:43,020
这个 并发共享虚拟异步

197
00:12:45,740 --> 00:12:46,620
也是八个字

198
00:12:48,080 --> 00:12:50,240
那么我理解 其实我们出了一个练习

199
00:12:50,240 --> 00:12:53,500
就是说 你们可以写一到两个程序 能够把这

200
00:12:54,160 --> 00:12:58,020
写应用程序 能够把这四个特征给反映出来

201
00:12:59,340 --> 00:13:03,240
所谓并发 我觉得你就可以写两个小程序

202
00:13:03,240 --> 00:13:06,080
它们放在一起 可以一起在运行

203
00:13:06,080 --> 00:13:08,200
这就是一个并发的体现

204
00:13:08,200 --> 00:13:09,560
当然这程序要执行时间长点

205
00:13:09,560 --> 00:13:11,580
等一下事情完了 感觉是窜想

206
00:13:12,000 --> 00:13:20,000
第二个共享,它们之间其实可以完成,比如说对同一个文件的读,一个读一个写,这

207
00:13:20,000 --> 00:13:22,360
就是一种共享的体现,如果你写一个小程序的话。

208
00:13:23,220 --> 00:13:27,660
第三个虚拟,就是你写程序的时候,其实并不知道另一个程序的存在,你可以不知道另一个程

209
00:13:27,660 --> 00:13:28,300
序的存在。

210
00:13:28,740 --> 00:13:31,900
在这种情况下,它其实是一种独占的感觉,感觉这个应用程序是独占

211
00:13:31,900 --> 00:13:37,780
的,它的Memory,它的CPU都在给你使用,这是一种虚拟的体验。

212
00:13:37,780 --> 00:13:40,640
比如说你可以给这个 你就申请4G的内存空间

213
00:13:40,640 --> 00:13:43,240
试一试 在你们的这个机器里面

214
00:13:43,240 --> 00:13:45,480
也许你有4G的内存 那就申请8G

215
00:13:45,480 --> 00:13:47,400
看下这会出现什么样的情况

216
00:13:48,700 --> 00:13:51,240
这一步呢 其实我也说过了 一步就是指引时间

217
00:13:51,240 --> 00:13:54,360
你会发现你上一个 把这个应用程序的时间设置

218
00:13:54,360 --> 00:13:57,340
指引时间设置长一点 比如说四循环 一个齿循环

219
00:13:57,340 --> 00:14:00,320
指引的时间稍微有一两分钟 这么一个时间的话

220
00:14:00,320 --> 00:14:03,520
你发现你在用相应的一些系统工具

221
00:14:03,520 --> 00:14:06,180
去统计它的指引 执行的这个完成时间的时候

222
00:14:06,180 --> 00:14:10,180
发现每次都是不一样 这个不一样就是所谓的不确定性

223
00:14:10,740 --> 00:14:16,040
这个我觉得当你拿了一个程序去展现这个超级种的特征的时候

224
00:14:16,040 --> 00:14:17,880
刘柯他的理解会更加深刻一些

225
00:14:18,420 --> 00:14:20,980
当然这都是在用的层面来理解它

226
00:14:20,980 --> 00:14:26,440
我们后面还会想到说你怎么能够在OS实现本身

227
00:14:26,440 --> 00:14:29,120
更深刻的直接地反映出他的一些特征

228
00:14:29,120 --> 00:14:34,160
这一点就需要我们在后续的讲超级种客的这个设计实现的时候

229
00:16:34,160 --> 00:16:35,640
就比较难以得到这种企业

230
00:16:35,640 --> 00:16:38,500
所以我鼓励和大家多活动

231
00:16:38,500 --> 00:16:41,420
答不出来是很好的

232
00:16:41,420 --> 00:16:42,420
没什么关系

233
00:16:42,420 --> 00:16:44,460
千万不要觉得答不出来是面子丢了

234
00:16:44,460 --> 00:16:45,640
或者要扣分了

235
00:16:45,640 --> 00:16:46,580
不会扣分

236
00:16:46,580 --> 00:16:48,360
面子也没啥

237
00:16:48,360 --> 00:16:49,660
就脸皮厚了一下

238
00:16:50,720 --> 00:16:52,040
我觉得这个没什么关系

239
00:16:52,040 --> 00:16:53,240
我觉得同学拿得挺好

240
00:16:54,460 --> 00:16:55,840
后面我就不提问了

241
00:16:55,840 --> 00:16:57,240
后面我们后面还要再讲

242
00:16:58,200 --> 00:16:58,560
所以

243
00:16:59,400 --> 00:17:01,100
我就大致就是通过这种方式

244
00:17:01,100 --> 00:17:02,720
大家可以看到后面也是类似的

245
00:17:02,720 --> 00:17:05,640
基本上会在每次课前面

246
00:17:05,640 --> 00:17:07,400
会把上一堂课大致复习一下

247
00:17:07,400 --> 00:17:08,220
或者要review一下

248
00:17:08,220 --> 00:17:10,080
大家可以比较清楚

249
00:17:10,080 --> 00:17:11,000
上一堂课讲的内容

250
00:17:11,000 --> 00:17:11,820
稍微回忆一下

251
00:17:11,820 --> 00:17:13,160
然后我们再开始这堂课的内容

252
00:17:14,760 --> 00:17:16,600
好 那我们这堂课

253
00:17:17,100 --> 00:17:18,960
是上一堂课没有讲完的内容

254
00:17:22,780 --> 00:17:23,820
系统结构

255
00:17:23,820 --> 00:17:24,980
系统结构这一块

256
00:17:25,620 --> 00:17:28,220
就是我们的OS是一个比较复杂的软件

257
00:17:29,580 --> 00:17:30,580
至少我们写

258
00:17:30,580 --> 00:17:33,400
其实我们实验的OS也要几千行代码

259
00:17:35,560 --> 00:17:36,840
不是一定要写五千行

260
00:17:37,400 --> 00:17:40,640
你要反映整个OS的构成大约五千行左右代码

261
00:17:40,640 --> 00:17:42,000
所以这个量还是稍微有点大

262
00:17:42,000 --> 00:17:44,320
但实际的OS更大 上千万行代码

263
00:17:45,000 --> 00:17:47,640
实际上这么大的一个软件的话

264
00:17:47,640 --> 00:17:52,040
它确实需要软件架构来支撑

265
00:17:52,040 --> 00:17:54,060
这种软件架构某种程度上说

266
00:17:54,060 --> 00:17:56,580
应该是属于软件工程的一个领域

267
00:17:56,580 --> 00:17:59,080
但我不知道咱们学软件工程

268
00:17:59,080 --> 00:18:01,140
有没有讲这些软件 复杂软件的设计

269
00:18:02,080 --> 00:18:02,800
有讲吗

270
00:18:04,420 --> 00:18:07,100
我假定他们没有讲超级程度的设计

271
00:18:07,100 --> 00:18:08,260
如果他讲的话

272
00:18:08,260 --> 00:18:10,020
我们就不用讲了

273
00:18:10,020 --> 00:18:13,180
至少我记得我跟软工的老师交流的时候

274
00:18:13,180 --> 00:18:14,840
他们并没有设计到OS

275
00:18:15,900 --> 00:18:18,560
我们先看到的是这个简单结构

276
00:18:18,560 --> 00:18:23,160
简单结构其实就是应用程序和OS之间

277
00:18:23,160 --> 00:18:26,360
就是一个应用和酷的关系

278
00:18:26,360 --> 00:18:27,460
OS是一个酷

279
00:18:27,980 --> 00:18:31,720
我们的应用程序直接通过权力调整的方式

280
00:18:31,720 --> 00:18:33,480
得到我们超级能服务

281
00:18:33,480 --> 00:18:35,260
所以他们是一个紧握的关系

282
00:18:35,260 --> 00:18:38,900
而且他们之间没有任何的隔离或者保护机制

283
00:18:38,900 --> 00:18:43,740
就使得当时的MS-DOS这种类似的简单的OS

284
00:18:43,740 --> 00:18:47,320
相对来说就是很容易出现一些安全的隐患

285
00:18:47,320 --> 00:18:49,500
当然现在这种架构有没有

286
00:18:50,040 --> 00:18:52,760
有一点需要注意 这个架构虽然说

287
00:18:52,760 --> 00:18:54,200
我们说它有不好的地方

288
00:18:54,200 --> 00:18:57,060
但是它有它适用的场景 什么场景呢

289
00:18:57,060 --> 00:18:59,320
比如说那个应用特别简单

290
00:18:59,320 --> 00:19:01,920
这样使得我们的OS也不需要那么复杂

291
00:19:01,920 --> 00:19:05,520
在这种场景下 这种架构还是有存在的价值的

292
00:19:05,520 --> 00:19:07,260
比如说我们现在的

293
00:19:07,260 --> 00:19:09,340
现在的领域 有些工业控制领域

294
00:19:09,340 --> 00:19:11,560
他们的一些应用需求

295
00:19:11,560 --> 00:19:13,040
它非常简单 这时候

296
00:19:13,040 --> 00:19:14,840
用这种简单的结构也是可以接受的

297
00:19:14,840 --> 00:19:18,060
并不是说这种结构就已经是淘汰了 完全不能接受

298
00:19:18,900 --> 00:19:20,840
第二个叫做单体分层结构

299
00:19:20,840 --> 00:19:23,060
这是我们现在的

300
00:19:23,060 --> 00:19:29,760
或者是unix的layer,BSD、macOS的kernel,或者是linux kernel

301
00:19:29,760 --> 00:19:32,640
这些kernel采取的一种结构

302
00:19:32,640 --> 00:19:35,260
那这种结构其实可以应对的更大规模的

303
00:19:35,260 --> 00:19:38,100
比如说3千万的代码

304
00:19:38,100 --> 00:19:39,800
那它基本上分了层次

305
00:19:39,800 --> 00:19:43,480
这个层次比如说最底层是一些基础的一些支撑

306
00:19:43,480 --> 00:19:45,720
在上层是driver,driver之上

307
00:19:45,720 --> 00:19:48,000
再是我们的文件系统

308
00:19:48,000 --> 00:19:50,320
然后在上面是内存管理等等

309
00:19:50,320 --> 00:19:58,860
这些一层一层的构造使得上层只需要下层的一个访问

310
00:19:58,860 --> 00:20:00,920
相当于上层需要下层的服务

311
00:20:00,920 --> 00:20:02,520
他们这些是一层一层的隔离的

312
00:20:02,520 --> 00:20:04,440
这种隔离性使得我们在开发软件的时候

313
00:20:04,440 --> 00:20:08,060
我们不需要知道整个软件的全貌全部

314
00:20:08,060 --> 00:20:11,940
我们只需要知道我所依赖的那个下一层是什么就OK了

315
00:20:11,940 --> 00:20:16,160
当然这是一个抽象和理想

316
00:20:16,160 --> 00:20:25,480
你真正实现的时候,你会发现,你好像很自然地,比如说我写一个进程,有可能

317
00:20:25,480 --> 00:20:31,420
很自然地去和driver打交道,你写内存也是一样,可能会绕过文件系统,

318
00:20:31,720 --> 00:20:38,480
直接访问存储设备,你这里面虽然说你是建议,但是你没有约束,这个什么是软

319
00:20:38,480 --> 00:20:43,260
件开发里面,其实写着写着就发现,他们现在调用关系越来越复杂,很

320
00:20:43,260 --> 00:20:45,600
难达到最开始的那种严格的约束。

321
00:20:46,160 --> 00:20:50,080
包括我们现在的Linux、Windows或者是BSD都这样

322
00:20:51,000 --> 00:20:53,060
从他们最开始设计的时候是分层的

323
00:20:53,060 --> 00:20:54,240
我们定好了一层一层的架构

324
00:20:54,240 --> 00:20:55,220
我们一层干什么事情

325
00:20:55,220 --> 00:20:57,160
但写着写着就不一样了

326
00:20:57,160 --> 00:21:00,600
这就是一个实际的开发过程中碰到的问题

327
00:21:00,600 --> 00:21:03,660
使得这种软件当它越来越庞大的时候

328
00:21:04,540 --> 00:21:06,440
其实我们作为一个开发者

329
00:21:06,440 --> 00:21:08,680
想去掌握它开发也就越来越困难

330
00:21:08,680 --> 00:21:13,300
这也是为什么你看到在一个大公司里面

331
00:21:13,300 --> 00:21:14,900
开发内核的是少数

332
00:21:14,900 --> 00:21:16,080
开发应用的是多数

333
00:21:16,420 --> 00:21:18,440
因为开发应用它知道的东西会少

334
00:21:18,440 --> 00:21:21,480
它只要知道底下的一层库就行了

335
00:21:21,480 --> 00:21:24,360
但是你开发内核你除了知道底下这一层之外

336
00:21:24,360 --> 00:21:26,480
它底下的底下都需要知道

337
00:21:26,940 --> 00:21:28,320
就使它开发更加复杂

338
00:21:28,320 --> 00:21:30,100
但这只是一个因素

339
00:21:30,100 --> 00:21:31,640
所以这是理想情况

340
00:21:31,640 --> 00:21:33,160
那么这个微内核架构

341
00:21:33,760 --> 00:21:37,200
微内核架构前面这种单级内核架构来自于产业界

342
00:21:37,200 --> 00:21:39,260
他们开发起来就这么一步步开

343
00:21:39,260 --> 00:21:40,460
从简单到复杂

344
00:21:40,460 --> 00:21:42,180
然后再逐渐分层来开发出来

345
00:21:42,680 --> 00:21:45,320
但微内核架构实际上是来自于学术界

346
00:21:45,320 --> 00:21:50,640
早期来自于软工特别厉害的一个学校

347
00:21:50,640 --> 00:21:52,720
CMU卡雷金梅伦

348
00:21:52,720 --> 00:21:56,300
他们那边的教授就是把这个微内核架构提出来了

349
00:21:56,300 --> 00:21:57,500
他觉得这个OS

350
00:21:57,500 --> 00:22:00,260
他们预见到这个OS发展越来越大之后

351
00:22:00,260 --> 00:22:03,620
一定会出现混乱或者复杂这种问题

352
00:22:03,620 --> 00:22:07,480
所以他就一开始讲内核是足够小的

353
00:22:07,480 --> 00:22:09,140
这个内核里面的功能也是足够小的

354
00:22:09,140 --> 00:22:13,860
这个所谓的复杂大是由于你需要完成的功能越来越多

355
00:22:13,860 --> 00:22:17,180
你对性能的要求越来越高 导致的

356
00:22:17,620 --> 00:22:20,320
那如果我们限制一个OS的规模

357
00:22:20,320 --> 00:22:22,500
就是它的功能只能是这么多

358
00:22:22,500 --> 00:22:24,840
那也许我们可以把这个OS给限制住

359
00:22:24,840 --> 00:22:29,460
使得它的范围 它的访问之间的电话接口都比较固定

360
00:22:29,460 --> 00:22:31,880
从而可以实现这个辅拉线降低

361
00:22:31,880 --> 00:22:33,320
那这就是一种设计

362
00:22:33,320 --> 00:22:38,940
在这种设计里面 它的内核只完成最基本的硬件控制

363
00:22:38,940 --> 00:22:41,660
就是HAU层就是所谓的硬件抽象场

364
00:22:41,660 --> 00:22:43,700
比如说我们的中段控制

365
00:22:43,700 --> 00:22:45,240
我们讲中段控制

366
00:22:45,240 --> 00:22:48,880
最基本的进程间通信的一个机制

367
00:22:48,880 --> 00:22:51,040
就是使得我们应用程序

368
00:22:51,040 --> 00:22:53,000
把这个应用1和应用n

369
00:22:53,000 --> 00:22:55,480
它们之间可以通过这个LPC机制

370
00:22:55,480 --> 00:22:57,960
就是local procedure call

371
00:22:57,960 --> 00:23:00,440
来完成相互之间的访问

372
00:23:00,440 --> 00:23:01,980
就它们之间不是直接访问的

373
00:23:01,980 --> 00:23:04,440
要通过这个绕一层来进行访问

374
00:23:05,080 --> 00:23:06,380
那为什么不直接访问

375
00:23:06,380 --> 00:23:08,960
是在于如果直接访问的话

376
00:23:08,960 --> 00:23:11,420
担心比如说应用程序1会破坏应用程序2

377
00:23:11,420 --> 00:23:14,620
我们不相信应用程序 这是一个

378
00:23:14,620 --> 00:23:17,060
第二个 我们传统意义上的说的

379
00:23:17,060 --> 00:23:20,760
文件系统 内存管理 精神管理放哪去了呢

380
00:23:20,760 --> 00:23:22,940
作为用户带的server存在

381
00:23:22,940 --> 00:23:25,760
比如这边看文件系统 内存管理等等

382
00:23:25,760 --> 00:23:26,740
还包括我们的driver

383
00:23:26,740 --> 00:23:29,120
全都丢到用户带去了

384
00:23:29,120 --> 00:23:31,600
第二次的内核确实可以很小

385
00:23:31,600 --> 00:23:33,340
几万毫代码就OK了

386
00:23:35,320 --> 00:23:37,500
一个很精巧的设计

387
00:23:37,500 --> 00:23:39,560
用起来没有呢

388
00:23:39,560 --> 00:23:41,620
在我们的产业界 比如说你现在用的机器

389
00:23:41,620 --> 00:23:43,340
Windows 你的安卓

390
00:23:43,740 --> 00:23:45,860
你的iOS 有没有用这种架构呢

391
00:23:45,860 --> 00:23:47,900
其实没有 这里面

392
00:23:47,900 --> 00:23:49,660
有一个很大的问题

393
00:23:49,660 --> 00:23:52,160
就在于 它这种间接的

394
00:23:52,160 --> 00:23:53,820
所有的这些

395
00:23:53,820 --> 00:23:55,480
控制或者数据的传输是

396
00:23:55,480 --> 00:23:57,520
间接方式来造成的 而这种间接方式

397
00:23:57,520 --> 00:23:59,580
会引入比较大的开销

398
00:23:59,580 --> 00:24:01,920
而这个性能问题呢 使得

399
00:24:02,800 --> 00:24:03,640
它满足不了

400
00:24:03,640 --> 00:24:05,320
应用的需求 就说白了

401
00:24:05,320 --> 00:24:07,560
它是没有满足我们应用对性能的一个要求

402
00:24:08,720 --> 00:24:11,340
特别是在和这种单铁内核进行比较的时候

403
00:24:11,340 --> 00:24:14,580
我们发现应用程序同样应用程序

404
00:24:14,580 --> 00:24:18,200
如果跑在单铁内核 跑在这种温度核销上

405
00:24:18,200 --> 00:24:21,720
它的性能会差三四倍 甚至一个数量级以上

406
00:24:22,280 --> 00:24:23,560
如果性能差这么多

407
00:24:24,820 --> 00:24:26,600
那对于一般的用户而言

408
00:24:26,600 --> 00:24:28,600
他宁愿用单铁内核

409
00:24:29,120 --> 00:24:33,460
这也说明一点 在对安全和性能这两个

410
00:24:33,460 --> 00:24:34,360
放在一起的时候

411
00:24:34,360 --> 00:24:38,560
我们的用户更愿意prefer 第一个就是性能

412
00:24:40,100 --> 00:24:42,160
好 这就是我们说的威力核架构

413
00:24:42,680 --> 00:24:46,240
当然 这个威力核架构也是一样说性能差

414
00:24:46,240 --> 00:24:48,620
但是它就完全不会用了 也不是

415
00:24:48,620 --> 00:24:51,480
再对一些安全要是特别高场合

416
00:24:52,320 --> 00:24:59,500
比如说核电站 比如说这种医疗设备等等

417
00:24:59,500 --> 00:25:02,900
那么采用威力核架构有它的一些存在的一些价值

418
00:25:02,900 --> 00:25:04,740
所以它在一些小的领域

419
00:25:04,740 --> 00:25:05,880
但是特别高的领域

420
00:25:05,880 --> 00:25:08,060
它是有存在的空间的

421
00:25:08,060 --> 00:25:09,100
这是v-layer架构

422
00:25:11,400 --> 00:25:13,900
然后在后面是一个叫做外核架构

423
00:25:15,660 --> 00:25:19,640
外核架构就是MIT的一个

424
00:25:19,640 --> 00:25:21,500
就是教授France Kaushack

425
00:25:21,500 --> 00:25:22,540
他提出来的

426
00:25:22,540 --> 00:25:24,700
他和他的学生一块提出来的一个外核

427
00:25:25,340 --> 00:25:27,780
我们通常说他会选择内核

428
00:25:27,780 --> 00:25:31,260
他这名字叫EXO kernel

429
00:25:31,260 --> 00:25:32,360
就是外核的意思

430
00:25:32,360 --> 00:25:36,360
为什么叫外核呢?是在于它认为传统意义上的内核

431
00:25:36,360 --> 00:25:40,020
其实应该和,就比如说我们的文件系统

432
00:25:40,020 --> 00:25:43,120
我们的网络协议站应该和我们的应用紧偶合

433
00:25:43,120 --> 00:25:45,160
比如这里面TPP协议站

434
00:25:45,160 --> 00:25:47,760
这里面POSIX所涉及到的文件系统等等

435
00:25:47,760 --> 00:25:52,380
这是以酷的形式直接和应用绑定

436
00:25:52,380 --> 00:25:54,560
这样绑定的话,直接绑定的话

437
00:25:54,560 --> 00:25:55,980
好像感觉没有什么安全性可以

438
00:25:56,380 --> 00:25:59,720
那它其实整个都丢在用户台空间了

439
00:25:59,720 --> 00:26:05,880
所以你要破坏也是破坏自己,破坏不了别人。好处呢,它可以直接去通过还是这样的

440
00:26:05,880 --> 00:26:10,940
方式来访问,那会比我们说的要绕过一层系统雕用再去访问内

441
00:26:10,940 --> 00:26:13,740
核更加快速,所以它是为了追求性能。

442
00:26:13,740 --> 00:26:18,920
那你这样的话,我们这个TCPIP,我们以前说TCPIP协议站或者Filesystem,它底下

443
00:26:18,920 --> 00:26:23,540
访问Driver,Driver在哪里体现的,Driver在这一层体现,它把那些最

444
00:26:23,540 --> 00:26:27,920
核心的跟硬件相关的操作呢,放在了所谓的这个外核这个架构,这

445
00:26:27,920 --> 00:26:33,360
特权机制,这些放在了,就是我们的特权机里面,做一个外核架构,在外

446
00:26:33,360 --> 00:26:39,840
核里面呢,抽象出和虚拟化出N个外设,它不是虚拟出一个计算机,

447
00:26:39,920 --> 00:26:41,160
它是虚拟出一些外设,

448
00:26:41,160 --> 00:26:47,560
使得TCP POSIX这些服务直接访问在虚拟书的外设

449
00:26:47,560 --> 00:26:53,480
来完成对计算机的一些操作的功能

450
00:26:53,480 --> 00:26:54,540
这是一种方式

451
00:26:54,540 --> 00:26:57,100
你看到如果在这种方式的情况下

452
00:26:57,100 --> 00:27:01,560
我们的不同的应用可以有一个定制的内核

453
00:27:01,560 --> 00:27:03,680
比如说这里面TCP POSIX

454
00:27:03,680 --> 00:27:07,060
这一块另外一个分布式的科学计算应用

455
00:27:07,060 --> 00:27:08,400
它可能需要大内存

456
00:27:08,400 --> 00:27:10,480
它会用到所谓的Distributed Share Memory

457
00:27:10,480 --> 00:27:14,280
就是把不同机器上的内存变成一个

458
00:27:14,280 --> 00:27:16,060
看起来像是一个机器的一个内存一样

459
00:27:16,060 --> 00:27:17,660
这样扩大了

460
00:27:17,660 --> 00:27:19,120
然后来实现

461
00:27:19,120 --> 00:27:21,820
在这里面会需要一系列的一些新的一些feature

462
00:27:21,820 --> 00:27:24,020
而这些feature是这里面提供不了的

463
00:27:24,020 --> 00:27:25,720
所以会专门针对这个应用

464
00:27:25,720 --> 00:27:27,200
科学计算的应用

465
00:27:27,200 --> 00:27:29,780
设计出一系列的这种内核的一些service

466
00:27:29,780 --> 00:27:34,200
然后它一样可以用到同样的一个外核的服务

467
00:27:34,200 --> 00:27:35,920
来完成对硬件的操控

468
00:27:35,920 --> 00:27:38,300
这种方式看起来也很不错

469
00:27:41,580 --> 00:27:43,600
但是现在有哪个机器是这么做的

470
00:27:43,600 --> 00:27:46,140
哪个计算机系统是这么做的

471
00:27:46,140 --> 00:27:46,960
我们现在也没看到

472
00:27:47,960 --> 00:27:49,520
这还是停留在论文里面

473
00:27:50,940 --> 00:27:53,540
比这个稍微还要弱一点

474
00:27:53,540 --> 00:27:55,640
这个还是有一些公司去实现了它

475
00:27:57,240 --> 00:27:59,840
这个基本上发了几篇博士论文

476
00:27:59,840 --> 00:28:01,960
发了几篇很顶级的会议的论文之后

477
00:28:02,360 --> 00:28:04,220
就没有看到采烟界去用它

478
00:28:05,000 --> 00:28:06,500
但是这个idea挺好的

479
00:28:06,500 --> 00:28:07,180
idea什么呢

480
00:28:07,180 --> 00:28:08,680
就是我就会把硬件

481
00:28:08,680 --> 00:28:11,320
把这个底层硬件尽量虚拟化

482
00:28:11,760 --> 00:28:15,000
来完成一种对上面的应用的知识

483
00:28:15,000 --> 00:28:18,560
这种idea其实现在换一种思路出现了

484
00:28:19,660 --> 00:28:20,960
我们就说虚拟机

485
00:28:21,480 --> 00:28:23,000
我们现在的虚拟机什么意思

486
00:28:23,000 --> 00:28:25,200
就是我们的Data Center里面

487
00:28:25,200 --> 00:28:26,020
就是数据中心里面

488
00:28:26,020 --> 00:28:27,800
比如阿里 陈迅

489
00:28:27,800 --> 00:28:29,440
他们有很多大的服务器

490
00:28:29,440 --> 00:28:32,000
这个服务器其实平时是用不满的

491
00:28:33,040 --> 00:28:33,980
平时它很空

492
00:28:34,600 --> 00:28:36,440
所以一台物理机用不满的情况下

493
00:28:36,440 --> 00:28:37,740
就浪费资源 耗电

494
00:28:38,460 --> 00:28:41,900
摆设也是耗空间耗电 那怎么办呢

495
00:28:42,500 --> 00:28:48,900
它在一台物理机上面虚拟出N个物理外设

496
00:28:48,900 --> 00:28:51,720
然后每个物理外设实际上就是在这里面

497
00:28:51,720 --> 00:28:54,240
有一个VM0 VM1 VM2 virtual machine

498
00:28:54,240 --> 00:28:56,560
这代表什么 代表它完整的虚拟机

499
00:28:56,560 --> 00:29:00,740
然后我们的OS和我们的应用跑在这个VM里面

500
00:29:01,280 --> 00:29:03,740
这种方式就可以使得一台物理机变成什么

501
00:29:03,740 --> 00:29:05,780
变成N台机器

502
00:29:05,780 --> 00:29:09,300
那如果它为什么卖云服务

503
00:29:09,300 --> 00:29:11,260
那就卖给你 你就可以去登上去用

504
00:29:11,260 --> 00:29:13,300
那我可以卖给用户 非常便宜的价格卖给用户

505
00:29:13,300 --> 00:29:16,020
大家反正就是你闲着也就闲着 还不如拉出来卖

506
00:29:16,020 --> 00:29:19,380
这所谓的云服务这种思想就诞生了

507
00:29:19,380 --> 00:29:23,280
而这种思想使得我们现在的很多的应用

508
00:29:23,280 --> 00:29:28,100
包括比如说我现在这些网页挂在GitHub上面

509
00:29:28,100 --> 00:29:31,460
挂在Git上那也是他们提供的云服务

510
00:29:31,460 --> 00:29:33,280
其实就是虚拟机的方式

511
00:29:33,280 --> 00:29:36,460
来实现了一个非常方便的对计算机的一个

512
00:29:36,460 --> 00:29:37,720
资源的充分利用

513
00:29:37,720 --> 00:29:39,660
这种技术现在成了一个主流

514
00:29:39,660 --> 00:29:42,880
它其实就是我们前面讲的这种外核架构的一种

515
00:29:42,880 --> 00:29:44,060
延伸和扩展

516
00:29:44,820 --> 00:29:49,300
只是它不是专门针对一个应用做一个OS的绑定

517
00:29:49,300 --> 00:29:52,000
而是我直接提供了一个虚拟的计算机

518
00:29:52,940 --> 00:29:55,900
虚拟的物理计算机来给我们的OS

519
00:29:55,900 --> 00:29:57,480
来进行直接的支持

520
00:29:57,480 --> 00:29:59,780
OS和应用直接的支持 这样的话

521
00:30:01,440 --> 00:30:05,300
就形成了我们现在在数据中心里面的服务系

522
00:30:05,300 --> 00:30:07,280
非常常见的那种虚拟机动架构

523
00:30:09,760 --> 00:30:12,300
这是这种外核架构的进一步的一个破绽

524
00:30:14,740 --> 00:30:17,920
好 那我们再看一下

525
00:30:18,860 --> 00:30:25,300
在这里面我们把前面的这些架构给它统一起来

526
00:30:25,300 --> 00:30:27,300
如果我们忽略这些架构的差异性

527
00:30:28,300 --> 00:30:32,440
那我们的OS和应用程序之间是什么一个关系呢

528
00:30:32,440 --> 00:30:36,860
实际上就是一个所谓的硬件的一层一层的抽象

529
00:30:36,860 --> 00:30:38,900
你对硬件进行怎么样的抽象

530
00:30:38,900 --> 00:30:42,380
来实际上对应用程序执行的一个支持

531
00:30:42,380 --> 00:30:45,920
而这个支持我们称之为比如说这个执行环境

532
00:30:45,920 --> 00:30:47,580
用一个更加通用的词来表示

533
00:30:47,580 --> 00:30:50,420
这个执行环境里面会涉及到

534
00:30:50,420 --> 00:30:54,880
对不同的物理资源的一个虚拟化和抽象

535
00:30:54,880 --> 00:30:56,900
比如说我们前面说的处理器是进程

536
00:30:59,560 --> 00:31:02,900
物理内存是地址空间 IOS设备是文件

537
00:31:02,900 --> 00:31:09,220
而且你会发现这个文件也会按照地址空间的方式来进行管理

538
00:31:09,220 --> 00:31:13,900
地址空间和文件成为进程所要管理的资源

539
00:31:15,180 --> 00:31:21,260
进程就成了一个我们说一个正在运行程序的一个直接体现

540
00:31:21,660 --> 00:31:26,880
所以 而这些东西 应用程序所需要的这些资源

541
00:31:26,880 --> 00:31:29,940
都是被我们超级统进行管理起来的

542
00:31:29,940 --> 00:31:34,100
它提供给我们应用程序这些抽象的和抽象的虚拟的

543
00:31:34,100 --> 00:31:35,860
或者甚至是物理的一些资源

544
00:31:35,860 --> 00:31:40,060
让我们的应用程序可以非常方便的在计划界面去运行

545
00:31:40,060 --> 00:31:42,020
这实际上就是我们超级统要干的事情

546
00:31:42,020 --> 00:31:44,040
所以你通过这种架构图

547
00:31:45,520 --> 00:31:48,340
可以去 这是一个非常高层抽象的架构图

548
00:31:48,340 --> 00:31:51,000
和我们一个超级统具体的设计实现对应起来

549
00:31:51,900 --> 00:31:55,020
你会看到我们这边的继承层包含了哪些东西

550
00:31:55,020 --> 00:31:56,180
我们的地址空间包含了哪些东西

551
00:31:56,180 --> 00:31:57,620
我们的文件包含了哪些东西

552
00:31:57,620 --> 00:32:00,160
你可以把这个再映射到这边来

553
00:32:00,160 --> 00:32:01,180
从而可以

554
00:32:01,180 --> 00:32:03,140
就像大家知道的就是

555
00:32:03,140 --> 00:32:05,020
你的原理你的理论

556
00:32:05,020 --> 00:32:06,360
其实是原理 我觉得没啥理论

557
00:32:06,360 --> 00:32:09,040
主要是原理 原理和你的实现

558
00:32:09,040 --> 00:32:11,840
设计实现其实是很对应的

559
00:32:11,840 --> 00:32:18,020
这是我们讲这个关于第四节的一个介绍

560
00:32:18,800 --> 00:32:20,200
好 这一部分就算讲完了

561
00:32:50,520 --> 00:32:52,940
不是说做了的同学 没做的同学举手

562
00:32:52,940 --> 00:32:55,200
那我觉得大家都做了是吧 那挺好

563
00:32:57,460 --> 00:32:59,020
都做了的话 那我操作起来的话

564
00:32:59,020 --> 00:33:02,300
大家看起来会比较方便一点

565
00:33:02,300 --> 00:33:04,200
那不让大家动手 还是我动手

566
00:33:07,160 --> 00:33:09,240
证明说试一试 Unix 和 Linux

567
00:33:09,240 --> 00:33:10,600
试一试的意思是什么意思呢

568
00:33:10,600 --> 00:33:15,420
就是希望大家通过应用程序

569
00:33:15,420 --> 00:33:17,400
来理解 OS 想达到这一步

570
00:33:17,400 --> 00:33:19,840
就这样主要想大家能够体会这一步

571
00:34:23,580 --> 00:34:27,720
这是一个Windows这么一个超级桶

572
00:34:27,720 --> 00:34:30,520
它其实内部嵌了一个叫做Watch Machine Monitor

573
00:34:30,520 --> 00:34:32,740
就是这么一个我们说的虚拟机这么一个环境

574
00:34:32,740 --> 00:34:35,360
这个Watch Machine Monitor里面跑了一个Linux

575
00:34:35,360 --> 00:34:38,860
这个Linux叫做就是你可以装Ubuntu

576
00:34:38,860 --> 00:34:40,460
装这上面的任何一个超级桶

577
00:34:40,460 --> 00:34:42,300
它虚拟是一台计算机

578
00:34:42,300 --> 00:34:45,280
比如说我现在这里面跑的这个WS

579
00:34:45,280 --> 00:34:47,860
比如这里面我就装了一个装哪

580
00:34:48,980 --> 00:34:49,340
对

581
00:34:49,340 --> 00:34:53,500
这里面就装了一个羽帮图20.04

582
00:34:53,500 --> 00:34:55,960
就装在WSL这个subsystem里面去

583
00:34:55,960 --> 00:34:58,060
这就是一个例子

584
00:34:59,200 --> 00:35:01,560
然后MacOS with Unix share

585
00:35:01,560 --> 00:35:03,780
MacOS是Linux吗

586
00:35:06,480 --> 00:35:08,960
也不是Lay Unix

587
00:35:10,580 --> 00:35:15,760
MacOS Linux其实往前面溯源都是从Unix来的

588
00:35:15,760 --> 00:35:16,660
Unix从哪来的

589
00:36:19,760 --> 00:36:21,480
我们前面也提到过

590
00:36:21,480 --> 00:36:25,820
目前全世界使用最多的超级系统就是Linux

591
00:36:25,820 --> 00:36:28,600
因为它横跨从超级系统机

592
00:36:29,260 --> 00:36:31,960
到服务器到移动终端

593
00:36:32,400 --> 00:36:35,220
它唯一没有占统治地位的就是桌面

594
00:36:35,220 --> 00:36:36,600
桌面它还搞不定

595
00:36:36,600 --> 00:36:37,760
搞不定Windows

596
00:36:38,940 --> 00:36:41,380
但是我们其实大家做实验的时候

597
00:36:41,380 --> 00:36:42,440
其实也在桌面上做的时候

598
00:36:42,440 --> 00:36:44,340
也是用Linux为主

599
00:36:45,160 --> 00:36:46,440
那你如果用的话

600
00:36:46,440 --> 00:36:48,060
其实也是和大家

601
00:36:48,060 --> 00:36:50,320
如果用 Mac 或者 Mac 的话可能有点不太熟悉

602
00:36:50,320 --> 00:36:53,300
不太习惯 Share 用制服方式

603
00:36:53,300 --> 00:36:55,760
有点回去了 又回到命令行方式来用

604
00:36:55,760 --> 00:36:58,500
所以你会装一种比较方便的 Share

605
00:36:59,160 --> 00:37:03,260
这里面列了一些现在比较时髦的 Share

606
00:37:03,260 --> 00:37:04,480
大家可以装一种

607
00:37:04,480 --> 00:37:07,220
装了之后就一系列小程序可以去用了

608
00:37:07,220 --> 00:37:10,320
包括我们通常操作的一些命令程序

609
00:37:10,320 --> 00:37:12,420
和一些开发用到的程序

610
00:37:12,420 --> 00:37:14,840
比如今天生意GDB等等 或者 Rust等等

611
00:37:14,840 --> 00:37:17,660
这都是去用的

612
00:37:19,000 --> 00:37:21,540
这个只是给大家大致看一看

613
00:37:21,540 --> 00:37:23,440
我们需要去进一步了解的是

614
00:37:23,440 --> 00:37:25,700
Linux对核提供冷却服务

615
00:37:25,700 --> 00:37:27,540
站在用的角度,不是站在实现的角度

616
00:37:27,540 --> 00:37:29,380
站在用的角度提供冷却服务

617
00:37:29,380 --> 00:37:31,060
我们看到它可以跑程序

618
00:37:31,060 --> 00:37:32,980
你可以执行程序

619
00:37:32,980 --> 00:37:35,580
第二,它可以帮你给程序分配内存

620
00:37:35,580 --> 00:37:37,820
程序要运行的时候,你需要内存吗?

621
00:37:37,820 --> 00:37:39,120
它可以分配内存

622
00:37:39,120 --> 00:37:41,380
第三个,你程序做完计算之后

623
00:37:41,380 --> 00:37:42,660
要把数据存下来

624
00:37:42,660 --> 00:37:44,860
它可以去支持文件

625
00:37:44,860 --> 00:37:46,980
以文件的形式把这个数据给存下来

626
00:37:46,980 --> 00:37:56,980
这里面涉及到文件名目录等等,而且还有一定的保障就是说你写的数据可能

627
00:37:56,980 --> 00:38:01,700
你加一些设置,让别人就防不了,这是所谓的防控制。

628
00:38:05,060 --> 00:38:10,520
进程、内存、文件,我们前面有三个抽象,内存叫地址空间,这三个抽

629
00:38:10,520 --> 00:38:11,340
象是主体。

630
00:38:11,340 --> 00:38:14,640
那除了这个之外 还有很多其他的 比如对用户的管理

631
00:38:14,640 --> 00:38:18,680
多用户支持 对网络的管理 对时间 对外设的管理等等

632
00:38:18,680 --> 00:38:20,320
这都是属于其他的一些东西

633
00:38:20,320 --> 00:38:24,820
那这些都是我们内核要提供的服务

634
00:38:24,820 --> 00:38:27,300
包括什么你现在的GPU 你玩游戏 你看电影等等

635
00:38:27,300 --> 00:38:31,240
所有这些东西都在于内核里面提供所谓的Syscode

636
00:38:31,240 --> 00:38:33,360
系统调用这些服务来帮你完成这些事情

637
00:38:33,360 --> 00:38:37,200
那我的问题来了 要支持这么多种服务

638
00:38:37,200 --> 00:38:39,320
那你觉得Syscode应该是什么一个量级

639
00:39:41,740 --> 00:39:46,160
我们还需要讲超级统计内部实现的时候,会理解它到底里面包含什么东西。

640
00:39:46,320 --> 00:39:47,480
我们现在在用的角度要考虑。

641
00:39:52,220 --> 00:39:57,760
这是一个例子。我们写了一个程序。请问这里面用了几个系统调用?

642
00:39:59,020 --> 00:40:00,560
大家能看出来吗?

643
00:40:30,660 --> 00:40:32,680
就是你真正写这个程序的时候

644
00:40:32,680 --> 00:40:35,300
你调的这个函数 其实确实是函数

645
00:40:35,300 --> 00:40:37,640
它实际上是一个C库提供

646
00:40:37,640 --> 00:40:40,440
C库里面实际上是系统调用的一个具体实现

647
00:40:40,440 --> 00:40:43,720
它会去封装成函数的形式给用户来用

648
00:40:44,540 --> 00:40:47,780
因为系统调用会比较复杂一点

649
00:40:47,780 --> 00:40:49,280
它不像函数那么简单

650
00:40:49,280 --> 00:40:52,400
我们下堂课的时候会讲到系统调用具体实现的时候会看到

651
00:40:52,400 --> 00:40:54,140
至少你在前面操作的时候

652
00:40:54,140 --> 00:40:57,420
感觉就是法文超系统的service

653
00:40:57,420 --> 00:40:59,220
通过系统调用法文超系统的service

654
00:40:59,220 --> 00:41:01,980
和我们通常写用程序的改变是一样的

655
00:41:01,980 --> 00:41:03,700
是在于我们有一层

656
00:41:04,500 --> 00:41:06,420
又加了一层C库

657
00:41:06,420 --> 00:41:09,940
就系统库来帮你来减轻了这个复杂性

658
00:41:11,500 --> 00:41:14,300
那么核心的性能量数量其实并不多

659
00:41:14,760 --> 00:41:17,300
比如说像我们写的这个超系统

660
00:41:18,120 --> 00:41:20,900
写到最后也就大约二三十个

661
00:41:21,620 --> 00:41:22,380
这个数量

662
00:41:23,180 --> 00:41:24,700
如果大家有同学

663
00:41:24,700 --> 00:41:26,580
比如说我们去看国外的

664
00:41:26,580 --> 00:41:27,780
做的不错的OS

665
00:41:27,780 --> 00:41:30,240
比如说也是实验类的XV6

666
00:41:30,640 --> 00:41:32,860
就是MIT的XV6

667
00:41:32,860 --> 00:41:33,700
这个OS

668
00:41:33,700 --> 00:41:36,180
那它也就是20多个系统标用

669
00:41:37,880 --> 00:41:40,500
所以我们希望通过应用

670
00:41:40,500 --> 00:41:41,640
你能够理解这些系统标用

671
00:41:41,640 --> 00:41:43,700
第一个有一个感性的认识

672
00:41:43,700 --> 00:41:45,460
就是你得有一个比较全面的认识

673
00:41:45,460 --> 00:41:46,900
一个基本的OS

674
00:41:46,900 --> 00:41:49,180
特别是我们以Unix为例的话

675
00:41:49,180 --> 00:41:50,580
它到底需要什么样的一些

676
00:41:50,580 --> 00:41:52,100
最核心的一些系统标用

677
00:41:52,100 --> 00:41:53,180
你会发现

678
00:41:53,180 --> 00:41:55,160
其实这些系统标用

679
00:41:55,160 --> 00:41:57,980
或多或少 和那三个抽象相关

680
00:41:57,980 --> 00:41:59,660
我们应用程序在写的时候

681
00:41:59,660 --> 00:42:02,620
自然就需要去就这种抽象的理解

682
00:42:02,620 --> 00:42:05,020
这抽象我们一直给大家挂

683
00:42:05,500 --> 00:42:10,400
进程 地址空间 还有文件

684
00:42:10,400 --> 00:42:13,340
这三个 但其实也不一定完全覆盖得住

685
00:42:13,340 --> 00:42:14,160
我们可以看看

686
00:42:15,720 --> 00:42:17,240
像这几个Fock

687
00:42:17,240 --> 00:42:20,580
Fock就是从一个进程创建另外一个进程

688
00:42:20,580 --> 00:42:21,860
叫Fock

689
00:42:22,280 --> 00:42:23,460
那么你创建进程

690
00:42:57,420 --> 00:43:01,180
这个标识一般你看都是一个整形

691
00:43:01,180 --> 00:43:03,700
因为发现也是很有意思的一个特点

692
00:43:03,700 --> 00:43:07,060
就是在所有的性能调用里面

693
00:43:07,060 --> 00:43:08,200
绝大部分的一些参数

694
00:43:08,200 --> 00:43:10,700
调用参数都是整形

695
00:43:10,700 --> 00:43:13,160
而这个整形代表的含义是非常不一样的

696
00:43:13,160 --> 00:43:17,440
你看代表PID 代表这个退出的状态

697
00:43:18,460 --> 00:43:19,700
这是什么一个特征

698
00:43:19,700 --> 00:43:21,680
这是C元特征

699
00:43:21,680 --> 00:43:23,440
C元是一个非常灵魂的特征

700
00:43:54,380 --> 00:43:56,340
然后盖的PID就获得单人进程的PID

701
00:43:56,340 --> 00:43:58,460
你看这都是跟进程相关的这几个

702
00:43:59,540 --> 00:44:03,980
Sleep稍微有点跟进程的调度相关

703
00:44:03,980 --> 00:44:05,440
因为它会让进程睡眠

704
00:44:06,460 --> 00:44:07,760
就是让自己睡眠

705
00:44:07,760 --> 00:44:09,440
Sleep是自己啊

706
00:44:09,440 --> 00:44:11,040
自己要暂停多少个时钟

707
00:44:11,040 --> 00:44:13,020
并没有说我让另一个进程去Sleep

708
00:44:13,020 --> 00:44:14,620
因为如果让进程Sleep的话

709
00:44:14,620 --> 00:44:16,940
相当于这个权限稍微大了

710
00:44:16,940 --> 00:44:20,200
这个exec干什么呢

711
00:44:20,560 --> 00:44:26,280
Fock是Fock出一个跟附件层一样的内容的执行层

712
00:44:27,260 --> 00:44:28,260
这是Fock

713
00:44:28,260 --> 00:44:32,120
我说内容是指的这个程序的逻辑是一样的

714
00:44:32,120 --> 00:44:33,940
但是我如果要执行新的程序怎么办

715
00:44:34,360 --> 00:44:35,940
那么我先Fock一个执行层

716
00:44:35,940 --> 00:44:39,900
然后再通过exec把他的执行层内容给换掉

717
00:44:39,900 --> 00:44:43,220
换成这里面这个file指向的执行文件里面的内容

718
00:44:43,760 --> 00:44:45,040
通过这两个

719
00:44:50,900 --> 00:44:52,200
好 大家休息一下

720
00:50:00,460 --> 00:50:06,620
好 我们继续开始上课了 刚才说到EXEC这个系统调用比较特殊的

721
00:50:06,620 --> 00:50:12,920
就是把当前进程的执行代码全给换成另外一个执行程序

722
00:50:12,920 --> 00:50:15,900
这个file执行执行程序 这样换完之后

723
00:50:15,900 --> 00:50:19,200
执行出来的逻辑就是按照新的文件去执行

724
00:50:19,200 --> 00:50:22,560
所以它是一种执行新程序的一种有效的方法

725
00:50:22,560 --> 00:50:25,320
但它这种方法需要前面有个Fock来配合一下

726
00:50:25,320 --> 00:50:26,600
这样才能够执行新程序

727
00:50:26,600 --> 00:50:29,720
所以Fock XEC那是一对 这也是一对

728
00:50:30,740 --> 00:50:33,940
这些介绍都是跟进程管理

729
00:50:33,940 --> 00:50:36,740
进程调度相关的一系列的系统调用

730
00:50:36,740 --> 00:50:38,460
那还有其他一些吗

731
00:50:38,460 --> 00:50:40,400
没了 我们这边就这么几个

732
00:50:40,400 --> 00:50:42,740
再接下来是跟内存相关的

733
00:50:42,740 --> 00:50:45,040
内存就一个 SBRK

734
00:50:46,700 --> 00:50:56,360
SBRK的含义是将进程的内存增加n个字节,需要注意这里面比较

735
00:50:56,360 --> 00:50:57,420
有一些tricky的事情。

736
00:50:58,140 --> 00:51:03,860
这个int是一个有符号整数,那你增加n个字节,这个n可以为负数,

737
00:51:04,640 --> 00:51:10,820
因为它其实可以增加负的n个字节,减了n个字节,可以加,可以减,返回新

738
00:51:10,820 --> 00:51:13,940
内存的开始地址,这是SBRK的一个特点。

739
00:53:44,100 --> 00:53:46,900
那么还有一个呢 对应的就是有rides有read

740
00:53:47,660 --> 00:53:50,280
就读进来 把这个从设备上的数据

741
00:53:50,280 --> 00:53:52,220
读到内存里面来 读到这个buffer里面去

742
00:53:52,220 --> 00:53:54,320
读一个字节 这是read

743
00:53:54,780 --> 00:53:56,940
然后既然要open就要close

744
00:53:56,940 --> 00:53:58,940
打开一个文件 关闭一个文件

745
00:54:02,400 --> 00:54:04,040
那我简单问一个问题

746
00:54:04,500 --> 00:54:07,780
我听李老师说 你们在学小学期的时候

747
00:54:07,780 --> 00:54:09,440
CIA家都学得很溜

748
00:54:09,440 --> 00:54:12,800
然后这folk这些openrides都编过程 是吧

749
00:54:15,500 --> 00:54:23,300
没用过那你们的CR家很高层吗

750
00:54:23,300 --> 00:54:28,240
写的我觉得就Qt是吧

751
00:54:31,360 --> 00:54:34,160
Qt Qt是写图形界面的

752
00:54:36,020 --> 00:54:40,720
这个超多系统确实没有像unix

753
00:54:40,720 --> 00:54:42,480
linux没有直接对图形界面的支持

754
00:54:42,880 --> 00:54:48,280
所以那你们如果,对,它封装了又封装了一大层,那你们这个都没用过的话,那

755
00:54:48,280 --> 00:54:55,940
我还再介绍稍微,那我倒好再问一个问题,你这个,我为什么不直接把这个fb

756
00:54:55,940 --> 00:55:00,940
换成一个新file就行了,我直接write这个file就ok了,我为什么要非要搞一个open,

757
00:55:01,360 --> 00:55:12,560
这open有没有点多余啊,open,close,对,这个同学说的有道理啊,

758
00:55:12,560 --> 00:55:17,960
你会发现我们的存储设备是一个共享的,是哪个程序都可以对这个存

759
00:55:17,960 --> 00:55:19,660
储设备里面的数据进行读和写

760
00:55:20,560 --> 00:55:24,440
我们前面讲到共享的时候,大家就会有些问题了,这共享会有些互斥的保

761
00:55:24,440 --> 00:55:24,800
护

762
00:55:24,800 --> 00:55:28,240
那么这种open和close就在某种程度上可以起来一种互斥的保护,我

763
00:55:28,240 --> 00:55:32,160
打开这个文件,你就别打开了,你要等我关闭之后再打开

764
00:55:32,460 --> 00:55:36,280
这就是干了这么一个事情,实际上是对共享资源的一个有效的保护

765
00:55:37,280 --> 00:55:40,040
这个解释是非常合理的

766
00:55:40,040 --> 00:55:43,180
好 这几个Open、Close、Read、Write

767
00:55:43,180 --> 00:55:45,720
这四个就基本就非常简单的

768
00:55:45,720 --> 00:55:48,360
这四个性能就可以把文件这一块给覆盖住

769
00:55:49,740 --> 00:55:50,380
非常爽

770
00:55:50,380 --> 00:55:53,420
再接下来是一些更加强大的一些知识

771
00:55:53,920 --> 00:55:54,800
DARP

772
00:55:54,800 --> 00:55:56,620
DARP可能反过来一个新的文件描述符

773
00:55:56,980 --> 00:55:59,580
它引用与文件描述符相同的文件

774
00:55:59,580 --> 00:56:00,360
这什么意思呢

775
00:56:01,320 --> 00:56:02,860
我得到两个FD

776
00:56:03,420 --> 00:56:05,280
我根据这个FD得到一个新的FD

777
00:56:05,280 --> 00:56:07,320
这FD1的话我得到FD2

778
00:56:07,320 --> 00:56:10,960
FD1和FD2是对应的同一个文件

779
00:56:12,480 --> 00:56:17,320
也意味着我对FD1进行write和对FD2进行write写的同一个文

780
00:56:17,320 --> 00:56:17,490
件

781
00:56:19,280 --> 00:56:20,660
OK 它有什么用

782
00:56:21,060 --> 00:56:27,420
这个后面会看到 它的用处主要是用在进程之间进行通信的

783
00:56:27,420 --> 00:56:29,740
所以你看到这个DARP和这个PAT

784
00:56:29,740 --> 00:56:32,260
PAT更好理解是管道

785
00:56:32,260 --> 00:56:34,900
我建一个管道 它会返回两个FD

786
00:56:34,900 --> 00:56:37,060
你看为什么用了int这么一个东西

787
00:56:37,320 --> 00:56:40,840
因为它返回了两个FD,一个FD用来读,一个FD用来写

788
00:56:40,840 --> 00:56:46,840
这样的话,对于同一个文件而言,我一个进程用这个读的FD

789
00:56:46,840 --> 00:56:49,560
另一个进程用这个写的FD就可以建好一个通道

790
00:56:49,560 --> 00:56:51,280
使得他们之间可以进行数据的传输

791
00:56:51,280 --> 00:56:53,140
这是所谓的进程间通讯

792
00:56:53,140 --> 00:56:57,940
所以大部分的PIP主要是用来进行这种进程间通讯的

793
00:56:58,740 --> 00:57:00,320
这个细节以后再讲

794
00:57:01,520 --> 00:57:06,800
然后再后面什么呢,CHDIR改变当前目录,多了个目录的概念

795
00:57:07,320 --> 00:57:12,020
再往后是什么MAKE电压,那这是跟目录相关,就是把这个文件系统的内

796
00:57:12,020 --> 00:57:12,700
容进一步扩展。

797
00:57:12,800 --> 00:57:17,960
除了文件字体之外,还有一些目录,你一个目录下可以放多个文件,那对

798
00:57:17,960 --> 00:57:20,860
目录就有一些基本的管理,比如创建目录。

799
00:57:22,140 --> 00:57:27,580
这里面是调整目录,你到哪个目录下面去进一步读文件,有MAKE,有

800
00:57:27,580 --> 00:57:30,680
创建,我们说创建目录为什么没有删除目录。

801
00:58:07,320 --> 00:58:09,240
查一查 我看看

802
00:58:09,240 --> 00:58:09,940
man一下

803
00:58:09,940 --> 00:58:12,000
man就是查这个信息

804
00:58:12,000 --> 00:58:14,440
叫mk.创建目录

805
00:58:14,440 --> 00:58:16,420
啊 这有创建目录

806
00:58:16,420 --> 00:58:20,880
m-a-n-r-m-d-r

807
00:58:20,880 --> 00:58:23,380
r-m-d-r

808
00:58:23,380 --> 00:58:25,760
不对 我再查查

809
00:58:25,760 --> 00:58:26,420
没有

810
00:58:27,480 --> 00:58:30,320
我加个-2

811
00:58:31,180 --> 00:58:33,360
-2 也没有

812
00:58:34,180 --> 00:58:35,420
诶 我看看

813
00:59:07,660 --> 00:59:09,840
所以我把它摘出来 我觉得很有代表性

814
00:59:09,840 --> 00:59:11,340
放在对面

815
00:59:11,340 --> 00:59:13,720
看来它也是把重要的列出来的

816
00:59:13,720 --> 00:59:14,980
并没有完全列全

817
00:59:15,820 --> 00:59:17,060
好 再看下一个

818
00:59:17,060 --> 00:59:18,440
Make Node

819
00:59:19,100 --> 00:59:22,520
创建一个设备文件

820
00:59:24,280 --> 00:59:25,960
RMLode可能应该有对应的

821
00:59:25,960 --> 00:59:27,180
一个删除设备文件

822
00:59:28,220 --> 00:59:29,840
那它里面可以注意一点

823
00:59:29,840 --> 00:59:31,000
它不叫设备

824
00:59:31,000 --> 00:59:32,320
它不叫创建一个设备

825
00:59:32,320 --> 00:59:34,420
它叫创建一个设备文件

826
00:59:35,100 --> 00:59:38,520
其实上面也可以说一个创建一个新的目录文件

827
00:59:38,520 --> 00:59:39,440
这意味着什么

828
00:59:40,000 --> 00:59:43,800
这意味着我们那个文件的抽象覆盖面非常广

829
00:59:45,040 --> 00:59:45,820
Everything is fine

830
00:59:46,400 --> 00:59:48,100
就是Unix的一个设计哲学就是

831
00:59:48,100 --> 00:59:53,360
它要简化对应用程序员的这种思考问题这种复杂性

832
00:59:53,360 --> 00:59:55,820
就是让应用程序员想得越简单越好

833
00:59:55,820 --> 00:59:57,180
所以它一个简单的办法

834
00:59:57,180 --> 00:59:58,460
底下有很多种资源嘛

835
00:59:58,460 --> 01:00:00,060
所有的资源我都认为是fine

836
01:00:00,060 --> 01:00:01,800
你的设备千千百万那没关系

837
01:00:01,800 --> 01:00:03,380
我全是把它认为是一种文件

838
01:00:03,380 --> 01:00:07,860
所以这个make node它会把一个node设备认为是一个文件

839
01:00:07,860 --> 01:00:09,940
通过这个make node做完这个操作之后

840
01:00:09,940 --> 01:00:11,600
它也会返回一个什么呢

841
01:00:11,600 --> 01:00:12,660
返回一个FD

842
01:00:12,660 --> 01:00:16,720
然后你对这个FD进行相应的比如说打开读写

843
01:00:16,720 --> 01:00:17,860
不是返回一个FD

844
01:00:17,860 --> 01:00:21,740
返回一个这么一个文件名

845
01:00:21,740 --> 01:00:24,080
然后再对这个文件名一起通过open打开之后

846
01:00:24,080 --> 01:00:25,660
可以对这个设备进行读写了

847
01:00:25,660 --> 01:00:27,100
按照文件的方式进行读写

848
01:00:27,600 --> 01:00:30,300
所以这个file是非常强大的一种抽象

849
01:00:30,640 --> 01:00:34,820
它等于是对各种资源的一种更加高层的抽象

850
01:00:35,160 --> 01:00:36,820
来屏蔽底层的差异

851
01:00:36,820 --> 01:00:39,720
这也是为什么导致我们的文件系统也不得不复杂化

852
01:00:39,720 --> 01:00:41,220
因为你的文件系统已经说

853
01:00:41,220 --> 01:00:42,740
如果按照这种说法的话

854
01:00:42,740 --> 01:00:45,500
我们文件系统不仅仅要管存储设备了

855
01:00:45,500 --> 01:00:46,760
我可能要管网络设备

856
01:00:46,760 --> 01:00:50,560
也要去管所谓的GPU或者是昇卡

857
01:00:50,560 --> 01:00:52,400
键盘鼠标都可以这么来管

858
01:00:52,400 --> 01:00:56,040
这就使得你的文件系统会更加复杂

859
01:00:56,640 --> 01:00:58,640
好 既然这个文件系统复杂之后

860
01:00:58,640 --> 01:01:01,700
你会发现我还需要了解文件系统相关的一些信息

861
01:01:01,700 --> 01:01:04,860
它到底是一个设备还是一个目录还是一个文件

862
01:01:04,860 --> 01:01:05,900
一般的文件呢

863
01:01:05,900 --> 01:01:08,500
那你会通过所谓的 F state 和 state

864
01:01:08,960 --> 01:01:11,400
来把他这个文件的一些基本信息

865
01:01:11,400 --> 01:01:14,360
什么时候创建的 大小多少 等等

866
01:01:14,360 --> 01:01:17,600
这些信息全都放在这么一个结构里面给传进来

867
01:01:17,600 --> 01:01:20,940
然后这些信息你本来都是应该放在文件系统里面帮你管起来的

868
01:01:21,860 --> 01:01:23,920
这个用户程序可以调这种系统调用

869
01:01:23,920 --> 01:01:26,900
来得到这个文件的相关的信息 进一步去了解文件

870
01:01:28,360 --> 01:01:31,900
我们再看最后两个 一个叫link 一个叫unlink

871
01:01:32,960 --> 01:01:36,220
link干什么呢 它是为文件创建另一个名字

872
01:01:36,220 --> 01:01:39,260
前面我们看到是为文件创建了一个新的FD

873
01:01:39,260 --> 01:01:41,920
就是用大大来创建新的FD

874
01:01:41,920 --> 01:01:45,140
那个是在一个进程里面 一个应用里面

875
01:01:45,140 --> 01:01:48,820
我可以创建两个FD来访问同一个文件

876
01:01:48,820 --> 01:01:52,160
而这个是在文件系统里面

877
01:01:52,160 --> 01:01:56,080
我创建了两个文件名 来指向同一个文件

878
01:01:56,500 --> 01:01:58,960
這兩個文件可以給不同的進程

879
01:01:58,960 --> 01:02:02,120
不同的應用去打開進行操作

880
01:02:02,120 --> 01:02:04,200
但其實它訪問的是同一個文件

881
01:02:04,200 --> 01:02:07,620
那它這麼做這個link這個操作呢

882
01:02:07,620 --> 01:02:12,580
目的是進一步的方便我們的用戶去管理文件

883
01:02:12,580 --> 01:02:16,880
我可以在一個目錄下創建一個文件

884
01:02:16,880 --> 01:02:20,280
然後在另一個目錄下再創建一個link這個同樣的一個文件

885
01:02:20,280 --> 01:02:22,840
這樣這個文件可能具有不同的一些身份

886
01:02:22,840 --> 01:02:25,840
它可以有更灵活的管理措施

887
01:02:25,840 --> 01:02:28,760
这是为什么要有一个link的这么一个结构

888
01:02:28,760 --> 01:02:30,160
有link就是有unlink

889
01:02:30,160 --> 01:02:33,040
你可以发现它不叫RM或者是DL

890
01:02:33,040 --> 01:02:34,120
它叫unlink

891
01:02:34,120 --> 01:02:35,640
unlink是什么 删除

892
01:02:36,780 --> 01:02:38,800
按道理我们前面的link和unlink是一对

893
01:02:38,800 --> 01:02:40,380
为什么它把它叫做删除文件

894
01:02:40,380 --> 01:02:44,720
是在于当一个文件有多个文件名的时候

895
01:02:44,720 --> 01:02:47,500
也意味着它有多个link的属性

896
01:02:47,500 --> 01:02:50,740
只有这个link的所有的属性都没了

897
01:02:50,740 --> 01:02:52,740
我才能够说把这个文件删除

898
01:02:52,740 --> 01:02:53,840
所以unlink之后呢

899
01:02:53,840 --> 01:02:57,060
它只是删除了其中这个属性的一个文件名

900
01:02:57,060 --> 01:02:59,060
最后如果unlink到某一步的时候

901
01:02:59,060 --> 01:03:02,800
发现这个文件名就只有一份了

902
01:03:02,800 --> 01:03:05,140
那最后就会彻底的删除这个文件

903
01:03:05,660 --> 01:03:09,440
这就是所谓link、unlink的一个理解

904
01:03:10,040 --> 01:03:13,220
这就看到了我们就大约20个

905
01:03:13,220 --> 01:03:14,360
就把现在讲完了

906
01:03:15,460 --> 01:03:17,420
如果是大家学应用程序的话

907
01:03:17,420 --> 01:03:18,880
那我就一堂课就给大家讲完了

908
01:03:19,300 --> 01:03:20,380
但大家觉得是超级讨

909
01:03:20,860 --> 01:03:24,040
这意味着什么 你们要把这些系统都要实现掉

910
01:03:24,400 --> 01:03:27,880
我几分钟讲这个内容 或者十分钟讲的内容

911
01:03:27,880 --> 01:03:29,800
其实你们要花一学期来去完成

912
01:03:29,800 --> 01:03:32,700
这就是区别 我们给应用程序带来非常大的方便

913
01:03:32,700 --> 01:03:34,560
但是给自己带来非常大的麻烦

914
01:03:34,560 --> 01:03:37,040
你们需要去理解这个麻烦性

915
01:03:37,860 --> 01:03:39,280
我们再解释一下这个方便性

916
01:03:39,280 --> 01:03:40,580
方便性就是非常简单的程序

917
01:03:40,580 --> 01:03:42,180
这个程序也来自于MIT

918
01:03:42,180 --> 01:03:46,080
MIT他们那个实验 这些非常简单的程序

919
01:03:46,080 --> 01:03:47,820
给个链接大家可以去访问

920
01:03:47,820 --> 01:03:51,460
大约10个左右的程序

921
01:03:52,220 --> 01:03:53,080
大约代码量

922
01:03:53,080 --> 01:03:56,540
每个代码量大约有10几行

923
01:03:56,540 --> 01:03:57,220
这个代码量

924
01:03:57,220 --> 01:03:59,580
但是你写它写的代码还是几千行

925
01:03:59,580 --> 01:04:01,880
超级统IQV6来支持它

926
01:04:01,880 --> 01:04:04,220
涉及到进程文件

927
01:04:04,220 --> 01:04:05,400
进程链通讯等等

928
01:04:05,400 --> 01:04:08,800
我们可以稍微看一下这些程序

929
01:04:08,800 --> 01:04:10,540
从而对它有更精准的了解

930
01:04:10,540 --> 01:04:12,980
为什么大家建立实验环境

931
01:04:12,980 --> 01:04:14,820
是在于你建立实验环境之后

932
01:04:14,820 --> 01:04:16,420
就很容易去呈现它的工作

933
01:04:16,420 --> 01:04:17,720
从而对它有更好的理解

934
01:04:17,820 --> 01:04:22,860
比如说第一个Copy点C

935
01:04:22,860 --> 01:04:25,820
我们可以看稍微看一下这个采取

936
01:04:34,540 --> 01:04:35,830
能看见吗

937
01:04:37,840 --> 01:04:39,820
先把这个再放下面

938
01:04:56,700 --> 01:04:58,880
我先讲一个比较具体的程序

939
01:04:58,880 --> 01:05:00,820
后面的程序可能就会讲得简单点

940
01:05:00,820 --> 01:05:03,420
你先看一个简单的

941
01:05:03,420 --> 01:05:04,040
这程序干啥

942
01:05:04,040 --> 01:05:05,860
这程序

943
01:05:05,860 --> 01:05:06,980
建立一个buffer

944
01:05:06,980 --> 01:05:09,060
这是谁的程序 我认为大家都懂了

945
01:05:09,060 --> 01:05:09,800
如果大家有不懂的 可以试试

946
01:06:11,460 --> 01:06:15,640
然后如果是大于0就读到了大于可读到了n个字节

947
01:06:15,640 --> 01:06:19,500
然后就write1buffern

948
01:06:19,500 --> 01:06:22,100
你看这里出现了一个我们前面说的这个

949
01:06:22,100 --> 01:06:24,560
叫什么 就是文件相关的read和write

950
01:06:24,560 --> 01:06:25,600
当然也有一个内存

951
01:06:25,600 --> 01:06:27,760
但内存我们直接是用这个没有通过桃系统

952
01:06:27,760 --> 01:06:29,560
直接就是通过我们编辑器

953
01:06:29,560 --> 01:06:31,900
给我们分配了六四字节的一个局务变量

954
01:06:33,120 --> 01:06:34,800
最后有一个exit退出

955
01:06:36,280 --> 01:06:42,200
这个程序退出谁执行 我们前面介绍的是只进程

956
01:06:42,200 --> 01:06:47,920
我执行完毕之后我要退出 退出这个信息这个零这个status

957
01:06:47,920 --> 01:06:56,280
会返回给我们的附近城 附近城是谁 不知道 这也没有显示

958
01:06:56,280 --> 01:07:01,020
反正我就退出零嘛 至于附近城是谁创建的我 那就是谁

959
01:07:01,020 --> 01:07:04,700
这个程序 请问这个程序的声音效果是怎么回事

960
01:07:05,660 --> 01:07:08,780
你们的理解 这是半弹 没有执行

961
01:07:13,520 --> 01:07:15,660
首先你要理解这个零和一是啥

962
01:07:17,580 --> 01:07:18,400
文件描述符

963
01:07:18,860 --> 01:07:22,660
我们前面说文件描述符应该要open才能得到一个文件描述符

964
01:07:22,660 --> 01:07:23,380
为什么它没有open

965
01:07:53,380 --> 01:07:54,300
但我们现在只有01

966
01:07:54,300 --> 01:07:56,260
那这个01为什么不需要open

967
01:07:56,260 --> 01:07:59,080
是在于我们的创建一个进程的时候

968
01:07:59,080 --> 01:08:01,680
缺整形状态的012就自动帮你打开了

969
01:08:02,680 --> 01:08:04,860
所以你就不需要再去做这个open操作

970
01:08:04,860 --> 01:08:06,100
它帮你建好了

971
01:08:06,100 --> 01:08:07,680
但是你看这种

972
01:08:08,360 --> 01:08:09,840
是熟的人知道012是啥

973
01:08:09,840 --> 01:08:11,420
不熟的人知道012是啥

974
01:08:11,420 --> 01:08:12,880
不知道 因为它没有内心系统

975
01:08:14,200 --> 01:08:15,720
所以非常简洁灵活

976
01:08:15,720 --> 01:08:17,080
又体验了C的简洁性

977
01:08:17,080 --> 01:08:20,640
但是它这个什么的容易出错

978
01:08:22,560 --> 01:08:24,820
好 我们看看执行出来什么效果

979
01:08:24,820 --> 01:08:30,700
说了半天还是要动一动

980
01:08:31,660 --> 01:08:34,640
这是一个应用程序 它跑在哪个超级种子上呢

981
01:08:36,940 --> 01:08:39,400
XV6上面 它不是跑在Linux上面

982
01:08:39,400 --> 01:08:44,500
XV6是一个Linux的一个 Unix的一个超级的精简版

983
01:08:44,500 --> 01:08:47,640
而且跑在Risk 5上面 所以我们要用

984
01:08:47,640 --> 01:08:53,640
这叫QMU,我们叫QMU模拟Target 5机器,然后把它跑起来

985
01:08:54,220 --> 01:09:00,600
你看XV6已经boot起来了,boot起来之后它里面找到两个CPU盒

986
01:09:02,040 --> 01:09:05,640
然后NIT start SH,SH是一个share

987
01:09:06,300 --> 01:09:10,300
我们说命令行的界面,这个命令行界面也是一个程序

988
01:09:11,060 --> 01:09:16,140
那NIT是什么?NIT starting share,这个细节说明什么

989
01:09:46,140 --> 01:09:50,300
但是这个显示本来就是我们的OS提供的显示

990
01:09:50,300 --> 01:09:51,540
但是我一敲回车

991
01:09:54,040 --> 01:09:56,840
看不见 怎么挡住了

992
01:09:56,840 --> 01:09:59,900
就是对 复制了一份

993
01:09:59,900 --> 01:10:02,140
结合刚才的弹 你会发现

994
01:10:03,640 --> 01:10:06,540
读了一个一行字符创

995
01:10:06,540 --> 01:10:10,400
在写了一行字符创 就干这个事情

996
01:10:11,100 --> 01:10:14,440
我再敲 随便敲 那其实还是一样

997
01:10:14,440 --> 01:10:20,900
它会显示 再把它显示出来 就干这个事情

998
01:10:20,900 --> 01:10:29,440
那我要出来怎么办 我这个死在这儿了

999
01:10:29,440 --> 01:10:31,500
我只要它N小于0才Break

1000
01:10:31,500 --> 01:10:35,880
我怎么能让它Break呢 我必须把它Care掉

1001
01:10:35,880 --> 01:10:39,700
往前学习性能要不要Care嘛 但是Care怎么Care

1002
01:10:40,500 --> 01:10:42,200
我不能够再写程序Care它

1003
01:11:12,200 --> 01:11:14,720
没办法控制怎么办 重启 或者关机

1004
01:11:14,720 --> 01:11:16,400
我都是做了一个关机操作

1005
01:11:17,400 --> 01:11:19,160
Q&A 关掉

1006
01:11:20,900 --> 01:11:23,260
这个其实我没有发出这个Keyer命令

1007
01:11:23,260 --> 01:11:24,620
所以它退不出去

1008
01:11:25,680 --> 01:11:27,460
这就是一个问题

1009
01:11:28,380 --> 01:11:29,540
其实这没有演示

1010
01:11:29,540 --> 01:11:31,760
我本来想演示一下Keyer 没Keyer掉

1011
01:11:32,540 --> 01:11:34,080
但有一点 我想问一下

1012
01:11:34,900 --> 01:11:36,200
我刚才问了一个问题

1013
01:11:36,200 --> 01:11:37,040
写程序的时候

1014
01:11:37,040 --> 01:11:38,560
我其实不知道我附近人是啥

1015
01:13:38,620 --> 01:13:46,760
Open,Open在哪,O,就写了一堆小程序

1016
01:13:50,840 --> 01:13:54,000
其实真正有效的代码就是11行12行

1017
01:13:55,220 --> 01:13:59,080
它干了干什么事情,Open了一个文件,这个写了一个WR only

1018
01:13:59,900 --> 01:14:03,720
就是这是一个标识,就是我可以读写,然后是有创建标记

1019
01:14:03,720 --> 01:14:05,880
创建标记就是说如果没有,我就要创建一个新的文件

1020
01:14:06,820 --> 01:14:08,260
这是打开了这么一个文件

1021
01:14:08,720 --> 01:14:11,760
打开这个文件之后 往里面写了三个 O O 回车

1022
01:14:13,560 --> 01:14:15,480
一共四个字母 这个写稿文也是个字母

1023
01:14:15,480 --> 01:14:18,220
写了四个字节写进去

1024
01:14:18,640 --> 01:14:22,180
所以最后当你开了的时候

1025
01:14:22,180 --> 01:14:24,520
把这个文件也显示出来就发现它就显示 O O

1026
01:14:24,520 --> 01:14:27,860
这是一个大字的过程 我就不进一步解释了

1027
01:14:27,860 --> 01:14:30,160
因为发现这里面它确实要打开一个新的

1028
01:14:30,160 --> 01:14:32,080
不是012的这种已有的

1029
01:14:32,080 --> 01:14:34,040
已经被缺生打开这个标识幅的时候

1030
01:14:34,040 --> 01:14:35,980
它必须要去Open一下

1031
01:14:36,740 --> 01:14:37,840
然后得到一个FD

1032
01:14:39,040 --> 01:14:43,100
零一二,也许这个就是三,也许就是三

1033
01:14:43,100 --> 01:14:45,980
如果它第三个,正好是一开始执行的话

1034
01:14:45,980 --> 01:14:48,860
那么三的话就write,write三的话就一直把这写进去了

1035
01:14:48,860 --> 01:14:50,420
然后最后有一个退出

1036
01:14:50,420 --> 01:14:53,080
那么你如果在刚才我那个share命令下执行这个open

1037
01:14:53,080 --> 01:14:56,800
也是一样,share是复进层,open是执进层

1038
01:14:56,800 --> 01:15:00,600
然后它退出之后会把这个退出码返回给share

1039
01:15:00,600 --> 01:15:01,840
这个肯定是能退出的

1040
01:15:01,840 --> 01:15:03,400
所以我们还可以执行一下,它一定会退出

1041
01:15:04,300 --> 01:15:06,080
这不会像我们刚才出不去

1042
01:15:17,400 --> 01:15:21,020
这很快 因为我已经编译过了 所以它执行比较快

1043
01:15:21,020 --> 01:15:23,820
那叫open

1044
01:15:24,320 --> 01:15:25,340
一下就出来了

1045
01:15:25,340 --> 01:15:26,480
啥也没有 啥也看不到

1046
01:15:26,480 --> 01:15:28,000
但是你应该看到一个文件

1047
01:15:29,200 --> 01:15:29,560
cat

1048
01:15:31,140 --> 01:15:32,960
output.txt

1049
01:15:32,960 --> 01:15:33,780
txt

1050
01:15:36,680 --> 01:15:37,820
三个小窝出现

1051
01:15:45,820 --> 01:15:47,540
就是我还看不到它的输出码

1052
01:15:47,540 --> 01:15:50,100
按道理来说 我这个Shell在等待它结束的时候

1053
01:15:50,100 --> 01:15:52,400
会得到它这个返回码

1054
01:15:52,400 --> 01:15:56,020
但现在我还缺少一个手段能够把它看回来

1055
01:15:56,020 --> 01:15:59,480
OK 然后这就是Open的操作

1056
01:15:59,480 --> 01:16:03,700
那后面呢 我就不细讲了

1057
01:16:03,700 --> 01:16:06,060
就是你可以看到这个应用程序非常简单

1058
01:16:06,060 --> 01:16:07,800
但它其实内部它会涉及到

1059
01:17:07,800 --> 01:17:11,800
就是不会装成一个office,这个层级就非常小。

1060
01:17:15,500 --> 01:17:22,580
这一块,大家可以看看Fock,对Fock有个直观的理解。

1061
01:17:35,720 --> 01:17:44,300
看这个Fork EACC混在一起的,你看这里面,这是一个进程,它Fork穿在这个进

1062
01:17:44,300 --> 01:17:45,580
程,穿在这个指令层。

1063
01:17:52,360 --> 01:17:54,700
如果是指进层 什么叫如果是指进层

1064
01:17:54,700 --> 01:17:57,460
就看它的Fock的返回值 性量也有返回值

1065
01:17:57,460 --> 01:18:01,920
如果返回值是0 意味着我自己是指进层

1066
01:18:01,920 --> 01:18:04,120
因为它指进代码完全逻辑是一样的

1067
01:18:04,120 --> 01:18:08,220
它整个复制了复进层所有的内容

1068
01:18:08,640 --> 01:18:09,840
但它的返回值不一样

1069
01:18:09,840 --> 01:18:11,780
所以返回值是0 意味着指进层

1070
01:18:11,780 --> 01:18:14,020
然后它就会去EXEC一个ECO

1071
01:18:14,020 --> 01:18:15,560
等于这个ECO是一个程序

1072
01:18:45,700 --> 01:18:52,040
這個退出這個1,這個1是status,會傳給通過操作系統,通過操作系統

1073
01:18:52,040 --> 01:18:53,940
的傳遞會給到附近層

1074
01:18:53,940 --> 01:18:59,400
附近層一旦收到了這個,當指令層死了之後呢,操作系統會把這個信息

1075
01:18:59,400 --> 01:19:01,760
傳給正在等待的附近層

1076
01:19:01,760 --> 01:19:06,440
從而讓這個wait這個系統等待的系統這樣能夠返回,就得到這個1

1077
01:19:06,440 --> 01:19:11,960
然後會打印出來這個狀態是,就是退出的這個狀態,就是退出碼,就是1

1078
01:19:11,960 --> 01:19:14,520
只有这个程序的一个写法 非常简单

1079
01:19:14,520 --> 01:19:15,440
也就写了

1080
01:19:18,260 --> 01:19:20,240
我就正好问一下 这有几个性能要用

1081
01:19:20,240 --> 01:19:21,840
这个程序用了几个性能要用

1082
01:19:24,740 --> 01:19:25,060
4

1083
01:19:26,580 --> 01:19:27,220
EXT

1084
01:19:29,120 --> 01:19:29,760
EXIT

1085
01:19:30,580 --> 01:19:31,920
printf是性能要用吗

1086
01:19:32,640 --> 01:19:34,220
它有Write 它里面就有Write

1087
01:19:34,220 --> 01:19:38,120
Yes 它掉的其实是Write1

1088
01:19:38,120 --> 01:19:39,680
Write1 掉Write1

1089
01:19:40,200 --> 01:19:46,200
Printf只是我们的C库提供的一个更加灵活强大的一个显示的一个函数

1090
01:19:46,720 --> 01:19:49,500
最底下是我们的Write1 写一个字不错

1091
01:19:50,420 --> 01:19:52,920
OK 这个就算下了

1092
01:20:00,500 --> 01:20:03,460
这个程序 给大家简单过了一下

1093
01:20:28,740 --> 01:20:33,980
但是我希望大家上完课之后

1094
01:20:33,980 --> 01:20:36,960
能够对这个问题有个清晰的理解

1095
01:20:36,960 --> 01:20:38,760
虽然我这个问题提的比较早了点

1096
01:20:39,260 --> 01:20:39,660
但是比较早了点

1097
01:20:39,680 --> 01:20:41,080
留在这儿吧 大家可以看到

1098
01:20:41,820 --> 01:20:44,020
这个Pype这一块我就不讲了

1099
01:20:44,020 --> 01:20:44,940
大家可以去试一下

1100
01:20:44,940 --> 01:20:45,780
就是我们前面说的

1101
01:20:45,780 --> 01:20:47,700
它把程序组合在一起了

1102
01:20:47,700 --> 01:20:49,020
通过这个Pype机制

1103
01:20:49,020 --> 01:20:49,920
基层线通信的机制

1104
01:20:49,920 --> 01:20:50,820
可以把程序组合在一起

1105
01:20:50,820 --> 01:20:52,280
实现更加强大的功能

1106
01:20:55,160 --> 01:20:56,820
没了吧 好

1107
01:20:56,820 --> 01:20:58,480
最后简单小节一下

1108
01:20:59,140 --> 01:21:00,460
就是我们在这里面

1109
01:21:00,460 --> 01:21:03,820
其实是通过这几个小的程序呢

1110
01:21:03,820 --> 01:21:06,240
你看到了Unix里面的

1111
01:21:06,240 --> 01:21:08,280
非常重要的一些idea

1112
01:21:08,280 --> 01:21:13,680
包括进程 文件系统 以进行通讯等等一系列的操作

1113
01:21:13,680 --> 01:21:15,720
这些接口都非常的简单

1114
01:21:16,460 --> 01:21:21,260
因为它当时unix用为了写unix专门发明的C语言

1115
01:21:21,260 --> 01:21:23,980
这个C语言又非常的灵活和简洁

1116
01:21:23,980 --> 01:21:28,120
所以它的接口定义也非常简洁 非常简单

1117
01:21:28,120 --> 01:21:31,580
基本上看到就只有整数和一个地址空间

1118
01:21:31,580 --> 01:21:34,060
就一个buffer 一个内存框

1119
01:21:34,060 --> 01:21:37,440
这些抽象虽然简单 但它可以组合

1120
01:21:37,440 --> 01:21:40,460
这种组合性使得它非常的灵活

1121
01:21:40,460 --> 01:21:43,060
而且这个抽象 我们前面说的文件的抽象

1122
01:21:43,060 --> 01:21:48,380
它是对底层的非常差异性非常大的一些东西

1123
01:21:48,380 --> 01:21:51,440
统一做了一个抽象 就是文件

1124
01:21:52,400 --> 01:21:54,420
这就使得我们的应用程序

1125
01:21:54,420 --> 01:21:57,060
非常简单地控制非常底下复杂的东西

1126
01:21:58,140 --> 01:22:02,380
这是我们站在应用的角度能看到的一种便捷性

1127
01:22:02,380 --> 01:22:05,120
就是超级桶的一种便捷性和灵活性

1128
01:22:05,120 --> 01:22:10,920
好 这一块就给大家做了一个小节

1129
01:22:10,920 --> 01:22:13,240
OK 好 这一块就算讲完了

1130
01:22:13,240 --> 01:22:17,520
我们就接下来讲一下第二讲

1131
01:22:19,140 --> 01:22:23,600
第二讲由于第二讲讲实践与实验的简要分析

1132
01:22:23,600 --> 01:22:27,820
就做个介绍 这是第一节的内容

1133
01:22:27,820 --> 01:22:29,680
那其实想让大家对什么呢

1134
01:22:29,680 --> 01:22:34,420
对这个我们后续的一些课程所要覆盖的知识点

1135
01:22:34,780 --> 01:22:39,420
以这个知识点它所对应的实验环节有一个理解

1136
01:22:39,420 --> 01:22:41,000
就是你学了这门课

1137
01:22:41,480 --> 01:22:43,600
除了我们这边说你要知道超级动物是什么

1138
01:22:43,600 --> 01:22:46,280
超级动物用哪些关键的一些知识点

1139
01:22:46,280 --> 01:22:48,880
你还知道这些知识点怎么去设计和实现

1140
01:22:48,880 --> 01:22:51,460
而不是把那些概念给背下来

1141
01:22:51,460 --> 01:22:54,660
背概念是我们这门课最不提倡的

1142
01:22:54,660 --> 01:22:55,800
背代码也更不提倡了

1143
01:22:55,800 --> 01:22:57,360
就是以后还有背代码的同学

1144
01:22:57,360 --> 01:22:59,420
这个其实完全没有必要

1145
01:22:59,900 --> 01:23:02,220
好 那我们就开始讲第二讲这个

1146
01:23:05,620 --> 01:23:11,660
我们讲这个,你会发现这门课就是和一般的其他的超级系统课不太一

1147
01:23:11,660 --> 01:23:12,120
样

1148
01:23:12,120 --> 01:23:18,340
我们是按照对应用的需求足够,就是满足应用的需求

1149
01:23:18,340 --> 01:23:22,680
按照这个特点来进行讲解,这是一个大的时间线

1150
01:23:22,680 --> 01:23:24,660
这个讲解里面,我发现应用有不同的需求

1151
01:23:24,660 --> 01:23:28,760
这个需求使得我们超级统要去实现这种对需求的支持

1152
01:23:28,760 --> 01:23:33,800
从而会有不同的一些知识点或者关键的一些内容

1153
01:23:33,800 --> 01:23:35,960
我觉得里面穿插的就体现出来了

1154
01:23:35,960 --> 01:23:37,060
是这么一个逻辑

1155
01:23:37,840 --> 01:23:39,180
所以像第一个利波OS

1156
01:23:39,800 --> 01:23:42,880
利波OS就是还有一个P处理

1157
01:23:42,880 --> 01:23:45,840
还有一个多道程序与分时多任务超级统

1158
01:23:46,420 --> 01:23:48,840
这是我们会涉及到的三个OS

1159
01:23:48,840 --> 01:23:50,240
当然这个OS虽然是三个

1160
01:23:50,240 --> 01:23:52,960
其实也是一个OS建立在另一个OS之上

1161
01:23:52,960 --> 01:23:55,240
一层一层的改进和叠加形成

1162
01:23:55,240 --> 01:23:58,200
所以并不认为大家就感觉要看三份完全不一样

1163
01:23:58,200 --> 01:23:59,980
但他们这些有个继承关系

1164
01:24:01,380 --> 01:24:08,940
不同的OS所要达到的目标、大目标、支持应用是没有变化的

1165
01:24:08,940 --> 01:24:12,680
但是应用的需求在变化,所以OS的功能也在变化

1166
01:24:12,680 --> 01:24:13,760
这是一个

1167
01:24:13,760 --> 01:24:15,920
这三点的贡献是什么呢

1168
01:24:15,920 --> 01:24:18,980
它重点是去使用物理硬件

1169
01:24:18,980 --> 01:24:21,520
它需要对物理硬件有一个充分的使用

1170
01:24:22,200 --> 01:24:25,980
但是只使用物理硬件还不足以去支持更加复杂的应用

1171
01:24:25,980 --> 01:24:28,360
特别是这个应用是很多的情况下

1172
01:24:30,020 --> 01:24:32,140
所以我们就出现了第二个

1173
01:24:32,140 --> 01:24:35,620
我们为了支持更复杂的应用需求

1174
01:24:35,620 --> 01:24:37,760
更多的应用程序去执行

1175
01:24:37,760 --> 01:24:39,600
我们就建立了三个抽象

1176
01:24:40,020 --> 01:24:43,760
第二个阶段就是看到为了支持复杂应用

1177
01:24:43,760 --> 01:24:47,640
所提出的地中间抽象 进程中间抽象和文件抽象

1178
01:24:47,640 --> 01:24:50,760
这是第二部分的OS

1179
01:24:50,760 --> 01:24:52,560
就是复杂化的

1180
01:24:53,100 --> 01:24:55,260
就是对应用需求复杂化的一个支持

1181
01:24:57,100 --> 01:25:03,320
第三个呢 是对应用所需要的这种多样性功能知识

1182
01:25:03,320 --> 01:25:06,720
就是你要提供这种灵活的功能

1183
01:25:06,720 --> 01:25:09,240
这种灵活的功能 我们说进程间通讯 我们前面已经提到

1184
01:25:09,240 --> 01:25:14,420
你可以通过进程间通讯 使得两个应用可以合在一起干一些事情

1185
01:25:14,420 --> 01:25:18,140
然后第二个呢 多个应用可以共享资源去做一些事情

1186
01:25:18,140 --> 01:25:20,760
那这种事情就涉及到并发操作

1187
01:25:21,160 --> 01:25:24,720
这个呢 第一要保证它提供相关机制去支持它这种功能

1188
01:25:24,720 --> 01:25:26,180
第二要保证它正确性

1189
01:25:26,180 --> 01:25:28,460
因为所有的变化它都非常容易产生bug

1190
01:25:28,880 --> 01:25:32,160
所以我们要有一些机制来帮助我们能够既保证高效

1191
01:25:32,160 --> 01:25:35,120
又不会有bug的一种OS

1192
01:25:35,120 --> 01:25:36,400
那就这两块

1193
01:25:36,400 --> 01:25:43,380
最后一块是说我们设备并不仅仅是这种所谓的这种print

1194
01:25:43,380 --> 01:25:46,020
或者是storage就是read write

1195
01:25:46,020 --> 01:25:47,880
可能还有更多其他的设备

1196
01:25:47,880 --> 01:25:49,060
你怎么去支持它

1197
01:25:49,060 --> 01:25:50,480
就是管理Io设备

1198
01:25:50,480 --> 01:25:51,860
所以这就是不同的OS

1199
01:25:51,860 --> 01:25:55,960
那么这三大类呢 形成了我们这个课程的一个就是

1200
01:25:57,220 --> 01:26:01,740
Base 我们基于这个OS来进行讲解 每个OS是三个OS基础之上搭

1201
01:26:01,740 --> 01:26:02,360
建出来的

1202
01:26:04,500 --> 01:26:09,480
那再稍微展开一点 你看到这个LibOS 讲LibOS重点要去理解

1203
01:26:09,480 --> 01:26:11,060
就是为了能够支持这个

1204
01:26:12,220 --> 01:26:16,740
基于一个酷的形式存在的一个OS呢 我们需要理解哪些东西呢

1205
01:26:16,740 --> 01:26:18,060
需要理解函数调用

1206
01:26:18,060 --> 01:26:20,620
需要理解这个编辑和操作用怎么去配合的

1207
01:26:20,620 --> 01:26:23,020
硬件如何启动和软件如何启动

1208
01:26:23,020 --> 01:26:24,720
边缘写的条是逻辑程序

1209
01:26:24,720 --> 01:26:26,520
其实关键一点就是和大家之前

1210
01:26:26,520 --> 01:26:28,460
写应用程序最大的补生在于

1211
01:26:28,460 --> 01:26:30,420
你写的是一个逻辑程序

1212
01:26:30,420 --> 01:26:32,660
底下没有OS 它还能跑

1213
01:26:33,440 --> 01:26:34,780
因为你在写OS

1214
01:26:35,780 --> 01:26:36,140
所以

1215
01:26:37,360 --> 01:26:38,560
你就发现

1216
01:26:38,560 --> 01:26:40,440
你以前用到的一些OS

1217
01:26:40,440 --> 01:26:42,500
行为里非常便捷的东西都没了

1218
01:26:42,500 --> 01:26:44,180
比如说你可以debug

1219
01:26:44,180 --> 01:26:46,820
你可以单步调试 单步中断 没了

1220
01:26:47,640 --> 01:26:48,640
但我们还可以用

1221
01:27:48,640 --> 01:27:50,340
能力给充分的发挥出来

1222
01:27:50,340 --> 01:27:54,100
从而可以使得我们OS可以管理更有效的

1223
01:27:54,100 --> 01:27:55,920
不会担心应用程序破坏我

1224
01:27:55,920 --> 01:27:57,380
更有效的管理这个应用程序

1225
01:27:57,380 --> 01:27:58,880
这是这一块

1226
01:27:58,880 --> 01:28:01,760
拥有的特先级就会涉及到

1227
01:28:01,760 --> 01:28:04,020
一个比较麻烦的事情叫切换

1228
01:28:04,020 --> 01:28:06,580
这个切换就是比较麻烦

1229
01:28:06,580 --> 01:28:08,960
你要确保你能够在

1230
01:28:08,960 --> 01:28:11,040
我们的APP和OS之间

1231
01:28:11,040 --> 01:28:12,320
它们运行在不同特先级里面

1232
01:28:12,320 --> 01:28:14,320
来回自如地切换

1233
01:28:14,320 --> 01:28:20,240
只有所谓的一个从一个课程级执行回到另一个课程级

1234
01:28:20,240 --> 01:28:22,040
最后它有一个状态的保存和恢复

1235
01:28:22,040 --> 01:28:23,120
那什么是状态

1236
01:28:23,120 --> 01:28:25,360
这是我们会进一步去理解的

1237
01:28:25,360 --> 01:28:27,160
对于我们的原理上来说就是一个状态

1238
01:28:27,160 --> 01:28:29,200
对于我们的实现来说是一堆继承器

1239
01:28:29,200 --> 01:28:31,200
这个你要知道怎么回事

1240
01:28:34,040 --> 01:28:39,120
多道程序是指的是跟前面这个P处理比起来

1241
01:28:39,120 --> 01:28:40,380
它在性能上又进了一步

1242
01:28:40,380 --> 01:28:40,820
为什么呢

1243
01:28:40,820 --> 01:28:44,160
因为前面在内存中始终只有一个APP

1244
01:28:45,400 --> 01:28:47,240
但是多少程序里面有多个APP

1245
01:28:48,480 --> 01:28:49,900
有多个APP之后

1246
01:28:49,900 --> 01:28:53,620
那你需要注意这些APP是共享一个内存空间的

1247
01:28:54,280 --> 01:28:55,420
他们虽然有特征级的划分

1248
01:28:55,420 --> 01:28:56,860
但是没有地址空间的划分

1249
01:28:58,860 --> 01:29:01,860
所以你需要去给每个APP设置他自己的地址空间

1250
01:29:01,860 --> 01:29:03,800
你会发现这个写APP都比较麻烦

1251
01:29:03,800 --> 01:29:05,760
我需要知道我的内存空间在哪

1252
01:29:05,760 --> 01:29:07,120
我的其实地址在哪

1253
01:29:07,120 --> 01:29:11,140
写出来的程序就不够简洁和方便

1254
01:29:11,140 --> 01:29:12,580
我们现在写程序根本不用care

1255
01:29:12,580 --> 01:29:15,400
我说我这个应用程序放在什么内存地址空间

1256
01:29:15,400 --> 01:29:16,900
从哪开始 不需要考虑

1257
01:29:18,120 --> 01:29:19,560
但是在早期的时候

1258
01:29:19,560 --> 01:29:20,920
这个多道程序设计的时候

1259
01:29:20,920 --> 01:29:23,400
你其实需要考虑 这是一个

1260
01:29:23,400 --> 01:29:26,860
第二个 你需要考虑这个都在内存中之后

1261
01:29:26,860 --> 01:29:29,580
那意味着我要去启动和执行一个APP很快

1262
01:29:29,580 --> 01:29:31,780
不像这儿 这里面执行的时候

1263
01:29:32,240 --> 01:29:33,040
我要执行一个APP

1264
01:29:33,040 --> 01:29:34,640
需要从这个APP从存储空间里面

1265
01:29:34,640 --> 01:29:36,200
加载到内存中去才能执行

1266
01:29:37,320 --> 01:29:40,720
但是当在多少程序的时候 比内存足够大了之后

1267
01:29:40,720 --> 01:29:42,700
你可以放多个程序 那我可以直接执行

1268
01:29:42,700 --> 01:29:45,440
不需要这个加载的过程 我一次性加载多个程序

1269
01:29:45,940 --> 01:29:49,260
既然加载执行之后 就会涉及到

1270
01:29:49,260 --> 01:29:51,600
有可能有些时候这个APT执行完毕了

1271
01:29:51,600 --> 01:29:53,000
我就要跳到这里去执行

1272
01:29:53,000 --> 01:29:55,140
但它存在一个所谓的调度问题

1273
01:29:55,140 --> 01:29:57,220
我们处理器能够去调度它

1274
01:29:57,220 --> 01:29:58,940
这个执行完毕 调下一个

1275
01:29:59,280 --> 01:30:01,580
你怎么去协作式的调度

1276
01:30:01,580 --> 01:30:02,900
协作的意思就是说

1277
01:30:02,900 --> 01:30:06,260
更多的是靠ADP之间的视觉性来完成这种调度

1278
01:30:06,260 --> 01:30:07,560
这是一种调度方式

1279
01:30:07,560 --> 01:30:08,700
第二个是空间的划分

1280
01:30:09,820 --> 01:30:12,980
这是我们是这个OS要去考虑知识点

1281
01:30:15,020 --> 01:30:16,920
然后再讲分十多任务

1282
01:30:16,920 --> 01:30:20,120
分十多任务最大的好处是减少所谓的这种

1283
01:30:20,120 --> 01:30:22,360
交互性的这种开销

1284
01:30:22,360 --> 01:30:23,560
交互体现了两点

1285
01:30:23,560 --> 01:30:25,880
一点是我们敲键盘鼠标这种交互

1286
01:30:25,880 --> 01:30:29,260
第二个是说它能够抢占

1287
01:30:29,260 --> 01:30:32,140
就是当一个应用像前面我们说协作什么的

1288
01:30:32,140 --> 01:30:35,540
我们想定这些应用都是友善的

1289
01:30:35,900 --> 01:30:38,480
我不干活 我就会把这个处理器给让出来

1290
01:30:38,480 --> 01:30:40,180
让其他应用去执行

1291
01:30:40,180 --> 01:30:43,020
但对于这种face多任务超级老来说

1292
01:30:43,020 --> 01:30:44,380
你这个应用

1293
01:30:44,380 --> 01:30:46,980
如果你是不干活也占CPU的话

1294
01:30:46,980 --> 01:30:50,280
那么我可以强制把你从这个CPU上给拉下来

1295
01:30:50,280 --> 01:30:53,380
让其他的应用去执行

1296
01:30:53,380 --> 01:30:55,020
这时候你可以发现

1297
01:30:55,020 --> 01:30:56,760
超级系统和应用之间

1298
01:30:56,760 --> 01:30:58,780
它的这种差异性越来越大

1299
01:30:58,780 --> 01:31:00,660
超级系统越来越不相信我们的应用程序

1300
01:31:30,660 --> 01:31:38,140
这里面的特圈级切换 脏下纹切换 中断处理

1301
01:31:38,140 --> 01:31:40,520
这些都和我们的RISC-V这个硬件

1302
01:31:40,520 --> 01:31:42,620
我们现在选的RISC-V 你选另外一种CPU

1303
01:31:42,620 --> 01:31:46,680
跟那种CPU的硬件 这有一个比较紧偶合的处理

1304
01:31:46,680 --> 01:31:49,040
这些都是和硬件打交道比较多的

1305
01:31:49,040 --> 01:31:51,420
所以是 幸好大家都学了组成原理课

1306
01:31:51,420 --> 01:31:52,720
所以我觉得这也不是什么负担

1307
01:31:53,200 --> 01:31:56,220
应该很轻松的应对RISC-V的这个

1308
01:31:56,220 --> 01:31:58,600
这个寄存器 这些汇编指令

1309
01:31:58,600 --> 01:32:00,240
我认为是没问题的

1310
01:32:00,240 --> 01:32:02,580
如果大家有问题的话 那我只能说是

1311
01:32:02,580 --> 01:32:04,240
康姆上课不够认真

1312
01:32:07,960 --> 01:32:09,920
再加上地址空间

1313
01:32:10,280 --> 01:32:12,260
这是有个地址空间抽象了 为什么呢

1314
01:32:13,340 --> 01:32:15,240
我们发现前面的这个

1315
01:32:15,860 --> 01:32:19,080
在这里面虽然有多个应用程序都在内存里面

1316
01:32:20,500 --> 01:32:22,660
但是这个应用程序

1317
01:32:22,660 --> 01:32:25,900
它占的地址空间 它可以任意访问其他应用地址空间

1318
01:32:25,900 --> 01:32:27,880
就它安全性还是得不到保障

1319
01:32:28,260 --> 01:32:33,800
所以我通过这种所谓的大家学了Risk5的主程原理课

1320
01:32:33,800 --> 01:32:37,640
就知道它有一个页机制 有这个虚存机制之后

1321
01:32:37,640 --> 01:32:41,640
我就可以给每一个APP限制一个空间

1322
01:32:41,640 --> 01:32:43,480
让它只能在这个空间里面访问

1323
01:32:43,480 --> 01:32:46,580
这样就进一步加强了所谓的隔离性

1324
01:32:46,580 --> 01:32:48,560
前面的隔离是用过它的那个它的隔离

1325
01:32:48,560 --> 01:32:50,760
这一块隔离是什么 是地址空间的隔离

1326
01:32:50,760 --> 01:32:52,080
比如说这两层隔离之后

1327
01:32:52,080 --> 01:32:57,300
才能够比较彻底的把APP限制在一个有限的范围之内

1328
01:34:28,060 --> 01:34:31,020
你有多少虚离秩序空间 也就有多少物理秩序空间

1329
01:34:31,020 --> 01:34:34,420
但是我们的OS还想进一步 什么叫进一步呢

1330
01:34:34,420 --> 01:34:37,260
就是让应用程序得到更大的方便

1331
01:34:37,260 --> 01:34:40,460
它可以申请超过物理秩序空间的一个地址空间

1332
01:34:41,040 --> 01:34:43,240
就超越物理秩序的虚离秩序

1333
01:34:43,240 --> 01:34:45,300
为什么叫虚离秩序呢 是在于

1334
01:34:51,400 --> 01:34:52,380
大家休息一下

1335
01:40:04,480 --> 01:40:10,440
那我们讲这个超越物理内存的虚拟存储

1336
01:40:11,080 --> 01:40:13,460
这里面有个词叫它不叫虚拟内存

1337
01:40:13,460 --> 01:40:14,620
它叫虚拟存储

1338
01:40:14,620 --> 01:40:15,560
为什么叫虚拟存储呢

1339
01:40:15,560 --> 01:40:17,380
其实内存也算是一种存储

1340
01:40:18,120 --> 01:40:19,640
然后能够达到超越物理内存

1341
01:40:19,640 --> 01:40:20,680
就是一定要把存储达到虚拟存储

1342
01:41:50,680 --> 01:41:54,520
有两部分 一个是业表 一个是虚拟存储

1343
01:41:54,520 --> 01:41:57,460
这两块需要大家去了解

1344
01:41:57,460 --> 01:42:01,760
有了这些之后 我们还会进一步讲进程抽象

1345
01:42:02,800 --> 01:42:04,120
进程抽象的意思就是说

1346
01:42:04,120 --> 01:42:06,800
我们要让这个程序执行得更加灵活

1347
01:42:06,800 --> 01:42:08,880
我们可以在运行过程中创建新的进程

1348
01:42:08,880 --> 01:42:11,140
创建新的可以运行的程序

1349
01:42:11,140 --> 01:42:12,520
我们可以让这个程序更好

1350
01:42:12,520 --> 01:42:15,340
更加方便去管理各种资源

1351
01:42:15,340 --> 01:42:20,840
包括类存 包括设备 包括文件 等等

1352
01:42:20,840 --> 01:42:23,880
那为此就搞出了所谓的一个进程 这么一个抽象

1353
01:42:23,880 --> 01:42:26,570
有这个进程抽象之后 我们就会对进程进行管理

1354
01:42:27,920 --> 01:42:33,200
你要知道什么时候创建 什么时候删除 什么时候让它停下来

1355
01:42:33,200 --> 01:42:34,700
这就自然有一个调度

1356
01:42:36,000 --> 01:42:39,640
所以进程抽象的OS 重点是进程管理和进程调度

1357
01:42:39,640 --> 01:42:43,660
这一块是我们要去掌握的内容

1358
01:42:43,660 --> 01:42:49,920
对面看到这个镜头,刚刚已经展示了复镜层要创建紫镜层,紫镜层还

1359
01:42:49,920 --> 01:42:51,800
可以创建紫镜层,等等。

1360
01:42:54,600 --> 01:42:57,620
然后在家会讲什么呢?会讲多处理器。

1361
01:42:58,540 --> 01:43:04,520
这其实在以前我们这一块内容是不讲的,因为老是觉得超纲。

1362
01:43:05,860 --> 01:43:11,480
但其实它已经不超纲了,我们的知识太落后了,没有跟上时代。

1363
01:43:11,480 --> 01:43:18,740
现在的机器,现在的计算机,小到你们的手表,手机,大到笔记本,服务器,

1364
01:43:19,220 --> 01:43:21,480
都是多核的,都是多处理器的。

1365
01:43:22,520 --> 01:43:27,280
应用程序,我不知道大家学并行编程,学没学?

1366
01:43:27,400 --> 01:43:32,080
没学的话,其实或多或少都会涉及到一点,就是你怎么去把这个多处理器给

1367
01:43:32,080 --> 01:43:34,060
用起来,让它跑得更快。

1368
01:46:04,800 --> 01:46:06,700
这是这要重点讲的内容

1369
01:46:06,700 --> 01:46:09,780
因为涉及到什么锁 信号量

1370
01:46:10,320 --> 01:46:11,480
还有什么条件变量

1371
01:46:11,480 --> 01:46:13,880
这些机制的一些设计与实现

1372
01:46:13,880 --> 01:46:18,460
以及用这些机制来实现并发问题的一些球迹

1373
01:46:18,460 --> 01:46:23,800
怎么去多个读进程和多个写进程

1374
01:46:23,800 --> 01:46:27,840
对同一个数据进行合理的读写操作

1375
01:46:27,840 --> 01:46:29,580
这是这一块内容

1376
01:46:29,580 --> 01:46:30,800
由于讲了现成

1377
01:46:30,800 --> 01:46:32,340
它和我们之前讲的进程不一样

1378
01:46:32,340 --> 01:46:35,820
所以我会讲这个进程线程的关系

1379
01:46:35,820 --> 01:46:40,060
同时还引入一个新的一个概念叫协程

1380
01:46:41,060 --> 01:46:42,140
这个协程

1381
01:46:43,480 --> 01:46:45,760
我理解大家很多同学也学过Python

1382
01:46:45,760 --> 01:46:46,940
Python就有协程的概念

1383
01:46:46,940 --> 01:46:48,900
还有加script有协程的概念

1384
01:46:48,900 --> 01:46:51,360
但是比较新的版本有这个概念

1385
01:46:51,360 --> 01:46:52,280
简单的理解

1386
01:46:52,280 --> 01:46:53,960
我讲简单的关系

1387
01:46:54,680 --> 01:46:56,780
一个进程包含多个线程

1388
01:46:56,780 --> 01:46:58,860
一个线程包含多个协程

1389
01:46:58,860 --> 01:47:00,140
就这么一个关系

1390
01:47:00,140 --> 01:47:03,920
那一個包含一個,那意味著力度在越來越小

1391
01:47:03,920 --> 01:47:07,760
力度越來越小,意味著對它管理的開銷就越來越小

1392
01:47:07,760 --> 01:47:09,600
基本這麼一個概念

1393
01:47:09,600 --> 01:47:12,080
我當然希望管理的開銷越小越好

1394
01:47:12,080 --> 01:47:15,720
這樣我可以讓這個處理器把更多的時間

1395
01:47:15,720 --> 01:47:18,320
用在實際的有效的一些計算上面

1396
01:47:18,920 --> 01:47:22,960
所以我們會講這個進程、現程、斜程

1397
01:47:22,960 --> 01:47:26,400
它們的對應,它們的機制有什麼樣的相同不同地方

1398
01:47:26,400 --> 01:47:27,520
它們的關係是什麼

1399
01:47:27,520 --> 01:47:30,680
这次我们讲这个并发YS的时候,我会涉及到内容

1400
01:47:31,840 --> 01:47:33,460
刚才已经讲到了,会涉及到

1401
01:47:33,460 --> 01:47:36,340
由于你这个有同步物质机制解决并发问题

1402
01:47:36,340 --> 01:47:37,260
可以涉及出来

1403
01:47:37,260 --> 01:47:39,100
但其实如果涉及不当的话

1404
01:47:39,100 --> 01:47:42,080
还有一个问题就是出楼怎么办

1405
01:47:42,080 --> 01:47:44,280
死锁怎么办

1406
01:47:44,280 --> 01:47:46,000
lock,死锁,deadlock

1407
01:47:46,660 --> 01:47:48,160
不是locks,deadlock

1408
01:47:48,160 --> 01:47:50,060
就是打卡那怎么办

1409
01:47:50,060 --> 01:47:52,000
那就是要解决死锁问题

1410
01:47:52,000 --> 01:47:55,540
除了并发问题之外,还解决死锁一系列的问题

1411
01:47:55,540 --> 01:47:58,920
这些问题是在并发OS里面要讲的内容

1412
01:47:58,920 --> 01:48:01,560
那这一块看到发了两部分

1413
01:48:01,560 --> 01:48:05,500
一部分是关于控制流的一个管理问题

1414
01:48:06,060 --> 01:48:08,280
就是协程、现程、进程

1415
01:48:08,280 --> 01:48:11,620
一个是多个控制流之间的协作问题

1416
01:48:11,620 --> 01:48:14,540
这是所谓的同步互斥

1417
01:48:14,540 --> 01:48:16,860
以及同步互斥可能带来的一些bug

1418
01:48:16,860 --> 01:48:18,620
这是我们要去了解的

1419
01:48:19,620 --> 01:48:21,020
这一块也是我们的一个难点

1420
01:48:21,020 --> 01:48:21,820
这是一个难点

1421
01:48:23,060 --> 01:48:28,800
最后一块其实也挺难的,叫做管理各种设备,因为设备千叉万变,由

1422
01:48:28,800 --> 01:48:36,140
于有各种千叉万变的设备,使得我们可以开发出各种漂亮的程序,可以

1423
01:48:36,140 --> 01:48:43,920
用来看视频,可以用来玩游戏,等等一系列的一些事情,都是由于我们有丰富

1424
01:48:43,920 --> 01:48:44,880
的外设造成。

1425
01:48:45,280 --> 01:48:50,080
如果我们的OS只有存储,只有键盘鼠标,那也是一个比较枯燥的OS。

1426
01:48:50,280 --> 01:48:54,920
这也是为什么大家一直觉得OS课,很多人觉得OS课不够漂亮,

1427
01:48:55,060 --> 01:48:58,540
都愿意学人机交互,就在于它不够漂亮,确实不够漂亮。

1428
01:48:59,760 --> 01:49:06,580
所以我们也希望我们的同学能够,这一张的更多的是一种介绍。

1429
01:49:07,740 --> 01:49:11,260
我说的介绍在动手方面是介绍,但我们也希望同学去动手,去实现一个

1430
01:49:11,260 --> 01:49:12,820
小的图形界面的游戏,

1431
01:49:12,820 --> 01:49:15,540
能够把我们的OS搞得更加丰富多彩一点

1432
01:49:15,880 --> 01:49:17,440
这个其实有同学已经做了

1433
01:49:19,440 --> 01:49:20,760
不是我们系的同学

1434
01:49:20,760 --> 01:49:23,260
不是我们校的同学

1435
01:49:23,260 --> 01:49:25,500
我们当时参加那个OS比赛的时候

1436
01:49:25,500 --> 01:49:28,900
有一个北游的同学就做了这么一个事情

1437
01:49:28,900 --> 01:49:30,480
他开发了一个贪吃蛇

1438
01:49:31,400 --> 01:49:32,820
贪吃蛇大家都听过这个游戏

1439
01:49:33,660 --> 01:49:34,900
那个蛇在吃球

1440
01:49:34,900 --> 01:49:36,440
然后吃了自己就完蛋了

1441
01:49:36,440 --> 01:49:37,640
吃了球就越来越长

1442
01:49:37,640 --> 01:49:39,120
就这么一个小游戏

1443
01:49:39,120 --> 01:49:42,700
然后它就涉及到了显存

1444
01:49:42,700 --> 01:49:44,220
显示的一个处理

1445
01:49:44,220 --> 01:49:45,580
图形 镜面的处理

1446
01:49:45,580 --> 01:49:47,200
对鼠标的处理等等

1447
01:49:47,200 --> 01:49:49,280
这是在我们现在这个OS里面

1448
01:49:49,280 --> 01:49:50,600
都没有涉及到的东西

1449
01:49:50,600 --> 01:49:51,720
做这个事情之后

1450
01:49:51,720 --> 01:49:53,180
就对各种设备支持之后

1451
01:49:53,180 --> 01:49:54,980
就可以看到这种内容

1452
01:49:54,980 --> 01:49:57,260
这是实践内容的一个考虑

1453
01:49:57,260 --> 01:49:58,580
第二个考虑就是

1454
01:49:58,580 --> 01:50:00,460
这个Io设备的交互问题

1455
01:50:00,460 --> 01:50:02,240
我们的CPU和我们的Io设备

1456
01:50:02,240 --> 01:50:04,000
怎么进行交互有效

1457
01:50:04,000 --> 01:50:06,280
就会涉及到一些执行模型

1458
01:50:06,780 --> 01:50:11,600
我记得主持人也都讲过,有基于轮循的、有基于冬段的、有基于

1459
01:50:11,600 --> 01:50:17,700
DMA的等等这种操作,这是在应验层面上能看得到的东西。

1460
01:50:17,860 --> 01:50:24,660
但是在更高层面上来说,还有一个同步亦步的操作过程。大家要注意,这里面

1461
01:50:24,660 --> 01:50:30,400
又出现了一次亦步,这个亦步和我们刚才讲操作系统的一个特征,亦步

1462
01:50:30,400 --> 01:50:32,980
的那个特征有相关性但是不一样。

1463
01:54:04,120 --> 01:54:09,000
这再说一下,这七周完成基础实验,然后与老师协商选择扩展实验来

1464
01:54:09,000 --> 01:54:10,080
代替考试。

1465
01:54:10,280 --> 01:54:14,440
越早完成基础实验,就可以越早开展基础实验,所以说你建议不要等到七

1466
01:54:14,440 --> 01:54:14,580
周。

1467
01:54:15,080 --> 01:54:19,340
因为万一你七周check没check过,你还要参加第八周的七中考试,那比

1468
01:54:19,340 --> 01:54:19,900
较紧张。

1469
01:54:20,020 --> 01:54:25,540
所以我建议你早点完成,早点被check过,然后你就可以早点就不用去七中考试

1470
01:54:25,540 --> 01:54:25,980
了。

1471
01:55:26,400 --> 01:55:28,660
发现我们是两门课

1472
01:55:28,660 --> 01:55:30,740
Commandos一门课 OS一门课

1473
01:55:30,740 --> 01:55:33,860
但其实Commandos有很多的联系

1474
01:55:33,860 --> 01:55:36,440
包括组成原理都是一样的

1475
01:55:36,440 --> 01:55:37,920
我们这门课讲课之后

1476
01:55:37,920 --> 01:55:40,480
其实组成原理和OS之间

1477
01:55:40,480 --> 01:55:42,000
相互之间都会有一些

1478
01:55:42,000 --> 01:55:43,160
相互之间的一些介绍

1479
01:55:43,160 --> 01:55:45,840
比如我要介绍组成原理一些知识

1480
01:55:45,840 --> 01:55:48,520
组成原理老师要介绍一些OS的知识

1481
01:55:48,520 --> 01:55:50,120
这种结合是比较紧偶合的

1482
01:55:50,620 --> 01:55:52,360
但是BAE和OS好像介绍的比较少

1483
01:55:52,360 --> 01:55:53,940
正好我也上了BAE的课

1484
01:55:53,940 --> 01:55:57,440
我能体会到它和OS的关系不大

1485
01:55:57,440 --> 01:56:00,340
但是当你上OS课的时候

1486
01:56:00,860 --> 01:56:02,180
你就要去理解一下

1487
01:56:02,640 --> 01:56:05,480
其实编译和OS之间也有千丝万缕的联系

1488
01:56:05,480 --> 01:56:07,960
而这种联系是一种影视的联系

1489
01:56:07,960 --> 01:56:10,220
也意味着你开发应用程序的时候你感觉不到

1490
01:56:10,220 --> 01:56:11,860
但是你要写OS的时候

1491
01:56:11,860 --> 01:56:13,180
你看到Compiler的时候也感觉不到

1492
01:56:13,180 --> 01:56:14,840
就我们现在的Compiler实验

1493
01:56:15,960 --> 01:56:17,460
仅仅是写到汇边

1494
01:56:17,940 --> 01:56:19,360
并没有再往后坐

1495
01:56:19,360 --> 01:56:21,080
并没有生成执行程序

1496
01:56:21,080 --> 01:56:23,380
所以后面还有一部分内容

1497
01:56:23,380 --> 01:56:26,580
其实跟Compiler相关的,你们没有涉及到

1498
01:56:26,580 --> 01:56:28,920
课程内容也没有讲到,只是提了几句

1499
01:56:28,920 --> 01:56:31,440
但你要做OS的时候,你会发现

1500
01:56:31,440 --> 01:56:34,700
你对Compiler的理解需要更多一点

1501
01:56:34,700 --> 01:56:37,220
这个多不是在于它那个翻译的过程

1502
01:56:37,220 --> 01:56:40,460
而在于它怎么和OS打交道的过程

1503
01:56:40,880 --> 01:56:44,360
就Compiler和OS之间有一些隐式的协议

1504
01:56:44,360 --> 01:56:46,780
有了这个协议之后,才能够让我们的

1505
01:56:46,780 --> 01:56:49,200
应用程序更好地在我们的机器上运行

1506
01:56:49,200 --> 01:56:53,480
OK 这就是为什么要讲这一节的一个原因

1507
01:56:55,300 --> 01:56:58,480
首先看一下 卡玛拉OS它面对的是什么 面对的是硬件

1508
01:56:58,480 --> 01:57:02,540
卡玛拉要把一段高级代码变成一个针对某个硬件的一个执行码

1509
01:57:02,540 --> 01:57:03,540
的一段程序

1510
01:57:03,540 --> 01:57:04,720
这是卡玛拉干的事情

1511
01:57:04,720 --> 01:57:08,240
那OS干的事情 接下来要把这个程序给跑起来

1512
01:57:08,240 --> 01:57:12,800
这是OS干的事情 所以它们俩之间是先后的一个依赖关系

1513
01:57:12,800 --> 01:57:14,320
你必须要生成一个程序 我才能跑

1514
01:57:15,380 --> 01:57:18,980
这是这一个 第二个 它们有共性的东西 它要应对这个硬件

1515
01:57:19,200 --> 01:57:24,080
只是它们应对应验的方式不一样,Compiler干的事情就是我要把高级原

1516
01:57:24,080 --> 01:57:29,980
生的这个机器码用,OS是要把这个机器给用起来,来管理这些执行

1517
01:57:29,980 --> 01:57:30,740
的程序。

1518
01:57:32,200 --> 01:57:40,480
我们开发在哪儿开发?基本上在舱楼上开发。但是我们的目标,就是我们要跑

1519
01:57:40,480 --> 01:57:44,840
的这个程序,你Compiler生成的那个程序,包括我们OS要跑的程序,是在RISC-V上。

1520
01:57:44,840 --> 01:57:49,020
所以你的开发环境和你的目标环境是不一样的

1521
01:57:49,020 --> 01:57:51,700
这意味着我们要去知道一套所谓的交叉

1522
01:57:52,680 --> 01:57:56,100
交叉编译的一套开发工具要会使用

1523
01:57:56,100 --> 01:57:58,920
其实我们Compiler那边课学的那个

1524
01:57:58,920 --> 01:58:02,220
就是编译原理学的那边课做的实验

1525
01:58:02,220 --> 01:58:04,500
就是一个交叉编译器

1526
01:58:04,500 --> 01:58:08,160
就是你跑在W上 但你生成的代码是生成的

1527
01:58:08,160 --> 01:58:09,240
针对Risk V的代码

1528
01:58:11,040 --> 01:58:13,300
那编译器开始动作 我们OS

1529
01:59:13,300 --> 01:59:16,540
如果我们有文件变成一个执行文件

1530
01:59:17,120 --> 01:59:19,080
这个你们要去制造个过程

1531
01:59:19,080 --> 01:59:21,660
才能更好地理解OS怎么执行的

1532
01:59:21,660 --> 01:59:23,300
以及OS怎么去加载程序执行

1533
01:59:25,400 --> 01:59:30,820
那OS在我们的编辑帮助我们干了那么多事情之后

1534
01:59:30,820 --> 01:59:33,320
我们OS就要去把这个执行程序给刨起来

1535
01:59:33,320 --> 01:59:35,660
所以OS干的事情是什么 加载执行管理

1536
01:59:36,740 --> 01:59:38,360
既然你要把这个执行程序刨起来

1537
01:59:38,360 --> 01:59:39,380
很明显的一点就是

1538
01:59:39,920 --> 01:59:47,440
Compiler通过Assembler还有Linker得到的执行程序,它里面的文件里

1539
01:59:47,440 --> 01:59:50,100
面到底有什么样的内容,我们OS首先要感知。

1540
01:59:50,440 --> 01:59:56,780
这个感知就在于他们建立好的协议,我的自我生成执行程序里面的一些

1541
01:59:56,780 --> 02:00:03,180
细节,我OS能够理解,我知道这里面到底哪些是代码,哪些是数据,这个至少

1542
02:00:03,180 --> 02:00:06,760
要知道,这些信息都是需要我们去理解的。

1543
02:00:06,760 --> 02:00:10,120
那我们的Compiler是按照某种规则生成这个执行程序

1544
02:00:10,120 --> 02:00:13,240
那我们的OS呢 基于某种规则把这个程序给读进来

1545
02:00:13,240 --> 02:00:15,980
读到哪儿去 读到我们的Memory中去

1546
02:00:15,980 --> 02:00:18,740
让它去执行 这是要干的事情

1547
02:00:20,040 --> 02:00:20,360
然后

1548
02:00:24,540 --> 02:00:26,580
这是一步啊 这是一步

1549
02:00:26,580 --> 02:00:29,200
但是还有一个问题 什么问题呢

1550
02:00:30,320 --> 02:00:33,720
OS自身其实也是一个被Compiler编辑出来的执行程序

1551
02:01:06,940 --> 02:01:13,960
对 总要有一个东西是不是靠Compiler生成的

1552
02:01:13,960 --> 02:01:18,140
它一定有一段代码 那个代码就是一段机器码固化在某个地方

1553
02:01:18,880 --> 02:01:20,340
来加载这个Bootloader

1554
02:01:20,340 --> 02:01:23,980
因为这Bootloader也是一个 比如说用C写的一段代码

1555
02:01:23,980 --> 02:01:25,960
所以那个东西在哪 我们后面会讲到

1556
02:01:25,960 --> 02:01:30,100
总之Bootloader带在OS 还有一个东西来加载Bootloader

1557
02:01:30,100 --> 02:01:31,720
这是一层一层加载

1558
02:01:33,400 --> 02:01:41,060
我们大致把生成程序和执行程序给大家做了个非常简单的介绍

1559
02:01:41,060 --> 02:01:47,920
接下来我们看一看为什么前面讲到OS能够理解Compiler生成的执行

1560
02:01:47,920 --> 02:01:48,800
程序

1561
02:01:48,800 --> 02:01:51,700
是在于首先我们要理解的Compiler的一个组成

1562
02:01:51,700 --> 02:01:59,120
前面讲到的编译器

1563
02:01:59,120 --> 02:02:01,000
编辑器 我们现在不是用大家写

1564
02:02:01,000 --> 02:02:04,280
是用一个工业级的GCC

1565
02:02:04,280 --> 02:02:05,680
主动是以C为例的

1566
02:02:05,680 --> 02:02:08,120
把他们这是GCC的一个程序来看的话

1567
02:02:08,120 --> 02:02:09,180
不是 这不是谁

1568
02:02:09,720 --> 02:02:11,000
这是Rust

1569
02:02:12,540 --> 02:02:12,980
好吧

1570
02:02:13,940 --> 02:02:15,560
Rust和C是一样的

1571
02:02:15,560 --> 02:02:18,120
他们生成的执行码都是一种执行码

1572
02:02:19,480 --> 02:02:21,840
就是叫做elf这种执行码

1573
02:02:22,580 --> 02:02:24,640
就是elf是一个缩写

1574
02:02:24,640 --> 02:02:27,180
excusable and linkable format

1575
02:02:27,620 --> 02:02:31,600
就是Linux上的程序基本上都是Elf格式的聲音程序

1576
02:02:31,600 --> 02:02:34,280
那麼這種程序是我們的編輯通過

1577
02:02:34,280 --> 02:02:37,020
Compiler、Assembler和Linker

1578
02:02:37,020 --> 02:02:39,340
最後得到的一個程序 就是這麼一個程序

1579
02:02:39,340 --> 02:02:41,960
那這個程序裡面呢 你看到這個編輯器而言

1580
02:02:41,960 --> 02:02:43,020
它給它分三部分

1581
02:02:43,500 --> 02:02:45,040
這個 它這個名字裡面有三部分

1582
02:02:45,040 --> 02:02:47,420
有一個CPU、廠商和超級統

1583
02:02:47,420 --> 02:02:49,580
其實你看那個GSC也是一樣的

1584
02:02:49,580 --> 02:02:51,440
就是你到底是針對聲稱的哪一種CPU

1585
02:02:51,440 --> 02:02:52,940
比如這裡面寫了一個

1586
02:02:52,940 --> 02:02:56,820
Risk 5 RISCV64GC就是针对这么一个

1587
02:02:57,840 --> 02:03:01,320
Risk 5的处理器生成这么一个指令集

1588
02:03:01,660 --> 02:03:04,420
然后厂商上Unknown就是不属于哪个厂商

1589
02:03:04,420 --> 02:03:07,460
然后超级统计是Linux和Gnue放在一起

1590
02:03:07,460 --> 02:03:09,080
为什么要把这个Gnue放在一起呢

1591
02:03:09,080 --> 02:03:11,160
是在于Linux代表Kernel

1592
02:03:11,160 --> 02:03:12,940
Gnue代表是Libc

1593
02:03:14,000 --> 02:03:14,320
它需要

1594
02:03:14,320 --> 02:03:16,340
它假定是开发是应用程序是Libc

1595
02:03:16,340 --> 02:03:18,800
但你看了下一个就不一样

1596
02:03:18,800 --> 02:03:20,740
这里面的这个Unknown代表厂商

1597
02:03:20,740 --> 02:03:22,860
不管是哪个就等于是没有一个具体的厂商

1598
02:03:22,860 --> 02:03:25,000
但它后面是LARM和ELF

1599
02:03:25,000 --> 02:03:26,860
这一个什么呢

1600
02:03:27,480 --> 02:03:31,700
它生成的这个程序不依赖于某个OS

1601
02:03:31,700 --> 02:03:33,880
这个生成程序实际上说生成的是一个

1602
02:03:33,880 --> 02:03:37,840
可以在联系上跑的基于GNU libc的一个应用程序

1603
02:03:37,840 --> 02:03:40,140
但这想说明的是什么呢

1604
02:03:40,140 --> 02:03:41,520
它生成可以生成逻辑程序

1605
02:03:41,900 --> 02:03:44,220
它也不需要有酷

1606
02:03:44,220 --> 02:03:46,860
ELF实际上只是执行程序的格式而已

1607
02:03:47,440 --> 02:03:48,400
它没有酷也可以

1608
02:03:49,920 --> 02:03:51,120
所以一般情况下

1609
02:03:51,120 --> 02:03:56,380
我们就可以应该选择这种后缀的这种交叉变异工具来帮助我们来生

1610
02:03:56,380 --> 02:03:56,840
成OS

1611
02:03:57,480 --> 02:03:59,620
这是一个简单的介绍

1612
02:03:59,620 --> 02:04:01,980
因为我们要生成的不是应用程序

1613
02:04:01,980 --> 02:04:04,120
我们要写什么 写逻辑程序

1614
02:04:06,220 --> 02:04:10,460
那elf格式其实是有这么一个看到一个图

1615
02:04:10,460 --> 02:04:12,480
这个elf格式我现在不会细讲

1616
02:04:12,480 --> 02:04:13,640
大家可以看得出来

1617
02:04:13,640 --> 02:04:15,040
它有一个format

1618
02:04:15,040 --> 02:04:16,380
就是跟数学结构一样

1619
02:04:16,380 --> 02:04:18,480
它有一个格式就是一个头

1620
02:04:18,480 --> 02:04:21,240
后面有各个Section

1621
02:04:22,360 --> 02:04:24,880
这个Section代表什么 比如说代码段数据段

1622
02:04:24,880 --> 02:04:26,000
那么这个头干什么呢

1623
02:04:26,000 --> 02:04:27,740
描述这个代码段数据段在什么地方

1624
02:04:27,740 --> 02:04:29,740
就这么一个文件

1625
02:04:30,300 --> 02:04:31,320
那么我们能够把

1626
02:04:31,320 --> 02:04:33,880
我们OS在要执行这个应用程序的时候

1627
02:04:33,880 --> 02:04:35,980
它会把这个Elf格式的头给补出来

1628
02:04:35,980 --> 02:04:39,720
然后从而可以识别出这个应用程序的

1629
02:04:39,720 --> 02:04:41,140
代码段数据段在什么地方

1630
02:04:41,140 --> 02:04:43,920
以及它应该放到虚存的哪个地址

1631
02:04:43,920 --> 02:04:44,980
然后就把它放进去了

1632
02:04:44,980 --> 02:04:47,200
这就是我们说为什么这里面的一个Section

1633
02:04:54,120 --> 02:04:57,340
要把這個程序放到內存空間去執行之後

1634
02:04:57,340 --> 02:04:59,060
它要放到一個地方

1635
02:04:59,060 --> 02:05:03,220
比如說把section放到某一塊的segment裡面

1636
02:05:03,220 --> 02:05:04,420
這是一個對應關係

1637
02:05:04,420 --> 02:05:06,980
你可以把這個理解為一個內存空間

1638
02:05:06,980 --> 02:05:10,560
這個理解為這個文件上的一塊數據

1639
02:05:10,560 --> 02:05:14,000
那我們的OS就要把文件上的這段數據

1640
02:05:14,000 --> 02:05:15,420
放到內存空間裡面去

1641
02:05:15,420 --> 02:05:17,180
這是大致的一個

1642
02:07:17,460 --> 02:07:20,660
因为他们底层都是不一样

1643
02:07:20,660 --> 02:07:22,300
但是Rust比较好

1644
02:07:22,300 --> 02:07:24,240
因为它只有一个call的一个code

1645
02:07:24,240 --> 02:07:29,180
你就可以比较容易的去实现在不同的OS里面

1646
02:07:32,660 --> 02:07:34,660
接下来讲的是这个

1647
02:07:34,660 --> 02:07:36,320
我们要写这个程序怎么写

1648
02:07:36,320 --> 02:07:39,660
当然接下来我可能是以Rust来讲的

1649
02:07:39,660 --> 02:07:43,180
但是C我觉得是更简单

1650
02:07:43,180 --> 02:07:43,980
什么叫更简单

1651
02:08:44,880 --> 02:08:49,460
也非常简单 就这么多就可以生成一个空的

1652
02:08:49,460 --> 02:08:52,380
实际上它也没干的一个 啥也执行不了的

1653
02:08:52,380 --> 02:08:54,700
一个通过编辑器的一个程序

1654
02:08:55,020 --> 02:08:56,940
这是Diameter的Program

1655
02:08:56,940 --> 02:08:58,720
它这里面连显示都没有

1656
02:08:58,720 --> 02:09:00,380
那生成之后是一个空文件

1657
02:09:00,380 --> 02:09:03,200
我们如果用一些工具去查它的话

1658
02:09:03,200 --> 02:09:05,240
有关于这个文件里面的执行代码是空的

1659
02:09:05,240 --> 02:09:07,120
啥也没有 它只是通过了编辑检查

1660
02:09:08,700 --> 02:09:09,980
这是这一块

1661
02:09:11,340 --> 02:09:12,820
那即使通过了编辑检查

1662
02:09:12,820 --> 02:09:14,960
它这个 虽然说我们写的是kernel

1663
02:09:14,960 --> 02:09:17,400
但它的格式还是elf格式

1664
02:09:17,400 --> 02:09:18,740
就跟刚才说的一样

1665
02:09:18,740 --> 02:09:21,380
你看到这里面 它有一个elf的头

1666
02:09:21,380 --> 02:09:23,580
它有代码段 有数据段

1667
02:09:23,580 --> 02:09:25,880
所以一旦这里面有内容之后呢

1668
02:09:25,880 --> 02:09:29,440
我们的 如果它是os的话

1669
02:09:29,440 --> 02:09:32,140
那应该由bootloader把它加到内存里面去

1670
02:09:32,140 --> 02:09:33,300
如果是应用程序的话

1671
02:09:33,300 --> 02:09:35,980
应该由os读这个elf加到内存里面去

1672
02:09:36,820 --> 02:09:38,380
但是 还有一种情况是什么呢

1673
02:09:38,380 --> 02:09:40,040
我们的bootloader其实没有那么强大

1674
02:09:40,040 --> 02:09:41,980
不需要写那么强大的elf解析

1675
02:09:41,980 --> 02:09:44,140
對愛虎文件格式的解析,那它怎麼做呢?

1676
02:09:45,620 --> 02:09:49,100
我們還有一種工具,會把這個Elf格式的執行程序

1677
02:09:49,100 --> 02:09:51,320
把它變成所謂的Binary image程序

1678
02:09:51,740 --> 02:09:54,240
就是把這些所有的信息都去掉,只留下什麼呢?

1679
02:09:54,280 --> 02:09:55,780
只留下Text段、Data段

1680
02:09:57,960 --> 02:10:01,180
存的剛貨,就只有這個代碼和數據

1681
02:10:02,160 --> 02:10:05,160
然後有了這個之後呢,那我們的Bootloader呢

1682
02:10:05,160 --> 02:10:09,760
只需把這一塊數據給丟到內存的某個定死的地方

1683
02:10:09,760 --> 02:10:11,480
它也沒法解析,它也不知道要放哪

1684
02:10:11,480 --> 02:10:13,640
但是我们约定好了 我们跟波特罗特说好了

1685
02:10:13,640 --> 02:10:16,360
里面放到0x8后面7个0的地方

1686
02:10:16,360 --> 02:10:18,060
只要放到这个地方的话

1687
02:10:18,060 --> 02:10:20,460
我接下来跳上去执行就OK了

1688
02:10:20,460 --> 02:10:21,980
这么一约定那就OK了

1689
02:10:21,980 --> 02:10:23,420
我可以写出这么一个

1690
02:10:23,420 --> 02:10:28,200
可以生成出这么一个所谓的Binary格式的文件

1691
02:10:28,200 --> 02:10:29,340
让波特罗特加载

1692
02:10:31,420 --> 02:10:35,380
这是能够简化对OS的加载过程

1693
02:10:35,380 --> 02:10:39,060
包括OS加载用这些也是可以采取各种方法来做

1694
02:10:39,060 --> 02:10:41,980
我们发现在前面的OS实验中

1695
02:10:41,980 --> 02:10:46,640
我们也是把应用程序从App格式转换成了所谓的Binary格式

1696
02:10:46,640 --> 02:10:49,300
让我们的OS直接加以到内存的某个地方

1697
02:10:49,300 --> 02:10:51,520
并没有去做这个App的解析

1698
02:10:52,160 --> 02:10:54,060
那我们如果要看这个App的信息的话

1699
02:10:54,060 --> 02:10:57,340
其实你用一些东西 比如Rust Read Objects等等就可以看着

1700
02:10:57,340 --> 02:11:00,620
我现在讲它稍微有点快了 但我觉得也OK

1701
02:11:01,280 --> 02:11:04,440
因为这个更多的是大家去了解它

1702
02:11:04,440 --> 02:11:05,800
不是光听完就够了

1703
02:11:05,800 --> 02:11:09,000
你们最后还是希望能够去动手实践一下

1704
02:11:09,000 --> 02:11:10,600
这样可能会更好一点

1705
02:11:11,440 --> 02:11:12,920
包括我们的实验指导

1706
02:11:12,920 --> 02:11:13,980
都有相应的一些操作

1707
02:11:13,980 --> 02:11:14,760
大家可以看看

1708
02:11:15,660 --> 02:11:17,660
这也是讲的是生成类空程序

1709
02:11:17,660 --> 02:11:18,800
就刚刚说的空程序

1710
02:11:19,800 --> 02:11:20,160
好

1711
02:11:20,160 --> 02:11:23,980
但是我们最终是要把这个OS能够刨起来

1712
02:11:23,980 --> 02:11:25,260
或者应用刨起来

1713
02:11:25,260 --> 02:11:26,580
无论是OS和应用刨起来

1714
02:11:26,580 --> 02:11:27,360
你会发现

1715
02:11:29,220 --> 02:11:31,380
这在我们编译课讲过的

1716
02:11:31,380 --> 02:11:33,780
就是你需要一个对它的所谓的

1717
02:13:03,920 --> 02:13:07,700
那么HIP这一块跟我们的卡盘上没关系

1718
02:13:07,700 --> 02:13:10,040
HIP是靠我们的超线组来管理的

1719
02:13:10,040 --> 02:13:12,920
超线组靠我们的应用程序调Metal和Free

1720
02:13:12,920 --> 02:13:15,400
靠我们的酷和OS的一个配合

1721
02:13:15,400 --> 02:13:18,220
Libc的酷和OS的配合或者RUSSE酷

1722
02:13:18,220 --> 02:13:21,640
来完成对空间的管理

1723
02:13:21,640 --> 02:13:23,920
这是一个情况

1724
02:13:23,920 --> 02:13:25,560
接下来的问题就来了

1725
02:13:25,560 --> 02:13:27,160
我现在说的是

1726
02:13:27,160 --> 02:13:30,280
这个Stack是OS把我们去生成的

1727
02:13:30,280 --> 02:13:31,460
那我OS也是个程序

1728
02:15:01,460 --> 02:15:02,260
软件执行

1729
02:15:04,900 --> 02:15:05,960
这应该

1730
02:15:06,900 --> 02:15:08,360
我应该在下课前能讲完

1731
02:15:09,920 --> 02:15:10,840
硬件启动

1732
02:15:10,840 --> 02:15:11,860
软件执行

1733
02:15:13,280 --> 02:15:14,780
首先看一下硬件

1734
02:15:14,780 --> 02:15:19,260
这个硬件是目前最高端的Risk 564的一个处理器

1735
02:15:20,580 --> 02:15:22,020
是Ci5

1736
02:15:22,020 --> 02:15:23,740
Ci5就是那个Brockley

1737
02:15:23,740 --> 02:15:25,380
那老师出来创业

1738
02:15:25,380 --> 02:15:27,160
然后创立了这么一个公司

1739
02:15:27,160 --> 02:15:27,880
做他的机器

1740
02:15:27,880 --> 02:15:30,320
我们买了十几台发觉他就是一台PC

1741
02:16:00,400 --> 02:16:05,640
差别太大。虽然这么大,这个没有吹它是人工智能的什么版子,但这个吹它

1742
02:16:05,640 --> 02:16:07,620
是人工智能的版子。

1743
02:16:08,280 --> 02:16:15,740
他里面带了一个叫做TPU,在这种情况下他带了TPU,还100块钱。国

1744
02:16:15,740 --> 02:16:21,320
内深圳的一个小公司做的叫SIPED,这名公司做的。

1745
02:16:21,920 --> 02:16:25,640
这也是我们这两年超级龙比赛的指定的硬件开发版

1746
02:16:26,460 --> 02:16:28,320
虽然小它有双核

1747
02:16:29,140 --> 02:16:31,760
而且比较有硬件有bug

1748
02:16:31,760 --> 02:16:33,780
硬件有bug是靠的是BIOS

1749
02:16:33,780 --> 02:16:37,320
就是我靠的bootloader帮它把bug给它屏蔽掉

1750
02:16:37,320 --> 02:16:40,000
然后OS才能够正常的work

1751
02:16:41,220 --> 02:16:44,020
这就是我们前面的一些同学做的一些工作

1752
02:16:44,560 --> 02:16:46,320
方便OS的开发

1753
02:16:48,560 --> 02:16:49,840
这是一个物理硬件

1754
02:16:49,840 --> 02:16:56,380
当然基于物理零件,这是在2018年和2021年开发出来的板子

1755
02:16:56,380 --> 02:17:02,180
那这是一个也是去年底出现的那个板子叫Nezar D1

1756
02:17:02,840 --> 02:17:08,660
这是一个稍微大点的公司,叫国内的全制公司出的一个处理器

1757
02:17:08,660 --> 02:17:16,380
处理平板,它的处理器是基于阿里的平头哥C906这么一个处理器

1758
02:17:16,380 --> 02:17:18,140
来做的

1759
02:17:18,140 --> 02:17:20,820
所以处理器是来自于Ali

1760
02:17:20,820 --> 02:17:22,300
板子是来自于全智

1761
02:17:22,300 --> 02:17:24,120
那么我们已经有外校的同学

1762
02:17:24,120 --> 02:17:25,340
把我们的Arco tutorial

1763
02:17:25,340 --> 02:17:26,660
能够在那里跑起来

1764
02:17:26,660 --> 02:17:29,500
这是一个1.2G比较强的一个处理器

1765
02:17:29,500 --> 02:17:30,160
它有1.2G

1766
02:17:30,160 --> 02:17:31,780
而且内存也足够大

1767
02:17:31,780 --> 02:17:33,500
像这个只有8兆

1768
02:17:34,120 --> 02:17:36,220
这个可以有8个G

1769
02:17:36,220 --> 02:17:38,520
这个差别比较大

1770
02:17:38,940 --> 02:17:40,580
那那个呢

1771
02:17:40,580 --> 02:17:41,740
这个有16个G

1772
02:17:41,740 --> 02:17:43,300
所以这更强

1773
02:17:44,520 --> 02:17:46,280
那我们这些有兴趣的同学

1774
02:17:46,280 --> 02:17:49,280
可以找老师去看他们给你们配一个

1775
02:17:49,280 --> 02:17:51,420
但是大问同学我觉得是没兴趣的

1776
02:17:52,900 --> 02:17:55,040
所以你们就用模拟器就好

1777
02:17:55,040 --> 02:17:58,060
模拟器又方便 又不需要接电

1778
02:17:58,060 --> 02:17:59,860
直接QMeo 这样的一台机器

1779
02:17:59,860 --> 02:18:01,860
在笔记本就可以跑QMeo

1780
02:18:01,860 --> 02:18:04,600
我们用QMeo来做模拟一台64位的机器

1781
02:18:04,600 --> 02:18:07,560
它包含最基本的部分CPU

1782
02:18:08,580 --> 02:18:11,500
我们现在假定是一个 我们也是单处理器

1783
02:18:11,500 --> 02:18:13,940
一块物理内存大约128兆

1784
02:18:13,940 --> 02:18:17,620
若干Io设备 就一块storage一块存储

1785
02:18:18,360 --> 02:18:20,900
一个串口 没了

1786
02:18:20,900 --> 02:18:22,580
就存储串口就是它的设备

1787
02:18:22,580 --> 02:18:25,620
在这么简陋的情况下 我们就来完成我们的实验内容

1788
02:18:27,480 --> 02:18:29,140
那这里面它模拟的是什么机械

1789
02:18:29,140 --> 02:18:31,140
它模拟的是Virt的一个虚拟机

1790
02:18:31,140 --> 02:18:33,280
就是Virtual的一个机器

1791
02:18:33,280 --> 02:18:36,920
这个机器就是缺少的内存就是108兆

1792
02:18:38,180 --> 02:18:40,680
而且它可以不带投音界面

1793
02:18:40,680 --> 02:18:42,080
你加这个参数就不带

1794
02:18:42,080 --> 02:18:44,480
你要不加参数 它还可以自动弹一个图形界面

1795
02:18:45,840 --> 02:18:48,820
操作起来稍微麻烦点 我们全面演行方式

1796
02:18:48,820 --> 02:18:50,800
直接就加一个这个no-graphic

1797
02:18:50,800 --> 02:18:52,480
就把它图形界面给cancel掉

1798
02:18:53,580 --> 02:18:55,040
然后再接下来

1799
02:18:55,040 --> 02:18:56,760
那个bootloader它叫BIOS

1800
02:18:56,760 --> 02:18:58,640
差不多里面的 通常说叫

1801
02:18:59,800 --> 02:19:02,340
Basic IO System

1802
02:19:02,340 --> 02:19:04,720
那这一块就是BIOS这一块

1803
02:19:04,720 --> 02:19:05,960
就是我们说的bootloader

1804
02:19:05,960 --> 02:19:07,040
我们可以指定一个

1805
02:19:07,040 --> 02:19:12,160
这个是跑在Risk5的Machine Mode

1806
02:19:12,160 --> 02:19:13,820
这一块我们不需要设计

1807
02:19:13,820 --> 02:19:15,620
夹定已经写好了

1808
02:19:15,620 --> 02:19:17,000
你只要用它就行了

1809
02:19:17,000 --> 02:19:18,960
我们重点是后面这个OS

1810
02:19:18,960 --> 02:19:20,340
那这个设备跑在哪呢

1811
02:19:20,340 --> 02:19:22,000
跑在一个存储设备上

1812
02:19:22,000 --> 02:19:24,160
你看GUNDevice

1813
02:19:24,160 --> 02:19:25,600
这个loader就是说

1814
02:19:25,600 --> 02:19:26,580
我们的硬件

1815
02:19:26,580 --> 02:19:27,760
QML这个模拟器

1816
02:19:27,760 --> 02:19:29,740
会把你这个OS

1817
02:19:29,740 --> 02:19:30,800
OS.bin

1818
02:19:30,800 --> 02:19:31,800
什么叫OS.bin呢

1819
02:19:31,800 --> 02:19:34,220
就把这个ELF格式的OS

1820
02:19:34,220 --> 02:19:35,800
转变成了Binary格式的OS

1821
02:19:35,800 --> 02:19:38,880
然后把这个文件会加载到一个纸巾的内存

1822
02:19:38,880 --> 02:19:40,020
这个内存放哪里看

1823
02:19:40,020 --> 02:19:44,320
0x802 后面有5个0 这么一个地址

1824
02:19:44,320 --> 02:19:46,240
这一步就是干这么一个事情

1825
02:19:46,240 --> 02:19:50,640
File ADDR来表明了我们的OS的位置

1826
02:19:50,640 --> 02:19:54,680
和这个OS的这个文件和它对应的位置放哪里

1827
02:19:55,200 --> 02:19:57,560
那有了这些参数之后呢

1828
02:19:57,560 --> 02:19:58,320
有了这些参数之后呢

1829
02:19:58,320 --> 02:19:59,360
我们就可以把QML

1830
02:19:59,360 --> 02:20:01,320
这机器运行一下就代表启动了

1831
02:20:01,320 --> 02:20:02,080
就把机器启起来

1832
02:20:02,080 --> 02:20:05,280
这和刚才我跑那个SV6是一样的

1833
02:20:05,280 --> 02:20:08,520
比如说用MIC file给它简化一点,最后它也是这些命运,一堆命运。

1834
02:20:11,220 --> 02:20:16,000
那启动完之后,首先第一步是谁执行。

1835
02:20:17,140 --> 02:20:21,740
硬件启动完之后,你们都是做过组成员领课的这个实验的,里面号称

1836
02:20:21,740 --> 02:20:22,980
是造过CPU的。

1837
02:20:23,540 --> 02:20:24,780
这个CPU怎么执行的?

1838
02:20:25,680 --> 02:20:28,020
一开始一定有一个固定的地方吧,是吧。

1839
02:20:28,540 --> 02:20:31,660
这也是一样,它有一个固定的地方,就是QMU里面指定的一个地方,那个地方就

1840
02:20:31,660 --> 02:20:32,460
我们称之为固件。

1841
02:21:02,460 --> 02:21:05,680
固件跳到Bootloader,Bootloader跳到OS

1842
02:21:05,680 --> 02:21:09,260
然后OS完成数字化之后,可以启动应用去执行

1843
02:21:09,260 --> 02:21:11,000
比如说我们前面看到IIT等等

1844
02:21:11,000 --> 02:21:14,640
这是一个大致的一层一层的数字化的过程

1845
02:21:14,640 --> 02:21:17,160
但我们重点关注的是什么?关注OS的启动

1846
02:21:17,160 --> 02:21:20,140
和最后OS启动完之后怎么去启动应用

1847
02:21:20,140 --> 02:21:22,000
这是我们要去设计到的内容

1848
02:21:22,880 --> 02:21:25,140
那如果同学有兴趣的话可以看着

1849
02:21:25,140 --> 02:21:28,120
QMe模拟的计算机内存是什么一个布局

1850
02:21:28,120 --> 02:21:33,800
我这里面专门把这个QMeo5.0咱们的指定的这个QMeo模拟器

1851
02:21:33,800 --> 02:21:34,780
的代码

1852
02:21:34,780 --> 02:21:36,720
给打出来可以看着

1853
02:21:40,020 --> 02:21:42,280
这是它的内存布局

1854
02:21:42,280 --> 02:21:45,000
然后我们说的那个BIOS Founder放在这

1855
02:21:45,000 --> 02:21:48,740
你看Wort Machine Model Room就放在LX1000的地方

1856
02:21:48,740 --> 02:21:52,420
所以说你那个Rocked SPI或者说Over SPI

1857
02:21:52,420 --> 02:21:53,980
它就会超级懂得放在这个地方

1858
02:21:53,980 --> 02:21:56,400
那我们的OS Founder

1859
02:24:26,400 --> 02:24:27,640
就应该知道了

1860
02:24:28,160 --> 02:24:29,120
这还是很有特点的

1861
02:24:29,120 --> 02:24:30,760
AU IPC ADDI

1862
02:24:31,340 --> 02:24:33,120
还有CSRR等等

1863
02:24:38,040 --> 02:24:40,020
我这个就算

1864
02:24:40,540 --> 02:24:41,440
还有一分钟

1865
02:24:42,280 --> 02:24:43,600
我还要抓紧才行

1866
02:24:51,280 --> 02:24:52,540
好 下课

