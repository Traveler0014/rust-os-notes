1
00:00:51,640 --> 00:00:58,940
就是共享屏幕,还有那个个人头像

2
00:00:58,940 --> 00:00:59,980
嗯,这个是个人头像

3
00:01:00,920 --> 00:01:08,920
没问题,陈老师,我建议您可以把那个头像做成那个画中画,这样的话,我我这

4
00:01:08,920 --> 00:01:16,680
边转播可能,或者我还不太会,没事,没事,那就这样吧,关掉也行,其实也不一定非要

5
00:01:16,680 --> 00:01:22,420
有必要有头像,好吧,没事,那就这样吧,时间快到了啊,那没事,那我就把头像关掉,不用

6
00:01:22,420 --> 00:01:25,620
管,不用管,没事,不用管,嗯。

7
00:01:56,540 --> 00:01:59,680
好 9点50

8
00:01:59,680 --> 00:02:11,680
咱们开始上课,今天我们不光有咱们同学来,

9
00:02:11,760 --> 00:02:17,580
咱们也有一些老师过来一起来听课,也很难得咱们同学和老师一起

10
00:02:17,580 --> 00:02:18,000
来。

11
00:02:18,760 --> 00:02:25,240
如果在上课的过程中,同学和老师有问题,咱们可以随时交流。

12
00:02:25,240 --> 00:02:31,900
咱们现在因为有这个腾讯会议嘛,它这个聊天这个我觉得还挺好的一个功能,有这个

13
00:02:31,900 --> 00:02:40,640
聊天之后呢,我们某种程度上可以通过这个语音或者是文字的方式来

14
00:02:40,640 --> 00:02:45,760
进行交流,这挺好的,到时候在客观观众也会提一些小问题,也希望咱们同

15
00:02:45,760 --> 00:02:50,960
学能够通过腾讯会议的聊天呢,私信的方式或者是共享的方式

16
00:02:50,960 --> 00:02:54,180
都行,来发出你们的一些对问题的一些看法。

17
00:02:55,260 --> 00:02:59,920
好 那我们就开始讲课

18
00:02:59,920 --> 00:03:03,400
这是我们的第十讲 进程间通讯的第二节

19
00:03:03,400 --> 00:03:06,380
关于IPC OS 这是第一部分内容

20
00:03:06,380 --> 00:03:09,780
讲完这部分之后 我们还会讲一下下一个章节

21
00:03:09,780 --> 00:03:14,420
并发里面的关于线程 写程等一部分的知识

22
00:03:14,420 --> 00:03:18,180
这是我们今天的主要的上课内容

23
00:03:22,240 --> 00:03:28,620
在这一块我们是偏实验一点,在这个实验中我们会重点强大的是怎么去支持

24
00:03:28,620 --> 00:03:31,460
所谓的进程兼通讯的OS

25
00:03:31,840 --> 00:03:35,940
这其实我们之前已经设计了一系列的OS,大家可以看一看

26
00:03:35,940 --> 00:03:41,800
从最早的LibOS,我们说它达到的目标就是要给应用提供支持,让它

27
00:03:41,800 --> 00:03:44,500
和硬件隔离,这是简单的回顾一下

28
00:03:44,500 --> 00:03:46,860
然后再做到了P处理这个OS

29
00:03:48,160 --> 00:03:51,440
除了我们说的这个函数级的电用隔离之外

30
00:03:51,440 --> 00:03:53,020
便于简化编程之外

31
00:03:53,020 --> 00:03:55,000
我们还真正让它彻底的

32
00:03:55,000 --> 00:03:56,580
就是有个特权级这种概念

33
00:03:56,580 --> 00:03:59,540
从而可以使得应用程序不能直接访问特权指令

34
00:03:59,540 --> 00:04:02,180
这样进一步加强了OS的安全性

35
00:04:02,180 --> 00:04:05,180
然后通过所谓的多道程序设计

36
00:04:05,180 --> 00:04:07,980
或者是time sharing 就是分时共享这种机制

37
00:04:07,980 --> 00:04:09,140
我们实现了新的OS

38
00:04:09,140 --> 00:04:13,040
这个OS可以让多个应用

39
00:04:13,040 --> 00:04:14,860
可以来共享CPU的资源

40
00:04:14,860 --> 00:04:17,220
这样就让这个整体的系统利用率得到提升

41
00:04:18,280 --> 00:04:20,120
在后面我们又做到了说什么呢

42
00:04:20,780 --> 00:04:23,180
就是加上地址空间的一个隔离机制

43
00:04:23,180 --> 00:04:25,500
有了地址空间隔离之后呢

44
00:04:25,500 --> 00:04:27,020
我们的不同的应用之间

45
00:04:27,020 --> 00:04:29,660
它不能够随意的访问任意的地址

46
00:04:29,660 --> 00:04:34,720
它实际上它访问这个地址是限制在我们这个OS给它的一块区域之内

47
00:04:34,720 --> 00:04:36,980
这是我们说这个有了地址空间的OS

48
00:04:36,980 --> 00:04:38,280
在网上之后呢

49
00:04:38,280 --> 00:04:40,420
我们就把这个进程的概念抽象出来

50
00:04:40,420 --> 00:04:41,740
形成所谓的Process OS

51
00:04:43,620 --> 00:04:49,080
有了ProcessOS之后,我们会发现我们对CPU资源和其他资源的管理

52
00:04:49,080 --> 00:04:50,660
稍微做了一个分割

53
00:04:50,660 --> 00:04:58,800
CPU这一块更多是以所谓任务的形式来进行切换、调度等等

54
00:04:58,800 --> 00:05:05,040
资源这一块你会发现它多了很多,包括我们后续讲的文件系统,文件

55
00:05:05,040 --> 00:05:05,800
成了一种资源

56
00:05:05,800 --> 00:05:08,680
我们这一堂课讲的这个IBC的机制

57
00:05:08,680 --> 00:05:11,840
比如说我们的管道 我们的信号都成了资源

58
00:05:11,840 --> 00:05:14,860
而这些资源都在我们的进程管理之下

59
00:05:14,860 --> 00:05:17,360
这里面专门也提出了所谓的文件系统

60
00:05:17,360 --> 00:05:20,520
这个文件系统最主要的一个作用就是

61
00:05:20,520 --> 00:05:23,580
让我们的程序 访问的数据

62
00:05:23,580 --> 00:05:25,840
可以持久地保存在一个存储介质上面

63
00:05:25,840 --> 00:05:27,780
比如说我们的块设备等等

64
00:05:27,780 --> 00:05:30,780
这是我们之前看到的这些

65
00:05:30,780 --> 00:05:33,500
就是我们的OS在不停地进化

66
00:05:33,500 --> 00:05:36,160
得到的一个展现

67
00:05:36,160 --> 00:05:38,160
但这个展现其实我们还会希望

68
00:05:38,160 --> 00:05:39,760
我们应用还提出更多的要求

69
00:05:39,760 --> 00:05:41,420
比如说在前面的这些

70
00:05:41,420 --> 00:05:42,880
虽然也支持了多个应用

71
00:05:42,880 --> 00:05:47,160
但这个应用它好像之间缺少一种互通

72
00:05:47,160 --> 00:05:48,460
我们强调了很多隔离

73
00:05:48,460 --> 00:05:50,620
你看这里面有特先级隔离

74
00:05:50,620 --> 00:05:53,680
这里面又实现了所谓的地址空间的隔离

75
00:05:53,680 --> 00:05:55,960
但是我们光有隔离还不够

76
00:05:55,960 --> 00:05:57,520
我们还需要交互

77
00:05:57,520 --> 00:05:59,840
这个交互就是我们这里面的

78
00:06:30,460 --> 00:06:32,220
它的范围也会更加广泛

79
00:06:32,220 --> 00:06:35,360
这就是我们说的Unix上面非常重要的一个设计哲学

80
00:06:35,360 --> 00:06:37,840
everything is fine 什么都是文件

81
00:06:38,540 --> 00:06:40,520
那有了文件之后就可以把它进行读写

82
00:06:40,520 --> 00:06:44,660
因为文件最主要的抽象特征就是可读可写

83
00:06:44,660 --> 00:06:46,320
那我们对这个pipe也是一样

84
00:06:46,320 --> 00:06:47,440
它有读写功能

85
00:06:47,440 --> 00:06:50,020
对SDDIN有所谓的输入

86
00:06:50,620 --> 00:06:51,440
读入功能

87
00:06:51,440 --> 00:06:53,360
SDDOUT有写出功能

88
00:06:53,360 --> 00:06:58,280
这就是我们说为了能够更好的知识境间交互

89
00:06:58,280 --> 00:06:59,760
我们扩展了文件抽象

90
00:07:00,900 --> 00:07:03,700
然后以文件的形式来进行各种各样的数据交换

91
00:07:03,700 --> 00:07:04,960
这是一种方式

92
00:07:04,960 --> 00:07:06,900
但是有些时候我们进程之间

93
00:07:06,900 --> 00:07:09,340
它可能不需要那么大量的数据交换

94
00:07:09,340 --> 00:07:11,100
它可能只是需要一种通知

95
00:07:11,100 --> 00:07:13,140
通知的效能及时响应

96
00:07:13,140 --> 00:07:14,960
这所谓的一部通知机制

97
00:07:14,960 --> 00:07:17,880
这里面我们用了信号这种机制来实现

98
00:07:17,880 --> 00:07:22,680
简单理解的信号就是一种所谓的叫做软件中段

99
00:07:22,680 --> 00:07:23,700
软中段

100
00:07:23,700 --> 00:07:24,720
它是对应什么呢

101
00:07:24,720 --> 00:07:25,520
对应了我们硬件

102
00:07:25,520 --> 00:07:26,400
我们说的Device

103
00:07:27,980 --> 00:07:31,520
比如说Timer,或者是串口,或者是Block device

104
00:07:31,520 --> 00:07:33,560
这些device都可以产生中的

105
00:07:33,560 --> 00:07:38,440
它可以义务地打断正在执行的应用程序或者超级统

106
00:07:38,440 --> 00:07:43,420
这个信号机制就是我们义务地打断当前正在运行的进程

107
00:07:43,420 --> 00:07:48,540
让它去执行对信号的通知响应机制

108
00:07:48,540 --> 00:07:49,800
所以在这里面我们看到

109
00:07:49,800 --> 00:07:52,480
为了能够支持这两种机制

110
00:07:52,480 --> 00:07:57,580
我们对OS进一步进化出来IOS做了扩展

111
00:07:57,580 --> 00:08:02,960
它的系统调用从前面的11个系统调用变到了17个

112
00:08:02,960 --> 00:08:05,620
这里面有四个信号相关

113
00:08:05,620 --> 00:08:08,020
两个是跟管道相关

114
00:08:08,020 --> 00:08:11,800
实际上就是我们说的发通知、传数据

115
00:08:11,800 --> 00:08:14,320
大致有这么相关的系统调用

116
00:08:14,320 --> 00:08:16,940
我们会看到后面我们会讲它怎么用

117
00:08:16,940 --> 00:08:19,280
以及怎么去设计和实现

118
00:08:19,280 --> 00:08:22,280
这是我们说这一节里面重点希望大家掌握的内容

119
00:08:23,560 --> 00:08:29,460
所以我们同学通过学习这一个章节需要理解这个文件抽象

120
00:08:29,460 --> 00:08:31,160
它已经不仅仅是文件了

121
00:08:31,160 --> 00:08:34,040
它的最主要的特征就是它读和写的能力

122
00:08:34,040 --> 00:08:36,340
可以进一步的特征到其他的一些领域

123
00:08:36,340 --> 00:08:39,500
第二个要去理解pipe signal怎么去实现

124
00:08:39,500 --> 00:08:44,100
我们同学不光会用也会去design

125
00:08:44,100 --> 00:08:47,000
就是你把这个机制给支持起来

126
00:08:47,000 --> 00:08:49,600
从而可以实现一个更完整的支持IBC的OS

127
00:08:49,600 --> 00:08:54,180
这就是画了一个早年的迅猛龙的图像

128
00:08:54,180 --> 00:08:55,860
在《侏罗纪世界》这个电影里面

129
00:08:55,860 --> 00:08:57,540
他们迅猛龙可以集中在一起

130
00:08:57,540 --> 00:08:59,400
来协同在一起来做一些事情

131
00:08:59,400 --> 00:09:00,440
甚至挑战霸王

132
00:09:01,960 --> 00:09:04,780
这就是我们希望同学达到的一个目标

133
00:09:04,780 --> 00:09:09,600
接下来我们会把这个总体思路给大家做个介绍

134
00:09:09,600 --> 00:09:13,760
相对于之前我们看到的这个OS

135
00:09:13,760 --> 00:09:15,360
它在哪里做了一些扩展

136
00:09:15,360 --> 00:09:16,600
我们可以看到这里面

137
00:09:18,020 --> 00:09:20,600
一部分是这块机制

138
00:09:22,000 --> 00:09:28,640
这块机制说它能够实现进程间的数据的传递

139
00:09:28,640 --> 00:09:31,560
它虚拟出来一个所谓的Pipe的管道机制

140
00:09:31,560 --> 00:09:35,020
第二是通知机制 通知在这里面Signal

141
00:09:35,020 --> 00:09:40,500
Signal机制通过我们所谓的特权级上下文的一个修改

142
00:09:40,500 --> 00:09:45,940
使得它可以及时响应内核或者是我们的信号发出一个通知之后

143
00:09:45,940 --> 00:09:51,040
可以让进程的 handler 停止当前正在执行的代码

144
00:09:51,040 --> 00:09:53,820
去专门执行响应信号的代码

145
00:09:53,820 --> 00:09:55,340
这是两块扩展

146
00:09:55,340 --> 00:09:58,600
为此在我们的进程控制块里面

147
00:09:58,600 --> 00:10:01,500
要做出一些新的扩展能力

148
00:10:01,500 --> 00:10:04,740
比如说它把 pipe std 进 std out

149
00:10:04,740 --> 00:10:07,720
前面说的变成了一个 fd 这是这一块

150
00:10:07,720 --> 00:10:10,280
还有一块就是我们说的 signal

151
00:10:10,280 --> 00:10:13,220
这相对独立的一块也会成为我们进程的一部分

152
00:10:13,220 --> 00:10:14,880
这里面成为我们进程的一部分

153
00:10:15,240 --> 00:10:21,820
这是我们说在我们之前的OS基础之上,又做了扩展之后,形成了一个新的

154
00:10:21,820 --> 00:10:22,140
OS。

155
00:10:25,900 --> 00:10:29,320
我们稍微再具体点讲,这里面就两部分,一个是Pype,一个是Signal,我们先

156
00:10:29,320 --> 00:10:30,140
从Pype开始讲。

157
00:10:30,880 --> 00:10:36,060
那Pype,如果要去理解它怎么去实现的话,其实首先要解决Pype市场,

158
00:10:36,620 --> 00:10:38,640
第二怎么用它,第三怎么管它。

159
00:10:38,640 --> 00:10:44,660
把这三个问题搞清楚之后呢,其实你就能够比较好地去理解Python的

160
00:10:44,660 --> 00:10:46,540
一个实在的一个含义。

161
00:10:50,080 --> 00:10:55,160
在这里面其实已经很新鲜地表现出来,Python就是一个,它叫管道,这是它的名字

162
00:10:55,160 --> 00:11:03,860
叫管道,其实就是一块memory,这个我后面会专门再去讲,它是内核中的

163
00:11:03,860 --> 00:11:04,400
一块内存。

164
00:11:04,820 --> 00:11:08,540
这个内存需要注意 内存和我们一般的内存不一样

165
00:11:09,640 --> 00:11:12,120
写是从这写出去的 读从这读出来

166
00:11:12,120 --> 00:11:16,120
所以它是一个顺序的读写的一块数据

167
00:11:16,120 --> 00:11:20,400
这个需要注意 你不能说我读的时候可以任意从某个位置开始读

168
00:11:20,400 --> 00:11:24,560
这不行 我们就要从这个尾巴开始读 从头开始塞进去

169
00:11:24,560 --> 00:11:28,000
这所谓的顺序读写 还有这么一个约束

170
00:11:28,000 --> 00:11:33,160
同时这里面的整个memory实际上是一个字节流

171
00:11:33,160 --> 00:11:35,580
实际上它是按字节为单位进行读写的

172
00:11:35,580 --> 00:11:36,860
这个字节意味着什么呢

173
00:11:36,860 --> 00:11:37,860
它并没有一个数字结构

174
00:11:37,860 --> 00:11:43,080
它只是一块一块像一个字节宿主一样的顺序读或者写

175
00:11:44,020 --> 00:11:45,540
那你既然是要读和写的

176
00:11:45,540 --> 00:11:46,960
其实你就说它是一个file

177
00:11:46,960 --> 00:11:48,440
不是它是一个文件

178
00:11:48,440 --> 00:11:50,620
所以它这个文件的接口它需要满足

179
00:11:50,620 --> 00:11:52,360
文件的接口什么最主要是读和写

180
00:11:52,360 --> 00:11:53,920
这两个接口要满足

181
00:11:53,920 --> 00:11:54,960
只是在读和写的时候

182
00:11:54,960 --> 00:11:57,440
你需要注意读是从这个地方开始

183
00:11:57,440 --> 00:11:58,680
写是从这个地方开始

184
00:11:58,680 --> 00:12:00,300
它们还是有它们的各自的特点

185
00:12:00,300 --> 00:12:02,680
不是说从任意的一个像我们正常的文件

186
00:12:02,680 --> 00:12:07,100
你说可以从一个offset位置开始读或者写

187
00:12:07,100 --> 00:12:07,620
它没有

188
00:12:07,620 --> 00:12:10,260
它只能是从头后尾开始读写

189
00:12:10,260 --> 00:12:15,100
那我们的应用就会基于特殊的Pype这个file

190
00:12:15,100 --> 00:12:17,940
来对Pype进行使用

191
00:12:17,940 --> 00:12:19,920
这里面给了一幅图可以看出来

192
00:12:19,920 --> 00:12:22,160
我创建了一个Pype

193
00:12:22,160 --> 00:12:23,300
这Pype比较特殊

194
00:12:23,700 --> 00:12:25,980
你创建一个Pype实行它两个FD

195
00:12:25,980 --> 00:12:27,480
我们说文件描述服务

196
00:12:27,480 --> 00:12:28,960
然后你为了能够读和写

197
00:12:28,960 --> 00:12:30,940
你可能要把其中的一个FD给关掉

198
00:12:30,940 --> 00:12:34,740
比如说这里面我把这个写这个FD给关掉

199
00:12:34,740 --> 00:12:36,180
而对于这个直径层来说

200
00:12:36,180 --> 00:12:37,140
这是附近层

201
00:12:37,140 --> 00:12:37,920
对于直径层来说

202
00:12:37,920 --> 00:12:39,360
它把这个读这个FD给关掉

203
00:12:39,360 --> 00:12:40,620
把这个关掉

204
00:12:40,620 --> 00:12:43,040
这样使得我写这个FD还存在

205
00:12:43,040 --> 00:12:44,640
我可以对它进行写操作

206
00:12:44,640 --> 00:12:45,620
就是Write

207
00:12:46,680 --> 00:12:48,380
那么这边是做读操作

208
00:12:48,380 --> 00:12:48,740
Read

209
00:12:48,740 --> 00:12:49,900
它们配合在一起

210
00:12:49,900 --> 00:12:53,500
来完成对这个PAP里面的数据的读写

211
00:12:53,500 --> 00:12:56,320
实际上就是意味着我们的直径层

212
00:12:56,320 --> 00:12:58,100
把数据写到管道里面来

213
00:12:58,100 --> 00:13:00,240
附近层把这个从管道里面把数据读出来

214
00:13:00,240 --> 00:13:03,960
他们实现了一个所谓的一个数据的一个交换或者传递

215
00:13:06,260 --> 00:13:09,120
那这是一个实际的应用程序

216
00:13:09,120 --> 00:13:11,080
这给了一个最主要的部分

217
00:13:11,080 --> 00:13:13,500
就是把我们刚才可视化那部分呢

218
00:13:13,500 --> 00:13:15,420
就是图像展示那部分呢

219
00:13:15,420 --> 00:13:17,280
给它编程化啊

220
00:13:17,280 --> 00:13:19,260
这个编程其实看起来也是非常简单

221
00:13:19,260 --> 00:13:21,720
这边你可以看着

222
00:13:21,720 --> 00:13:23,420
第一个比较重要的什么呢

223
00:13:23,420 --> 00:13:25,960
创建了一个包含两个元素的FD宿主

224
00:13:29,280 --> 00:13:33,000
这就跟我们前面的不一样,我们一般打一个文件是什么呢?

225
00:13:33,020 --> 00:13:37,240
是一个FD,它这里面是返回了两个FD,是靠什么呢?靠这个系统来用

226
00:13:37,240 --> 00:13:40,760
叫PUB系统来用,它返回了两个FD,创建了一个PUB,返回了两

227
00:13:40,760 --> 00:13:41,700
个FD

228
00:13:41,700 --> 00:13:46,760
然后呢,第二步,这个Map实际上代表的是叫做复进程

229
00:13:47,420 --> 00:13:49,920
然后复进程执行放货返回0,它又是什么?

230
00:13:50,060 --> 00:13:52,380
放货返回0就是因为当天在执行程里面执行了

231
00:13:52,380 --> 00:13:58,160
执行执行之后,它干什么?Close,Close一个FD,也Close这个1,把这个write端

232
00:13:58,160 --> 00:14:00,660
给关掉了

233
00:14:00,660 --> 00:14:06,300
然后呢,申明了一个buffer,然后从这里面读,从这个0开始读,这个0实际上就是

234
00:14:06,300 --> 00:14:07,500
一个读的一个FD

235
00:14:07,500 --> 00:14:12,300
我们说你一个pipe,它有一个读写,两个FD组成,它只用了形容一个

236
00:14:12,300 --> 00:14:15,840
那这是谁用的?这是指镜头来用的读pipe

237
00:14:15,840 --> 00:14:20,640
那对于附镜头而言,那就是pipe,它的反回是大于0的,这是附镜头

238
00:14:20,640 --> 00:14:24,840
附近程把这个读的一端给关闭掉,把这个关了

239
00:14:24,840 --> 00:14:29,420
然后对它进行写操作,和这个匹配的读操作是写操作

240
00:14:29,420 --> 00:14:34,020
那你写操作的话,它写的是写的是同一个pipe,需要注意

241
00:14:34,380 --> 00:14:41,160
我们看到的,你读写虽然用的不同的fd,但是你是同一个pipe

242
00:14:41,900 --> 00:14:45,240
这个pipe没有变,只是它的fd的指向不一样

243
00:14:45,240 --> 00:14:48,920
然后你写完之后呢,最后就可以等待这个

244
00:15:18,920 --> 00:15:25,300
管理这一块 它其实就是我们说进程已经成了一个资源的一个container 一个容

245
00:15:25,300 --> 00:15:25,860
器

246
00:15:25,860 --> 00:15:28,220
那其实我们管理是主要的进程来进行管理

247
00:15:28,220 --> 00:15:34,160
所以这个首先大家需要把这个进程 进程通通化 要有充分的认识

248
00:15:34,160 --> 00:15:36,940
它的这个内容在不停的扩展

249
00:15:36,940 --> 00:15:41,880
我们从前面很早前可能这一块都没有 到现在有了FD

250
00:15:41,880 --> 00:15:44,460
FD之后还会有新的东西 比如说有了pipe

251
00:15:44,460 --> 00:15:49,220
有了所谓的我们说的STD1、STD2这种Device

252
00:15:49,220 --> 00:15:50,440
还有什么?还有Signal

253
00:15:50,440 --> 00:15:53,680
这都是在不停地扩展进程控制化

254
00:15:53,680 --> 00:15:56,240
那PAP是其中的一个新的资源

255
00:15:56,240 --> 00:15:59,360
它这里面是通过什么?通过FD来进行管理

256
00:16:00,220 --> 00:16:01,640
这是一块

257
00:16:04,680 --> 00:16:06,320
然后再具体看怎么管理

258
00:16:06,320 --> 00:16:07,520
这个管理的过程

259
00:16:08,720 --> 00:16:11,920
对,这个管理的过程其实就是围绕着

260
00:16:11,920 --> 00:16:16,820
我们说这个pipe的它所对应的那个buffer来进行处理的

261
00:16:16,820 --> 00:16:18,700
这个在后面我们会进一步讲解

262
00:16:18,700 --> 00:16:20,820
在那进程角度来说你只要知道

263
00:16:20,820 --> 00:16:25,220
这段buffer会变成这个FDTable里面的一个描述服

264
00:16:25,220 --> 00:16:27,620
它会指向一个具体的buffer

265
00:16:27,620 --> 00:16:30,560
然后我们的应用程序是根据描述服来进行处理的

266
00:16:30,560 --> 00:16:31,760
描述服是向文件描述

267
00:16:31,760 --> 00:16:35,420
所以说应用程序是根据文件的接口

268
00:16:35,420 --> 00:16:39,880
read和write来实际上是对一块内存进行读写操作

269
00:16:40,560 --> 00:16:45,180
这是它的一个就是我们说在管理上需要注意的一些事情

270
00:16:47,160 --> 00:16:49,360
那么对于Signal 我们看第二个Signal

271
00:16:49,360 --> 00:16:54,220
Signal和这个Pybe是不太一样的

272
00:16:54,220 --> 00:16:56,940
因为首先它就Signal并没有抽象成一个文件

273
00:16:56,940 --> 00:16:59,760
它觉得这个抽象成文件并不太match

274
00:16:59,760 --> 00:17:01,980
因为它不是用来读和写

275
00:17:01,980 --> 00:17:04,240
它更多的是一种通知机制

276
00:17:04,240 --> 00:17:09,220
这就使得我们需要去找另外一个跟它类似的东西

277
00:17:09,220 --> 00:17:10,600
什么呢?就是中断

278
00:17:10,600 --> 00:17:13,240
其实我们前面叫intrapped handler

279
00:17:13,980 --> 00:17:16,180
或者exception 异常hander

280
00:17:16,660 --> 00:17:19,180
或者是trap handler 或者是中断hander

281
00:17:19,180 --> 00:17:21,340
正面叫signal handler 实际上是类似的

282
00:17:21,340 --> 00:17:24,040
所以这个signal是和我们的中断是对应的

283
00:17:24,040 --> 00:17:27,220
同样的问题就是你如何使用这个signal 如何管理它

284
00:17:28,020 --> 00:17:29,640
我们看一看

285
00:17:29,640 --> 00:17:31,820
首先我们给它视察

286
00:17:31,820 --> 00:17:35,780
它是内核通知应用的一种软件中断

287
00:17:35,780 --> 00:17:39,000
这是对signal的一个基本的定义

288
00:17:39,000 --> 00:17:41,560
你既然是一种通知 那么有通知那个标识

289
00:17:41,560 --> 00:17:45,160
所以我们这里面可以发现通知什么通知实际上它也是一个编号

290
00:17:45,560 --> 00:17:47,300
编号0代表什么 编号1代表什么

291
00:17:47,300 --> 00:17:49,820
那就是代表不同的这个通知的内容

292
00:17:49,820 --> 00:17:51,800
它只需要用一个整形就表示了

293
00:17:51,800 --> 00:17:53,120
这个整形其实可以很大

294
00:17:53,120 --> 00:17:55,180
它这里面用了一小部分

295
00:17:55,180 --> 00:17:56,860
60多个来表示

296
00:17:56,860 --> 00:17:58,520
对我们通常的这个

297
00:17:58,520 --> 00:17:59,360
比如说Linux来说

298
00:17:59,360 --> 00:18:02,680
它用了60多个整形值来表示不同的信号

299
00:18:03,740 --> 00:18:04,780
既然有了这个

300
00:18:05,180 --> 00:18:06,260
第一对信号有了编码

301
00:18:06,260 --> 00:18:07,780
第二你要去响应它

302
00:18:07,780 --> 00:18:11,080
所以你自然就有一个对应的SignalHandler

303
00:18:11,080 --> 00:18:14,040
这里面就是说你针对不同的Signal

304
00:18:14,040 --> 00:18:16,460
你有相应的一个处理历程

305
00:18:16,460 --> 00:18:18,000
这就是所谓的SignalHandler

306
00:18:18,000 --> 00:18:20,580
它是和Signal是有对应关系的

307
00:18:20,580 --> 00:18:22,300
当然你需要通过某种系统雕用

308
00:18:22,300 --> 00:18:23,680
把这个关系给建立起来

309
00:18:23,680 --> 00:18:25,940
就这样它这两者之间有一个联系

310
00:18:27,400 --> 00:18:29,600
那么一旦建立好联系之后

311
00:18:31,020 --> 00:18:32,800
比如说我们进程A

312
00:18:32,800 --> 00:18:35,540
就可以给进程B发一个信号

313
00:18:36,760 --> 00:18:42,960
这个发信号的话,使得进程B当前的执行会停下来,执行对这个信号

314
00:18:42,960 --> 00:18:43,740
的响应。

315
00:18:44,180 --> 00:18:47,600
响应完之后,再恢复刚才停下来的地方继续执行。

316
00:18:47,900 --> 00:18:52,720
这就特别像我们说硬件产生中那种机制,只是整个这个过程是由我们

317
00:18:52,720 --> 00:18:55,920
的软件和内核来实际完成。

318
00:18:56,500 --> 00:19:01,620
所以这里面,内核干的事情稍微要复杂一些,而且也会涉及到,因为你打断了

319
00:19:01,620 --> 00:19:02,940
当前这个进程B的执行。

320
00:19:02,940 --> 00:19:06,240
所以说也会涉及到对这个进程B的所谓的Track Contact

321
00:19:06,240 --> 00:19:13,560
就是我们说的这个特权及上下文的一个处理和恢复这么一个过程

322
00:19:13,560 --> 00:19:15,060
这个后面会再进一步讲解

323
00:19:15,060 --> 00:19:16,760
大致的你可以知道这个总理思路

324
00:19:16,760 --> 00:19:19,820
你也是怎么回事就OK了

325
00:19:19,820 --> 00:19:20,620
这是它的应用程序

326
00:19:20,620 --> 00:19:22,000
可以看到怎么来做这个

327
00:19:22,800 --> 00:19:24,580
如果我要写一个APP的话

328
00:19:24,580 --> 00:19:25,620
那怎么来写这个事情

329
00:19:25,620 --> 00:19:27,340
这里面也对应着在我们这个例子里面

330
00:19:27,340 --> 00:19:28,860
就Signal Simple这么一个RS

331
00:19:28,860 --> 00:19:30,480
这里面会有相应的一个写法

332
00:19:30,480 --> 00:19:32,220
比如说这个应用程序很简单

333
00:19:32,220 --> 00:19:35,800
我要先写好一个Handler

334
00:19:35,800 --> 00:19:37,800
这就是一个所谓的SignalHandler

335
00:19:37,800 --> 00:19:39,220
再去print一下

336
00:19:39,760 --> 00:19:41,420
然后就调一个SignalReturn

337
00:19:41,420 --> 00:19:42,380
这么一个形态用

338
00:19:42,380 --> 00:19:45,740
回到前一个位置继续执行

339
00:19:45,740 --> 00:19:48,200
这就是这些东西要干的事情

340
00:19:48,200 --> 00:19:50,380
这是我们说的SignalHandler是干的事情

341
00:19:50,380 --> 00:19:51,720
那么对于我们的主程序来说

342
00:19:51,720 --> 00:19:52,400
它怎么办呢

343
00:19:52,400 --> 00:19:53,280
首先要配置

344
00:19:53,280 --> 00:19:58,000
我们要把某一个信号量的值

345
00:19:58,000 --> 00:20:00,540
和这个Handler给它建立对应关系

346
00:20:00,540 --> 00:20:02,000
所以看到这种怎么建议呢

347
00:20:32,500 --> 00:20:40,220
可能之前这个信号量有另外一个老的一个handle

348
00:20:40,220 --> 00:20:42,640
这样我可以把老的handle保存下来

349
00:20:42,640 --> 00:20:44,820
使得我后面还有机会恢复它

350
00:20:44,820 --> 00:20:45,920
干这么一个事情

351
00:20:45,920 --> 00:20:48,740
只是为了保存老的一些信息

352
00:20:48,740 --> 00:20:50,640
这里面我们主要是为了建立新的

353
00:20:50,640 --> 00:20:52,560
所以这个old其实后面没有用上

354
00:20:52,560 --> 00:20:54,420
那这个算是建立好这个过程了

355
00:20:54,420 --> 00:20:57,180
建立好这个过程之后 我就可以发消息

356
00:20:57,180 --> 00:20:59,880
发通知信息用skill这个系统代用

357
00:20:59,880 --> 00:21:02,440
你看这比较特殊是什么 自己给自己发

358
00:21:02,440 --> 00:21:05,020
我自己建好一个Handler之后 其实自己发

359
00:21:05,020 --> 00:21:09,020
并不是像前面那个例子说的 让另外一个进程

360
00:21:09,020 --> 00:21:10,280
这也意味着自己也可以给自己发

361
00:21:10,280 --> 00:21:12,580
这Keyer给谁发呢

362
00:21:12,580 --> 00:21:15,420
当前我自己的PID是多少 得到PID之后

363
00:21:15,420 --> 00:21:17,840
给他发一个Signal

364
00:21:17,840 --> 00:21:20,320
这就是一个非常简单的例子

365
00:21:20,320 --> 00:21:22,280
几行程序可以把这个展现出来

366
00:21:22,280 --> 00:21:25,300
大家可以看看 当然你可以再写另外一个

367
00:21:25,300 --> 00:21:27,300
不同的一个进程 让他来给

368
00:21:27,300 --> 00:21:31,680
只要你知道建好SignalHandler的进程PID

369
00:21:31,680 --> 00:21:34,840
你就可以通过Kailh信息要给他发信息

370
00:21:34,840 --> 00:21:38,420
然后实际上是交给我们超级统盘做后续的处理

371
00:21:38,980 --> 00:21:40,240
这个用起来是很简单

372
00:21:40,860 --> 00:21:43,070
但是内核需要干的事情稍微多一点

373
00:21:44,680 --> 00:21:45,340
内核为什么多

374
00:21:45,340 --> 00:21:46,100
因为它在这

375
00:21:46,100 --> 00:21:51,920
Signal也是我们说是进程的一种资源

376
00:21:51,920 --> 00:21:55,700
这种资源你要去正确的设置

377
00:21:55,700 --> 00:22:02,700
而且它跟所谓的我们前面说的Trap Context有比较大的联系

378
00:22:02,700 --> 00:22:05,260
因为它要改变当前这个程序的执行站

379
00:22:05,260 --> 00:22:06,840
可能执行站在这儿 要改掉

380
00:22:06,840 --> 00:22:09,740
要改到另一个地方 改到我们的Signal Handler

381
00:22:09,740 --> 00:22:11,800
执行Handler之后再回到这个地方再去执行

382
00:22:11,800 --> 00:22:16,960
那么这些信息都需要和Trap Context有一定的关系

383
00:22:18,120 --> 00:22:20,160
所以对Signal的一个管理

384
00:22:20,160 --> 00:22:23,380
实际上就是涉及到对Trap Context的一个管理

385
00:22:23,380 --> 00:22:27,800
就是这儿,对这个还得管理,这个大家需要注意

386
00:22:28,720 --> 00:22:32,360
好,那总体思路就给大家简单介绍完毕

387
00:22:32,360 --> 00:22:34,480
我们再看看这个从哪儿来的

388
00:22:34,940 --> 00:22:37,520
讲这么多,大家也需要了解一下这个

389
00:22:37,520 --> 00:22:39,820
它也不是说一下子就冒出来

390
00:22:40,300 --> 00:22:43,260
其实它们有它们的历史的一个发展过程

391
00:22:43,260 --> 00:22:45,660
这管道的概念来自于Belsys

392
00:22:45,660 --> 00:22:47,240
我们说Unix来自于Belsys

393
00:22:47,240 --> 00:22:51,320
这个管道也是Belsys,道格拉斯MicroRE

394
00:22:51,320 --> 00:22:54,180
它在1964年那时候还没有Unix

395
00:22:54,180 --> 00:22:57,200
这个时间实际上是很早的 这还没有Unix

396
00:22:57,200 --> 00:22:59,380
1964年的时候它就已经提出了一个ID

397
00:22:59,380 --> 00:23:03,340
就是要把多个程序像花园的水管一样连在一起

398
00:23:03,340 --> 00:23:04,540
花园水管都连在一起

399
00:23:04,540 --> 00:23:10,180
然后实际上就使得数据可以在不同的程序之间流动

400
00:23:10,180 --> 00:23:14,860
这个ID就管道 这是典型的管道的一个事物

401
00:23:16,020 --> 00:23:17,900
这个光它有ID了之后 它并没有实现

402
00:24:18,380 --> 00:24:28,720
这个是再重新复习一下,这是我们C源的发明者,就和Ken Thompson一起的一位专

403
00:24:28,720 --> 00:24:31,900
家。大家什么名字大家想想,这个就不再进一步讲了。

404
00:24:33,280 --> 00:24:39,720
那信号呢?信号其实也是从Unix发展出来的。当然我们这边查的不是说一定是

405
00:24:39,720 --> 00:24:41,880
最早,只是我们在Unix里面可以看到。

406
00:24:41,880 --> 00:24:45,720
因为是第一个版本,第一个版本就出现了信号

407
00:24:45,720 --> 00:24:48,300
只是它当时的设计和我们现在知道有点不同

408
00:24:48,300 --> 00:24:50,340
因为它针对不同的信号有不同的系统调用

409
00:24:50,340 --> 00:24:55,920
当时的设计还是稍微它的抽象性和这种归纳性稍微弱了一点

410
00:24:55,920 --> 00:25:00,080
但在版本4之后,它就可以通过一个系统调用来捕获所有的信号

411
00:25:00,080 --> 00:25:05,940
这样就把这个在软件工程上面把这个系统调用设计得更加精巧

412
00:25:05,940 --> 00:25:07,140
这是这一个

413
00:25:07,140 --> 00:25:09,800
但这个信号它的实现比较复杂

414
00:25:09,800 --> 00:25:12,260
我说实际上在内核中的时间比较复杂

415
00:25:12,580 --> 00:25:15,880
而且随着我们操作我们的功能进一步扩展之后

416
00:25:17,800 --> 00:25:21,860
就使得信号在应对各种各样的编辑条件上面

417
00:25:21,860 --> 00:25:24,180
会有一些可能考虑不周的地方

418
00:25:24,180 --> 00:25:26,860
我们可以发现像零零石或零零石没力

419
00:25:26,860 --> 00:25:31,080
这个信号内核实现中出bug的概率是比较大的

420
00:25:33,180 --> 00:25:36,880
所以大家如果去深入理解一下信号的内核实现的话

421
00:25:36,880 --> 00:25:40,160
可能对此有更进一步的一个体会

422
00:25:40,980 --> 00:25:42,980
这是对它的历史的一个简短介绍

423
00:25:43,920 --> 00:25:47,620
再一下我们看一下我们说叫实践

424
00:25:47,620 --> 00:25:49,340
大致的一个实践过程

425
00:25:49,340 --> 00:25:53,180
这就是我们把我们的实践带

426
00:25:53,180 --> 00:25:54,960
Aquatutorial V3给取出来

427
00:25:54,960 --> 00:25:56,600
Checkout是第7个

428
00:25:56,600 --> 00:25:57,940
Setch7的Branch

429
00:25:57,940 --> 00:25:59,260
然后Make Run之后

430
00:25:59,260 --> 00:26:00,340
其实可以到Share

431
00:26:00,340 --> 00:26:01,720
我们说这个Unix Share

432
00:26:01,720 --> 00:26:03,180
到Share之后就可以敲命

433
00:26:03,180 --> 00:26:06,420
比如说这里面我们说的这个Pipe Test

434
00:26:06,420 --> 00:26:09,080
就是一个Pype的一个测试

435
00:26:09,080 --> 00:26:11,140
那PypeTest呢,我看看

436
00:26:17,420 --> 00:26:23,800
在这就是PypeTest就是前面我介绍的那个简单的例子的一个稍微

437
00:26:23,800 --> 00:26:24,600
完整的一个版本

438
00:26:24,600 --> 00:26:26,200
大家也可以去看一下

439
00:26:26,200 --> 00:26:36,360
基本上就是说复习条指令层通过对Pype的这个不同的FT进行操作

440
00:26:36,360 --> 00:26:44,360
来完成这个传递,这里面也是一样,读PAP,这是写PAP,这是一个例子。

441
00:26:48,600 --> 00:26:54,040
第二个是signal,signal就是我们说,也是一个signal sample的一个例子,这个sign

442
00:26:54,040 --> 00:26:56,360
al sample就在这儿。

443
00:26:58,900 --> 00:27:02,200
这个是example 你可以看到 其实就这么短一段代码

444
00:27:02,200 --> 00:27:04,860
就把我们前面说的 建立这个

445
00:27:06,260 --> 00:27:12,220
针对这个信号的处理历程 就是这个处理历程

446
00:27:12,220 --> 00:27:16,320
然后再给自己发信号 就这么一个简单的例子

447
00:27:16,320 --> 00:27:19,740
实际上代码就可以把这个功能完成了

448
00:27:19,740 --> 00:27:21,020
这是一个非常简单的施力

449
00:27:22,160 --> 00:27:23,620
大家也可以去试一下

450
00:27:26,360 --> 00:27:30,080
假设你们实践了之后,其实我们还更重要的是了解它怎么实现

451
00:27:30,080 --> 00:27:34,720
不光是你会用它,还会知道它具体怎么去实现

452
00:27:34,720 --> 00:27:38,220
所以我们可以看看,我们为了完成这两部分功能

453
00:27:38,220 --> 00:27:42,720
就是pipe和信号,我们大致做了哪些事情

454
00:27:42,720 --> 00:27:45,560
第一个就是你建了一堆应用程序,测试用力

455
00:27:45,560 --> 00:27:48,480
你知道怎么去写这个应用

456
00:27:48,480 --> 00:27:51,480
应用是驱动或者是开发很重要的一个东西

457
00:27:51,480 --> 00:27:53,640
基本上很多大家在做实验中可以看到

458
00:27:53,940 --> 00:27:58,380
你通过应用来调错,你知道自己哪儿错了,自己哪儿时间不足,都是通过应用

459
00:27:58,380 --> 00:27:58,880
来驱动的。

460
00:27:59,040 --> 00:28:03,700
所以说基于测试的一种,Driven的一种软件开发方式,就是我们在目前

461
00:28:03,700 --> 00:28:05,680
OS里面用的比较多的。

462
00:28:05,780 --> 00:28:10,540
这里面代码看,这里面给了一堆的新增加的关于pipe和关于signal

463
00:28:10,540 --> 00:28:11,680
的一个测试用力。

464
00:28:11,980 --> 00:28:16,580
大家可以看看,这里面这些测试用力也是由于我们增加了新的系统标用。

465
00:28:16,960 --> 00:28:21,120
这里面一个是新增,一个是修改,你可能对某些已有的系统标要做一定的

466
00:28:21,120 --> 00:28:21,700
修改。

467
00:28:21,700 --> 00:28:29,460
还有增加新的性能,包括这里面的Pipe,或者是我们说的Dot,还有Key,Sig

468
00:28:29,460 --> 00:28:32,300
Action等等,这都是我们说新增的一些东西

469
00:28:33,580 --> 00:28:39,400
那这是应用部分,那么对于内核部分来说,你会发现它的扩展的部分,几大块

470
00:28:39,400 --> 00:28:47,000
我们说超级桶现在有三个重要的抽象,一个是进程,一个是地址空间,一个是

471
00:28:47,000 --> 00:28:48,980
文件,其实在这里面都涉及了

472
00:28:48,980 --> 00:28:59,400
你看到在TAS里面,就是我们说的进程这一块,你需要去包装新的我们说

473
00:28:59,400 --> 00:29:01,000
的Signal这种字语

474
00:29:01,000 --> 00:29:06,840
然后你会在这里面会有一个所谓的FDTable的一个新的扩展

475
00:29:06,840 --> 00:29:10,920
它会去把文件指向

476
00:29:10,920 --> 00:29:14,700
我们说STD-IN和STD-OUT这种Device也可以指向

477
00:29:14,700 --> 00:29:19,120
所谓的Pipe这种内存 这种新的文件抽象

478
00:29:19,120 --> 00:29:21,900
这就是对我们做进程的一个扩展

479
00:29:21,900 --> 00:29:23,920
第二是Memory这一块

480
00:29:23,920 --> 00:29:27,300
Memory这一块就是它创造出一个UserBuffer

481
00:29:27,300 --> 00:29:29,280
这个UserBuffer实际上就是我们说的Pipe

482
00:29:29,280 --> 00:29:30,280
它一块内存

483
00:29:30,280 --> 00:29:33,980
这块内存是给User不同的进程时间

484
00:29:33,980 --> 00:29:37,320
来进行数据传递的一个设置

485
00:29:37,320 --> 00:29:39,140
就相对叫做UserBuffer

486
00:29:39,140 --> 00:29:42,760
这是一个对PAP的一个支持

487
00:29:42,760 --> 00:29:45,580
对文件来说

488
00:29:45,580 --> 00:29:49,080
它需要把它那个抽象给扩展

489
00:29:49,080 --> 00:29:51,600
就是我们说的File这么一个接口

490
00:29:51,600 --> 00:29:53,680
针对PAP作为扩展

491
00:29:53,680 --> 00:29:56,480
针对STDIN STDOUT作为扩展

492
00:29:56,480 --> 00:29:58,760
就是标准输出和这样做扩展

493
00:29:58,760 --> 00:30:01,380
使得他们俩也可以以文件的形式

494
00:30:01,380 --> 00:30:06,760
来被这个进程的FDTable所链接

495
00:30:06,760 --> 00:30:10,280
然后并进一步给我们应用程序提供那种Read&Write的接口

496
00:30:11,060 --> 00:30:12,660
这是这三块的一个知识

497
00:30:12,660 --> 00:30:16,000
那么为能管应用去能够用上它

498
00:30:16,000 --> 00:30:19,440
所以你还会有一个对Syscode的一个扩展

499
00:30:20,920 --> 00:30:22,640
这里面要调整什么呢

500
00:30:22,640 --> 00:30:24,220
调整这个SysRead和SysWrite

501
00:30:24,220 --> 00:30:26,960
它不是说只是针对这种

502
00:30:27,380 --> 00:30:31,380
我们说针对BlocksDevice的这种文件的读写

503
00:30:31,380 --> 00:30:36,440
而是还要针对所谓的标准Io还有Pype进行读写

504
00:30:36,440 --> 00:30:40,400
所以在这里面它会有对它进行调整

505
00:30:40,400 --> 00:30:42,940
还要新增了一些新增了一些性能加价

506
00:30:43,900 --> 00:30:45,240
然后这里面还有一块

507
00:30:45,780 --> 00:30:47,440
Trap这一块实际上就是我们说的

508
00:30:47,440 --> 00:30:51,320
Trap有一个对Trap Contacts的一个处理

509
00:30:51,320 --> 00:30:52,920
这个处理是和Signal相关的

510
00:30:53,600 --> 00:30:58,380
它要确保我为了能够跳到新的Signal Handler去执行

511
00:30:58,380 --> 00:31:02,760
我需要把当前的进程的Trap Contacts保存起来

512
00:31:03,560 --> 00:31:05,720
当Signal Handler执行完毕之后

513
00:31:05,720 --> 00:31:09,500
恢复当天被打断的地方继续执行

514
00:31:09,500 --> 00:31:11,700
这一块就和Trap相关

515
00:31:11,700 --> 00:31:15,220
这就是我们说在内核层面

516
00:31:18,560 --> 00:31:22,320
需要去做的扩展和改进

517
00:31:22,320 --> 00:31:25,220
这是一个非常Overview的展示

518
00:31:26,960 --> 00:31:29,100
做这个工作和意见无关

519
00:31:29,100 --> 00:31:31,300
所以不需要增加新的意见

520
00:31:31,300 --> 00:31:33,600
不叫和意见无关,不需要增加新的意见

521
00:31:33,600 --> 00:31:37,180
我们更多的是在以前已经介绍完毕的硬件基础之上

522
00:31:37,180 --> 00:31:38,760
来看下怎么去设计这个程序

523
00:31:40,840 --> 00:31:42,500
先看Pub设计

524
00:31:42,500 --> 00:31:46,660
我们前面已经大致讲了一下它的总体的一个overview

525
00:31:46,660 --> 00:31:50,940
Pub设计实际上其实重点要理解的是文件

526
00:31:50,940 --> 00:31:52,680
就是你实际上是对文件进行扩展

527
00:31:53,200 --> 00:31:57,000
所以为了支持文件的扩展,其实你要做四方面的事情

528
00:31:57,000 --> 00:31:59,960
这上面包含了内核的部分,也包含了

529
00:32:04,320 --> 00:32:10,440
对于内核而言,你需要实现基于文件的标准输入输出,基于文件

530
00:32:10,440 --> 00:32:11,080
的管道。

531
00:32:13,300 --> 00:32:18,700
这个管道实际上是对Memory的读写特殊的支持。

532
00:32:20,560 --> 00:32:28,000
现在的标准输入输出实际上是对创口的读写进行重新的封装,

533
00:32:28,100 --> 00:32:29,820
按照文件的方式进行封装。

534
00:32:29,820 --> 00:32:32,040
他就是做了这么一个事情

535
00:32:32,040 --> 00:32:36,140
然后还有对我们说的PCB进程通知框

536
00:32:36,140 --> 00:32:37,680
做出一定的调整

537
00:32:37,680 --> 00:32:40,400
这是我们说他要做的事情

538
00:32:40,400 --> 00:32:43,780
那么对于用户态来说

539
00:32:43,780 --> 00:32:45,820
重点是这个Share

540
00:32:46,800 --> 00:32:50,080
我们的Share需要能够支持迷你行参数

541
00:32:50,080 --> 00:32:52,920
能够让我们的应用程序

542
00:32:52,920 --> 00:32:55,080
Share里面会执行不同的应用程序

543
00:32:55,080 --> 00:32:56,880
但应用程序它要能够支持迷你行参数

544
00:32:56,880 --> 00:32:58,420
这之前我们不需要 就没有

545
00:32:58,420 --> 00:33:00,220
在现在我们需要支持密码的参数

546
00:33:00,220 --> 00:33:02,860
第二要支持这么一个特殊的符号就是管道

547
00:33:02,860 --> 00:33:10,320
大家如果看到说A管道B

548
00:33:10,320 --> 00:33:14,760
把A的输出通过管道传递给B

549
00:33:14,760 --> 00:33:16,680
让B以为是输入

550
00:33:16,680 --> 00:33:18,620
虽然A和B完全是没关系的

551
00:33:18,620 --> 00:33:20,800
但是由于在Share的统一管理之下

552
00:33:20,800 --> 00:33:22,760
A和B都是Share的指进层

553
00:33:22,760 --> 00:33:24,260
那么它就可以通过这种管道

554
00:33:24,260 --> 00:33:26,520
这种特殊的符号能够把这个建立起来

555
00:33:26,520 --> 00:33:28,040
那么Share一旦看到这种符号

556
00:33:28,040 --> 00:33:32,040
看这个符号之后,它会对A和B做出一些额外的处理,

557
00:33:32,260 --> 00:33:36,500
让他们把这个把A的输出从定向到B的输入。

558
00:33:36,720 --> 00:33:39,240
这所谓的从定向就通过一个Pype来完成了。

559
00:33:39,340 --> 00:33:40,700
这个后面会给大家进一步讲解。

560
00:33:40,880 --> 00:33:47,140
这就是说,我们在做Pype实现的时候,需要做四部分事情。

561
00:33:48,780 --> 00:33:52,080
先看看第一部分,就是这个基于文件的表演输出书。

562
00:33:52,760 --> 00:33:54,860
这个0就代表SDD1就是读,

563
00:33:55,700 --> 00:33:58,100
stdout就是写 就是1和2都是代表

564
00:33:58,100 --> 00:34:04,340
本来还有stderr 就是错误输出

565
00:34:04,340 --> 00:34:06,920
那我们这里面统一把这个去掉 简化

566
00:34:06,920 --> 00:34:08,300
就是一个stdout

567
00:34:09,800 --> 00:34:12,540
然后这里面其实就重新封装一下

568
00:34:12,540 --> 00:34:16,180
就把这个 如果你这个文件描述是零的

569
00:34:16,720 --> 00:34:19,640
就是要读 文件描述是零这种文件

570
00:34:19,640 --> 00:34:21,080
它实际上它这个所谓的读

571
00:34:21,080 --> 00:34:24,520
就是把它直接调到call

572
00:34:24,520 --> 00:34:27,340
通过这个SBI接口得到一个符号

573
00:34:27,340 --> 00:34:30,380
当然这里面读的话可能是读一个buffer

574
00:34:30,380 --> 00:34:33,140
所以你每次的call可能实际上是一个字符

575
00:34:33,140 --> 00:34:36,280
所以你实际上这个循环会读出多个字符

576
00:34:36,280 --> 00:34:39,440
写也是一样 就是往这个所谓的创口去写

577
00:34:39,440 --> 00:34:41,100
就put chance也是一个字符

578
00:34:41,100 --> 00:34:43,800
那你也是一个循环 把它一个一个写下去

579
00:34:43,800 --> 00:34:47,540
其实就在于把这个read和write这个文件接口

580
00:34:47,540 --> 00:34:54,840
和我们的SBI 更底层这种之下的一个创口的输入输出

581
00:34:54,840 --> 00:34:58,260
给它对接起来 包装起来 封装了一下

582
00:34:58,260 --> 00:35:00,480
这就是实现了所有的文件结构

583
00:35:00,480 --> 00:35:04,260
在实现文件结构之后 我们对0和对1的处理

584
00:35:04,260 --> 00:35:06,500
实际上对0的毒就是掉了这个

585
00:35:07,520 --> 00:35:10,160
对1的血就掉它 这就完成了

586
00:35:10,160 --> 00:35:13,740
所以它这个TK文件的标准输出非常简单

587
00:35:13,740 --> 00:35:18,560
就是对 FDTable 重新做了一下管理和配置

588
00:35:18,960 --> 00:35:20,160
包装了一下

589
00:35:22,420 --> 00:35:23,340
那这是一个

590
00:35:23,340 --> 00:35:27,320
第二个需要注意的是我们后面在创建进程的时候

591
00:35:27,320 --> 00:35:28,600
创建进程的时候

592
00:35:29,120 --> 00:35:33,020
我们会缺省的把 0、1、2 给设置好

593
00:35:33,020 --> 00:35:35,600
就相当于是把 FDTable 只要你创建一个进程

594
00:35:35,600 --> 00:35:38,900
那么 FDTable 里面的前三项

595
00:35:38,900 --> 00:35:40,440
0、1、2 就设置好了

596
00:35:40,440 --> 00:35:42,480
这个进程就不用 care 这个事情

597
00:35:42,480 --> 00:35:51,880
实际上进程就有确诊认识,就是说,只要我在执行,我就知道0是从创口

598
00:35:51,880 --> 00:36:00,120
输入,1和2是通过创口输出,这就是我们的OS给它建好的一部分的内

599
00:36:00,120 --> 00:36:04,640
容,你就可以直接用,你也不需要去专门的去做,我们前面讲对文件要有一个

600
00:36:04,640 --> 00:36:10,140
Open,它不需要,它已经等于是帮你做了Open的输出化工作,这就是这一块。

601
00:36:10,140 --> 00:36:13,120
而且在FOC的时候需要注意

602
00:36:13,120 --> 00:36:15,220
FOC的时候其实这个FDTable是一个什么

603
00:36:15,220 --> 00:36:16,900
我们说FD是一个资源

604
00:36:16,900 --> 00:36:19,840
所以FDTable也是一个资源的集合了

605
00:36:20,660 --> 00:36:23,400
所以我们复兴程在创建紫禁程的时候

606
00:36:24,040 --> 00:36:26,260
你这个紫禁程需要什么

607
00:36:26,260 --> 00:36:29,200
需要重新复制一份新的FDTable

608
00:36:29,840 --> 00:36:31,260
既然复制一份新的FDTable

609
00:36:31,260 --> 00:36:32,560
那么对于我们前面那个来说

610
00:36:32,980 --> 00:36:34,840
012也是一样的

611
00:36:34,840 --> 00:36:37,920
对于紫禁程它012还是和复兴程012是一样

612
00:36:37,920 --> 00:36:43,080
都指向了我们说的这个创口的输入和输出的这么一个操作

613
00:36:44,440 --> 00:36:46,300
这是Fock复制的时候

614
00:36:46,300 --> 00:36:52,400
那么对于这是对我们这个进程空中块的一个扩展

615
00:36:52,400 --> 00:36:55,840
那么对于管道对于管道而言

616
00:36:55,840 --> 00:36:57,280
它增加了两个性能代用

617
00:36:57,280 --> 00:36:58,530
第一很重要叫SysPype

618
00:37:02,150 --> 00:37:10,130
SysPype就是返回了一个长度为2的数组

619
00:37:10,130 --> 00:37:15,330
这个数组里面将来是PypeFD0和PypeFD1

620
00:37:16,150 --> 00:37:20,030
0和1你可以一个用来读一个用来写

621
00:37:20,030 --> 00:37:22,050
当然你如果返回的是-1的话

622
00:37:22,050 --> 00:37:23,330
就是还有return一个值

623
00:37:23,330 --> 00:37:25,650
返回是-1的话表面出错了

624
00:37:25,650 --> 00:37:27,130
如果是正确的话应该返回0

625
00:37:27,130 --> 00:37:30,190
这是它的一个设置

626
00:37:30,190 --> 00:37:31,510
那输出的原因很多种

627
00:37:31,510 --> 00:37:33,330
比如说你这个地址不对等等

628
00:37:35,730 --> 00:37:37,750
当然还有其他的一些输出的情况

629
00:37:37,750 --> 00:37:39,690
这就是我们说我们做潮景的时候

630
00:37:39,690 --> 00:37:41,730
一定要考虑的比较全面

631
00:37:41,730 --> 00:37:42,870
这里面我虽然没有说

632
00:37:42,870 --> 00:37:43,870
大家可以想一下

633
00:37:43,870 --> 00:37:46,390
比如说你FD满了怎么办

634
00:37:46,390 --> 00:37:47,550
或者说其他一些情况

635
00:37:47,550 --> 00:37:49,610
这都是需要大家去

636
00:37:49,610 --> 00:37:51,770
在写OS的时候需要去注意的一些问题

637
00:37:53,350 --> 00:37:58,590
好,那FD只是说我建立了一个文件描述符,

638
00:37:58,730 --> 00:38:03,970
但是文件描述符指向的那个实际的pipe所对应的那个内存并没有,

639
00:38:04,190 --> 00:38:08,470
这是我们说的要建立一个buffer,还是要有个buffer。

640
00:38:08,890 --> 00:38:12,530
所以我们在pipe的时候,就是我们说调pipe shuntdown的时候,

641
00:38:12,650 --> 00:38:16,970
除了建立这个文件描述符之外,我们还需要把这个buffer给建好,

642
00:38:16,970 --> 00:38:19,310
这个buffer就是这里面大致的一个结构

643
00:38:19,310 --> 00:38:22,490
你看这是一个 这是它的实际的array

644
00:38:23,070 --> 00:38:24,330
那为什么叫ring呢

645
00:38:24,330 --> 00:38:27,590
实际上就是它像类似于一个环一样

646
00:38:27,590 --> 00:38:29,590
我写写写 写满了之后

647
00:38:29,590 --> 00:38:31,430
我就会从头开始进一步写

648
00:38:31,430 --> 00:38:34,650
就是像一个环一样 不停地往里面前冲

649
00:38:34,650 --> 00:38:40,210
这是所谓这个iprring的一个含义

650
00:38:40,210 --> 00:38:43,430
那这里面需要记录很重要的一些信息

651
00:38:43,430 --> 00:38:47,190
比如说它这个读的位置在哪儿 写的位置在哪儿

652
00:38:48,810 --> 00:38:50,610
这个是pipe里面很重要的一点

653
00:38:50,610 --> 00:38:56,090
然后这个还有一个整个buffer的头和尾在什么地方

654
00:38:56,090 --> 00:38:57,170
因为你一直在读写

655
00:38:57,170 --> 00:39:00,350
所以这个头和尾其实它也在动态的变化中

656
00:39:00,350 --> 00:39:05,230
这是我们关于pipe的一个结构的一个简单的描述

657
00:39:05,230 --> 00:39:10,610
需要注意这个东西并不在TCB里面

658
00:39:10,610 --> 00:39:15,630
这个buffer它应该在我们说应该在超级桶里面

659
00:39:15,630 --> 00:39:19,930
你这里面的只是某一个打开的FD指向它而已

660
00:39:20,590 --> 00:39:23,030
所以我在创建 我在比如说指进层

661
00:39:23,030 --> 00:39:25,270
附近的指进层你复制的是这一部分

662
00:39:25,270 --> 00:39:27,390
你这个东西还只有一份

663
00:39:27,390 --> 00:39:29,750
只是说我另外一个指进层

664
00:39:29,750 --> 00:39:34,250
它里面的FD table里面的某一项也指向它而已

665
00:39:34,250 --> 00:39:36,510
这个需要注意 这也是一块

666
00:39:36,510 --> 00:39:38,770
你叫PCB或者TCB也好

667
00:39:38,770 --> 00:39:40,010
就是反正这是一个TCB

668
00:39:40,010 --> 00:39:40,790
这是一个PCB

669
00:39:42,010 --> 00:39:45,610
他们的某一个FD指向了同一个PAP

670
00:39:45,610 --> 00:39:46,990
只是一个FD用于读

671
00:39:46,990 --> 00:39:48,470
一个FD用于写而已

672
00:39:52,090 --> 00:39:56,370
那你有了这个buffer之后

673
00:39:56,370 --> 00:39:57,330
有了这个buffer之后

674
00:39:57,330 --> 00:39:58,910
接下来就是要对这buffer

675
00:39:58,910 --> 00:40:00,070
准备一些读和写的问题

676
00:40:00,070 --> 00:40:01,210
所以你会看到

677
00:40:01,210 --> 00:40:05,470
它专门提供了跟我们说的那个标准Io一样

678
00:40:05,470 --> 00:40:08,390
它有一个Read&Write的一个特定的一个Read&Write

679
00:40:08,390 --> 00:40:10,910
接口是一样 但是距离实现不一样

680
00:40:10,910 --> 00:40:13,710
来完成对这个Buffer的读和写

681
00:40:13,710 --> 00:40:15,710
那个Buffer读和写很重要点在于你冲哪儿还是读

682
00:40:15,710 --> 00:40:17,710
冲哪儿还是写 所以它的这个位置

683
00:40:18,250 --> 00:40:19,870
随着你的读写它一直在变化

684
00:40:19,870 --> 00:40:22,710
这是一个我们叫顺序读写的一个过程

685
00:40:23,730 --> 00:40:28,610
好 这是这一块 把这几个实现完之后呢

686
00:40:28,610 --> 00:40:33,410
那其实我们说这个pipe基本上就算是完成了

687
00:40:33,410 --> 00:40:37,650
当我们的应用程序在创建完PAP之后发出这个读和写之后

688
00:40:37,650 --> 00:40:39,890
其实最终会落到这里面的读

689
00:40:40,610 --> 00:40:46,210
就这里面的这个读或者写来完实际的读写操作

690
00:40:48,810 --> 00:40:54,330
这是关于PAP这一块的一些功能的一些介绍

691
00:40:54,330 --> 00:40:58,930
那么为了能够支持所谓的我们说A

692
00:41:31,450 --> 00:41:33,490
那么我们之前只是有个parse

693
00:41:33,490 --> 00:41:34,930
你要执行哪个程序就完了

694
00:41:34,930 --> 00:41:36,570
现在除了程序之外呢

695
00:41:36,570 --> 00:41:37,750
这个程序还带了一些参数

696
00:41:38,130 --> 00:41:42,110
所以你对这个exec那样有一定的扩展

697
00:41:42,110 --> 00:41:43,390
那么有了这个扩展之后呢

698
00:41:43,390 --> 00:41:49,370
我们就可以对share程序做出同样的扩展

699
00:41:49,370 --> 00:41:51,550
这个share程序是让你带了参数之后

700
00:41:51,550 --> 00:41:52,710
你可以把参数识别出来

701
00:41:52,710 --> 00:41:57,650
然后调exec来根据这个参数来执行

702
00:41:58,330 --> 00:42:00,530
那么这只是一个接口层面的一个事情

703
00:42:00,530 --> 00:42:02,190
命令上参数的一个支持

704
00:42:02,190 --> 00:42:06,030
那么你如果具体到超级种内部来说的话

705
00:42:06,030 --> 00:42:07,410
你其实还是要有一个实现

706
00:42:07,410 --> 00:42:09,530
这个实现就是我们说的这个

707
00:42:10,010 --> 00:42:12,390
对内核里面的这个exec

708
00:42:13,070 --> 00:42:14,410
怎么去支持的问题

709
00:42:15,650 --> 00:42:19,690
这个支持其实就是要考虑到这个参数farm

710
00:42:20,070 --> 00:42:21,950
这个参数其实放在这个

711
00:42:21,950 --> 00:42:23,570
我们说的用户都有自己的站买

712
00:42:23,570 --> 00:42:24,890
用户站

713
00:42:24,890 --> 00:42:26,550
就是应用程序在执行的时候

714
00:42:26,550 --> 00:42:28,410
进程在这里它有个用户带有个内核站

715
00:42:28,730 --> 00:42:32,790
那么在开始执行之前会把所有的参数压在上面去

716
00:42:32,790 --> 00:42:36,570
同时会设置两个东西

717
00:42:36,570 --> 00:42:39,450
比如说设置一个A0集成器放什么命令上参数的个数

718
00:42:40,310 --> 00:42:41,750
而A1集成器放什么

719
00:42:41,750 --> 00:42:44,230
放这个参数的其实位置在这里

720
00:42:44,770 --> 00:42:47,030
所以像这个地方实际上就是A0

721
00:42:47,030 --> 00:42:48,810
这里面标识是0的 只是标识0

722
00:42:48,810 --> 00:42:52,930
比如这里面会 甲定应该有几个参数呢

723
00:42:52,930 --> 00:42:56,070
这里面写的是两个参数

724
00:42:57,290 --> 00:43:01,930
那么从这开始 ARGV0是第一个参数

725
00:43:01,930 --> 00:43:02,730
它指向这个地方

726
00:43:02,730 --> 00:43:04,450
所以它第一个参数是AA

727
00:43:05,070 --> 00:43:07,610
第二个参数 ARGV1呢

728
00:43:07,610 --> 00:43:08,490
指向的是这个地方

729
00:43:08,490 --> 00:43:10,230
那实际上它的参数是BB

730
00:43:11,030 --> 00:43:12,570
所以对于这个来说

731
00:43:12,570 --> 00:43:13,330
AX1试验的时候

732
00:43:13,330 --> 00:43:15,230
它实际上参数是两个

733
00:43:16,390 --> 00:43:18,170
这个需要注意一下

734
00:43:18,170 --> 00:43:21,550
那么我们有了这个A0A1这些分析之后呢

735
00:43:21,550 --> 00:43:26,250
其实我们就可以从这个用户站里面把这个进一步的参数给读出来

736
00:43:26,250 --> 00:43:29,830
来让我们程序根据这个输入参数来进行进一步的执行

737
00:43:30,550 --> 00:43:31,990
这个大家需要去了解

738
00:43:31,990 --> 00:43:35,190
比如在这里面就是可以看到我们的

739
00:43:36,430 --> 00:43:37,170
就是libc里面

740
00:43:37,170 --> 00:43:39,410
就是我们的lib,lib库里面

741
00:43:39,410 --> 00:43:40,270
lib库里面呢

742
00:43:40,270 --> 00:43:42,290
就用了它,lib库里面就确实

743
00:43:42,290 --> 00:43:45,950
它里面就把这个ARGC,ARGV就放在这边

744
00:43:45,950 --> 00:43:50,990
这个就是我们说的这个A0,A1集成器的内容

745
00:43:50,990 --> 00:43:54,470
有了它之后,我们就可以把这个站里面的信息给读出来

746
00:43:55,750 --> 00:43:59,450
这是配合着那个用户带的库所用的知识

747
00:43:59,450 --> 00:44:01,790
这个库最终会调MAT,MAT函数

748
00:44:01,790 --> 00:44:06,510
MAT函数来进入我们实际用程序这个组执行部分

749
00:44:06,510 --> 00:44:07,510
开始执行

750
00:44:10,490 --> 00:44:13,590
好,那我们其实讲到这儿还没有讲到去怎么去重订项

751
00:44:13,590 --> 00:44:15,250
还没讲重订项,我们看看怎么来重订项

752
00:44:15,250 --> 00:44:18,630
为了重新重订项,我们还有一个很特殊的一个系统调用

753
00:44:25,330 --> 00:44:29,450
就是将进程中已经一个打开的文件描述服务复制一份

754
00:44:29,450 --> 00:44:32,010
分别到一个新的文件描述服务里面

755
00:44:32,010 --> 00:44:33,450
这里面需要注意的是

756
00:44:33,450 --> 00:44:34,450
它复制

757
00:44:34,870 --> 00:44:37,470
它比如说这个FD已经是一个打开的文件

758
00:44:37,470 --> 00:44:38,670
它会产生一个新的FD

759
00:44:38,670 --> 00:44:40,570
另外一个FD

760
00:44:40,570 --> 00:44:41,130
防护威胁

761
00:44:41,130 --> 00:44:43,170
这是它的一个防护威胁

762
00:44:43,590 --> 00:44:44,430
这个iSize

763
00:44:44,430 --> 00:44:46,550
但如果错误的话可能就是负一了

764
00:44:46,550 --> 00:44:47,190
讲的正确的话

765
00:44:47,190 --> 00:44:48,610
它应该是一个大于零的另外一个FD

766
00:44:48,610 --> 00:44:50,230
大于0.0那个另外一个fd

767
00:44:51,710 --> 00:44:55,110
那这是为什么要这么做啊

768
00:44:55,110 --> 00:44:55,970
先看它怎么实现

769
00:44:55,970 --> 00:44:57,450
然后我们再讲为什么怎么做

770
00:44:57,450 --> 00:45:00,350
这个实现就是它在这个内部

771
00:45:00,350 --> 00:45:02,950
会去专门调一个分配fd的一个函数

772
00:45:02,950 --> 00:45:07,850
那分配fd的话就是会去找这个fd table里面

773
00:45:07,850 --> 00:45:11,410
fd table里面最小的一个空闲的fd是啥

774
00:45:12,110 --> 00:45:15,150
如果找到了最小的最小边最小值

775
00:45:15,150 --> 00:45:18,510
就是从0开始一直到n

776
00:45:18,510 --> 00:45:22,250
那么在这里面哪一个这个FDTable里面哪一个是空闲

777
00:45:22,250 --> 00:45:23,910
比如0是空闲就是把0给分出来

778
00:45:23,910 --> 00:45:25,650
如果是1是空闲就把1分出去

779
00:45:25,650 --> 00:45:27,030
这就是找一个最小值

780
00:45:27,030 --> 00:45:28,510
找到最小值之后呢

781
00:45:28,510 --> 00:45:29,010
空闲值呢

782
00:45:29,010 --> 00:45:30,590
然后就把它复制给这里面

783
00:45:30,590 --> 00:45:31,670
这个一旦复制之后

784
00:45:31,670 --> 00:45:34,110
那这个另外FD就不空闲了

785
00:45:34,110 --> 00:45:34,930
也被占用了

786
00:45:34,930 --> 00:45:36,570
这个需要注意一下

787
00:45:39,730 --> 00:45:42,210
那其实这个为什么这么做

788
00:45:42,210 --> 00:45:44,290
在于就是我们能够支持重新一项的功能

789
00:45:44,290 --> 00:45:47,290
偶尔自动重新下 我们看看怎么来自动重新下

790
00:45:48,450 --> 00:45:51,110
这是对Urshare它做了扩展

791
00:45:51,110 --> 00:45:55,450
因为Urshare可以支持有这个

792
00:45:55,450 --> 00:45:59,710
我们前面说的这种参数的支持

793
00:45:59,710 --> 00:46:01,250
有参数的支持 还有什么呢

794
00:46:01,250 --> 00:46:04,450
还有这个所谓的这个新的信用应用的支持

795
00:46:04,450 --> 00:46:06,550
有PAP的支持 合在一起之后呢

796
00:46:06,550 --> 00:46:08,370
我们就可以完成非常有意思的功能

797
00:46:08,370 --> 00:46:11,370
就刚才我们说的把A的输出作为B的输入

798
00:46:11,370 --> 00:46:13,850
这个事怎么来做 这里面就给了一个例子

799
00:46:15,330 --> 00:46:20,850
对于我们的Share来说,Share是附近层,这个Share代表的是附近层

800
00:46:22,950 --> 00:46:28,930
那么A和B是直径乘1,直径乘2,这是两个直径乘

801
00:46:30,370 --> 00:46:33,470
所以我的Share程序看了这么一条命令之后呢

802
00:46:33,470 --> 00:46:39,110
我会把它拆成三部分,一个A,一个管道,一个B

803
00:46:40,050 --> 00:46:43,230
那么A代表是我要看到A之后,我知道它是一个直径程序

804
00:46:43,230 --> 00:46:46,710
当然这里面没有材质 这是做了非常简化的一个设计

805
00:46:46,710 --> 00:46:50,990
变成之后 我们看到A是一个指令层 B是一个指令层

806
00:46:54,790 --> 00:46:57,150
OK 现在是下课休息时间

807
00:46:57,150 --> 00:46:59,570
咱们先休息五分钟 然后继续再给大家讲解

808
00:52:09,350 --> 00:52:13,010
好 我们开始上课

809
00:52:19,070 --> 00:52:23,450
我看到聊天群里面有同学在问

810
00:52:23,450 --> 00:52:28,430
那个pipe怎么确定哪个是读哪个是写

811
00:52:28,430 --> 00:52:33,190
首先我们这里面没有一个说标准

812
00:52:33,190 --> 00:52:34,490
更多是种约定

813
00:52:34,490 --> 00:52:36,330
约定和标准还是不太一样

814
00:52:36,330 --> 00:52:37,110
约定什么呢

815
00:52:37,110 --> 00:52:39,050
0 我们先说012

816
00:52:39,050 --> 00:52:42,990
012实际上就是我们说的标准的

817
00:52:42,990 --> 00:52:46,370
文件输入输出的描述符

818
00:52:46,370 --> 00:52:49,810
0代表的是输入,就是读

819
00:52:49,810 --> 00:52:52,990
而1和2代表的是输出,写

820
00:52:53,750 --> 00:52:57,650
如果是读的话,就代表我们要对应的文件是要做read操作

821
00:52:57,650 --> 00:52:59,330
你做write操作没有任何意义

822
00:52:59,330 --> 00:53:01,610
或者说是取决理是实现

823
00:53:01,610 --> 00:53:05,690
我们的os可能会给它报错或者说是没有任何效果

824
00:53:06,450 --> 00:53:08,890
而1实际上是写,就是write

825
00:53:08,890 --> 00:53:16,310
就是我要看01是写,对,写的话,那就是我要对它做write,那你要做read的话,其实也得不到

826
00:53:16,310 --> 00:53:21,970
什么东西,这取决于我们那个把它定义向那个device视察,我们这边说是用,我们

827
00:53:21,970 --> 00:53:29,590
现在在实验中用是串口,那实际的general OS中也有可能是它把这个0

828
00:53:29,590 --> 00:53:36,410
定义到什么,定义到键盘,1定义到屏幕,这也是有可能的,就像我们现在看到

829
00:53:36,410 --> 00:53:38,870
的,这取决于我们这个OS

830
00:53:40,050 --> 00:53:48,570
对于我们现在的OS来说,我们可以把它影响到一个特殊的串口设备里面,串

831
00:53:48,570 --> 00:53:51,650
口设备既支持鼓蕾自制器,这是一个。

832
00:53:51,810 --> 00:53:59,770
第二个,怎么来判断呢?其实我理解从你用这种pipe,穿进这个pipe之后,这个0

833
00:53:59,770 --> 00:54:05,830
和1,不叫pipe的0和1,而叫pipe的两个描述符,你怎么去绑定去约

834
00:54:05,830 --> 00:54:06,090
你?

835
00:58:06,090 --> 00:58:07,810
意味着它指向同一个pipe

836
00:58:07,810 --> 00:58:10,450
这样pipe的写端

837
00:58:10,970 --> 00:58:13,150
然后再close fd

838
00:58:13,150 --> 00:58:15,230
那意味着这里面我写

839
00:58:15,230 --> 00:58:17,790
我这个其实close不是必须的

840
00:58:17,790 --> 00:58:20,350
这个close就是要避免了两个

841
00:58:20,350 --> 00:58:23,630
通过两个fd对同一个pipe已经写

842
00:58:23,630 --> 00:58:25,430
操作这么一个可能性

843
00:58:25,430 --> 00:58:28,910
那这样使得只能通过0来进行写

844
00:58:29,670 --> 00:58:31,650
这样这个0已经变成了什么

845
00:58:31,650 --> 00:58:37,650
变成了这个output fd这么一个指向的那个pipe了

846
00:58:38,730 --> 00:58:40,850
然后再做什么呢 再做exec

847
00:58:41,530 --> 00:58:43,370
执行什么 执行a

848
00:58:43,370 --> 00:58:44,750
所以在执行a的时候

849
00:58:44,750 --> 00:58:48,510
这个a的执行程序

850
00:58:48,510 --> 00:58:50,230
我们知道前面讲的exec

851
00:58:51,370 --> 00:58:52,950
它的代码段 数据段

852
00:58:52,950 --> 00:58:57,350
用户的空间都已经重新被a所覆盖了

853
00:58:57,350 --> 00:59:01,090
但是它的TCB或者PCB 进程控制块里面的

854
00:59:01,090 --> 00:59:04,110
那个SDTable这一块

855
00:59:04,110 --> 00:59:06,610
它的那个0指向实际上是一个pipe

856
00:59:06,610 --> 00:59:08,790
这一块是传下去了的

857
00:59:08,790 --> 00:59:10,750
所以对于Air而言

858
00:59:10,750 --> 00:59:13,690
它以为比如它要去做一个print

859
00:59:14,770 --> 00:59:16,790
它以为的这个输出

860
00:59:16,790 --> 00:59:18,710
输到所谓的串管上去的

861
00:59:18,710 --> 00:59:21,170
其实是你这里面0已经指向这了

862
00:59:21,170 --> 00:59:22,770
print最终是write0

863
00:59:22,770 --> 00:59:26,050
write0一个buffer

864
00:59:26,050 --> 00:59:27,550
那这个0实际上指向是pipe

865
00:59:27,550 --> 00:59:30,270
所以你实际上是往pipe里面做写操作

866
00:59:30,270 --> 00:59:35,090
这就是这个A的行为其实已经被改变了

867
00:59:35,090 --> 00:59:36,530
就是Io重订一项

868
00:59:36,530 --> 00:59:38,550
对于B而言也是一样的

869
00:59:38,550 --> 00:59:39,990
你看B的话就在这一块

870
00:59:39,990 --> 00:59:41,410
这是B指令层

871
00:59:41,410 --> 00:59:43,770
它是另外一个FD就是InputFD

872
00:59:43,770 --> 00:59:45,810
那么你Close什么Close0

873
00:59:45,810 --> 00:59:47,470
Close0之后关闭了文件描述0

874
00:59:48,090 --> 00:59:49,210
再DARP一下

875
00:59:49,210 --> 00:59:51,670
那使得文件描述0和这个文件描述服务

876
00:59:51,670 --> 00:59:53,610
InputFD指向同一个文件

877
00:59:53,610 --> 00:59:55,610
实际上指向Pub的Read那一端

878
00:59:55,610 --> 00:59:57,330
这一端Read这一端

879
00:59:57,330 --> 00:59:59,250
然后CloseInputFD

880
00:59:59,250 --> 01:00:07,710
那么这个1指向什么,1指向的是B进程的,它要去read的那一块的操作

881
01:00:07,710 --> 01:00:10,990
你read是向read什么,read是这个pipe的read端

882
01:00:11,850 --> 01:00:15,250
但对于B和A而言,这两个竞争人其实他们不知道

883
01:00:15,250 --> 01:00:23,530
因为这都是在做这个exec之前,我们的share做了一系列的这些辅助操作

884
01:00:23,530 --> 01:00:26,570
或者叫做pipe环境接力操作,重新向操作

885
01:00:26,570 --> 01:00:29,670
把都建好之后 再去分辨自行线是谁

886
01:00:29,670 --> 01:00:31,510
从而达到了说

887
01:00:32,170 --> 01:00:36,690
这个A和B通过一个pipe的buffer

888
01:00:36,690 --> 01:00:40,570
来完成了写和读这么一个过程

889
01:00:40,570 --> 01:00:43,130
这就是重新项的一个实现

890
01:00:43,130 --> 01:00:44,630
你可以看到这个实现里面

891
01:00:44,630 --> 01:00:46,830
除了我们超新网要做一些事情之外

892
01:00:46,830 --> 01:00:48,730
我们的share也很重要的一个工作

893
01:00:48,730 --> 01:00:53,370
它要把这个pipe的环境要重新构建一下

894
01:00:53,370 --> 01:00:55,110
实现所谓的IO重新项

895
01:00:55,110 --> 01:00:56,170
才能把事情给做好

896
01:00:57,890 --> 01:01:03,330
OK 好 那这个就把这个Pub这一块做了一个简单的介绍

897
01:01:03,330 --> 01:01:05,150
第二 我们讲一下Signal的实现

898
01:01:05,150 --> 01:01:07,450
Signal和Pub还是很不一样的

899
01:01:07,450 --> 01:01:09,790
因为它并不是基于文件的一个抽象

900
01:01:09,790 --> 01:01:11,750
那么Signal有相应的一些系统调用

901
01:01:11,750 --> 01:01:13,450
它有核心税结构

902
01:01:13,450 --> 01:01:16,770
重点是建立好Signal Handler

903
01:01:16,770 --> 01:01:19,730
这一块就相当于是信号处理历程

904
01:01:21,190 --> 01:01:25,390
以及基于Send发送信号 接收信号处理

905
01:01:25,390 --> 01:01:30,970
中间涉及到了上下纹切换的一个,或者上下纹改变的一个事情,这个上下纹

906
01:01:30,970 --> 01:01:34,770
重点是哪个上下纹,这里面有很多上下纹,我们前面说的这么多上下纹

907
01:01:34,770 --> 01:01:39,590
里面主要是这个上下纹,陷入上下纹,大家可以看看怎么来处理的。

908
01:01:41,070 --> 01:01:44,630
首先,了解一下系统雕用,它做了一些创建。

909
01:01:45,450 --> 01:01:50,310
SigAction,这个是设置新的信号处理地层。

910
01:01:50,650 --> 01:01:56,890
这个是设置一个屏蔽位,比如你不想响应的一个信号,你可以设置一下Mask来

911
01:01:56,890 --> 01:01:58,330
屏蔽某个信号。

912
01:01:58,630 --> 01:02:00,630
Keyout感的Send发送。

913
01:02:01,150 --> 01:02:06,650
SigReturn实际上就是能够,你必须理解为这个恢复的一个过程。

914
01:02:06,650 --> 01:02:12,950
它能够回到上次被打断的地方,正常执行,是要干这个事情,被打断的

915
01:02:12,950 --> 01:02:13,850
正常执行。

916
01:02:14,550 --> 01:02:19,590
所以有了这个四个性能量之后,其实整个处理过程也就分了四部分,大家

917
01:02:19,590 --> 01:02:21,090
可以看看,这里面标出来了。

918
01:02:21,710 --> 01:02:24,590
这是进程A、进程B,进程A可以给进程B发信号。

919
01:02:24,830 --> 01:02:28,590
进程B为了认识小页信号,它需要一个Handler。这里面有四个步骤。

920
01:02:28,590 --> 01:02:33,190
第一步是通过SigAction建立SigHandler的对应关系

921
01:02:33,190 --> 01:02:36,970
就是把这个信号值和这个Signal这个东西

922
01:02:36,970 --> 01:02:38,070
给它建立对应关系

923
01:02:38,070 --> 01:02:38,790
这是第一步

924
01:02:40,070 --> 01:02:41,590
第二步建立对应关系之后

925
01:02:41,590 --> 01:02:44,630
我们的进程A就发信号用Key

926
01:02:44,630 --> 01:02:46,290
给这个PID这边简化了

927
01:02:46,290 --> 01:02:49,710
给这个进程B的PIDB

928
01:02:50,590 --> 01:02:52,590
给它发信号值

929
01:02:52,590 --> 01:02:54,070
那其实到内核里面了

930
01:02:54,070 --> 01:02:55,850
这个内核里面会查一下

931
01:02:55,850 --> 01:03:00,050
因为你前面已经建立好对于进程B而言

932
01:03:00,050 --> 01:03:04,290
它在内核里面有这么一个对应关系表

933
01:03:04,290 --> 01:03:06,630
KeyValue 这个Key对应这个Value

934
01:03:06,630 --> 01:03:08,410
所以它一查这个信号值

935
01:03:08,410 --> 01:03:09,650
在这个进程里面这个信号值

936
01:03:09,650 --> 01:03:12,430
其实有一个对应的Handler已经建好了

937
01:03:12,430 --> 01:03:18,450
所以它就会设置新的TrapContext

938
01:03:22,610 --> 01:03:23,950
设置新的TrapContext

939
01:03:23,950 --> 01:03:26,710
使得内核可以跳到进程B的这个地方去执行

940
01:03:26,710 --> 01:03:28,370
而不是之前的地方

941
01:03:28,370 --> 01:03:31,110
然后设置新的传统安装还要保留老的

942
01:03:31,110 --> 01:03:32,330
还有一个old的

943
01:03:32,330 --> 01:03:34,310
上一次的trap contest

944
01:03:36,010 --> 01:03:39,930
好 那么当这个SigHunter处理完相应指令之后

945
01:03:39,930 --> 01:03:41,470
它会执行SigReturn

946
01:03:41,470 --> 01:03:43,430
这个SigReturn干什么呢

947
01:03:43,430 --> 01:03:45,150
就是把这个老的一会恢复回来

948
01:03:46,090 --> 01:03:46,870
恢复回来之后

949
01:03:46,870 --> 01:03:48,230
我再一次返回的时候

950
01:03:48,230 --> 01:03:50,590
就从老的这里面指向那个位置返回

951
01:03:50,590 --> 01:03:53,210
就回到了正常被打的指令处

952
01:03:53,590 --> 01:03:55,170
这个指令处本来是绑在哪里?

953
01:03:55,190 --> 01:03:58,210
绑在老的Trap Context里面

954
01:03:59,230 --> 01:04:01,290
所以一旦执行这个Sigreturn之后

955
01:04:01,290 --> 01:04:03,310
就可以在下一次回到用户态的时候

956
01:04:03,310 --> 01:04:06,190
到了一个被打中的正常地方去执行

957
01:04:06,190 --> 01:04:09,210
这就是它的一个大致的信号处理过程

958
01:04:11,430 --> 01:04:15,370
你可以看看这边的一个SigAction很重要的结构就是这个

959
01:04:17,370 --> 01:04:18,630
把这个建立好

960
01:04:20,630 --> 01:04:25,990
由于它的灵活性,它还建立了一个Mask,如果没有灵活性,其实这个Handle就

961
01:04:25,990 --> 01:04:26,270
够了

962
01:04:26,270 --> 01:04:31,370
所以它在这边由Mask和Handle形成了整个SigAction里面信号

963
01:04:31,370 --> 01:04:33,750
处理的一个配置的一个碎结构

964
01:04:33,750 --> 01:04:37,890
这个是它的一个大致的结果,那么对应的系统要用的就是这个SigSigA

965
01:04:37,890 --> 01:04:38,230
ction

966
01:04:40,650 --> 01:04:44,890
同类也是一样,其他三个就是屏蔽位,这个我们用的比较少

967
01:04:44,890 --> 01:04:48,990
这个大致上主要阻碍某一些对信号的响应

968
01:04:48,990 --> 01:04:51,710
清除站 从信号历程返回

969
01:04:51,710 --> 01:04:55,010
将来建立新的恢复老的TrackContext

970
01:04:56,130 --> 01:04:58,490
然后SysKeyer就是发信号

971
01:04:59,670 --> 01:05:02,290
这个就是增加这四个系统加上的简单的描述

972
01:05:02,290 --> 01:05:03,670
其实除了第一个稍微复杂点

973
01:05:03,670 --> 01:05:06,570
后面三个就非常的简单

974
01:05:06,570 --> 01:05:09,070
至少在接口上非常简单

975
01:05:09,070 --> 01:05:11,810
那你可以看到我们说Signal也是

976
01:05:11,810 --> 01:05:12,910
在内核实验里面

977
01:05:12,910 --> 01:05:14,470
进入通知化里面Signal也是一个资源

978
01:05:16,930 --> 01:05:23,450
这里面有好几个结构,都是跟signal相关的,比较重要的,比如说我们前面

979
01:05:23,450 --> 01:05:31,430
说的在内核里面一个进程,它其实有一个表,就是信号处理历程表,这里面

980
01:05:31,430 --> 01:05:39,070
会有一个SIG的number,就是信号的值,对应的一个handle的ADDR。

981
01:06:12,430 --> 01:06:18,690
OK,那么对于SigAction的大致执行过程其实就是这样,就是保存老的OldA

982
01:06:18,690 --> 01:06:18,730
ction

983
01:06:18,730 --> 01:06:20,370
OldAction在哪儿保存呢?

984
01:06:20,430 --> 01:06:23,330
记得从这里面读出来,这里面有相应的一个表

985
01:06:23,330 --> 01:06:27,290
这个表里面给出了Handle和Mask的一个所谓的Action的结构

986
01:06:27,290 --> 01:06:31,370
所以在这里面可以把它恢复回来,然后再设置新的

987
01:06:32,150 --> 01:06:36,490
这个传回给用户台,这个OldAction会传给用户台

988
01:06:36,490 --> 01:06:43,910
表里面会设成新的SELECTION,这个是它实际做的过程,对PCB的

989
01:06:43,910 --> 01:06:44,910
一个修改。

990
01:06:46,130 --> 01:06:50,490
然后Kill怎么做?Kill其实也很简单,你Kill不带了个PID吗?

991
01:06:51,670 --> 01:06:58,630
带了PID,所以根据PID就知道它的PCB在哪,找到PCB。

992
01:06:58,630 --> 01:07:07,150
然后就去在它里面说,我正在pending,你要插一个,说你现在有这个信号要响

993
01:07:07,150 --> 01:07:07,890
应了,

994
01:07:07,950 --> 01:07:12,610
就插那个信号,插那个pending位里面,这样就在insert这里面去,使得它就知道,

995
01:07:12,650 --> 01:07:14,230
这一块我需要去响应。

996
01:07:16,570 --> 01:07:23,490
那么怎么响应,这是比较复杂的,就是一旦进程B收到了这个信号之后,怎么响

997
01:07:23,490 --> 01:07:25,270
应,这个稍微复杂一点。

998
01:07:25,270 --> 01:07:29,430
这是我觉得是理解信号最麻烦的地方

999
01:07:30,290 --> 01:07:34,370
但是我觉得只要大家能够对哪个结构对清楚呢

1000
01:07:35,950 --> 01:07:37,510
对这个理解清楚

1001
01:07:37,510 --> 01:07:40,350
那我觉得整个问题理解就比较容易

1002
01:07:40,870 --> 01:07:42,070
首先我们看看

1003
01:07:42,070 --> 01:07:45,390
这假设前面说进程A离进程B发信号

1004
01:07:45,390 --> 01:07:48,770
那么进程B如果还正在应务台执行的时候

1005
01:07:48,770 --> 01:07:50,310
其实它没发现信号

1006
01:07:50,310 --> 01:07:52,030
只有当它进入内核之后

1007
01:07:52,030 --> 01:07:53,530
需要注意这个时机在什么呢

1008
01:07:53,530 --> 01:07:56,910
当进程B通过中断也好 通过系统能量也好

1009
01:07:56,910 --> 01:07:58,850
总之它某种方式要进入内核

1010
01:07:58,850 --> 01:08:01,850
进入内核之后 它会到哪来

1011
01:08:01,850 --> 01:08:04,790
我们就重新回复一下 重新复习一下

1012
01:08:04,790 --> 01:08:09,790
对中断和异常响应的处理过程

1013
01:08:10,910 --> 01:08:13,230
OS接收到这个信息之后 它会到哪

1014
01:08:13,670 --> 01:08:16,770
我们说现在响应的不灵敏了

1015
01:08:24,230 --> 01:08:26,270
哎呀 这个好像确实有点慢了

1016
01:08:27,290 --> 01:08:30,890
AllTracks这么一个入口

1017
01:08:30,890 --> 01:08:36,430
在入口里面它会做TrackContext的保存以恢复

1018
01:08:36,430 --> 01:08:39,630
所以这里面就保存了当前这个APP

1019
01:08:39,630 --> 01:08:44,230
比如说进程B 执行到这个点之后

1020
01:08:44,230 --> 01:08:48,650
这个点的位置信息就保存在TrackContext里面

1021
01:08:48,650 --> 01:08:51,310
保存完之后还能以所有的计程器信息保存起来

1022
01:08:51,310 --> 01:08:52,850
然后再做TrackHandle

1023
01:08:52,850 --> 01:08:57,070
然后在具体处理,你是来自于系统调用,还是来自于中断,还是来自于异

1024
01:08:57,070 --> 01:08:57,650
常

1025
01:08:57,650 --> 01:09:00,910
处理完之后,在TrapHandle的最后部分

1026
01:09:01,470 --> 01:09:08,170
它会去看看当前进程是否有别人发过来的信号

1027
01:09:08,170 --> 01:09:13,450
就是叫HandleSignal,到这一步来查了

1028
01:09:13,450 --> 01:09:16,730
查有没有Pending的信号,结果它发现查到有Pending信号

1029
01:09:16,730 --> 01:09:19,890
原来有Pending信号,它会做两种处理

1030
01:09:19,890 --> 01:09:23,910
一种是说KernelSignalHandler, 还有一个是UserSignalHandler

1031
01:09:23,910 --> 01:09:27,770
所谓Kernel这个含义是什么呢?

1032
01:09:27,830 --> 01:09:31,670
这个含义是说有些缺陷处理

1033
01:09:31,670 --> 01:09:36,850
就是如果你不设置这个用户带 不设置SignalHandler的话

1034
01:09:36,850 --> 01:09:38,970
那么我们内核可以做一个缺陷处理

1035
01:09:38,970 --> 01:09:40,730
缺陷处理一般是把它care掉

1036
01:09:40,730 --> 01:09:43,390
把当前进程给杀掉

1037
01:09:43,390 --> 01:09:44,770
或者是忽略掉

1038
01:09:44,770 --> 01:09:47,810
这是取决于你的信号的缺陷配置

1039
01:09:47,810 --> 01:09:51,430
如果是一个被用户设置了的

1040
01:09:51,430 --> 01:09:53,090
那么就在这里面执行这一步了

1041
01:09:53,090 --> 01:09:54,150
CoreUserSignalHandle

1042
01:09:54,150 --> 01:09:57,370
这我们通常要去重点理解的

1043
01:09:57,370 --> 01:09:59,030
这个你前面不是建好一个表吗

1044
01:09:59,030 --> 01:10:01,410
这个表里面已经说了我有一个

1045
01:10:03,550 --> 01:10:07,390
Signal和对应的Handle的一个对应关系

1046
01:10:07,390 --> 01:10:08,250
那所以呢

1047
01:10:08,630 --> 01:10:09,970
我要干的第一件事情

1048
01:10:09,970 --> 01:10:12,450
就要构造一个新的一个TrapContext

1049
01:10:12,990 --> 01:10:15,090
在构造之前要保存老的TrapContext

1050
01:10:15,090 --> 01:10:18,710
要保存起来 就保存关于这一块的一个信息要保存起来

1051
01:10:18,710 --> 01:10:21,450
也相当于下次处理完TrapHandler之后

1052
01:10:21,450 --> 01:10:22,430
我还从这回去执行

1053
01:10:23,070 --> 01:10:25,750
所以老的TrapContact是要保存起来

1054
01:10:25,750 --> 01:10:27,530
保存完之后我要搞一个新的

1055
01:10:27,530 --> 01:10:31,690
搞个新的就是实际上把最主要是SEPC设置成Handle

1056
01:10:32,770 --> 01:10:33,970
意味着什么 回到用台的时候

1057
01:10:33,970 --> 01:10:39,170
一定要跳到Signal的Handle那个地方去执行

1058
01:10:39,170 --> 01:10:40,650
现在这个笔已经慢了

1059
01:10:41,850 --> 01:10:44,190
这个还是微软超系统哪地方响应不够及时

1060
01:10:45,830 --> 01:10:48,470
好 然后你这个到底是想要哪个

1061
01:10:48,470 --> 01:10:50,910
还有一个参数放在这个计程器里面

1062
01:10:50,910 --> 01:10:54,170
有个sig的一个number放在这个计程器10里面

1063
01:10:54,170 --> 01:10:56,150
把这个设置好之后我就可以

1064
01:10:56,150 --> 01:10:58,290
当然还有一些更detail的一些

1065
01:10:58,290 --> 01:11:02,010
比如说它这里面的站怎么处理

1066
01:11:02,010 --> 01:11:04,790
是用已有的站还是要建立新的站

1067
01:11:04,790 --> 01:11:06,590
这都是一些具体的实现细节

1068
01:11:06,590 --> 01:11:08,070
但大致比很重要的人知道

1069
01:11:08,070 --> 01:11:09,470
你这么来设置之后

1070
01:11:09,470 --> 01:11:12,390
当你再去restore

1071
01:11:12,390 --> 01:11:16,710
回到 回到 通过SIT回到用上去执行的时候呢

1072
01:11:16,710 --> 01:11:18,210
你回的是这个地址

1073
01:11:18,210 --> 01:11:20,050
已经不是之前的

1074
01:11:20,050 --> 01:11:20,570
这个地址

1075
01:11:22,230 --> 01:11:23,250
然后这就是

1076
01:11:23,630 --> 01:11:24,970
为什么能够去

1077
01:11:24,970 --> 01:11:25,950
只要我

1078
01:11:26,910 --> 01:11:30,350
我发了一个 进程A发了个信号之后 我进程B能够迅速的去执

1079
01:11:30,350 --> 01:11:32,290
行的一个原因就是执行了这么一块

1080
01:11:32,290 --> 01:11:33,010
代码

1081
01:11:33,010 --> 01:11:36,710
这边涉及到比较长的一个执行序列 所以把它标出来 大家可以理解一下

1082
01:11:38,290 --> 01:11:41,150
执行完之后还要回去啊 这边是第二个需要考虑的问题

1083
01:12:13,570 --> 01:12:16,330
然后包括其他一些计程器也都恢复了

1084
01:12:16,330 --> 01:12:18,550
然后在执行SIT之后就意味着

1085
01:12:18,910 --> 01:12:21,870
它要从之前被打断的地方继续执行

1086
01:12:21,870 --> 01:12:24,830
这就使得我们的应用程序

1087
01:12:24,830 --> 01:12:27,470
能够就像啥事也没发生一样

1088
01:12:27,470 --> 01:12:29,310
继续执行这个APP

1089
01:12:30,430 --> 01:12:32,830
所以这是CGreturn里面要处理的事情

1090
01:12:32,830 --> 01:12:34,490
大家能把这个想明白之后

1091
01:12:34,490 --> 01:12:39,350
我觉得整个信号处理机制就会比较清楚

1092
01:12:39,350 --> 01:12:43,510
核心是保存、恢复、修改、trap contest

1093
01:12:44,790 --> 01:12:47,350
这个理解就OK了

1094
01:12:47,950 --> 01:12:51,210
至于这个SIG block mask

1095
01:12:51,210 --> 01:12:55,350
我们说要屏蔽,它要做一些屏蔽操作

1096
01:12:57,890 --> 01:13:01,350
屏蔽操作,这个不是重点

1097
01:13:01,350 --> 01:13:05,910
大家知道它能够通过这个系统疗养能够屏蔽对某些信号的响应

1098
01:13:05,910 --> 01:13:08,810
但需要注意一点,有些信号是不可屏蔽的

1099
01:13:08,810 --> 01:13:10,750
就跟我们不可屏蔽中断一样

1100
01:13:10,750 --> 01:13:12,630
这有一些是不可屏蔽信号

1101
01:13:13,410 --> 01:13:15,450
这个细节不用太了解

1102
01:13:15,450 --> 01:13:22,110
但至少知道有些信号是必须要去通过OS来进行处理的

1103
01:13:22,110 --> 01:13:23,450
那我就

1104
01:13:24,730 --> 01:13:28,790
大致的把这个关于管道和信号

1105
01:13:28,790 --> 01:13:32,470
把这两个例子作为我们这个IPC的OS

1106
01:13:32,470 --> 01:13:35,130
需要重点理解的给大家做了一个介绍

1107
01:13:36,750 --> 01:13:37,990
那大家可以放心

1108
01:13:38,470 --> 01:13:43,490
我们其实并没有布置相应的实验去实现

1109
01:13:43,490 --> 01:13:45,410
我们的第五个实验刚布置

1110
01:13:45,410 --> 01:13:49,170
主要是涉及到同步互斥的一些

1111
01:13:49,170 --> 01:13:51,330
包括死锁的一些理解

1112
01:13:51,330 --> 01:13:58,410
信号和管道更多是在进程来往来做一些事情

1113
01:13:59,750 --> 01:14:02,430
希望大家通过对信号管道理解知道

1114
01:14:02,430 --> 01:14:05,050
我们进程之间其实也可以实现

1115
01:14:06,090 --> 01:14:09,030
数据的传递、消息的通知等等。

1116
01:14:10,410 --> 01:14:13,270
这是这一块的内容,就给大家整个介绍完毕。

1117
01:14:19,530 --> 01:14:23,050
好,那我看看同学有什么问题。

1118
01:14:23,450 --> 01:14:28,910
我看同学的问题是,请问这个和之前的中断处理是不是差不多?

1119
01:14:29,930 --> 01:14:33,970
和之前的中断处理比中断处理稍微不太一样,

1120
01:14:33,970 --> 01:14:37,970
就是在于我们说对那个TrapContext做了进一步的修改

1121
01:14:39,310 --> 01:14:41,970
你要说差不多 有点差不多 但是还是有差别

1122
01:14:43,910 --> 01:14:46,250
我再说一点 中断处理在哪儿不同

1123
01:14:46,250 --> 01:14:48,910
中断处理它是说

1124
01:14:48,910 --> 01:14:55,950
只要我的那个外设产生了比如失踪

1125
01:14:55,950 --> 01:14:57,370
只要产生了一个中断

1126
01:14:57,370 --> 01:15:01,050
当前我如果在用户态 进程在用户态执行的时候

1127
01:15:01,050 --> 01:15:05,530
那這個用戶態的這個無論直線上 它會迅速被打斷

1128
01:15:05,530 --> 01:15:09,070
進入到內核態去響應 用硬件有這個機制

1129
01:15:09,070 --> 01:15:11,850
這是硬件 我們說組成原理給大家講過

1130
01:15:11,850 --> 01:15:15,230
中斷是一種易步的 只要產生就迅速打斷單線上的執行

1131
01:15:15,230 --> 01:15:17,630
然後去到內核裡面去做對中斷的響應

1132
01:15:17,630 --> 01:15:19,970
這是中斷的處理 這是硬件中斷

1133
01:15:19,970 --> 01:15:23,150
但我們說這個信號實際上是軟件中斷

1134
01:15:23,150 --> 01:15:26,830
它是軟的話 既然是軟 其實它這個易步性就沒那麼強

1135
01:15:26,830 --> 01:15:32,270
什麼意思?我進程A給進程B發了一個信號

1136
01:15:33,670 --> 01:15:37,390
那麼假設我們考慮是就考慮是多核處理器

1137
01:15:37,390 --> 01:15:38,710
這樣可能更好理解一點

1138
01:15:38,710 --> 01:15:40,590
就兩個處理器 兩個核

1139
01:15:40,590 --> 01:15:44,090
一個核跑進程A 另一個核跑進程B

1140
01:15:44,090 --> 01:15:46,450
那麼進程A給進程B發了一個信號

1141
01:15:46,970 --> 01:15:48,250
那麼我發信號的時候

1142
01:15:48,250 --> 01:15:50,230
我進程A是signal的一個信號

1143
01:15:50,230 --> 01:15:52,910
然後內核裡面把記錄進程B的結構裡面去了

1144
01:15:52,910 --> 01:15:55,690
但是這個進程B還在用戶態執行

1145
01:15:55,690 --> 01:15:57,750
只要进程B在用后来执行

1146
01:15:57,750 --> 01:15:59,430
你进程A发这个信号

1147
01:15:59,430 --> 01:16:02,890
它就不能及时让进程B去响应

1148
01:16:02,890 --> 01:16:05,490
为什么呢 因为进程B还没到内核里面来

1149
01:16:05,490 --> 01:16:07,350
只有进程B通过某种方式

1150
01:16:07,350 --> 01:16:08,550
它自己发的信号要用

1151
01:16:08,550 --> 01:16:10,050
或者是产生了一个中断

1152
01:16:10,050 --> 01:16:12,030
它到了内核里面之后

1153
01:16:12,030 --> 01:16:16,390
才会在这个内核的TrapHandler的最后那一步

1154
01:16:16,390 --> 01:16:18,610
来完成对信号的处理

1155
01:16:18,610 --> 01:16:21,290
所以从这个即时性上来说

1156
01:16:21,290 --> 01:16:23,290
它的即时性不如中断的

1157
01:16:23,290 --> 01:16:25,330
硬件中断处理的极致性强

1158
01:16:26,030 --> 01:16:27,390
它必须要等到

1159
01:16:28,430 --> 01:16:31,250
进程币到了内核里面之后才能处理

1160
01:16:32,010 --> 01:16:33,010
处理这个

1161
01:16:33,790 --> 01:16:34,470
信号

1162
01:16:34,470 --> 01:16:35,830
一个极端情况来说

1163
01:16:36,810 --> 01:16:38,610
我必须要等到这个时间片

1164
01:16:38,610 --> 01:16:41,550
如果我自己不发信用条件的话,必须要等到时间片用完之后

1165
01:16:41,550 --> 01:16:44,710
由于中断的原因导致我进程币到了内核里面来

1166
01:16:44,710 --> 01:16:47,330
才能响应这个信号

1167
01:16:47,330 --> 01:16:48,790
这是有差别的

1168
01:16:48,790 --> 01:16:49,690
这个差别

1169
01:16:49,690 --> 01:16:51,070
就是其实性的响应差别

1170
01:16:51,630 --> 01:16:52,690
有一定的差别

1171
01:16:53,590 --> 01:16:56,970
好,那这个同学的问题我就给大家回答差不多了

1172
01:16:57,370 --> 01:16:59,270
好,我很欢迎大家来问问题

1173
01:16:59,870 --> 01:17:01,930
因为平常我问题大家答的比较少

1174
01:17:01,930 --> 01:17:04,390
但大家问问题我会答的比较多

1175
01:17:04,870 --> 01:17:09,950
好,那这一块讲完之后我们进入到下一讲

1176
01:17:09,950 --> 01:17:11,690
线程与斜程

1177
01:17:15,330 --> 01:17:19,830
这个是我们跟我们的lab第五个最后一个实验是有关系的

1178
01:17:19,830 --> 01:17:22,450
所以希望大家能够去理解一下

1179
01:17:24,170 --> 01:17:31,210
首先,为什么需要线程?老是在不停地给大家灌这种不同的概念,这概念是必

1180
01:17:31,210 --> 01:17:32,170
须要存在的吗?

1181
01:17:33,150 --> 01:17:38,310
所以我觉得大家要再打个问号,不是老是说一个啥就是啥,为什么需要线程,这些要明白。

1182
01:17:38,970 --> 01:17:44,770
然后再去讲这个怎么去使用线程,线程的到底是啥,怎么去设计实现一个线

1183
01:17:44,770 --> 01:17:47,550
程,这是我们这一节要讲的内容。

1184
01:17:48,430 --> 01:17:54,530
首先,为什么需要限制,那首先是在于你现在有什么,你有进程,我们前面讲了进程隔

1185
01:17:54,530 --> 01:18:00,690
离,各种进程隔离机制,讲了进程间的消息传递,数据传输,还有通

1186
01:18:00,690 --> 01:18:03,550
知机制等等,它不挺好了吗?为什么还有什么不足呢?

1187
01:18:04,230 --> 01:18:11,890
其实我们要理解这个进程之间还有一些问题,这个问题就是数据共享,数据交换

1188
01:18:11,890 --> 01:18:14,510
不方便,管理开销比较大。

1189
01:18:14,750 --> 01:18:22,790
就这两个,我们说的这一块和这一块,交换不方便,数据共享不方

1190
01:18:22,790 --> 01:18:24,490
便,进程开销,管理大。

1191
01:18:24,830 --> 01:18:30,710
这就是这个问题,咱们举个例子,用一个播放器来说

1192
01:18:30,710 --> 01:18:35,670
比如这个RAID的一个文件,然后对它对文件,RAID文件里面的数据,对这个

1193
01:18:35,670 --> 01:18:37,970
音频文件做解压,然后再播放

1194
01:18:37,970 --> 01:18:42,810
咱们都对这个文件里面的Data进行操作

1195
01:18:43,330 --> 01:18:47,710
那么这是一个进程,没问题,但是如果性能不够的话,我们是把它拆成三个进程,这是一个

1196
01:18:47,710 --> 01:18:48,230
进程

1197
01:18:48,230 --> 01:18:53,270
这是第二个进程,这是第三个进程,那我拆成三个进程的话,可以并发或者并行

1198
01:18:53,270 --> 01:18:53,490
执行

1199
01:18:53,910 --> 01:18:57,530
但是这个data的传输,你要不然前面讲的pipe,或者用前面的说的那个消息

1200
01:18:57,530 --> 01:19:04,150
对列等等,或者share memory都不太方便,那为什么不能够用同样一块内存来做

1201
01:19:04,150 --> 01:19:04,730
处理呢?

1202
01:19:05,250 --> 01:19:11,110
那其实我们虽然可以把它控制流分成三块,但是你把你这个隔离,你的隔离使

1203
01:19:11,110 --> 01:19:14,090
得它变成一个共享比较困难的一个原因。

1204
01:19:14,270 --> 01:19:19,810
所以我们想到的是说,我们能把控制流分成三块,但我们不隔离,这其实就可以引

1205
01:19:19,810 --> 01:19:23,410
入所谓的就是现成不足,所谓的现成不足。

1206
01:19:24,290 --> 01:19:26,490
一个很重要的原因,就是要解决这两个问题。

1207
01:19:27,350 --> 01:19:29,470
交换数据更方便,因为大家在同一个地址空间。

1208
01:19:29,670 --> 01:19:37,570
第二呢,管理开销比较小,因为它的整个切换等等,不像我们的进程还需要有

1209
01:19:37,570 --> 01:19:37,830
页表。

1210
01:19:38,130 --> 01:19:40,250
同一个地址空间嘛,同一个页表不需要切换。

1211
01:19:41,230 --> 01:19:44,130
不需要切换页表,不是不需要切换,是不需要切换页表。

1212
01:19:44,270 --> 01:19:47,950
所以这就是很重要的,为什么要引入现成的一个原因。

1213
01:19:51,170 --> 01:19:57,050
好,那这是一种写法,我们说这种写法就是我们通常说假设不引入现场,

1214
01:19:57,530 --> 01:20:02,950
你要团结三个进程,其实我们已经说到了,他们这些传递数据是比较麻烦的。

1215
01:20:05,630 --> 01:20:13,570
这是一个很直观的显示,我们在之前的建议中更多的是这种结构。

1216
01:20:14,030 --> 01:20:19,630
就是你如果把这个控制流的一个子型看成一个线程的话,那么对于之前来说,我们

1217
01:20:19,630 --> 01:20:21,410
这个进程是一个单线程的情况。

1218
01:20:21,970 --> 01:20:27,530
那如果我们对进程做进一步的扩展,在这个进程里面有多个控制流,

1219
01:20:28,110 --> 01:20:31,170
那么就形成了所谓的多线程进程的概念。

1220
01:20:32,170 --> 01:20:39,610
多线程进程的话,线程是在CPU执行的,所以这三个线程都要去占

1221
01:20:39,610 --> 01:20:43,410
用CPU执行,会是有线程的切换,就类似于我们前面讲的进程切

1222
01:20:43,410 --> 01:20:44,130
换一样。

1223
01:20:44,270 --> 01:20:50,290
但线程切换,为了能够支持线程切换,所以说你每一个就随时切换,因为

1224
01:20:50,290 --> 01:20:55,000
我们有中断,随时可以打断切换一个进程,所以说我们需要有这么一些东西。

1225
01:20:55,520 --> 01:21:01,940
线程有自己的站,有自己的系统器。那意味着你需要保存与恢复,你做

1226
01:21:01,940 --> 01:21:07,140
切换的时候要保存与恢复这个线程的站和系统器。

1227
01:21:07,540 --> 01:21:16,200
那么这一块东西是什么?这一块实际上是进程的资源。我们之前讲的文

1228
01:21:16,200 --> 01:21:21,720
件,我们刚才讲的那个pipe管道都是一种资源,打开的这种资源。

1229
01:21:21,720 --> 01:21:29,020
这种资源是被这些属于同一个进程的所有这些县城所共享的。这是

1230
01:21:29,020 --> 01:21:30,580
共享的资源。

1231
01:21:30,860 --> 01:21:35,480
既然共享资源还包括这个Data,我们说Data都是共享的,所以它可以直接看到,直接

1232
01:21:35,480 --> 01:21:37,400
访问,这是它方便的地方。

1233
01:21:37,820 --> 01:21:42,540
但是后面也讲到了,你不光要方便,还要正确,所以还有一个同步互斥的问题,

1234
01:21:42,640 --> 01:21:45,980
那是我们在后面的第12节给大家讲的内容。

1235
01:21:47,420 --> 01:21:54,740
OK,那这个线程有了线程之后呢,其实我们最大的好处就是方便还有一个性能,

1236
01:21:55,120 --> 01:22:00,080
就是它可以特别在这种并行执行的时候呢,它由于共享同一个地址中间,

1237
01:22:00,120 --> 01:22:09,480
大家可以去用多个处理器来对数据进行访问,就是它的好处可以得到更

1238
01:22:09,480 --> 01:22:14,060
大的一个体现,这是我们说的这个线程的好处。

1239
01:22:15,800 --> 01:22:21,100
我们再比较一下线程和进程。一旦我们引用线程的概念之后,进程就

1240
01:22:21,100 --> 01:22:21,960
变成了另外一个东西。

1241
01:22:22,000 --> 01:22:26,580
以前说进程要调度,现在说进程不需要调度,现在更多的是管理,它是一个资

1242
01:22:26,580 --> 01:22:32,840
源的容器。资源是什么?我们前面说到的文件和data都是资源。

1243
01:22:33,740 --> 01:22:47,260
线程也是属于竞程的,线程是CPU的调度单位,线程也可以把线程看

1244
01:22:47,260 --> 01:22:48,960
成是竞程的一种资源

1245
01:22:50,280 --> 01:22:55,280
但是更多的情况下,线程是CPU的抽象,竞程是各种资源的管理的

1246
01:22:55,280 --> 01:22:56,040
一个抽象

1247
01:22:56,040 --> 01:23:04,380
进城拥有整个资源的一个环境,而县城只是不占了其中的一些属于

1248
01:23:04,380 --> 01:23:10,200
县城的东西,比如说县城自营过程中的那个站和它的这个集成器,这是它的

1249
01:23:10,200 --> 01:23:10,940
一个这一点。

1250
01:23:11,060 --> 01:23:15,820
那么县城在整个自营过程中,它的那些状态,生命器等等,和我们之前讲进

1251
01:23:15,820 --> 01:23:20,480
城的是一样的,就是它就续组设执行,这三个都是有的,也同样就有这

1252
01:23:20,480 --> 01:23:21,480
种状态之间的切换。

1253
01:23:21,480 --> 01:23:28,620
只是它在并行执行,所有的时间、空间、开销、更多的字体的切换会小一些

1254
01:23:28,620 --> 01:23:33,400
这是他们的一个大致的理解,实际上是现成是属于进程

1255
01:23:35,680 --> 01:23:39,480
因为这又画不出来了,现成属于进程

1256
01:23:41,520 --> 01:23:48,140
OK,那还有一些可以理解的,一个进程中可以存在多个现成,多是1到N

1257
01:23:48,140 --> 01:23:48,560
个

1258
01:23:48,560 --> 01:23:54,680
各个线程之间可以并发执行,各个线程可以共享资源。这个是属于同

1259
01:23:54,680 --> 01:23:59,560
一进程的资源,需要注意,这个资源是同一个进程。

1260
01:24:02,460 --> 01:24:07,540
然后,当进程中的一个线程崩溃时,会导致其所属进程的所有线程崩

1261
01:24:07,540 --> 01:24:07,740
溃。

1262
01:24:09,020 --> 01:24:13,640
这里面专门我强调一下CIGR和Java不一样,因为Java为什么不一样呢?

1263
01:24:13,640 --> 01:24:19,440
Java跑在JVM虚拟机里面,JVM自己有一套自己的一套管理

1264
01:24:19,440 --> 01:24:26,200
它不像CIGR他们的线程是直接跑在物理的执行环境里面

1265
01:24:26,200 --> 01:24:29,980
直接执行的是物理机制里面,而这个是JVM封装了一下

1266
01:24:30,320 --> 01:24:34,440
所以它有更严格的一个隔离机制,不会造成整个进程的崩溃

1267
01:24:35,980 --> 01:24:45,460
这是它的一个介绍,那么怎么来使用它,这用的是,用的是标准的那个unix和linux

1268
01:24:45,460 --> 01:24:46,760
里面跑的一个程序

1269
01:24:46,760 --> 01:24:52,400
可以看到在这里面用的话很简单,就是我创建一个线程,pcware create,就创建一个

1270
01:24:52,400 --> 01:24:53,060
线程

1271
01:24:53,060 --> 01:24:57,780
这线程代表什么,就是这个东西,这东西是啥,函数,相当于把一个函数封

1272
01:24:57,780 --> 01:24:58,440
上一个线程

1273
01:24:59,120 --> 01:25:02,160
当然这函数里面可以再进步掉函数,实际上更复杂的一个功能

1274
01:25:04,560 --> 01:25:09,440
然后你主要结束了 结束了之后它有一个和类似于我们说的Wid P

1275
01:25:09,440 --> 01:25:10,280
ID对应的

1276
01:25:11,020 --> 01:25:16,360
这相当于是主线程来等待其他线程的返回

1277
01:25:16,360 --> 01:25:25,160
因为这个mine其实我们说实际上在这里面就变成了一个所谓的主线程

1278
01:25:26,060 --> 01:25:30,000
还有一点需要注意这里面线程的线程之间并不像我们的进程之间是一个

1279
01:25:30,000 --> 01:25:30,980
负子关系

1280
01:25:32,480 --> 01:25:35,240
不是这种复制关系 它是一个对等关系

1281
01:25:35,240 --> 01:25:37,840
除了这个主线程 它是主

1282
01:25:37,840 --> 01:25:39,840
所谓的主就是说我可以调Joy

1283
01:25:39,840 --> 01:25:41,860
那其他线程也可以调Joy

1284
01:25:41,860 --> 01:25:45,820
只是说这个P1和P2之间

1285
01:25:45,820 --> 01:25:47,680
和这个本来的这个主线程之间

1286
01:25:47,680 --> 01:25:48,700
并不是复制关系

1287
01:25:48,700 --> 01:25:50,280
需要注意它们是一个对等关系

1288
01:25:50,280 --> 01:25:53,460
这一点大家需要理解一下

1289
01:25:54,060 --> 01:25:55,960
所以你看到在实际实验中

1290
01:25:55,960 --> 01:25:58,780
它并不会像我们的进程观点那样

1291
01:25:58,780 --> 01:26:01,580
副执行程还有一个所谓的链接信息

1292
01:26:01,580 --> 01:26:02,360
这个没有

1293
01:26:04,140 --> 01:26:04,920
那等待

1294
01:26:05,680 --> 01:26:06,820
P1 P2

1295
01:26:06,820 --> 01:26:09,260
执行完毕之后 比如执行

1296
01:26:09,880 --> 01:26:14,300
MessRide的函数 他就把这个打出来 把A和B打出来之后呢

1297
01:26:14,300 --> 01:26:15,760
他在

1298
01:26:16,460 --> 01:26:18,240
等到他结束

1299
01:26:18,240 --> 01:26:21,320
然后他会打出一个自己是一个主线程 然后就return

1300
01:26:21,320 --> 01:26:22,840
这是一个

1301
01:26:22,840 --> 01:26:25,320
线程的一个使用 最主要是创建线程

1302
01:26:25,320 --> 01:26:26,780
和等待线程结束

1303
01:26:26,780 --> 01:26:29,540
你可以类比于我们的Fock和Wit

1304
01:26:29,540 --> 01:26:30,760
类似于这两个东西

1305
01:26:33,420 --> 01:26:34,800
你要去执行的话

1306
01:26:35,680 --> 01:26:36,980
可以得到这个程序

1307
01:26:36,980 --> 01:26:38,040
大家可以去稍微去

1308
01:26:38,040 --> 01:26:38,960
没不全的

1309
01:26:38,960 --> 01:26:41,240
大家可以去再稍微补一补一些

1310
01:26:41,240 --> 01:26:41,840
投文件

1311
01:26:41,840 --> 01:26:43,660
Include文件就可以把这个执行起来

1312
01:26:43,660 --> 01:26:44,720
这是它一个执行过程

1313
01:26:46,540 --> 01:26:48,240
这是它的这个系统调用

1314
01:26:48,240 --> 01:26:49,640
这个让大家理解一下

1315
01:26:49,640 --> 01:26:50,700
这是标准的

1316
01:26:51,300 --> 01:26:52,360
我们说叫Projects

1317
01:26:53,800 --> 01:26:59,300
我们的超级东里面的一个通用的一个接口规范

1318
01:26:59,300 --> 01:27:02,280
可以看到它里面带了这个几个参数

1319
01:27:02,280 --> 01:27:04,560
这里面最主要就是这个start routing

1320
01:27:05,240 --> 01:27:07,500
就是线程运行是从哪开始运行

1321
01:27:07,500 --> 01:27:08,640
它从这开始执行

1322
01:27:08,640 --> 01:27:10,460
它代表的就是线程的执行体

1323
01:27:10,460 --> 01:27:13,200
然后还有一些线程执行体需要的参数

1324
01:27:13,200 --> 01:27:15,760
这些是一些配置信息

1325
01:27:15,760 --> 01:27:18,360
可以做出更复杂的配置

1326
01:27:18,360 --> 01:27:20,100
这个我们就不再进一步展开

1327
01:27:20,100 --> 01:27:28,620
PthreadJoin就是我们说的等待,它等待刚才创建的Thread结束,结束

1328
01:27:28,620 --> 01:27:33,640
之后,它就有一个返回值,这就是我们说的现成的返回值。

1329
01:27:42,040 --> 01:27:47,600
线程,我看有同学在提问,那没关系,等会我再回答,我先把这个线

1330
01:27:47,600 --> 01:27:52,360
程一部分讲完再回答,那线程的基本定义,线程就是进程的一部分,属于

1331
01:27:52,360 --> 01:27:56,820
进程,描述指令流的执行状态,它是进程中指令执行中的基本单

1332
01:27:56,820 --> 01:28:00,140
位,是CPU调过的基本单位,这是它的一个定义。

1333
01:28:00,140 --> 01:28:04,940
这里面其实很明确的看出这个T,这个T就是Thread,Control Block

1334
01:28:05,280 --> 01:28:11,000
它里面最主要的包含了一些跟现成执行相关的上下文信息

1335
01:28:11,580 --> 01:28:14,580
我们前面说的占信息、计程机信息等等

1336
01:28:15,020 --> 01:28:17,460
为什么要保证这些信息,因为我们要切换它

1337
01:28:17,460 --> 01:28:20,020
这两个之间要进行切换

1338
01:28:20,020 --> 01:28:24,640
你不得不把一个当天执行的一个现成的一个状态保存起来

1339
01:28:24,640 --> 01:28:28,720
然后去切换到另一个现成执行状态,才能让另一个现成去正常执行

1340
01:28:28,720 --> 01:28:34,240
那么在这个进程的整个地图空间里面,你会发现它有一些专门属于

1341
01:28:34,240 --> 01:28:43,220
线程的东西,比如这个线程的Stack,这是它们线程中独有的东西,OK。

1342
01:28:48,260 --> 01:28:52,260
这里面讲这个线程,进一步就强调了线程是一个处理机调度的一个单

1343
01:28:52,260 --> 01:28:52,520
位。

1344
01:28:55,500 --> 01:28:57,080
而进程是资源的分配单位

1345
01:28:57,080 --> 01:28:58,340
那么现成就是一种资源

1346
01:28:59,300 --> 01:29:00,860
这个之前我们已经讲过了

1347
01:29:02,900 --> 01:29:04,240
稍微扩展一下

1348
01:29:04,240 --> 01:29:09,240
那么看看这个OS的不同的一些对现成支持方式

1349
01:29:09,240 --> 01:29:10,320
早期的MS-DOS

1350
01:29:11,600 --> 01:29:14,720
我们说微软发家的那个OS

1351
01:29:14,720 --> 01:29:16,920
就是一个单进程的一个系统

1352
01:29:18,120 --> 01:29:19,940
然后呢像一些Chains超级统计

1353
01:29:20,480 --> 01:29:26,080
我们国内的一个实时超级桶,开源的超级桶大家有兴趣可以去看,单进

1354
01:29:26,080 --> 01:29:27,240
程多线程

1355
01:29:28,280 --> 01:29:34,000
然后传统的Unix是多进程系统,它有多个进程

1356
01:29:35,740 --> 01:29:43,540
那么对于现代的Unix,比如说Linux或者是FreeBSD

1357
01:29:43,540 --> 01:29:47,080
这些它是多进程多线程超级桶

1358
01:29:47,080 --> 01:29:51,200
它这里面既支持多个进程,在进程里面也支持多个线程

1359
01:29:51,200 --> 01:29:56,580
这是所谓的现代的Unix造型,包括Windows也是一样,这是它们的不同的支持方

1360
01:29:56,580 --> 01:29:57,060
式

1361
01:29:57,060 --> 01:30:01,080
这是一个非常Overview的展现

1362
01:30:04,540 --> 01:30:08,080
这些细节我觉得刚才已经说过了,大家可以看到

1363
01:30:08,080 --> 01:30:15,220
进程存在多个线程,线程共享地址空间,共享资源

1364
01:30:15,220 --> 01:30:17,400
崩溃后会造成进程崩溃

1365
01:30:17,400 --> 01:30:19,700
这里面大家听起来都是概念

1366
01:30:19,700 --> 01:30:21,420
但其实你如果落到实现上

1367
01:30:21,420 --> 01:30:22,920
还是有些细节需要注意

1368
01:30:22,920 --> 01:30:25,400
这概念讲起来还是挺简单的

1369
01:30:26,180 --> 01:30:28,340
但是做的时候需要去考虑细节

1370
01:30:28,340 --> 01:30:30,460
等会我会问一些问题

1371
01:30:30,460 --> 01:30:32,120
大家就可以知道了

1372
01:30:32,120 --> 01:30:34,360
还是有一些需要注意的

1373
01:30:34,360 --> 01:30:37,140
就是你光知道概念还远远不够

1374
01:30:37,140 --> 01:30:38,820
我们还要知道它的内在

1375
01:30:38,820 --> 01:30:40,320
以及实现的一些细节

1376
01:30:43,300 --> 01:30:55,960
这就讲到这个切换的问题,就是它能减少时间空间开销,因为创建线程快。

1377
01:30:57,080 --> 01:31:03,500
那我想问一下同学,为什么它创建线程比创建进程要快?

1378
01:31:08,000 --> 01:31:15,600
大家可以在这个聊天里面用私聊也行,公共聊也行,能回答一下这个问题吗?

1379
01:31:18,360 --> 01:31:19,480
为什么会快?

1380
01:31:24,180 --> 01:31:27,020
不需要复制地图的空间,很好,我觉得是这个意思。

1381
01:31:27,020 --> 01:31:33,320
这是很重要一点,就是大家都前面看到那个Fock,我干了很大的事,大家读代码的可以看到,

1382
01:31:33,440 --> 01:31:36,420
虽然7.2.1就四个字Fock,啥参数都没有

1383
01:31:36,420 --> 01:31:39,720
但在内部实验里面,它需要把整个这个地址空间,整个这个代码端数

1384
01:31:39,720 --> 01:31:43,620
据端的那个页表,要整个给复制一份

1385
01:31:44,440 --> 01:31:50,300
这个可要挺大,内存的code也是一个很大的开销,但现场不需要,因为它是共享

1386
01:31:50,300 --> 01:31:51,100
地址空间

1387
01:31:52,060 --> 01:31:54,360
确实这就是创建为什么快的原因

1388
01:31:55,280 --> 01:31:58,480
那么切换也快,其实也是一样,切换它不切换页表

1389
01:31:58,480 --> 01:32:02,020
它只要切换它那个上下文,那上下文是什么呢?

1390
01:32:02,060 --> 01:32:04,880
比如说一堆集成器,把一堆集成器切换就OK了

1391
01:32:04,880 --> 01:32:06,360
所以它切换的也快

1392
01:32:07,200 --> 01:32:10,600
而且甚至有些现成的设计实现,它全是用物态执行的

1393
01:32:10,600 --> 01:32:14,380
那意味着它连那个用物态内核态的切换也可以省掉

1394
01:32:14,380 --> 01:32:17,140
这是属于它为什么快的一个原因

1395
01:32:18,560 --> 01:32:21,540
还有一点就是执行效率高

1396
01:32:21,540 --> 01:32:24,700
同一个计程的多线之间共享内存和文件资源

1397
01:32:24,700 --> 01:32:26,180
特别是共享内存

1398
01:32:26,180 --> 01:32:29,020
共享内存的话就意味着它可以不通过内核直接进行通讯

1399
01:32:29,020 --> 01:32:33,040
我们前面讲通讯的一种直接间接的一个定义就是

1400
01:32:33,760 --> 01:32:35,500
我不经过OS叫直接

1401
01:32:36,520 --> 01:32:39,900
所以我们同样共享同一个全局变量的话

1402
01:32:39,900 --> 01:32:41,260
那我可以直接访问

1403
01:32:41,260 --> 01:32:42,600
当然要确保访问的对啊

1404
01:32:42,600 --> 01:32:43,800
所以我一直强调说

1405
01:32:43,800 --> 01:32:48,920
你还要用好所谓的同步互制机制之后才能够正确的访问它

1406
01:32:48,920 --> 01:32:51,920
这个在后面会强调 这也是我们的一个难点

1407
01:32:52,940 --> 01:32:58,020
好 接下来我们就看一下这个线程它的几种实现方式

1408
01:32:58,020 --> 01:33:02,660
这个就是站在一个设计实现的角度

1409
01:33:02,660 --> 01:33:09,160
更深入了解这个线程的很重要的一个机制 它的一个设计实现

1410
01:33:09,160 --> 01:33:13,940
我们把整个这个线程分了四类 把它细化了一下

1411
01:33:13,940 --> 01:33:18,260
基于什么呢 基于你在哪管在哪运行 基于这两个因素

1412
01:33:18,780 --> 01:33:22,420
在哪管它 在哪运行 如果都在用物态管

1413
01:33:23,280 --> 01:33:27,260
那么我们还称之为就是用物态的管理且运行的现成

1414
01:33:27,260 --> 01:33:30,720
如果你在内核里面管 但在用物态执行

1415
01:33:30,720 --> 01:33:34,240
那这是一种方式 还有什么内核里面管 内核里面执行

1416
01:33:34,240 --> 01:33:37,640
还有一种是混合的 就是怎么说

1417
01:33:37,640 --> 01:33:41,040
就是它需要用物态和它要协成在一起来管

1418
01:33:42,860 --> 01:33:45,740
运行的时候也是一样,他们要协作在一起来运行

1419
01:33:45,740 --> 01:33:50,680
这种所谓的mixed mode,很明显这种方式最灵活也最复杂

1420
01:33:52,480 --> 01:33:57,460
那我们现在的超系统怎么来做的,我们可以看看

1421
01:33:59,060 --> 01:34:02,640
先考虑一下这个用户态管,用户态运行这种情况

1422
01:34:03,940 --> 01:34:11,160
這種情況既然是用物態管 那又有什麼 內核不知道

1423
01:34:11,160 --> 01:34:18,320
這裡面我有多個現成 內核裡面管的是一個PCB或者TCB無所謂了

1424
01:34:18,740 --> 01:34:22,060
就是你這裡面沒有這裡面的信息 這些信息全是用物態

1425
01:34:22,060 --> 01:34:25,680
那看不到它怎麼去它進行調度 沒有辦法進行調度

1426
01:34:25,680 --> 01:34:29,480
所以它調度管理全在用物態完成的 是用物態管理

1427
01:34:30,700 --> 01:34:42,400
那么这种 Thread 早期的 Pthread 还有 Soros Thread 有这种存在

1428
01:34:42,400 --> 01:34:49,220
我们现在通常说话叫 User Leveled Thread, Green Thread, Stackful Corroding, Feeble等等

1429
01:34:49,220 --> 01:34:50,400
这都是不同的名字

1430
01:34:50,400 --> 01:34:53,460
但这些名字我觉得大家知道就行了

1431
01:34:53,460 --> 01:34:55,640
最主要你要知道关注两点

1432
01:34:55,640 --> 01:34:58,000
在哪管 在哪运行 把这个搞清楚

1433
01:34:58,000 --> 01:34:59,800
其他只是一种称呼而已

1434
01:34:59,800 --> 01:35:03,100
我们更注重了它内在的一个特征

1435
01:35:03,900 --> 01:35:05,000
这是一类

1436
01:35:06,060 --> 01:35:09,820
这一类的特点是这里面所谓的线程

1437
01:35:09,820 --> 01:35:12,000
内核不可知 内核看不到

1438
01:35:14,420 --> 01:35:16,560
那么既然是内核不可知 内核看不到的话

1439
01:35:16,560 --> 01:35:18,580
那么谁来管它呢 就已经有一个库

1440
01:35:18,580 --> 01:35:22,820
说是线程库来管理

1441
01:35:22,820 --> 01:35:24,500
那么这个线程库呢

1442
01:35:26,080 --> 01:35:27,080
有没有语言级的支持

1443
01:35:27,080 --> 01:35:31,660
如果你用C写的,它没有这个语言级支持。

1444
01:35:32,340 --> 01:35:34,900
Go写的有一点,有一些。

1445
01:35:35,040 --> 01:35:39,080
Rust写的有一些,Java写的有一些。

1446
01:35:39,400 --> 01:35:45,020
C是没有的,C是全靠酷来完成的,语言级不做这个考虑。

1447
01:35:45,560 --> 01:35:47,920
那么既然是酷来做的,酷里面就有相应的功能。

1448
01:35:48,080 --> 01:35:53,800
通常放在内核里面的功能,比如创建、终止、同步、调度等等,都在用它的

1449
01:35:53,800 --> 01:35:54,100
自行。

1450
01:35:54,100 --> 01:35:57,720
但是因为它有它的天然的一些问题 好处是快

1451
01:35:58,540 --> 01:36:00,360
就是因为你不进入内核嘛

1452
01:36:00,360 --> 01:36:02,080
那所以你这个上远纹切换就不需要了

1453
01:36:02,480 --> 01:36:04,220
我要切换只是在函数级

1454
01:36:04,220 --> 01:36:07,800
在一个进程里面做各种各样的切换

1455
01:36:07,800 --> 01:36:10,740
快是它最大的好处 但不足在哪呢

1456
01:36:11,740 --> 01:36:14,340
它其实没法去随时被打断

1457
01:36:15,160 --> 01:36:18,240
你随时被打断只能是通过 比如说我们前面是讲通过中断

1458
01:36:18,240 --> 01:36:20,220
你一旦通过中断就要进入内核

1459
01:36:21,060 --> 01:36:23,800
所以这里面的这种会出现一个问题

1460
01:36:56,540 --> 01:37:00,020
休息时间 大家先休息一下

1461
01:42:14,900 --> 01:42:18,160
好 我们继续上课 大家都听得比较辛苦

1462
01:42:18,160 --> 01:42:22,320
还有最后45分钟 我们就可以下课了

1463
01:42:22,320 --> 01:42:23,680
好 我们讲到这个线程

1464
01:42:24,300 --> 01:42:32,440
线程由于用户态管理且运行的线程它不被我们的内核OS看到

1465
01:42:32,440 --> 01:42:38,160
所以它会导致整个属于进程的所有的线程都会被等待

1466
01:42:38,160 --> 01:42:40,060
一个主设其他全等待

1467
01:42:40,060 --> 01:42:43,280
第二它也不支持基于线程的处理机抢占

1468
01:42:43,280 --> 01:42:44,200
没法抢占

1469
01:42:44,200 --> 01:42:45,500
它用不太

1470
01:42:45,940 --> 01:42:47,800
你要抢占就进入内核台

1471
01:42:47,800 --> 01:42:50,360
只能按照进程来分配CPU时间

1472
01:42:51,120 --> 01:42:55,140
超级我们要对它进行分配的话,只能按照进程来分配。

1473
01:42:55,620 --> 01:42:59,040
所以在这里面,你很难说把比如这里面有十个,这里面有五个,

1474
01:42:59,200 --> 01:43:01,960
你要对它们进行均匀的时间分配,还做不到。

1475
01:43:02,480 --> 01:43:06,260
这是我们说现成的一些不足。

1476
01:43:07,920 --> 01:43:12,480
那么我们再看第二类,类合态管理且用户态运行的现成。

1477
01:43:12,980 --> 01:43:17,400
这个现成就是说我们类合要能感知到这个在用户态运行的现成的存

1478
01:43:17,400 --> 01:43:17,640
在。

1479
01:43:17,640 --> 01:43:24,140
这实际上就是我们现在的ACO tutorial里面做的一种设计实现方式

1480
01:43:24,140 --> 01:43:27,760
那么我们看到除了它之外还有Windows

1481
01:43:27,760 --> 01:43:30,980
我们说的是Windows也是一样的

1482
01:43:30,980 --> 01:43:35,420
Windows也是内在管理用户在运行

1483
01:43:35,960 --> 01:43:38,840
而且这个现成很明确的就是属于进程里面的一部分

1484
01:43:38,840 --> 01:43:40,640
它会有多个的存在

1485
01:43:41,620 --> 01:43:46,860
然后它这样的话就由内核来实现现成的创建

1486
01:43:46,860 --> 01:43:56,100
中指 手機的一些意想不到的情況 又亂發音了

1487
01:43:56,100 --> 01:44:00,380
好 咱們繼續 就是內核完成現成的創建中指和管理

1488
01:44:00,380 --> 01:44:03,440
包括切換 那麼內核來維持 維護這個什麼

1489
01:44:03,440 --> 01:44:06,740
你這樣做切換 它內核的 就是說現成的控制塊

1490
01:44:06,740 --> 01:44:09,460
它那個狀態 內核另外來維護

1491
01:44:09,460 --> 01:44:12,500
那麼現成只因進行療用而被阻塞 不會影響其他現成

1492
01:44:12,500 --> 01:44:16,560
因為正好我可以把另外一個現成去切換一下

1493
01:44:16,560 --> 01:44:17,640
让另外一些人去执行

1494
01:44:17,640 --> 01:44:18,920
这都是属于它的好处

1495
01:44:19,280 --> 01:44:23,340
因为内核可以统一管理了

1496
01:44:23,340 --> 01:44:24,480
那这种方式

1497
01:44:25,540 --> 01:44:26,260
我看看

1498
01:44:27,060 --> 01:44:29,240
这种方式的实现其实看到这里面

1499
01:44:29,720 --> 01:44:30,720
就是对应到这里面

1500
01:44:31,500 --> 01:44:33,460
这个TCB我们叫做thread

1501
01:44:33,460 --> 01:44:35,880
这TCB实际上是我们的PCB的一部分

1502
01:44:35,880 --> 01:44:37,540
有个TCB

1503
01:44:37,540 --> 01:44:38,860
指向的TCB

1504
01:44:38,860 --> 01:44:39,920
这样的话

1505
01:44:40,380 --> 01:44:41,960
这个kernelThread1,kernelThread2

1506
01:44:41,960 --> 01:44:44,160
可能都属于同一个进程的话

1507
01:44:44,160 --> 01:44:44,880
比如说这个

1508
01:44:51,080 --> 01:45:05,840
这是我们在这里面的一个大致的记录,这里面讲的是线程VS进程,这种方

1509
01:45:05,840 --> 01:45:10,660
式就是前面说的那种用户态管理和用户态实现的,这是这种方式。

1510
01:45:11,260 --> 01:45:20,520
而这个是因为这个线程通话在里头,这是一种用户态执行,但是内感态管

1511
01:45:20,520 --> 01:45:22,300
理的一种方式,这是两种不同的方式。

1512
01:45:22,860 --> 01:45:26,800
所以这个线程就分了两类,它和进程也不太一样。

1513
01:45:27,460 --> 01:45:33,320
在这里面,我们的内核只看到了进程,看不到这里面的线程。

1514
01:45:37,600 --> 01:45:53,000
我们再说一类叫做统合运行的现场,还少了一类,我们还一类,难道

1515
01:45:53,000 --> 01:45:54,080
是我们有更新?

1516
01:46:03,460 --> 01:46:06,320
看看在这里面介绍的

1517
01:46:12,520 --> 01:46:13,720
内核

1518
01:46:13,720 --> 01:46:15,720
英特尼设计实现

1519
01:46:15,720 --> 01:46:18,320
看这一块,用互态管理

1520
01:46:27,720 --> 01:46:31,100
这个PDF还更新的不够

1521
01:46:33,280 --> 01:46:41,020
所以我照这个来讲,这个是新的一部分内容,这应该更容易能够看到我们新的

1522
01:46:41,020 --> 01:46:42,120
一个实现。

1523
01:46:42,740 --> 01:46:47,380
内阁态管理和用物态运行的现成有些不足的地方,特别是相对

1524
01:46:47,380 --> 01:46:49,180
于前面是在用物态管理的这个情况。

1525
01:46:49,660 --> 01:46:56,020
第一个情况什么呢?就是现成切换的开销比较大,因为它要进入内核,所以有

1526
01:46:56,020 --> 01:46:57,140
一个上海门的切换。

1527
01:46:58,140 --> 01:47:01,860
第二个 它会与传统的进程管理机制造一些矛盾

1528
01:47:01,860 --> 01:47:06,140
这些以前的系统要用 它主要针对进程来的

1529
01:47:06,140 --> 01:47:10,660
你现在引用现成之后 那就会带来一些工程上语意上的不协调

1530
01:47:11,020 --> 01:47:14,300
比如说举个例子 FOC 和我们刚才讲的 Signal

1531
01:47:14,740 --> 01:47:16,180
Signal Action 这一块

1532
01:47:16,180 --> 01:47:19,220
这个 FOC 为什么有影响 大家想想 FOC

1533
01:47:19,220 --> 01:47:25,080
我们 FOC 含意是说我要创建一个进程

1534
01:47:25,080 --> 01:47:33,560
既然你说线程属于一个进程的话,那么我创建进程的时候,是否要把属于这个

1535
01:47:33,560 --> 01:47:35,760
进程的所有线程都给创建了呢?

1536
01:47:37,740 --> 01:47:39,580
大家想想需要吗?

1537
01:47:43,220 --> 01:47:49,120
能在这个聊天里面回答一下这个问题吗?我想看看咱们同学的一些想法。

1538
01:48:26,280 --> 01:48:30,640
我可能不用,也可能用,这完全取决于设计实现。

1539
01:48:30,900 --> 01:48:34,220
比如,以我们现在的ArcoTutorial为例,

1540
01:48:34,540 --> 01:48:39,840
我们的Fock就会把属于这个进程的所有线程都复制一份。

1541
01:48:41,060 --> 01:48:42,380
用,这是回答是用。

1542
01:48:43,020 --> 01:48:44,780
因为我们为什么这么来设计呢?

1543
01:48:44,780 --> 01:48:50,440
因为我们在PCB的设计里面就很明确地指出来,

1544
01:48:50,960 --> 01:48:59,600
在PCB里面有一个线程的宿主,你所有属于PCB的线程都在这个宿

1545
01:48:59,600 --> 01:49:05,520
主下面,自然我会把这个宿主里面的线程也都要copy一份,全都去

1546
01:49:05,520 --> 01:49:07,440
复制一份,这是我们的设计。

1547
01:49:07,760 --> 01:49:17,400
因为我们强调的是线程是属于进程的,那么一个进程里面会有多个线程

1548
01:49:17,400 --> 01:49:19,660
的实现,这是我们的一个design。

1549
01:49:20,220 --> 01:49:26,120
但是你如果看一下Unix或者是Linux的实现,你会发现它的Fock比较有意思,

1550
01:49:26,180 --> 01:49:28,380
它的Fock语意不是这么来定义的。

1551
01:49:28,420 --> 01:49:34,440
它的Fock语意是说,当我引入了多线程之后,我在做Fock的时候,我只是把

1552
01:49:34,440 --> 01:49:38,460
属于这个进程的当前的这个线程给复制了,

1553
01:49:38,740 --> 01:49:43,920
而属于这个进程的其他线程我并不复制。也因为它只复制了一个线

1554
01:49:43,920 --> 01:49:45,960
程,它并没有复制其他的线程。

1555
01:49:48,340 --> 01:49:59,020
为什么要这么来做呢?我说取决于它的实现,因为在它的实现里面,比如Linux

1556
01:49:59,020 --> 01:50:05,840
为例吧,它的一个线程,本质上来说是一个共享地址空间的进程。

1557
01:50:07,340 --> 01:50:15,420
每一个它所谓的线程只有自己独立的PCB进程控制块。为什么它称之为

1558
01:50:15,420 --> 01:50:18,800
一个共享地址控制的进程呢?因为它有自己的PCB。

1559
01:50:19,020 --> 01:50:26,360
而我们的ArcoTutorial,我们的线程是共享了一个进程控制块,不是用独

1560
01:50:26,360 --> 01:50:28,800
立的进程控制块。这是它的实际上的区别。

1561
01:50:28,800 --> 01:50:35,040
由于这种实际上的区别,使得我作为Linux而言,由于我的所谓

1562
01:50:35,040 --> 01:50:39,640
的线程,拥有自己的PCB,

1563
01:50:39,980 --> 01:50:44,180
所以我在做Fock的时候,我只需把这个PCB给复制了,

1564
01:50:44,300 --> 01:50:51,140
也就是把我当前共享地址空间这个线程的进程控制块给复制一

1565
01:50:51,140 --> 01:50:51,840
份就OK了。

1566
01:50:52,480 --> 01:50:57,080
这是很自然的一个设计,这也是目前Linux是这么来做的。

1567
01:50:57,080 --> 01:50:59,380
那这样做会带来什么进一步的问题呢

1568
01:51:00,440 --> 01:51:01,520
当然有问题了

1569
01:51:01,520 --> 01:51:02,920
如果大家想一想

1570
01:51:02,920 --> 01:51:04,860
大家想一想 我们在

1571
01:51:05,300 --> 01:51:08,680
还没有讲到 但大家也都能理解 就是有一个所谓同步务次

1572
01:51:08,680 --> 01:51:10,620
比如说我拿了一个资源

1573
01:51:10,620 --> 01:51:13,460
拿了资源之后 拿了一个锁 简单说拿了一个锁

1574
01:51:16,180 --> 01:51:17,820
进程A的

1575
01:51:20,140 --> 01:51:20,780
线程

1576
01:51:20,780 --> 01:51:24,120
线程什么呢 线程P1 拿了一个锁

1577
01:51:24,120 --> 01:51:26,760
然后我线程P2呢 去执行那个Fock

1578
01:51:57,080 --> 01:52:00,100
线程,比如你这个P2,想再去拿这把锁就拿不到。

1579
01:52:01,560 --> 01:52:07,440
这就出现了一个所谓的语意上带来的不协调或者是有问题的情况,怎么

1580
01:52:07,440 --> 01:52:08,320
来处理。

1581
01:52:08,780 --> 01:52:16,140
那只能借助于我们在写应用程序的时候,你要去做相应的一些设置。

1582
01:52:16,280 --> 01:52:24,260
比如说我在Fock之前,我让所有的线程把他所用的锁都交给当前我要F

1583
01:52:24,260 --> 01:52:25,060
ock的这个线程。

1584
01:52:56,180 --> 01:53:01,380
一个进程里面有多个线程,它在执行,线程在执行。那你到底是给这个

1585
01:53:01,380 --> 01:53:03,480
进程中哪个线程来发信号呢?

1586
01:53:04,260 --> 01:53:10,700
这语意上就出现一些漏洞。那你也不得不,有些所谓的一些约定,你可以

1587
01:53:10,700 --> 01:53:15,160
指定它的主线程来响应,或者给所有的线程发信号。

1588
01:53:15,480 --> 01:53:22,300
这都是一些由于引入了这个线程之后,带来一些所谓的不协调的问题,这个

1589
01:53:22,300 --> 01:53:26,540
问题现在解决没有了,并没有彻底解决,所谓没有彻底解决,并没有形成标准,

1590
01:53:26,740 --> 01:53:31,980
大家有各自的设计实现,这我们说这个内核带管理前,因为它运行的线

1591
01:53:31,980 --> 01:53:33,620
程的一些潜在的一些不足。

1592
01:53:38,100 --> 01:53:44,140
OK,那我们来看看这块,其实我就讲这个是内核线程的一个执行情况。

1593
01:53:45,980 --> 01:53:51,280
呃,我再把刚才那个PTT打开,可能会好一点,稍微等一下。

1594
01:54:07,960 --> 01:54:09,320
今天讲到的是。

1595
01:54:17,580 --> 01:54:23,560
就是内核泰管理用户泰设计实现的一个情况。

1596
01:54:24,240 --> 01:54:26,160
我们从这开始来进一步讲解。

1597
01:54:27,060 --> 01:54:30,040
那前面讲到的就是零零四内核,我看前面说到了一点。

1598
01:54:30,600 --> 01:54:38,660
零零四所谓的实现里面,它的现成是拥有自己独立的PCB的。

1599
01:54:38,660 --> 01:54:42,400
而我们的R code主要其实现成并不拥有自己独立的PCB。

1600
01:54:42,400 --> 01:54:45,400
这就是导致了在实验上面有些不同

1601
01:54:45,400 --> 01:54:49,220
导致它在做系统调整的时候也有一些相应的差异性

1602
01:54:49,220 --> 01:54:53,600
就我们现在的实现和标准的Linux Unix POSSIBLE的语意也不太

1603
01:54:53,600 --> 01:54:53,900
一样

1604
01:54:55,060 --> 01:54:57,420
好 那我们再看下一类就是所谓的内核态管理

1605
01:54:57,420 --> 01:54:58,580
内核态运行的现场

1606
01:54:58,580 --> 01:55:00,900
这类现成统称为内核现场

1607
01:55:00,900 --> 01:55:02,000
为什么出现内核现场

1608
01:55:02,000 --> 01:55:05,220
是在于我们内核里面其实也需要一种所谓的运发机制

1609
01:55:05,220 --> 01:55:07,340
来处理相应的一些事件

1610
01:55:07,920 --> 01:55:08,560
这是原因

1611
01:55:08,560 --> 01:55:10,020
比如说我们Linux的内核现场

1612
01:55:10,840 --> 01:55:15,700
其实也有同学做了这种内核现成的扩展,但我们并没有放到我们现在的

1613
01:55:15,700 --> 01:55:16,500
实验中来。

1614
01:55:16,860 --> 01:55:21,560
但大致可以理解为,在内核中有相对独立的kernel thread的存在,它

1615
01:55:21,560 --> 01:55:27,060
不属于某一个用户台运行的进程,它属于内核。

1616
01:55:27,680 --> 01:55:31,120
为什么属于内核呢?其实内核,我们这个Aquatutorial里面也有一个设计,就是说

1617
01:55:31,120 --> 01:55:32,220
我们内核用自己的页面。

1618
01:55:32,660 --> 01:55:39,120
如果你把内核看成一个特殊的进程的话,用特权级的进程的话,那么这些C

1619
01:55:39,120 --> 01:55:43,220
onsulate就属于特殊的内核,这么理解可能更加自然一点。

1620
01:55:44,700 --> 01:55:49,100
那么内核相对来说,内核线程它是内核的一个分身,所谓分身就是它

1621
01:55:49,100 --> 01:55:53,200
可以并行或者并发的来处理一些特定的事件。

1622
01:55:53,200 --> 01:55:55,900
内核线程整个调度由内核复制

1623
01:55:55,900 --> 01:55:58,200
那它和其他的一些比如说这个进程

1624
01:55:58,200 --> 01:56:01,940
或者进程所属的线程调度是一样的

1625
01:56:01,940 --> 01:56:03,400
它是一个基本的调度单位

1626
01:56:05,400 --> 01:56:06,520
那用在哪儿

1627
01:56:06,520 --> 01:56:08,340
我们其实可以用在什么地方

1628
01:56:08,340 --> 01:56:09,560
比如说一些周期性的任务

1629
01:56:09,560 --> 01:56:10,440
比如说把bubble catch

1630
01:56:10,440 --> 01:56:12,520
我们前面说的门禁系统里面有个bubble catch

1631
01:56:12,520 --> 01:56:13,700
定期要写回

1632
01:56:14,040 --> 01:56:16,540
这个定期写回的事情可以作为一个任务

1633
01:56:16,540 --> 01:56:19,400
用Current thread,就是内核线程的方式来实现

1634
01:56:19,400 --> 01:56:21,720
比如说在可用物理程很少的情况下

1635
01:56:21,720 --> 01:56:25,260
实行虚成交换的一个操作,也可以用专门的可能数捺来实现。

1636
01:56:25,680 --> 01:56:27,500
还比如说我们前面讲的日治文件系统,

1637
01:56:28,160 --> 01:56:32,240
日治事务处理的写回操作,也可以用可能数捺操作。

1638
01:56:32,500 --> 01:56:35,300
这种操作实际上体现的一种就是灵活性,

1639
01:56:35,460 --> 01:56:40,500
我可以通过这种分时的方式来完成一些事件的执行。

1640
01:56:41,040 --> 01:56:42,820
而这个事件执行取决于我们的调度,

1641
01:56:42,980 --> 01:56:45,000
这样就更加的灵活和高效,

1642
01:56:45,060 --> 01:56:48,520
只有在一些必要的时候才触发内核现成去执行。

1643
01:56:48,520 --> 01:56:54,260
而这些内核线程一定会比较迅速地完成它的工作,这样才能够把这个CPU

1644
01:56:54,260 --> 01:56:58,880
让出来给我们的进程,给我们的用户台的这个线程来去执行。

1645
01:56:59,140 --> 01:57:02,780
这是我们说内核台管理和内核台运行的一个线程的情况。

1646
01:57:03,100 --> 01:57:09,220
当然这里面大家也需要去注意的是哪儿呢?如果你的内核线程运行时间过长,那很

1647
01:57:09,220 --> 01:57:13,720
明显会影响到我们这个用户台内核的这个,用户台进程的执行,用户

1648
01:57:13,720 --> 01:57:14,980
台线程的执行。

1649
01:57:14,980 --> 01:57:18,660
或者你这边一旦有内核 内核线程有些bug的话

1650
01:57:18,660 --> 01:57:19,620
那整个系统就有问题

1651
01:57:19,620 --> 01:57:23,200
这都是一些它在处理之后需要注意的问题

1652
01:57:23,940 --> 01:57:29,340
第三类我们称之为混合管理前运行的线程

1653
01:57:29,340 --> 01:57:33,280
所谓混合就是其实需要我们的用户台和内核台一起来管理

1654
01:57:33,280 --> 01:57:34,920
这所谓混合管理

1655
01:57:34,920 --> 01:57:37,020
那这混合管理实际上是MN的一个模型

1656
01:57:37,020 --> 01:57:43,720
什么意思呢 就是在用户台有M个用户线程

1657
01:58:44,060 --> 01:58:48,060
作为一个用户的进程来呈现

1658
01:58:48,060 --> 01:58:49,520
那么这个用户进程呈现

1659
01:58:51,540 --> 01:58:56,830
它可以绑定在多个thread里面

1660
01:59:02,080 --> 01:59:04,720
多个thread里面会绑定在一个LWC里面

1661
01:59:04,720 --> 01:59:08,020
这个thread可以绑定在MN模型

1662
01:59:08,020 --> 01:59:12,280
这个模型就是可以最大化的提供所谓的灵活性

1663
01:59:13,640 --> 01:59:17,460
而早期的12小系统是在C的一个运行库里面

1664
01:59:17,460 --> 01:59:22,100
对这个库和OS做了一个配置,使他们之间可以相互协调

1665
01:59:22,100 --> 01:59:26,740
这种方式并没有得到Linux的认可

1666
01:59:26,740 --> 01:59:31,080
当时设计得很灵活,但好像并没有被广泛的Linux接受采用

1667
01:59:32,260 --> 01:59:38,100
现在够远的Go Runtime和OS也是一样,相互配合

1668
01:59:38,100 --> 01:59:41,020
但这个OS是个通用小系统,比如说它这里面可以是Windows,可以是Linux

1669
01:59:41,020 --> 01:59:44,300
但Go Runtime里面做了很多的一些新的design

1670
01:59:44,300 --> 01:59:48,660
结合了一些语言特征来实现了一个就是MN模型

1671
01:59:48,660 --> 01:59:50,380
就我们前面说到的就是

1672
01:59:50,380 --> 01:59:53,780
拨个Go的这个thread

1673
01:59:53,780 --> 01:59:57,260
会绑到一个kernel认识到的一个process

1674
01:59:58,760 --> 02:00:01,420
再去被翠细调度

1675
02:00:01,420 --> 02:00:03,840
那么由于Go Runtime的设计实现比较灵活

1676
02:00:03,840 --> 02:00:08,100
它可以弥补早期的那个green thread

1677
02:00:08,100 --> 02:00:12,900
在所谓它没法去切换,没法去有效地去进行调谷这么一个问题

1678
02:00:12,900 --> 02:00:18,100
它和OS之间有一个协调,使得它可以更大化地去发挥这种

1679
02:00:18,920 --> 02:00:21,500
并行的一个处理的效果,这是它的Go Routing

1680
02:00:21,500 --> 02:00:25,840
它叫Go Routing,它叫R-U-T-I-N-E

1681
02:00:25,840 --> 02:00:28,400
所谓的够圆的协程

1682
02:00:28,400 --> 02:00:32,740
现在这个运行的一段时间,这个

1683
02:00:32,740 --> 02:00:34,740
比书写不是特别流畅

1684
02:00:35,400 --> 02:00:39,580
这是这一块的一个设计实现,给大家简单介绍一下。

1685
02:00:39,900 --> 02:00:44,300
这个实际上就是由我们的库或者编程员来决定有多少个内核级的线程

1686
02:00:44,300 --> 02:00:46,780
和多少个用户级的线程进行复用。

1687
02:00:48,340 --> 02:00:52,620
你如果不是编程员来决定的话,就由我们的Runtime来决定,就是Go Runtime

1688
02:00:52,620 --> 02:00:53,160
来决定。

1689
02:00:55,100 --> 02:01:00,380
这个是一个配置,然后内核只识别内核级的线程,逼它进行调度。

1690
02:01:01,780 --> 02:01:06,740
那么用户台的那个库会完成用户台现成的一个配置和管理

1691
02:01:06,740 --> 02:01:10,320
这个是它们的一个设计实现

1692
02:01:11,340 --> 02:01:16,560
好 最后来讲一下关于这个切换的问题

1693
02:01:16,560 --> 02:01:19,920
那么现成的上连文切换和我们之前讲的这个任务的上连文切换

1694
02:01:19,920 --> 02:01:22,020
其实是很类似的

1695
02:01:22,020 --> 02:01:24,320
如果在内核里面去实现这个切换的话

1696
02:01:24,320 --> 02:01:25,800
那么现成是调过的基本单位

1697
02:01:25,800 --> 02:01:29,760
所以它的切换实际上就是把它那个现成执行所当前的那个集成器

1698
02:01:29,760 --> 02:01:31,300
可以保证有恢复就OK了

1699
02:01:33,020 --> 02:01:35,960
但需要注意一点 如果两个线程属于不同的进程的时候

1700
02:01:35,960 --> 02:01:40,000
切换的过程实际上是和进程上的切换是一样的

1701
02:01:40,000 --> 02:01:42,260
因为你切换到另一个进程的线程的时候

1702
02:01:42,260 --> 02:01:45,180
你需要用到另一个进程的页表

1703
02:01:45,180 --> 02:01:47,940
所以你还是要切换那个页表的

1704
02:01:47,940 --> 02:01:51,060
在这种情况下 这个线程切换和进程切换其实是一回事

1705
02:01:51,360 --> 02:01:53,800
但如果两个线程是属于同一个进程的话

1706
02:01:54,420 --> 02:01:56,340
由于它们整个地址空间是共享的

1707
02:01:56,340 --> 02:02:02,940
所以我只要切换线程的上下文就行了,我们不需要去切换进程上下文,

1708
02:02:02,960 --> 02:02:07,560
比如说我们的页表就不需要切换了,这个是需要稍微注意一下的。

1709
02:02:07,560 --> 02:02:11,940
OK,这一步就简单的把这个线程这一块给大家介绍完毕。

1710
02:02:17,100 --> 02:02:18,940
接下来我们讲第二个,携程。

1711
02:02:21,400 --> 02:02:27,240
协程叫co-routing,一样,首先为什么需要协程,第二怎么使用协程,第三个协程的

1712
02:02:27,240 --> 02:02:29,940
设计实现,给大家做个简要介绍。

1713
02:02:32,300 --> 02:02:38,240
首先线程,一样,线程一定有些地方不够好才会引入协程,如果线程已经足

1714
02:02:38,240 --> 02:02:39,760
够好了,没必要要协程。

1715
02:02:40,340 --> 02:02:46,340
线程有什么样的一些潜在的问题呢,就是我们前面线程跟进程比,说线程

1716
02:02:46,340 --> 02:02:53,580
的各方面的开销小,但是跟携程比起来,或者说跟一些大规模进行Io

1717
02:02:53,580 --> 02:02:59,420
操作的一些差距施用起来的话,发现线程还是有些问题,占用的内作还是

1718
02:02:59,420 --> 02:03:05,560
太大,因为线程有自己独立的占,那么线程由于有独立的占之后,你在做

1719
02:03:05,560 --> 02:03:09,740
线程的切换的时候,你还要去切换占,这一块其实是比较大的一个问题。

1720
02:03:09,740 --> 02:03:14,560
第二,现成法文共享书记容易出错,需要我们一些同步控制机制来保证,这

1721
02:03:14,560 --> 02:03:18,720
也是它的一个问题,这是我们看到它的一个谴责问题。

1722
02:03:18,940 --> 02:03:24,960
那我们为此引入了所谓的谐诚,这谐诚概念本身其实还是比较早的,

1723
02:03:25,240 --> 02:03:30,420
在1963年的时候就提出来的谐诚,那谐诚是什么呢,是行为与主程序相

1724
02:03:30,420 --> 02:03:35,040
似的执进程,subrouting,subrouting就是我们现在说的function,或者是procedure,

1725
02:03:35,040 --> 02:03:42,300
这都是一些不同的英文单词对同一个编程实体的一个表述

1726
02:03:42,300 --> 02:03:44,080
这样就是我们说的函数

1727
02:03:44,080 --> 02:03:48,120
你可以简单地以为指力层就是call routing或者是谐程

1728
02:03:48,120 --> 02:03:55,340
应该说指力层或者function是谐程的一种特例

1729
02:03:55,340 --> 02:03:58,700
谐程是一种更广义上的一种函数

1730
02:03:58,700 --> 02:04:00,240
这个怎么来说

1731
02:04:00,240 --> 02:04:04,520
你可以看到这里面color调了一个function

1732
02:04:05,080 --> 02:04:07,000
但是它叫斜程

1733
02:04:07,000 --> 02:04:10,320
方形通常说从它的出口出去之后

1734
02:04:10,320 --> 02:04:11,900
再次掉的时候还会从入口

1735
02:04:11,900 --> 02:04:14,140
从一个入口来进来

1736
02:04:14,140 --> 02:04:15,520
就它入口是一个

1737
02:04:19,360 --> 02:04:21,140
这是出口入口

1738
02:04:21,140 --> 02:04:23,320
那么下次进来的时候还是从这个地方来

1739
02:04:23,320 --> 02:04:24,800
再掉的时候还是从这个地方来

1740
02:04:24,800 --> 02:04:25,920
但是斜程不一样

1741
02:04:25,920 --> 02:04:28,920
斜程可以从中间某个地方出去

1742
02:04:28,920 --> 02:04:30,000
下次再掉的时候

1743
02:04:30,000 --> 02:04:32,680
它是从刚才中间某个地方出去的地方再回来

1744
02:04:32,680 --> 02:04:35,600
就是它的入口、出口是多个的

1745
02:04:35,600 --> 02:04:37,040
所以我们说为什么说

1746
02:04:37,040 --> 02:04:38,380
纸、粒层是邪神的一种特例

1747
02:04:38,380 --> 02:04:40,220
在于你前面的入口只有一个

1748
02:04:40,220 --> 02:04:42,700
这入口有多个 出口也有多个

1749
02:04:42,700 --> 02:04:46,660
这就是邪神和我们说通常是function的一种

1750
02:04:46,660 --> 02:04:47,820
比较大的一个差别

1751
02:04:48,240 --> 02:04:51,980
所以我们在这里面也试图给邪神

1752
02:04:51,980 --> 02:04:53,740
给出一个比较精确的一个定义

1753
02:04:53,740 --> 02:04:55,920
邪神是一种程序的一种组件

1754
02:04:55,920 --> 02:04:57,340
是由纸、粒层

1755
02:04:57,340 --> 02:04:59,560
这样在我们当中的函数的概念犯化而来

1756
02:04:59,560 --> 02:05:00,700
就是用犯化

1757
02:05:03,060 --> 02:05:07,940
指令层只有一个入口点,且只返回一次。而协成允许有多个入口点,可以

1758
02:05:07,940 --> 02:05:09,580
在指定位置挂起和恢复。

1759
02:05:09,800 --> 02:05:14,180
你看到这里面一个词,挂起和恢复。通常和我们现在的现成,你要挂起和恢复,

1760
02:05:14,360 --> 02:05:16,420
就相当于是保存与恢复是一个道理。

1761
02:05:16,620 --> 02:05:19,480
它这里面有一个协成的上下文的保存与恢复的过程。

1762
02:05:20,620 --> 02:05:23,760
所以,协成的横行思想是控制着主动让出与恢复。

1763
02:06:23,760 --> 02:06:27,000
可以再调一个resume,恢复这个写成的姿势。

1764
02:06:27,940 --> 02:06:33,320
所以这就是我们说这个写成的一个大致的一个定义,

1765
02:06:33,420 --> 02:06:35,120
当然这里面我们对写成会进一步的细化,

1766
02:06:35,240 --> 02:06:37,340
什么叫无任写成,后面会讲到。

1767
02:06:38,480 --> 02:06:42,000
那么在04年的时候,RUA是一个编程语言,

1768
02:06:42,080 --> 02:06:43,220
脚本编程语言。

1769
02:06:44,840 --> 02:06:46,340
RUA的作者写了一篇paper,

1770
02:06:46,700 --> 02:06:49,620
叫重新思考一下这个写成,

1771
02:06:49,620 --> 02:06:57,260
按照三個因素來對協成進行分類,協成有不同的實驗方式,不是只

1772
02:06:57,260 --> 02:07:02,480
有一種實驗方式,不同類型有不同的這種協成的定義和設計實現。

1773
02:07:02,680 --> 02:07:10,200
三個方面,控制傳遞、站的構造,是否是編成語言所能感知到的第一

1774
02:07:10,200 --> 02:07:14,140
類對象,基於這個來對協成進行分類。

1775
02:07:14,640 --> 02:07:24,280
我们看一看,这里面是多线程,这里面是一个多线程,这是一个斜程,看起来非常

1776
02:07:24,280 --> 02:07:25,000
类似。

1777
02:07:25,320 --> 02:07:32,700
但这个细节上面还是有不同的,这个我们后面会给大家看到。这里面是一个一个的,这里面

1778
02:07:32,700 --> 02:07:38,660
有三个,三个,我看这里面有三个线程,这里面只有一个线程,这里面有三个

1779
02:07:38,660 --> 02:07:39,180
线程。

1780
02:07:39,940 --> 02:07:47,340
协成是属于线程里面的一个结构,这一点来说是一样的,但是内部不

1781
02:07:47,340 --> 02:07:56,480
一样,第一我们看控制传递机制,分为对称和非对称,什么叫对称呢?

1782
02:07:56,480 --> 02:07:59,160
就是协成之间可以直接传递控制

1783
02:07:59,160 --> 02:08:07,040
协成A,C1可以直接把它的控制权传递给C2

1784
02:08:07,040 --> 02:08:09,280
那意味着C1和C2是对称的

1785
02:08:09,840 --> 02:08:10,880
不存在谁调过谁

1786
02:08:10,880 --> 02:08:14,760
如果是Color和Colly

1787
02:08:18,300 --> 02:08:20,240
这两个之间是一个非对称的

1788
02:08:20,240 --> 02:08:22,500
就是我Color调Colly

1789
02:08:23,040 --> 02:08:29,040
你callee不能直接在指令管中把这个控制权传递给callee,不行,我callee可以

1790
02:08:29,040 --> 02:08:31,780
调callee,这是一种所谓的非对称方式。

1791
02:08:32,140 --> 02:08:37,100
但如果是像thread1,由于切换切到thread2,这是一种对称方式,thread

1792
02:08:37,100 --> 02:08:38,920
1和thread2之间是对等的。

1793
02:08:39,100 --> 02:08:43,540
那么非对称就是callee和callee之间就是非对称方式,所以这是两种协称的

1794
02:08:43,540 --> 02:08:44,080
机制。

1795
02:08:47,000 --> 02:08:50,860
就是对等协称是等价的,控制权可以直接对等协称之间传递。

1796
02:08:50,860 --> 02:08:54,080
但是你如果是非对称的方式,比如call or callee方式的话,

1797
02:08:55,420 --> 02:08:59,860
那么非对称的协称挂起时将控制权要防卫给调用者,防卫防卫

1798
02:08:59,860 --> 02:09:00,680
给callee。

1799
02:09:00,880 --> 02:09:04,840
非对称的协称本身是一个callee,这是所谓非对称的一种协称的一

1800
02:09:04,840 --> 02:09:06,820
种和对称的一种定义。

1801
02:09:07,840 --> 02:09:14,440
第二个,有没有占?无占协称是说,我这个协称是没有自己的占,

1802
02:09:14,900 --> 02:09:20,160
我是共享了所属现成的那个占,就它的占是用了现成占。

1803
02:09:21,880 --> 02:09:26,880
它的函数代表所有的站开销是用在线上,而这个协成所谓的context保

1804
02:09:26,880 --> 02:09:27,400
存在哪里呢?

1805
02:09:27,400 --> 02:09:31,440
保存在堆上面,这所谓的无站协成。

1806
02:09:32,080 --> 02:09:37,340
而有站协成呢,这个实际上就是一种线程,就是用在管理并运行的线

1807
02:09:37,340 --> 02:09:38,640
程。

1808
02:10:08,640 --> 02:10:13,940
我们所谓的友战协诚 友战协诚其实就是我们前面讲的用户台的现成

1809
02:10:13,940 --> 02:10:19,880
用户台管理 用户台运行的现成 这只是一个概念 所以大家能够理解

1810
02:10:19,880 --> 02:10:24,640
然后第三个区分是看你是不是first class语言对象

1811
02:10:26,300 --> 02:10:30,080
什么叫first class 比如说我们的变量

1812
02:10:30,080 --> 02:10:36,020
变量我们通常变量是一个A B 是一个数值

1813
02:10:36,020 --> 02:10:38,900
但是你如果这个A等于B

1814
02:10:38,900 --> 02:10:41,420
这是一种比如AB是一个整形的话

1815
02:10:41,420 --> 02:10:42,040
给它复制

1816
02:10:42,040 --> 02:10:43,700
这是直接对它进行操作

1817
02:10:44,480 --> 02:10:47,740
这是比如整形变量是一个first-class的语言对象

1818
02:10:47,740 --> 02:10:49,360
那么对于协称而言

1819
02:10:49,840 --> 02:10:51,800
协称也是一种语言级支持的

1820
02:10:51,800 --> 02:10:55,220
比如说我让一个变量等于协称1

1821
02:10:55,220 --> 02:10:57,320
这协称里有一个自己的定义

1822
02:10:57,320 --> 02:10:58,780
如果能这么来处理的话

1823
02:10:58,780 --> 02:11:00,320
把这个协称当成一个变量来使的话

1824
02:11:00,320 --> 02:11:02,160
那实际上是first-class的语言对象

1825
02:11:02,160 --> 02:11:04,100
比如说我们的Go语言

1826
02:11:34,580 --> 02:11:36,720
如果也没有形成所谓的标准

1827
02:11:36,720 --> 02:11:39,160
比如像我们的Posix这种标准的话

1828
02:11:39,160 --> 02:11:40,660
那很难大规模推广

1829
02:11:40,660 --> 02:11:42,560
所以它是受限的

1830
02:11:42,560 --> 02:11:43,320
C语言可以实现

1831
02:11:43,320 --> 02:11:44,920
但是很麻烦

1832
02:11:44,920 --> 02:11:46,980
然后使用起来也很不方便

1833
02:11:46,980 --> 02:11:48,100
不具有通用性

1834
02:11:48,100 --> 02:11:49,120
这就是我们说的一个

1835
02:11:49,120 --> 02:11:50,560
企业层的支持

1836
02:11:50,560 --> 02:11:52,580
目前看到支持企业层的语言

1837
02:11:52,580 --> 02:11:53,820
其实已经越来越多了

1838
02:11:54,540 --> 02:11:55,960
但这个概念本身还是比较细

1839
02:11:55,960 --> 02:11:58,120
真正在实际语言中用

1840
02:11:58,120 --> 02:12:00,260
虽然是64年提出来的

1841
02:12:00,260 --> 02:12:03,820
但真正在实际语言中用的话

1842
02:12:03,820 --> 02:12:08,640
其实还是2000年之后的一些事情

1843
02:12:08,640 --> 02:12:09,760
包括C-SHARP

1844
02:12:09,760 --> 02:12:10,660
更早的C-SHARP

1845
02:12:10,660 --> 02:12:12,480
然后Java、Python

1846
02:12:12,480 --> 02:12:15,120
Python、Java还没有完全形成标准

1847
02:12:15,120 --> 02:12:21,200
还有2000年的CI加2020年

1848
02:12:21,200 --> 02:12:24,220
2020年才提出对写生的支持

1849
02:12:24,220 --> 02:12:25,720
那么这里面更多的区分

1850
02:12:25,720 --> 02:12:28,520
是基于有站和无站的区别

1851
02:12:28,520 --> 02:12:29,860
但这都是语言级支持

1852
02:12:29,860 --> 02:12:32,820
都作为first class的语言级支持的对象

1853
02:12:33,180 --> 02:12:38,260
相对而言,这种脚本式语言,它更容易去支持这种写成的概念

1854
02:12:38,260 --> 02:12:42,140
因为它是解释性自行的,它的管理控制的能力会更强

1855
02:12:42,140 --> 02:12:46,300
但对于这种所谓的这种,我们说的这种非脚本形式

1856
02:12:46,300 --> 02:12:49,200
就直接去编译成自行码去执行的这个语言来说

1857
02:12:49,200 --> 02:12:54,160
它的支持就更困难一些,这是目前的一个现状

1858
02:12:54,160 --> 02:12:57,200
那我们可以简单看一下这种构语言写的写成

1859
02:12:57,200 --> 02:13:01,640
很简单啊,就看,只要在这个函数里前面加了一个构

1860
02:13:01,640 --> 02:13:05,720
就变成了一个所谓的一个Go Routing,就是Go的鞋藏

1861
02:13:06,820 --> 02:13:09,160
那它的执行就可以随时会被

1862
02:13:09,160 --> 02:13:13,000
也会被,不叫随时,会被这个Go的运营时所打断

1863
02:13:13,000 --> 02:13:15,060
所以你看到这里面在执行过程中

1864
02:13:16,420 --> 02:13:17,900
这是一个Go Routing

1865
02:13:17,900 --> 02:13:22,100
这个Go Routing,这里面它会发现在执行过程中

1866
02:13:22,100 --> 02:13:26,150
它会被打断,会切到其他的Go Routing去执行

1867
02:13:27,500 --> 02:13:30,080
这是,就在这里面,本来按道理来说

1868
02:13:30,080 --> 02:13:34,540
如果是函数的话,它应该012应该是执行完毕之后,才会执行其他的,

1869
02:13:34,780 --> 02:13:45,060
在这里面中间插了一个,是在于在这里面做了一个Yard,把它让出去,这是一个简

1870
02:13:45,060 --> 02:13:49,660
单的例子,这所有的例子我们都有给出了相应的一些网址,大家有兴趣的

1871
02:13:49,660 --> 02:13:50,280
可以试一下。

1872
02:13:55,480 --> 02:14:00,280
Python也一样,在Python里面是你看加了什么关键字呢?

1873
02:14:00,320 --> 02:14:02,180
语言及知识都有些关键字

1874
02:14:02,720 --> 02:14:05,100
叫async,这个定义了一个协程

1875
02:14:05,100 --> 02:14:08,160
这像是一部函数就是协程

1876
02:14:08,160 --> 02:14:10,140
这里面一部函数里面可以迁到一部函数

1877
02:14:10,140 --> 02:14:12,000
这里面再进一步调一些一部函数

1878
02:14:12,000 --> 02:14:14,440
那么这个await也是另一个关键字

1879
02:14:14,440 --> 02:14:15,900
await就是y,i,e,y

1880
02:14:16,920 --> 02:14:18,000
放弃了

1881
02:14:18,000 --> 02:14:20,260
它这个代表我要去取得一个

1882
02:14:20,260 --> 02:14:21,900
网站的一个返回信息

1883
02:14:21,900 --> 02:14:23,260
这个网络传输很慢

1884
02:14:23,260 --> 02:14:24,680
所以它这里面就压了出去

1885
02:14:26,020 --> 02:14:26,660
把这个

1886
02:14:26,660 --> 02:14:28,420
鞋程让给其他的鞋程去执行

1887
02:14:28,420 --> 02:14:31,360
这样提高它说Io交互的效率

1888
02:14:31,360 --> 02:14:33,820
这本身来说整个这个

1889
02:14:33,820 --> 02:14:35,560
程序就是一个异步的一个

1890
02:14:35,560 --> 02:14:36,620
鞋程的一个程序

1891
02:14:36,620 --> 02:14:38,220
那它会去

1892
02:14:38,920 --> 02:14:40,300
多次访问这个

1893
02:14:40,880 --> 02:14:43,560
同一个网站得到不同的这个UI地址

1894
02:14:43,560 --> 02:14:45,400
这是它这个程序干的一个事情

1895
02:14:45,400 --> 02:14:47,660
你看这里面就关键词讲了Async和Abit

1896
02:14:48,140 --> 02:14:49,960
Async定义了这个鞋程的一个

1897
02:14:52,820 --> 02:14:59,260
Await是让这个携程主动让出,大致这么一个操作,是Python的一个实现。

1898
02:14:59,660 --> 02:15:04,980
Rust也是一样,Rust用于Future这个机制,这就是我们说的,你可以理解为就是

1899
02:15:04,980 --> 02:15:06,560
一种携程。

1900
02:15:06,680 --> 02:15:13,880
怎么来定义呢?你看,我把Hello World定义为一个携程,它也是一样,加了个Async,

1901
02:15:14,220 --> 02:15:16,000
这就是一个携程。

1902
02:15:16,000 --> 02:15:21,380
把这个协程作为一个变量 传给一个函数来进行调度

1903
02:15:21,380 --> 02:15:25,820
那个block-on可以以为是一个协程调度的一个round time

1904
02:15:25,820 --> 02:15:31,260
让它去调度 它就会去按照我们说在这里面去执行一些所谓的

1905
02:15:31,260 --> 02:15:36,000
也会有一些所谓的这个 它叫比如说一个fn.await

1906
02:15:37,180 --> 02:15:40,920
来完成这个所谓的让出的一个操作

1907
02:15:40,920 --> 02:15:43,000
这就是它的一个执行效果

1908
02:15:43,000 --> 02:15:47,700
基本上可以看出來 函數體中就可以通過這種讓出

1909
02:15:47,700 --> 02:15:52,060
和下次再去恢復時期來實現一個非常高效的

1910
02:15:52,060 --> 02:15:56,020
協成級的調度和切換

1911
02:15:56,020 --> 02:15:58,360
當然這裡面所有都是主動發出的

1912
02:15:58,360 --> 02:16:00,520
都靠這種Await這種方式

1913
02:16:00,520 --> 02:16:02,180
或者說前面說到的這種

1914
02:16:02,180 --> 02:16:05,600
在前面或者後面加的什麼等待來發出的

1915
02:16:05,600 --> 02:16:07,180
而這個Go需要注意

1916
02:16:07,180 --> 02:16:10,900
這個Go語言你不用專門寫出自己的Await

1917
02:16:10,900 --> 02:16:12,460
它是在這個函數裡面

1918
02:16:12,460 --> 02:16:15,840
比如這個print只是一個酷函數

1919
02:16:15,840 --> 02:16:19,960
在print的內部它自己欠缺了一些所謂的一些壓力操作

1920
02:16:19,960 --> 02:16:22,580
從而來實現了所謂的這種協生性的切換

1921
02:16:23,440 --> 02:16:24,260
這是三種

1922
02:16:25,600 --> 02:16:27,400
那麼你說這個協生性能高

1923
02:16:27,400 --> 02:16:29,780
可能比一比 確實可以比一比

1924
02:16:29,780 --> 02:16:31,520
有同學說這個進程

1925
02:16:31,520 --> 02:16:32,900
我其實是不是一個進程就夠了

1926
02:16:32,900 --> 02:16:34,280
我也不需要多進程

1927
02:16:34,280 --> 02:16:35,360
你有多CPU的情況下

1928
02:16:35,360 --> 02:16:36,320
你再用單進程

1929
02:16:36,320 --> 02:16:37,380
那只能用到一個CPU

1930
02:16:37,380 --> 02:16:38,740
這面也效率不高

1931
02:16:38,740 --> 02:16:41,640
這裡面就在一個多核在我自己機上跑的一個效果

1932
02:16:42,460 --> 02:16:49,360
我记忆可能以为是一个八核的一台机器吧

1933
02:16:49,360 --> 02:16:50,080
八个处理器

1934
02:16:51,280 --> 02:16:52,380
在上面跑的话

1935
02:16:52,380 --> 02:16:53,820
那么干净成

1936
02:16:53,820 --> 02:16:56,120
这是用Python语言来做了一个测试

1937
02:16:56,120 --> 02:16:57,640
就是频繁的取这个网址

1938
02:16:57,640 --> 02:16:59,260
得到一个语语ID

1939
02:16:59,260 --> 02:17:00,640
访问这个网址

1940
02:17:00,640 --> 02:17:02,480
每次访问都会访问一个不同的语语ID

1941
02:17:03,240 --> 02:17:05,400
你可以访问在访问的100次

1942
02:17:05,400 --> 02:17:07,000
这边就比如读100次

1943
02:17:07,000 --> 02:17:07,960
然后去取这个

1944
02:17:07,960 --> 02:17:10,200
那么这每一次取的是一个

1945
02:17:40,200 --> 02:17:45,260
建成了一个所谓的一个进程池,有多个进程,每个进程可以占用一个处

1946
02:17:45,260 --> 02:17:46,480
理器去执行。

1947
02:17:48,100 --> 02:17:52,720
那么通过这种方式,它实现了4倍的一个加速,这是进程,进程和进程

1948
02:17:52,720 --> 02:17:53,200
的切换。

1949
02:17:54,000 --> 02:18:00,580
那么还限程,限程相当于把这个进程池换成了限程池,就这么一点区别。

1950
02:18:00,660 --> 02:18:07,520
当然写出来其实区别不大,然后去执行这个所谓的这个限程,这就是一个限程的

1951
02:18:07,520 --> 02:18:07,700
执行。

1952
02:18:07,700 --> 02:18:12,860
线程执行体和所谓的竞争执行体是差不多的,都是这个执行体

1953
02:18:14,400 --> 02:18:14,680
这是

1954
02:18:17,560 --> 02:18:20,280
对,执行体都是这个,所以看出来

1955
02:18:20,280 --> 02:18:24,600
他们执行的内容差不多,但差别在哪,在切换

1956
02:18:24,600 --> 02:18:26,560
在切换,状态保证有恢复等等

1957
02:18:26,560 --> 02:18:28,140
还有创建等等

1958
02:18:28,140 --> 02:18:28,940
那么这里面

1959
02:18:30,400 --> 02:18:30,760
它

1960
02:18:30,760 --> 02:18:33,080
线程花了4秒,那如果用斜程

1961
02:18:34,820 --> 02:18:35,180
这是

1962
02:19:35,560 --> 02:19:39,920
本身这个协程呢 如果要用得好的话需要语言的支持

1963
02:19:41,260 --> 02:19:45,800
而我们这里面还是有一部分同学选择C语言做实验

1964
02:19:45,800 --> 02:19:48,540
那么C语言呢 其实做协程相对来说比较困难一些

1965
02:19:48,540 --> 02:19:49,840
说RUS比较容易一些

1966
02:19:49,840 --> 02:19:53,880
所以我们这里面并没有把他这个协程的设计实现作为一个重点来讲

1967
02:19:54,600 --> 02:19:57,940
因为C没有对应的一个好的一个参考

1968
02:19:57,940 --> 02:20:04,400
所以我们这里面就暂时就不会做对协程的设计实现做深入的讲解

1969
02:20:04,400 --> 02:20:06,700
这是这一块的内容

1970
02:20:06,700 --> 02:20:08,000
这是我们的第二部分

1971
02:20:08,000 --> 02:20:11,000
就给大家介绍完毕

1972
02:20:12,400 --> 02:20:15,080
有同学问 单核下是不是性能其实差不多

1973
02:20:17,300 --> 02:20:18,020
这个问题

1974
02:20:19,020 --> 02:20:20,160
好 那举个例子

1975
02:20:20,160 --> 02:20:21,040
比如单核下

1976
02:20:21,040 --> 02:20:22,220
我证明是多核机器

1977
02:20:22,220 --> 02:20:25,460
单核下跑近程 线程 斜程

1978
02:20:25,460 --> 02:20:27,000
性能怎么样

1979
02:20:28,160 --> 02:20:29,780
留个问题 我觉得这个问题挺好

1980
02:20:29,780 --> 02:20:31,360
这个同学提的问题挺好

1981
02:20:31,360 --> 02:20:33,200
其实是有差别的

1982
02:20:35,080 --> 02:20:37,060
有同学可以去试一试

1983
02:20:37,060 --> 02:20:39,200
把你的处理器限制成一个单核

1984
02:20:39,200 --> 02:20:41,240
然后就跑一跑 看看有没有差别

1985
02:20:41,240 --> 02:20:43,220
我的提示是有差别

1986
02:20:43,220 --> 02:20:46,020
但数据说话 如果有同学做出这个数据

1987
02:20:46,020 --> 02:20:46,900
我们可以交流

1988
02:20:46,900 --> 02:20:49,060
或者我专门以后提个问题

1989
02:20:49,060 --> 02:20:51,440
也可以请同学来看一看

1990
02:20:51,440 --> 02:20:54,060
千万不要不一样

1991
02:20:54,060 --> 02:20:55,200
这很重要

1992
02:20:58,560 --> 02:20:59,280
好 那

1993
02:20:59,280 --> 02:21:00,260
一个千万不要不一样

1994
02:21:00,260 --> 02:21:01,900
第二你有大量的Io操作

1995
02:21:01,900 --> 02:21:03,180
你如果只有一个Io操作

1996
02:21:03,180 --> 02:21:04,120
那没啥区别

1997
02:21:04,560 --> 02:21:06,960
但你如果有上万个Io操作

1998
02:21:06,960 --> 02:21:10,300
那就有区别了

1999
02:21:10,300 --> 02:21:10,580
好

2000
02:21:10,580 --> 02:21:13,900
这个同学的问题我只是模糊的回答了一下

2001
02:21:13,900 --> 02:21:19,320
我们先看看第三集支持线程学生的OS

2002
02:21:21,000 --> 02:21:23,020
这个是测用在实验环节

2003
02:21:23,020 --> 02:21:26,300
就是我们讲下这个线程

2004
02:21:26,300 --> 02:21:27,600
主要是其实主要是线程

2005
02:21:28,500 --> 02:21:31,120
这个OS支持这一块怎么来做

2006
02:21:32,120 --> 02:21:38,760
这是我们后续讲同步物词的时候所需要用到的一个OS

2007
02:21:38,760 --> 02:21:44,780
我们OS会在现成的OS技术之上再做进一步的同步物词的一些支持

2008
02:21:44,780 --> 02:21:49,800
所以这一块也需要大家对它有一个比较清晰的了解

2009
02:21:49,800 --> 02:21:51,620
我们现在还有大概五分钟下课

2010
02:21:51,620 --> 02:21:54,420
所以我会开一个头

2011
02:21:54,420 --> 02:21:57,100
这一部分内容其实相对来说还是比较简单

2012
02:21:57,100 --> 02:21:59,520
相对于我们之前的这个IPCOS

2013
02:21:59,520 --> 02:22:01,540
它的区别量多了线程

2014
02:22:02,120 --> 02:22:03,260
这里面能看出来

2015
02:22:04,700 --> 02:22:05,780
它不是一个的进程

2016
02:22:05,780 --> 02:22:09,400
而是一个的线程在占用处理区域执行

2017
02:22:09,400 --> 02:22:10,720
每个线程有自己的占

2018
02:22:12,800 --> 02:22:13,780
这是它的一块

2019
02:22:13,780 --> 02:22:16,520
而且如果你把这个线程管理放在用户台

2020
02:22:16,520 --> 02:22:18,880
我们说在管理用户台执行的话

2021
02:22:18,880 --> 02:22:20,780
那么你这个所谓这个round time

2022
02:22:20,780 --> 02:22:21,860
就要放在用户台去执行

2023
02:22:21,860 --> 02:22:22,740
这是用户台的round time

2024
02:22:22,740 --> 02:22:24,800
但如果放在内壳里面执行

2025
02:22:24,800 --> 02:22:26,340
你就会有相应的一个

2026
02:22:26,340 --> 02:22:29,680
在PCB里面会有一个TCBS

2027
02:22:29,680 --> 02:22:34,900
就是有一系列的线程的一个类似于一个项量或者数组

2028
02:22:36,380 --> 02:22:38,040
来管理 还来进行管理

2029
02:22:38,040 --> 02:22:41,400
所以这一块和这一块是有点对等

2030
02:22:41,860 --> 02:22:43,760
只是一个方向用户还有一个方向类似的

2031
02:22:43,760 --> 02:22:45,660
这就是区别 这是我们说

2032
02:22:45,660 --> 02:22:49,380
这个所谓的要支持线程的OS要干的事情

2033
02:22:49,380 --> 02:22:53,080
就要对我们之前的IPC OS做进一步的扩展

2034
02:22:56,120 --> 02:22:56,480
OK

2035
02:22:57,200 --> 02:23:00,040
前面已经讲了这些我都已经讲过一遍了

2036
02:23:00,040 --> 02:23:02,080
我就不再进入讲,我们讲到这个现场

2037
02:23:03,320 --> 02:23:06,080
就是要在进程内实现多个控制

2038
02:23:07,300 --> 02:23:09,160
实现这个控制

2039
02:23:09,160 --> 02:23:11,980
但是我们有两种方式,用户态管理和内态管理

2040
02:23:12,460 --> 02:23:14,140
这是还是有区别的

2041
02:23:14,140 --> 02:23:17,400
这是我们做了两种方面的设计

2042
02:23:17,400 --> 02:23:20,540
其实这个设计的很重要一点在于

2043
02:23:20,540 --> 02:23:23,660
你要把进程,就在针对CPU这一点

2044
02:23:23,660 --> 02:23:26,740
你要把这个进程、限程、协程要做一个抽象

2045
02:23:27,900 --> 02:23:31,680
我们所有的东西如果涉及到CPU的执行

2046
02:23:31,680 --> 02:23:34,480
CPU的切换

2047
02:23:34,480 --> 02:23:36,940
那其实我们可以把这三个抽象成一个任务

2048
02:23:36,940 --> 02:23:37,900
我觉得这个词挺好

2049
02:23:37,900 --> 02:23:40,360
就是通过任务来统一的表示

2050
02:23:40,360 --> 02:23:42,380
他们三者之间的一个抽象

2051
02:23:42,380 --> 02:23:44,060
当然他们也会有区别

2052
02:23:44,060 --> 02:23:44,720
有了这个之后

2053
02:23:44,720 --> 02:23:47,720
你会去理解他们各自实现上的差异

2054
02:23:47,720 --> 02:23:49,360
比如说其实这个协程

2055
02:23:49,360 --> 02:23:57,320
我们是基于一个线程的,那么也意味着鞋层并没有说我要把鞋层在多个

2056
02:23:57,320 --> 02:23:58,440
处理机上去执行,

2057
02:23:58,660 --> 02:24:02,300
如果同一个线程的话,因为你线程绑在一个CPU上,

2058
02:24:02,500 --> 02:24:07,440
所以你这个线程中的鞋层只是在这个线程所在的CPU上去切换执行,

2059
02:24:07,800 --> 02:24:10,280
这是它的一些特点。

2060
02:24:10,460 --> 02:24:15,100
而线程本身又属于一个进程的,一个进程可以有多个线程,

2061
02:24:15,500 --> 02:24:22,840
那么,这个现场可以在不同处理器上执行,它就可以达到并行,而协成是一种

2062
02:24:22,840 --> 02:24:23,620
并发。

2063
02:24:24,620 --> 02:24:30,980
并发的意思就是说,它其实并没有在多个处理器上并行的执行,并发是

2064
02:24:30,980 --> 02:24:35,100
切换的执行,在一个处理器上切换的执行,这是并发的一个含义。

2065
02:25:05,100 --> 02:25:09,800
CPU的一個訪問的問題或者是在CPU上執行的一個狀態的保存與恢

2066
02:25:09,800 --> 02:25:10,520
復的問題

2067
02:25:10,520 --> 02:25:12,480
那就是所謂的context

2068
02:25:12,480 --> 02:25:15,640
那context實際上就是CPU的記存器

2069
02:25:15,640 --> 02:25:16,540
說白了就是CPU的記存器

2070
02:25:16,540 --> 02:25:21,420
只是這個記存器裡面有些細節和它本身的組織管理是相關的

2071
02:25:21,420 --> 02:25:23,100
比如對於無站協成而言

2072
02:25:23,100 --> 02:25:25,400
它在記存器裡面的SP

2073
02:25:25,400 --> 02:25:30,540
指向的是協成所屬的那個線程的那個站的指針

2074
02:25:30,540 --> 02:25:32,160
但對於有站協成

2075
02:25:32,160 --> 02:25:33,600
也就是線程而言

2076
02:25:33,600 --> 02:25:39,520
它的SP指向了自己的那个所独占的那个现成的那个信息

2077
02:25:39,520 --> 02:25:42,720
而其他的继承器呢 通用继承器 特别是通用继承器呢

2078
02:25:42,720 --> 02:25:47,840
指向当前那个执行点的时候 它所用到的那些

2079
02:25:47,840 --> 02:25:52,060
继承器的一些值 这样才能够从这个执行点再往下去走

2080
02:25:52,060 --> 02:25:55,240
这个执行点里面很重要一点 这个执行点就是PC继承器

2081
02:25:55,240 --> 02:25:58,840
还有一个PC继承器 还指向当前执行的位置

2082
02:25:59,540 --> 02:26:04,520
所以除了这个sp、pc还有一堆的channel的继承器

2083
02:26:05,360 --> 02:26:09,200
这些形成了所谓的task的context

2084
02:26:11,060 --> 02:26:14,860
那么你的不同的组织结构意味着你在做切换的时候

2085
02:26:14,860 --> 02:26:16,600
还对某些其他地方要做切换

2086
02:26:16,600 --> 02:26:18,950
比如说对于线程而言你切换这个就OK了

2087
02:26:19,860 --> 02:26:22,020
对于线程而言我要切换站

2088
02:26:22,020 --> 02:26:25,500
对于近程而言我要切换页表等等

2089
02:26:25,500 --> 02:26:28,100
这都是一些切换上的一些细节

2090
02:26:28,100 --> 02:26:29,340
需要大家注意

2091
02:26:30,380 --> 02:26:34,000
OK 还有一分钟

2092
02:26:34,000 --> 02:26:36,980
我这个就稍微在这打住了

2093
02:26:36,980 --> 02:26:39,580
我稍微做一个总结

2094
02:26:40,220 --> 02:26:44,780
就是我们今天这堂课讲了IPC的实验

2095
02:26:45,320 --> 02:26:50,160
也讲了进一步 IPC是这样基于进程的

2096
02:26:50,160 --> 02:26:51,820
Interprocess Communication

2097
02:26:51,820 --> 02:26:53,760
那么也讲了线程 Thread

2098
02:26:53,760 --> 02:26:55,080
Corouting 协程

2099
02:26:55,080 --> 02:26:58,800
以及基于现成的OS的设计实现

2100
02:26:58,800 --> 02:27:01,080
希望大家在课后能够去

2101
02:27:01,080 --> 02:27:02,720
同学们能够去看一下

2102
02:27:02,720 --> 02:27:06,580
我们实验的指导书和实验的代码

2103
02:27:06,580 --> 02:27:09,040
能够这份内容有更清楚的了解

2104
02:27:09,040 --> 02:27:11,440
并可以尝试着去理解一下

2105
02:27:11,440 --> 02:27:12,560
我们的第五个实验

2106
02:27:15,360 --> 02:27:17,120
好 今天课就到这结束

2107
02:27:17,120 --> 02:27:18,160
谢谢大家

