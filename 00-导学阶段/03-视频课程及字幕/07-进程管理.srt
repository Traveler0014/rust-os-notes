1
00:02:55,640 --> 00:02:57,000
好 我们开始上课了

2
00:02:59,140 --> 00:03:02,240
大家应该完成了其中考试 应该可以放松一下

3
00:03:02,240 --> 00:03:05,160
然后再过一周可以放个假 可以进一步放松一下

4
00:03:05,160 --> 00:03:11,000
我觉得挺好的 这次考试大家满不满意

5
00:03:11,760 --> 00:03:14,100
有同学满意 有同学不满意

6
00:03:14,100 --> 00:03:17,700
满意的同学挺好 不满意的同学可以继续满意一下

7
00:03:17,700 --> 00:03:22,320
你通过跟老师的交流 找出自己不满意在哪

8
00:03:23,400 --> 00:03:24,700
我觉得这就是机会

9
00:03:24,700 --> 00:03:26,660
就是我说一下这个

10
00:03:27,420 --> 00:03:28,660
郑重推荐一下午餐会

11
00:03:28,660 --> 00:03:29,660
我发现这个午餐会

12
00:03:29,660 --> 00:03:31,160
从一开始只有三个人到

13
00:03:31,160 --> 00:03:32,560
上次翻到了八个人

14
00:03:33,120 --> 00:03:34,060
一下翻了不少

15
00:03:34,060 --> 00:03:36,500
然后这种那个披萨的价钱也涨了

16
00:03:36,500 --> 00:03:37,500
翻了一倍

17
00:03:39,220 --> 00:03:40,400
在这个会上呢

18
00:03:40,400 --> 00:03:41,320
其实大家就聊聊天

19
00:03:41,320 --> 00:03:42,120
我觉得挺好的

20
00:03:42,120 --> 00:03:44,280
然后我也知道了大家的一些想法

21
00:03:44,280 --> 00:03:48,480
对考试的一些建议和意见

22
00:03:48,480 --> 00:03:49,260
然后呢

23
00:03:49,260 --> 00:03:51,200
对上课也有很多建议和意见

24
00:03:51,200 --> 00:03:52,280
我觉得有些建议

25
00:03:52,280 --> 00:03:53,280
我觉得其实挺好的

26
00:03:53,280 --> 00:03:59,380
我也,我们会在后续的课程中给大家进一步地去改进

27
00:03:59,380 --> 00:04:03,000
比如说,举个例子,我看这里面同学提的说

28
00:04:03,900 --> 00:04:05,640
觉得我们的课后练习不够

29
00:04:06,440 --> 00:04:10,000
他觉得考试出了很多题,我都没见过

30
00:04:11,440 --> 00:04:13,160
要增强课后练习

31
00:04:14,100 --> 00:04:16,240
但这个其实是我们之前被砍掉的内容

32
00:04:16,240 --> 00:04:19,360
我们之前增加了很多课后练习,同学反馈工资量太大

33
00:04:19,360 --> 00:04:20,560
所以我们砍掉了

34
00:04:20,560 --> 00:04:22,240
但是现在同学又要求恢复

35
00:04:22,240 --> 00:04:31,620
我们可以考虑恢复一下,增加更类似于考试那种题型的或者类型的课

36
00:04:31,620 --> 00:04:33,380
后练习,让大家去做一下。

37
00:04:33,880 --> 00:04:40,240
第二个同学提出来,我不会临时编程,你考临时编程很糟糕。

38
00:04:42,560 --> 00:04:46,780
我记得你们大一的时候,李国良老师给你们上那个编程课就是在临时面去

39
00:04:46,780 --> 00:04:47,340
编的吧。

40
00:05:17,340 --> 00:05:20,340
大家去理解一下 然后大家觉得它比较困难

41
00:05:22,440 --> 00:05:25,760
所以我们会加强大家对应用程序的理解

42
00:05:25,760 --> 00:05:28,780
这个其实也是来自于我们的同学的一个反馈

43
00:05:28,780 --> 00:05:31,780
我觉得我们很多建议就是得到了很多

44
00:05:31,780 --> 00:05:33,340
两方面完全不同的感觉

45
00:05:33,340 --> 00:05:35,000
就以前我们上超级种课的时候

46
00:05:35,560 --> 00:05:38,040
同学给我们反馈说老师只想内核

47
00:05:38,040 --> 00:05:39,880
根本就不知道应用程序怎么去用

48
00:05:40,360 --> 00:05:41,580
我应用程序都不会写

49
00:05:41,580 --> 00:05:43,400
所以我们就提供一下应用程序

50
00:05:43,400 --> 00:05:44,220
让大家去理解一下

51
00:05:44,220 --> 00:05:46,920
但确实大家好像通过这次实验发掘

52
00:05:46,920 --> 00:05:49,600
大家对应用程序的理解还弱一点

53
00:05:49,600 --> 00:05:53,120
所以我们能做的事情是什么回事呢

54
00:05:53,120 --> 00:05:55,280
就只要你粘边了就得分打得宽松一点

55
00:05:55,280 --> 00:05:57,100
所以你们基本上还是算对的

56
00:05:57,100 --> 00:05:57,840
不会算错

57
00:05:57,840 --> 00:05:58,920
所以这点大家放心

58
00:06:00,500 --> 00:06:02,100
然后这点说明一个问题

59
00:06:04,820 --> 00:06:08,760
大家对应用程序和OS间的关系

60
00:06:08,760 --> 00:06:11,860
还是理解的不是特别的深入

61
00:06:11,860 --> 00:06:12,940
火力也不是特别深入

62
00:06:13,960 --> 00:06:19,600
所以我们后面还会进一步地去在这方面加强一下,让你能够理解,不是说

63
00:06:19,600 --> 00:06:21,660
只知道OS怎么做的,

64
00:06:21,680 --> 00:06:25,340
而在于你知道这些所有OS做的事情其实都是给应用程序做支持的。

65
00:06:25,500 --> 00:06:33,420
那应用程序的一些行为或者它的一些请求,它会造成OS怎么样影响,这个我觉得也是

66
00:06:33,420 --> 00:06:35,040
需要大家去理解的。

67
00:06:35,040 --> 00:06:39,960
这就是我觉得这门课的一个特点,它是比较系统地来考虑问题,不是说你站

68
00:06:39,960 --> 00:06:41,000
在某情境的一个点,

69
00:06:41,000 --> 00:06:44,000
然后我看还有什么

70
00:06:44,000 --> 00:06:46,000
我看这里面给了很多建议

71
00:06:48,020 --> 00:06:50,000
上次同学给了

72
00:06:54,960 --> 00:06:56,700
建议给一个决策术

73
00:06:57,500 --> 00:06:58,920
什么意思就是说

74
00:06:58,920 --> 00:07:01,120
根据一个竖状结构

75
00:07:01,120 --> 00:07:06,320
来理解整个OS的上课的一个把握

76
00:07:06,320 --> 00:07:08,680
因为经常有可能

77
00:08:39,080 --> 00:08:40,600
叫做资源汇总

78
00:08:41,280 --> 00:08:43,200
资源汇总里面写了一个QA

79
00:08:43,200 --> 00:08:44,740
但是大家可能都没注意

80
00:08:45,220 --> 00:08:46,900
这就是希望大家能够

81
00:08:47,460 --> 00:08:49,660
通过微信通过各种方式

82
00:08:49,660 --> 00:08:50,820
把问题列出来

83
00:08:51,340 --> 00:08:52,940
然后我们的助教去收集起来

84
00:08:52,940 --> 00:08:53,840
放在问答墙里面

85
00:08:53,840 --> 00:08:55,320
使得大家更好的共享

86
00:08:55,320 --> 00:08:57,840
但这个作用并没有体现出来

87
00:08:57,840 --> 00:09:00,900
没有达到像编译那么一个好的效果

88
00:09:00,900 --> 00:09:04,680
这一点我再提醒一下

89
00:09:04,680 --> 00:09:06,280
希望大家尽量问

90
00:09:06,280 --> 00:09:07,700
这样我们的助教会帮助

91
00:09:07,700 --> 00:09:09,920
把大家的问题和答案收集起来

92
00:09:09,920 --> 00:09:11,820
放在这里面给大家去共享

93
00:09:11,820 --> 00:09:15,200
这个是然后视频讲解视频也是一样

94
00:09:15,200 --> 00:09:16,320
我们也是学编译

95
00:09:16,320 --> 00:09:18,420
把这个视频这一块放上去

96
00:09:18,420 --> 00:09:19,540
学了编译很多东西

97
00:09:21,640 --> 00:09:23,400
然后上一期编译还没有吃饭

98
00:09:23,400 --> 00:09:25,100
这些我们编译还可以吃披萨

99
00:09:25,100 --> 00:09:26,360
我觉得还是挺好的

100
00:09:28,060 --> 00:09:30,400
然后还有一点是

101
00:09:32,880 --> 00:09:35,480
我看到学生一个反馈

102
00:09:46,940 --> 00:09:50,320
如果能发现这个问题 我觉得这个学员学得很认真

103
00:09:50,320 --> 00:09:55,560
确实我们的UQOR代码和AFL代码在实现上不一致

104
00:09:56,140 --> 00:10:00,460
那为什么我们不能让它一致呢

105
00:10:00,460 --> 00:10:02,060
老师一直希望它一致

106
00:10:02,060 --> 00:10:04,800
但是这需要我们的助教更多的付出

107
00:10:04,800 --> 00:10:07,680
我们的助教还没做到这一步

108
00:10:07,680 --> 00:10:10,120
他的能力或者时间经历各方面的原因

109
00:10:10,120 --> 00:10:13,800
导致Milford和阿扣还不够一致

110
00:10:13,800 --> 00:10:15,820
我们希望Milford跟阿扣尽量一致一下

111
00:10:15,820 --> 00:10:19,560
这样大家理解起来更加方便一点

112
00:10:19,560 --> 00:10:21,880
因为毕竟老师上课的时候可能确实是阿扣

113
00:10:21,880 --> 00:10:24,220
至少照着阿扣这个思维来讲的多一点

114
00:10:24,220 --> 00:10:25,860
这是一个潜在的问题

115
00:10:26,420 --> 00:10:28,020
那为什么这样就够了呢

116
00:10:28,020 --> 00:10:29,120
就在于其实还有一点

117
00:10:29,120 --> 00:10:31,280
就这个实验其实只要是已过

118
00:10:32,020 --> 00:10:33,960
Has-Case就算是OK了

119
00:10:34,540 --> 00:10:35,860
但其实大家要知道

120
00:10:35,860 --> 00:10:43,100
你TestCase其实应该只是完成了80分,你那个里面还有大量的Bug,我们没有

121
00:10:43,100 --> 00:10:46,780
足够充分的TestCase可以测出来,或者你的不足,没有测出来。

122
00:10:46,980 --> 00:10:50,280
这也是实验的一个局限性。

123
00:10:51,480 --> 00:10:57,860
所以有同学说,我好像不用看整个代码,不就可以很容易地就把这个实验给做

124
00:10:57,860 --> 00:11:04,760
出来了。可能有这种情况,但这种情况其实你对实验的把握是不够深入的。

125
00:11:05,780 --> 00:11:11,460
因为OS,我一直传达OS是一个全局的OVO,全局的一个系统的指考,

126
00:11:12,160 --> 00:11:18,480
所以我们希望大家去读代码,看代码,把这个代码全部OVO,全部要看一遍。

127
00:11:18,740 --> 00:11:22,320
这个是一个要求,但这个要求很难去直接去考核大家。

128
00:11:23,600 --> 00:11:28,600
它只能间接地在你们的考试中,在你们的课程的理解中去体会。

129
00:11:30,500 --> 00:11:37,120
所以虽然我们没法通过测试来做,如果要通过测试,比如说实验来让大家

130
00:11:37,120 --> 00:11:39,640
去把所有大法例也透彻的话,那么你们功能量会非常大。

131
00:11:39,960 --> 00:11:43,560
我们给出很多的空来去填,这个其实也没太大的必要。

132
00:11:43,680 --> 00:11:50,760
所以我们的建议是,老师和助教说,尽量请你们去把每一次试验的云南

133
00:11:50,760 --> 00:11:51,920
书读一下。

134
00:11:52,460 --> 00:11:55,360
那么一个有效的办法,在这里面我们也是通过这个交流之道。

135
00:11:55,360 --> 00:11:57,680
我觉得有些同学他的做法是非常好的

136
00:11:58,780 --> 00:12:00,320
我们实验有很多个

137
00:12:00,320 --> 00:12:01,760
或者说我们的章节有很多

138
00:12:01,760 --> 00:12:05,720
每个章节其实它的OS的实现是一个增量性实现

139
00:12:05,720 --> 00:12:07,160
虽然都号称多不同的OS

140
00:12:07,800 --> 00:12:10,060
所以重点你只要把前一个看好之后

141
00:12:10,060 --> 00:12:12,260
你下面一步一步地去看它的地图

142
00:12:12,260 --> 00:12:14,420
你要知道它这个地图在什么地图

143
00:12:14,420 --> 00:12:16,160
就是为什么要去有这个地图

144
00:12:16,160 --> 00:12:17,600
这个地图到底玩怎么样的功能

145
00:12:18,340 --> 00:12:19,540
你通过理解地图

146
00:12:19,540 --> 00:12:22,140
你可以对它这个差异性或者它这个特征

147
00:12:22,140 --> 00:12:23,540
会有更深刻的理解

148
00:12:23,540 --> 00:12:27,180
这一点这个同学是学得比较好

149
00:12:27,180 --> 00:12:28,420
然后还有同学说

150
00:12:29,560 --> 00:12:31,360
老师给的那个课前预习

151
00:12:31,360 --> 00:12:32,760
要不然说没有课前预习

152
00:12:32,760 --> 00:12:33,820
他听歌其实比较困难

153
00:12:33,820 --> 00:12:34,760
我其实给了

154
00:12:34,760 --> 00:12:36,800
但又可能觉得给的课前预习太多了

155
00:12:36,800 --> 00:12:37,660
课前预量太大了

156
00:12:37,660 --> 00:12:39,120
确实老师给的课前预量比较大

157
00:12:39,480 --> 00:12:40,820
你可以挑重点来看

158
00:12:40,820 --> 00:12:41,900
就是你不一定全看

159
00:12:41,900 --> 00:12:43,560
你根据最直接的

160
00:12:43,560 --> 00:12:45,400
比如老师上课slides稍微过一下

161
00:12:45,400 --> 00:12:46,840
如果slides看觉得有些问题

162
00:12:46,840 --> 00:12:48,500
需要进步多么再看一下课本

163
00:12:48,500 --> 00:12:49,360
或者看一下code

164
00:12:49,360 --> 00:12:51,200
这样课也会比较好一点

165
00:12:51,200 --> 00:12:52,600
但也有同学说

166
00:12:52,600 --> 00:12:59,260
我看了那个tutorial或者看了那个书,看了slides之后,我在听老师讲,觉得老

167
00:12:59,260 --> 00:13:02,740
师在重复这些内容,好像没太大意思。

168
00:13:03,480 --> 00:13:08,800
我觉得如果是这种同学,你水平很高。我对他的建议是说,你就不用上课了,你

169
00:13:08,800 --> 00:13:15,220
直接回去,你做练习也好,你做大实验也好,你做其他事也好,我觉得都OK。

170
00:13:15,220 --> 00:13:25,220
因为确实我们现在面对的同学,我觉得应该是中等靠下一等的同学,这是我们最

171
00:13:25,220 --> 00:13:27,220
主要去上课要针对的目标。

172
00:13:27,480 --> 00:13:34,060
对于中等偏上的同学,你觉得你通过自学就能搞定的,那我觉得非常好。

173
00:13:34,180 --> 00:13:37,080
你真的没必要再重复听一遍,浪费时间。

174
00:13:37,080 --> 00:13:39,280
你就按照你的兴趣

175
00:13:40,280 --> 00:13:41,920
如果你有比较大的欧阳的兴趣

176
00:13:41,920 --> 00:13:42,480
就做大实验

177
00:13:42,480 --> 00:13:43,460
你要没有欧阳的兴趣

178
00:13:43,460 --> 00:13:45,020
你就去做你感兴趣的事情

179
00:13:45,020 --> 00:13:47,160
通过考试我觉得就挺好

180
00:13:47,160 --> 00:13:50,320
我觉得这一点我没有任何的疑问

181
00:13:50,840 --> 00:13:52,300
但一个同学说我不想预习

182
00:13:52,300 --> 00:13:53,080
那听课也行

183
00:13:53,080 --> 00:13:55,020
但听课可能就会有些听不懂的地方

184
00:13:55,460 --> 00:13:56,960
通常听不懂你记下来之后

185
00:13:56,960 --> 00:13:59,120
你课后去补也行

186
00:13:59,120 --> 00:14:01,740
但前提是你要去把这个问题搞懂

187
00:14:01,740 --> 00:14:02,660
这很重要

188
00:14:02,660 --> 00:14:05,360
我觉得这次考试就也暴露出一些问题

189
00:14:05,360 --> 00:14:11,080
有的同学可能就理解得比较极限一点,只是想把老师说过的话给记住。

190
00:14:11,280 --> 00:14:17,460
我一直说,记不是一个好的学习方法,大家都能理解,但是不管怎么样,可能你还是有这种情况

191
00:14:17,460 --> 00:14:17,900
出现。

192
00:14:18,000 --> 00:14:22,540
我举个简单的例子,有同学接到老师上课的时候,在讲多机页表的时候

193
00:14:22,540 --> 00:14:23,980
就说了一点说,

194
00:14:24,720 --> 00:14:30,020
多机页表是为了解决一个页表占空间大的问题,单机页表占空间大,

195
00:14:30,280 --> 00:14:31,320
多机页表占空间少。

196
00:14:31,760 --> 00:14:36,840
我是说过这话,但我还应该上下语,什么情况下是会这种情况。但是在一些情况

197
00:14:36,840 --> 00:14:41,880
下,它多阶表会比单阶表还会占的空间多。我们给人家提这个例子,

198
00:14:42,340 --> 00:14:46,800
结果他一直想到我这句话,觉得他做的题是错的,明明是对的,他其实

199
00:14:46,800 --> 00:14:53,880
做对的题给划了,然后再重新给个错误答,这就是比较机械地比较

200
00:14:53,880 --> 00:14:54,800
老实的一个题。

201
00:14:54,800 --> 00:15:02,520
我觉得应该有一个正确的思考,这个是需要大家理解的。还有一点就是,超级同胞

202
00:15:02,520 --> 00:15:05,520
本身应对的场景是非常多的。

203
00:15:06,340 --> 00:15:14,840
我记得我当时多次强调过,我们说的很多的话没有绝对的正确,它一定是

204
00:15:14,840 --> 00:15:20,100
基于某个上下文,在这个上下文这个话是可以自洽的,或者说逻辑上是

205
00:15:20,100 --> 00:15:21,960
没有矛盾的,就OK了。

206
00:15:22,400 --> 00:15:26,960
你可以给出同样不同的答案,只要你把它说得圆,我们都会认为是对的。

207
00:15:27,760 --> 00:15:30,880
所以这一点大家也需要注意,就是你要把这个上下文搞明白。

208
00:15:31,120 --> 00:15:36,060
我们这里面超运课里面有大量的上下文,这个需要。

209
00:15:36,860 --> 00:15:41,280
然后还有同学觉得这个老师给的什么GitHub也有,Git也有,然后网络学校

210
00:15:41,280 --> 00:15:44,880
也有,还有咱们清华的Git也有,各种各样的信息。

211
00:15:45,160 --> 00:15:49,600
那其实对于谁而言,你们只要关注Git的那个清华的信息就够了,你

212
00:15:49,600 --> 00:15:50,480
没必要去看GitHub。

213
00:15:53,120 --> 00:15:58,540
然后那个slides,我们也给了一个唯一的,就github上面有一个slides,我们在第一堂

214
00:15:58,540 --> 00:16:04,920
课的slides上面给过链接,你只要访问一处就行了,没必要去说我要多

215
00:16:04,920 --> 00:16:07,440
个地方去看,确实增加大家的负担,没必要。

216
00:16:38,240 --> 00:16:42,660
我觉得我稍微解释一下,编译和超级系统不一样,编译是一个线性的过

217
00:16:42,660 --> 00:16:49,840
程,就是它前面的前端、中端、后端相对独立,比较线性。

218
00:16:50,980 --> 00:16:55,460
所以我理解前端,我不必须理解后端,它确实有这种特点。

219
00:16:56,060 --> 00:17:02,120
但是对于超级系统而言,我增加一个功能,我改了一个地方,它可能牵扯的是

220
00:17:02,120 --> 00:17:04,560
所有的地方都要跟着去适应和修改。

221
00:17:04,560 --> 00:17:08,860
大家后面会看到,比如我讲明天系统的时候就发现,它其实和我们Memory管理

222
00:17:08,860 --> 00:17:12,500
有关,和我们进程管理有关,和冬段异常处理也有关。

223
00:17:14,560 --> 00:17:19,660
最后讲明天系统,我前面都不考了,不可能,都会有关系的。所以它是

224
00:17:19,660 --> 00:17:22,580
一种非线性关系,这是OS的一个课点。

225
00:17:22,920 --> 00:17:27,540
所以让我画重点,我可以画,那画这个重点等于是不画,没什么区别。

226
00:17:27,700 --> 00:17:33,400
我们讲的那些课程内容,应该来说,老师如果是认为不考的,会像刚

227
00:17:33,400 --> 00:17:35,700
才说的很明确,这是不考的内容。

228
00:17:35,780 --> 00:17:43,700
如果没有说这种话的话,那我觉得大家还是要注意一下,这个是这个课程的特点造成的,

229
00:17:43,720 --> 00:17:46,980
我们不太好去画出这种一定不考的地方。

230
00:17:46,980 --> 00:17:50,020
因为它的牵扯性相关性牵扯太多了

231
00:17:50,660 --> 00:17:53,120
很难去精确的划分中是哪些考本就不考

232
00:17:53,640 --> 00:17:55,980
这个也给大家解释一下

233
00:18:00,720 --> 00:18:02,520
从整个的考试成绩来说

234
00:18:02,520 --> 00:18:04,460
我刚感觉跟去年比起来

235
00:18:04,460 --> 00:18:07,280
比去年的还是要略高一些

236
00:18:09,400 --> 00:18:11,060
然后我跟李老师也商量过

237
00:18:11,580 --> 00:18:13,580
从超级种课的这个课程来说

238
00:20:43,580 --> 00:20:45,900
地址空间管理 整合在一起

239
00:20:45,900 --> 00:20:48,860
专门形成了所谓进程管理的一个结构

240
00:20:48,860 --> 00:20:49,780
叫做进程空间化

241
00:20:49,780 --> 00:20:53,000
在这里面去把所有的那些前面的内容

242
00:20:53,000 --> 00:20:54,420
再做一次整合

243
00:20:54,420 --> 00:20:56,240
你可以简单地解释为

244
00:20:56,240 --> 00:20:57,880
这个process的时候

245
00:20:57,880 --> 00:20:58,720
我们讲这个process

246
00:20:58,720 --> 00:21:01,460
其实是我们前面内容的一个成构

247
00:21:01,460 --> 00:21:03,660
让它更加有效地去应对

248
00:21:03,660 --> 00:21:06,960
后续的灵活高效的应用执行

249
00:21:09,040 --> 00:21:11,900
这是一个大的背景

250
00:21:12,420 --> 00:21:18,820
好,在讲这个之前,我们上一堂课已经讲到了有这么一个小的例子,以例子为例,

251
00:21:18,900 --> 00:21:23,680
就是讲我们要写一个应用程序,它能够自己去创建,

252
00:21:23,760 --> 00:21:28,400
不是通过超级种,自己直接就可以发出一种请求,我要创建一个执行者,我要去执

253
00:21:28,400 --> 00:21:31,320
行新的程序,那么当然需要超级种支持了。

254
00:21:31,820 --> 00:21:41,620
这两个字是我们可以看到,这个图就是讲到了我们怎么去支持它。虽然这不是完全的原

255
00:21:41,620 --> 00:21:46,260
理,这实际上是从我们实验中给它抽象出来的一个图,但大家也能看出来,

256
00:21:46,640 --> 00:21:54,780
对于我们要管理的一个所谓的进程而言,它的一个状态,所有的状态,这是它的

257
00:21:54,780 --> 00:21:56,640
状态的一个记录,包含了什么?

258
00:21:56,640 --> 00:21:59,180
我们之前学的上下文

259
00:21:59,180 --> 00:22:01,580
有线路上下文 有任务上下文

260
00:22:01,580 --> 00:22:02,640
然后还有一个状态什么呢

261
00:22:02,640 --> 00:22:03,400
它的地址空间

262
00:22:03,400 --> 00:22:05,600
就是我们说这个地址空间放在这儿了

263
00:22:05,600 --> 00:22:07,100
然后它内核里面还有一个内核站

264
00:22:07,100 --> 00:22:09,380
因为它在内核里面就做相应的一些处理

265
00:22:09,380 --> 00:22:11,200
然后在这里面我们因为说

266
00:22:11,200 --> 00:22:13,320
它还有一些比如说创建紫禁城

267
00:22:13,320 --> 00:22:15,240
那么所谓的父子关系

268
00:22:15,240 --> 00:22:16,760
还有一个建立

269
00:22:18,960 --> 00:22:21,160
这些信息这是动态变化的

270
00:22:21,160 --> 00:22:21,740
还有什么

271
00:22:21,740 --> 00:22:23,280
我们在运行过程中

272
00:22:23,280 --> 00:22:24,600
它可能是running的

273
00:22:24,600 --> 00:22:26,980
正在执行战斗CPU去执行

274
00:22:26,980 --> 00:22:29,720
就在这 正在战斗CPU执行的一个running time

275
00:22:29,720 --> 00:22:31,600
也有可能处于ready time

276
00:22:32,340 --> 00:22:33,120
就旧区 time

277
00:22:33,120 --> 00:22:35,980
因为我现在没有战斗CPU

278
00:22:35,980 --> 00:22:36,960
但是我准备好了

279
00:22:36,960 --> 00:22:38,820
只要你给我CPU这样就可以去执行

280
00:22:38,820 --> 00:22:41,600
那么这种状态的信息在这里面也有体现

281
00:22:43,260 --> 00:22:45,840
OK 那所有这些进程都会被一个

282
00:22:45,840 --> 00:22:48,460
所谓的一个叫task manager来管理起来

283
00:22:48,460 --> 00:22:51,320
而且可以用一个简单的一个list

284
00:22:51,320 --> 00:22:53,140
或者是项量或者数字都OK了

285
00:22:53,140 --> 00:22:53,880
这取决于数字结构

286
00:22:56,180 --> 00:23:02,100
现在讲的内容并没有特别强调performance,并没有强调性能,所以我们只要能够用

287
00:23:02,100 --> 00:23:02,880
就行。

288
00:23:03,240 --> 00:23:06,100
所以你看它就是这么一个结构,你可以认为是一个链表。

289
00:23:06,280 --> 00:23:10,480
然后这个结构把所有的这些处于ready type的,就具体的竞争力关系,

290
00:23:11,140 --> 00:23:16,840
所以我们就可以通过这种超级种的这种结构能够去控制说,我要让哪个

291
00:23:16,840 --> 00:23:17,880
程序去执行,

292
00:23:18,200 --> 00:23:23,080
哪个程序先不要执行,挂到对面去,这就是我们一个大致的过程。

293
00:23:23,080 --> 00:23:25,760
如果要创建新的应用

294
00:23:25,760 --> 00:23:28,460
那你就要创建一个新对应的所谓的TCB

295
00:23:28,460 --> 00:23:29,920
把它跨到这里面去

296
00:23:29,920 --> 00:23:33,880
那你就可以让我们OSA去执行

297
00:23:33,880 --> 00:23:37,700
这就是整个大致的一个

298
00:23:37,700 --> 00:23:39,660
对我们说前一个OS

299
00:23:39,660 --> 00:23:44,680
就前一个结构的一个进一步的重构

300
00:23:44,680 --> 00:23:49,360
搞得更加符合我们应用的需求

301
00:23:49,360 --> 00:23:50,520
更加灵活

302
00:23:51,720 --> 00:23:52,760
再讲一下

303
00:23:52,760 --> 00:23:59,160
假设有了这个结构之后,我们可以看一看,我们的 OS 启动之后,怎么就能够

304
00:23:59,160 --> 00:24:00,280
把这个竞争给启举起来?

305
00:24:01,080 --> 00:24:10,880
首先,第一步,OS 处理化,这个处理化很想要对自己建立好自己所需要的一个空

306
00:24:10,880 --> 00:24:10,940
间。

307
00:24:11,100 --> 00:24:15,960
比如说,我们 OS 内部也有一个虚拟的空间,这一步要搞好,自己要能搞好

308
00:24:15,960 --> 00:24:16,500
自己。

309
00:24:16,500 --> 00:24:20,500
关于自己之后 我要去让应用程序执行的

310
00:24:20,500 --> 00:24:22,340
一定会存在一个第一个应用程序

311
00:24:22,340 --> 00:24:24,120
就是叫做NIT PROC

312
00:24:24,120 --> 00:24:28,200
这个应用程序其实大家如果去做实验的话

313
00:24:28,200 --> 00:24:29,180
你也看不到这个程序

314
00:24:29,180 --> 00:24:32,060
因为它在后面 隐藏了它没有一个界面

315
00:24:32,060 --> 00:24:35,020
有界面是什么 有界面是share 我们看到有share

316
00:24:35,020 --> 00:24:37,880
而这个NIT PROC实际上就是我们说的一个

317
00:24:37,880 --> 00:24:41,180
第一个根的应用程序

318
00:24:41,180 --> 00:24:42,160
运行的应用程序

319
00:24:42,160 --> 00:24:45,300
由它来FOC出其他的程序

320
00:24:45,300 --> 00:24:47,760
只有这个NIT Proc自己不是Fock的

321
00:24:47,760 --> 00:24:51,620
它是谁创建的 硬生生的创建出了这么一个

322
00:24:52,660 --> 00:24:53,700
第一个程序

323
00:24:54,560 --> 00:24:56,040
就跟那个孙悟空跳出来一样

324
00:24:56,040 --> 00:24:57,060
那石头给它蹦出来

325
00:24:57,060 --> 00:24:59,860
后面的猴子那应该是孙悟空

326
00:24:59,860 --> 00:25:01,300
也不是啊

327
00:25:02,040 --> 00:25:07,040
就是后面的都是由NIT Proc给它Fock出来的

328
00:25:07,040 --> 00:25:09,640
所以其他可以看出来是它的一个指纵性

329
00:25:09,640 --> 00:25:12,580
这里面其实我可以拿一个Linux来做一个展示

330
00:26:12,960 --> 00:26:17,580
一个EXEC,这两个系列会帮助我们创建各种各样的新的执行层

331
00:26:18,640 --> 00:26:22,080
这就是最开始的一部分工作

332
00:26:22,080 --> 00:26:26,540
再接下来呢,我们这个MIT会创建IIT Pro会创建Share

333
00:26:26,540 --> 00:26:28,900
就到这个Share了,有了Share之后就像这样

334
00:26:28,900 --> 00:26:31,760
我就可以敲字符了,那你敲字符的话

335
00:26:31,760 --> 00:26:34,580
就可以去让它接受这个字符串

336
00:26:34,580 --> 00:26:36,820
比如说我们接受一个这么一个字符串

337
00:26:36,820 --> 00:26:39,680
这个字符串其实代表一个应用程序的名字

338
00:26:39,680 --> 00:26:45,500
有了这个名字之后,我们的Share就会通过Fog,创建一个纸进程,再通

339
00:26:45,500 --> 00:26:50,580
过EXEC,实行这个新的程序,就OK了。

340
00:26:50,980 --> 00:26:58,080
接下来的这个程序也可以再进一步去Fog,再EXEC,这样就形成类似于

341
00:26:58,080 --> 00:27:08,320
这么一个非常有规律的速断结构的一个当前的进程的父子关系的图

342
00:27:08,320 --> 00:27:08,420
案。

343
00:27:08,420 --> 00:27:11,180
这就是这个大致的一个结构

344
00:27:12,000 --> 00:27:15,620
OK 那我就把这个例子先给大家有一个总结的overview

345
00:27:17,000 --> 00:27:20,580
和在一起 所有我前面说的这前面这些步骤

346
00:27:21,760 --> 00:27:25,320
这些步骤 这些步骤都是在这个管理之下进行的

347
00:27:25,320 --> 00:27:29,980
就是都在我们那个任务manager的task manager这个管理之下来完成

348
00:27:29,980 --> 00:27:34,620
它会把你创建的这些进程放在这些列表里面

349
00:27:34,620 --> 00:27:35,900
对它进行有效的管理

350
00:27:35,900 --> 00:27:37,480
什么时候选择在CPU上执行

351
00:27:37,480 --> 00:27:39,260
这个调度是我们后面为讲的类似

352
00:27:39,260 --> 00:27:42,280
这大致是一个它的一个流程

353
00:27:45,220 --> 00:27:45,560
好

354
00:27:46,520 --> 00:27:49,160
那进程管理其实这些方面面是挺多的

355
00:27:49,160 --> 00:27:51,440
我们这边重点讲最关键的几个

356
00:27:52,620 --> 00:27:54,440
一个是进程切换

357
00:27:55,760 --> 00:27:56,780
进程切换

358
00:27:56,780 --> 00:27:58,400
第二个是进程创建与复制

359
00:27:58,400 --> 00:28:00,660
第三个是进程加代与执行

360
00:28:00,660 --> 00:28:02,800
最后一个是进程等待与退出

361
00:28:02,800 --> 00:28:09,180
这里面其实是包含了我们竞争管理最核心的部分的内容

362
00:28:09,180 --> 00:28:11,780
所以说那自然就是这就是重点

363
00:28:11,780 --> 00:28:13,840
这个我觉得大家能够理解我说的话

364
00:28:15,060 --> 00:28:16,400
只要我们看竞争切换

365
00:28:17,500 --> 00:28:18,860
竞争切换这一道

366
00:28:18,860 --> 00:28:20,060
其实竞争往前面讲

367
00:28:20,060 --> 00:28:22,560
它和我们之前讲的任务其实很类似的

368
00:28:23,240 --> 00:28:25,400
所以你会发现它这个所谓的切换

369
00:28:25,400 --> 00:28:27,080
它和任务切换是类似的

370
00:28:27,080 --> 00:28:29,680
就是暂停当前运行的竞争

371
00:28:29,680 --> 00:28:32,120
然后把它从运行它变成其他状态

372
00:28:32,120 --> 00:28:34,540
这其他状态到目前为止

373
00:28:34,540 --> 00:28:35,520
我们就应该是说

374
00:28:35,520 --> 00:28:37,220
如果这个进程还没有结束的话

375
00:28:37,220 --> 00:28:38,260
就是ReadyTime

376
00:28:38,260 --> 00:28:39,440
如果进程结束了

377
00:28:39,440 --> 00:28:42,520
它应该是结束退出这个状态

378
00:28:42,520 --> 00:28:44,520
然后再选择另外一个进程

379
00:28:44,520 --> 00:28:45,520
从这个选择

380
00:28:45,520 --> 00:28:48,140
从我们说这个就绪对线里面

381
00:28:48,140 --> 00:28:49,060
从这里面选择一个

382
00:28:49,060 --> 00:28:51,560
比如投这个进程

383
00:28:51,560 --> 00:28:53,520
再拿去执行

384
00:28:53,520 --> 00:28:55,160
从就绪台变成运行台

385
00:28:55,160 --> 00:28:57,080
就它去占用处理器去执行

386
00:28:57,080 --> 00:28:58,980
这是一个切换的过程

387
00:28:58,980 --> 00:29:00,600
那么这个切换前切换后

388
00:29:00,600 --> 00:29:04,880
它会保存和恢复进程的上下文

389
00:29:06,020 --> 00:29:07,080
这才叫进程上下文

390
00:29:07,080 --> 00:29:08,020
进程上下文是什么

391
00:29:08,700 --> 00:29:09,840
我们又读遍了进程上下文

392
00:29:09,840 --> 00:29:11,400
我们这次期中考试还考了

393
00:29:12,060 --> 00:29:13,540
TRAP上下文

394
00:29:13,540 --> 00:29:14,640
任务上下文

395
00:29:14,640 --> 00:29:15,540
函数上下文

396
00:29:15,540 --> 00:29:16,860
有一些同学答得很好

397
00:29:17,440 --> 00:29:19,180
基本上是把老师的slides

398
00:29:19,180 --> 00:29:20,380
维生风不动地写出来了

399
00:29:20,380 --> 00:29:21,140
老师还没看明白

400
00:29:21,140 --> 00:29:22,120
他比我记得还清楚

401
00:29:23,060 --> 00:29:25,300
我就发觉咱们同学记性确实非常好

402
00:29:25,300 --> 00:29:27,180
但也有同学确实不知道

403
00:29:27,180 --> 00:29:28,640
那个上下文是什么

404
00:29:28,640 --> 00:29:31,080
这个就是对于理解不够

405
00:29:31,080 --> 00:29:34,600
我们其实说所有这些抽象的概念其实都是代码

406
00:29:34,600 --> 00:29:38,140
里面的数以结构和对应的控制逻辑

407
00:29:38,140 --> 00:29:40,460
进程上下文是啥 其实就这一块

408
00:29:40,460 --> 00:29:43,700
就把之前的做了一个包装

409
00:29:43,700 --> 00:29:49,140
就把地址空间trap上下文还有任务上下文做了一个封装

410
00:29:49,140 --> 00:29:50,120
称之为进程上下文

411
00:29:50,940 --> 00:29:53,340
所以这里面的保存进程上下文

412
00:29:53,340 --> 00:29:58,120
其实可以理解为从开始trap上下文的保存

413
00:30:28,120 --> 00:30:37,340
这些内容,一堆集成器,还有相应的一些,这些基本上通集成器和一些spe

414
00:30:37,340 --> 00:30:41,840
cial集成器,我们对Risk 5来讲叫CSR集成器,对于你换了CPU可能

415
00:30:41,840 --> 00:30:42,820
有其他的集成器。

416
00:30:43,020 --> 00:30:47,040
总的来说,这些集成器的保存是为了能够回到用户台能够去

417
00:30:47,040 --> 00:30:56,860
正常执行,这是需要的。

418
00:30:58,560 --> 00:31:00,540
这是这个信息做个介绍

419
00:31:01,420 --> 00:31:04,520
OK 进程切换其实我就非常快地讲完了

420
00:31:06,300 --> 00:31:08,380
因为之前的细节

421
00:31:08,380 --> 00:31:10,160
我们讲地址空间切换

422
00:31:10,160 --> 00:31:11,880
讲chart切换

423
00:31:11,880 --> 00:31:13,520
讲任务切换都讲得过

424
00:31:13,520 --> 00:31:15,360
然后合在一起就是我们的进程切换

425
00:31:15,360 --> 00:31:18,760
所以大家如果还有点疑惑的话

426
00:31:18,760 --> 00:31:20,140
把之前的内容看一下

427
00:31:20,140 --> 00:31:22,860
我觉得就回顾一下就应该OK了

428
00:31:22,860 --> 00:31:23,800
就知道这个问题了

429
00:31:24,660 --> 00:31:30,660
讲第二个问题,就是进程的创建与复制。这里面我们会以两个超级种为例

430
00:31:30,660 --> 00:31:30,960
来讲。

431
00:31:31,040 --> 00:31:35,840
一个是我正在用的Windows,就是Windows超级种。

432
00:31:37,300 --> 00:31:47,500
Windows超级种它其实是在80年代末,九十年代初的时候,微软做的一个非常

433
00:31:47,500 --> 00:31:48,380
牛的OS。

434
00:31:48,380 --> 00:31:53,000
那这个OS它积蓄了之前的OS的一些经验

435
00:31:53,360 --> 00:31:56,260
它制造了自己的一个CPU 叫做CreateProcess

436
00:31:58,360 --> 00:32:03,200
这么一个函数来创建了一个进程

437
00:32:03,200 --> 00:32:05,000
你看它带了一个FireLine 这什么意思呢

438
00:32:05,000 --> 00:32:07,180
实际上就是说我创建Process的时候

439
00:32:07,180 --> 00:32:09,280
它可以是个新程序 它应该是个新程序

440
00:32:09,280 --> 00:32:11,160
它不太care的时候 我要复制

441
00:32:11,160 --> 00:32:12,940
我们说Fog 刚才有讲Fog 它没有复制

442
00:32:12,940 --> 00:32:16,280
它就是说 我就要把这个新的一个程序来创建出来

443
00:32:16,280 --> 00:32:19,340
给他安排相应的地址空间

444
00:32:19,340 --> 00:32:20,160
他的上下轴

445
00:32:20,160 --> 00:32:21,400
然后可以正常去执行

446
00:32:22,500 --> 00:32:25,180
这里面这是他最简单的一个选词

447
00:32:25,180 --> 00:32:26,100
是一个非常简单的

448
00:32:26,100 --> 00:32:28,120
他实际的参数是非常多的

449
00:32:28,120 --> 00:32:29,580
一个同样增加不同的参数

450
00:32:29,580 --> 00:32:32,800
来实现对这个process的一个

451
00:32:32,800 --> 00:32:34,520
指令环境的一个定制

452
00:32:34,520 --> 00:32:36,080
这非常重要在于

453
00:32:36,080 --> 00:32:37,460
我们的process都是运行在一个

454
00:32:37,460 --> 00:32:39,220
所谓的指令环境里面的

455
00:32:39,220 --> 00:32:41,680
我们曾经这个期中考试也考虑到

456
00:32:42,100 --> 00:32:44,960
提那个软件的指令环境是什么

457
00:32:44,960 --> 00:32:49,400
执行环境就是他所依赖的那套东西,比如说他依赖超级统给他地

458
00:32:49,400 --> 00:32:53,560
址平坚,依赖超级统给他的站,等等。这都是一些执行环境。

459
00:32:54,280 --> 00:32:59,980
你可以通过设置不同的参数来改变执行环境,比如说我是否要继承创建

460
00:32:59,980 --> 00:33:05,120
我这个进程所拥有的一些资源,我们虽然还没有讲到,但大家都可以理解的,比如

461
00:33:05,120 --> 00:33:05,720
文件。

462
00:33:06,820 --> 00:33:12,440
我创建进程的那个文件,我能不能给被创建的进程,让他去继承这

463
00:33:12,440 --> 00:33:12,860
些信息。

464
00:33:12,860 --> 00:33:19,720
这都是属于这些参数可以去选择的,所以这些参数是比较复杂的,这是

465
00:33:19,720 --> 00:33:25,000
QuidProcess的一个大致的含义。

466
00:33:27,140 --> 00:33:34,820
第二个是Unix,它就用了两个,它没有像Windows一样用了一个。

467
00:35:05,440 --> 00:35:07,400
那这个Fog是非常好的一个东西

468
00:35:07,400 --> 00:35:08,980
它没有任何的参数

469
00:35:09,580 --> 00:35:11,140
直接执行一个函数就完了

470
00:35:12,360 --> 00:35:13,760
它非常简洁的使用

471
00:35:13,760 --> 00:35:15,480
不像这个前面的Windows

472
00:35:15,480 --> 00:35:17,060
它后面会带一堆参数

473
00:35:17,060 --> 00:35:18,920
你需要理解每个参数的含义

474
00:35:18,920 --> 00:35:20,200
开发成本会比较高

475
00:35:20,200 --> 00:35:21,740
这开发成本很低

476
00:35:23,160 --> 00:35:25,360
但是后面也会有其他那些问题

477
00:35:25,360 --> 00:35:27,320
这个我们在后面主义展来讲

478
00:35:27,680 --> 00:35:29,040
我们还是先看看

479
00:35:29,580 --> 00:35:30,780
先把这个问题抛开

480
00:35:30,780 --> 00:35:32,020
我们先看看它的一些

481
00:35:33,260 --> 00:35:34,460
实现的例子

482
00:35:34,460 --> 00:35:36,360
这前面其实已经给了个例子

483
00:35:36,360 --> 00:35:37,840
你看它这个调用

484
00:35:37,840 --> 00:35:41,560
这个调用就是这么一个 fork 扣号就完了

485
00:35:41,560 --> 00:35:44,840
让它返回一个整形 PID

486
00:35:44,840 --> 00:35:47,360
如果返回整形 PID 是0的话

487
00:35:47,360 --> 00:35:51,100
那意味着当前我已经创建了一个指令层

488
00:35:51,100 --> 00:35:52,660
指令层已经得到执行了

489
00:35:52,660 --> 00:35:54,600
我现在是指令层正在执行

490
00:35:54,600 --> 00:35:56,660
所以会做后面的事情

491
00:35:56,660 --> 00:35:59,680
那么指令层也许会执行一个 EXEC

492
00:36:00,240 --> 00:36:02,660
来把这个 program 给刨起来

493
00:36:03,400 --> 00:36:05,660
它这个Program还可以带很多参数

494
00:36:07,320 --> 00:36:09,760
你会发现这也是一个灵活性

495
00:36:09,760 --> 00:36:12,220
目前为止到我们现在这个OS

496
00:36:12,220 --> 00:36:13,880
就是我们现在支持Process OS

497
00:36:13,880 --> 00:36:16,080
我们这个Program还不支持

498
00:36:16,780 --> 00:36:18,200
有程序的参数

499
00:36:18,200 --> 00:36:19,020
还是有参数

500
00:36:19,020 --> 00:36:21,080
但是程序本身是没有参数的

501
00:36:21,080 --> 00:36:22,760
所以这是我们在后面的实验

502
00:36:22,760 --> 00:36:24,060
下一个实验的时候

503
00:36:25,460 --> 00:36:26,520
支持IPC的时候

504
00:36:26,520 --> 00:36:27,980
它会把这一部分给补上去

505
00:36:27,980 --> 00:36:30,800
就看我们在一步步的再增加再更了

506
00:36:30,800 --> 00:36:36,480
有了X1C之后,就会以新的程序来覆盖我们的整个资源,包括我们

507
00:36:36,480 --> 00:36:38,460
的地址空间,这是Folk。

508
00:36:38,680 --> 00:36:44,920
那Folk到底干了什么事情?它创建了一个纸进程,这个纸进程成了大量

509
00:36:44,920 --> 00:36:47,120
的复制性的东西。

510
00:36:47,300 --> 00:36:52,240
这个东西用了进程或者用了复制,这个说法比较好,因为它是两份,不是一

511
00:36:52,240 --> 00:36:52,960
份,变成两份。

512
00:36:53,420 --> 00:36:57,220
比如说它复制了它的变量和内存,复制了它的所有竞争器。

513
00:36:58,420 --> 00:37:00,700
这个实际上什么呢 就复制了它整个地质空间

514
00:37:01,880 --> 00:37:04,220
就是我还有一份跟它一样的地质空间

515
00:37:07,500 --> 00:37:09,960
但是如果它们俩完全一样的话

516
00:37:10,340 --> 00:37:12,400
你怎么知道它是复进层还是止进层

517
00:37:12,820 --> 00:37:15,040
它一定有一个地方不一样

518
00:37:15,040 --> 00:37:18,000
就是通过 当然在内核里面

519
00:37:18,000 --> 00:37:20,180
在内核里面 我创建了一个止进层

520
00:37:20,180 --> 00:37:21,580
我实际上创建了一个TCB

521
00:37:21,580 --> 00:37:23,000
创建了一个进层控制框

522
00:37:23,000 --> 00:37:24,920
它们就是两个进层控制框

523
00:37:24,920 --> 00:37:26,460
在内核里面看得很清楚

524
00:37:26,800 --> 00:37:30,200
但对应用程序而言 它们的代码是一样的

525
00:37:30,200 --> 00:37:33,220
那我怎么知道我是自己是附近城还是止境城

526
00:37:33,220 --> 00:37:36,460
就根据这个PID 就是Fork的返回值

527
00:37:37,400 --> 00:37:40,200
返回这个PID来决定 PID是0 这是止境城

528
00:37:40,200 --> 00:37:43,640
如果PID是一个大于0的值 那就是附近城

529
00:37:43,640 --> 00:37:45,760
就是附近城返回了

530
00:37:46,300 --> 00:37:48,400
那附近城如果大于0的值是什么呢

531
00:37:48,400 --> 00:37:51,300
实际上是止境城的PID号 是止境城PID号

532
00:37:51,300 --> 00:37:54,200
所以我知道止境城PID号之后

533
00:37:54,200 --> 00:37:55,600
我附近城可以干其他事情

534
00:37:55,600 --> 00:37:57,620
比如说我可以等待指定程度结束

535
00:37:57,620 --> 00:37:59,500
我可以用这个PID号来等待结束

536
00:37:59,500 --> 00:38:03,000
那这也是一个通常说讲到的退出等待的一套技术教育

537
00:38:06,980 --> 00:38:11,700
那这是可以看到的一个非常非常

538
00:38:11,700 --> 00:38:13,420
general的一个展示

539
00:38:13,420 --> 00:38:17,020
这是我们的C的代码

540
00:38:17,020 --> 00:38:19,600
那么它的一个地址空间是这么一回事

541
00:38:19,600 --> 00:38:21,460
通过一个Fog操作之后

542
00:38:21,460 --> 00:38:24,620
它会根据这里面四字组成新的一个

543
00:38:54,620 --> 00:38:55,890
他在干啥

544
00:38:59,340 --> 00:39:01,790
这个咋回去呢

545
00:39:05,660 --> 00:39:06,770
我刷一下

546
00:39:11,060 --> 00:39:12,960
这玩意

547
00:39:33,380 --> 00:39:36,600
就是PID零零是指进程之后 它会执行一个exec

548
00:39:36,600 --> 00:39:39,000
exec会执行另外一个程序的名字

549
00:39:39,000 --> 00:39:40,980
会把这个地图上给创建出来

550
00:39:40,980 --> 00:39:42,740
这就是它一个执行代码

551
00:39:42,740 --> 00:39:42,940
这就是PID零零是指进程之后

552
00:39:42,940 --> 00:39:46,000
这个代码里面 我们写代码经常会在这

553
00:39:46,000 --> 00:39:48,940
就是执行完这个之后 然后会有一个print

554
00:39:54,140 --> 00:39:55,840
然后这是指印层干的事情

555
00:39:55,840 --> 00:40:00,180
对于附近层而言 PID是在后面这个不等于零的情况下

556
00:40:00,180 --> 00:40:03,940
它会有这么一段执行代码 它会等待PID的结束

557
00:40:07,000 --> 00:40:10,040
有点小帅度 我觉得大家应该通过在线的

558
00:40:10,040 --> 00:40:12,540
或者我刚才讲解跟大致的这段代码的含义

559
00:40:13,100 --> 00:40:16,320
这里面有两个问题想问一下大家

560
00:40:16,320 --> 00:40:18,040
我画的这个图线这个地方

561
00:40:18,040 --> 00:40:21,680
就是在EXEC这个系统调用之后

562
00:40:21,680 --> 00:40:24,620
直接这个print这个这段代码能不能执行到

563
00:40:27,580 --> 00:40:28,380
第一个问题

564
00:40:30,280 --> 00:40:32,460
有的人说能 有的人说不能

565
00:40:33,220 --> 00:40:35,420
说不能同学请举手

566
00:40:37,940 --> 00:40:39,680
其实我说能同学呢

567
00:40:39,680 --> 00:40:40,580
估计也还有同学

568
00:40:40,580 --> 00:40:42,300
那不举手的同学是不知道的

569
00:40:48,400 --> 00:40:54,100
这个能还是不能,应该这些答案是不能的。

570
00:40:54,200 --> 00:41:06,440
为什么?这个printf这行代码,或者整个这条代码,都是属于附近层的代码端

571
00:41:06,440 --> 00:41:07,020
的类型。

572
00:41:07,620 --> 00:41:14,640
然后我做EXEC的时候,它会把它的calculate,比如说这里面叫calc一个计算器,这个

573
00:41:14,640 --> 00:41:21,100
计算器的代码内容整个覆盖掉,整个之前的背景成的代码内容。

574
00:41:21,160 --> 00:41:26,720
所以这个代码根本就不存在了,就不可能执行到这个地方来,代码已经不存

575
00:41:26,720 --> 00:41:26,920
在了。

576
00:41:26,920 --> 00:41:32,940
它会把前面的全杆清掉,然后再重新分配空间,放置新的程序的

577
00:41:32,940 --> 00:41:34,640
代码内容,所以不可能执行到。

578
00:41:36,520 --> 00:41:42,120
这是需要去理解的。第二个,我给的这个代码还有没有其他问题?

579
00:41:45,960 --> 00:41:51,920
这个以前考过,所以我的课案可以讲习题,这就是讲习题。我考这道题,我说这个

580
00:41:51,920 --> 00:41:54,460
代码有问题。你能找出问题在哪儿?

581
00:41:57,020 --> 00:41:58,340
能看这个代码有什么问题?

582
00:45:04,720 --> 00:45:09,880
这也不对,我没说这个代码对的。我只是说你要注意,还要考虑小于零的情况。

583
00:45:11,160 --> 00:45:14,600
我没有说这个代码对的,这代码也是错的。

584
00:45:16,640 --> 00:45:23,560
但至少你可以看出来,我们通常情况下会有一些这算是编程的问题,就是你对各

585
00:45:23,560 --> 00:45:27,540
种条件考虑不周,这出bug的一个形象出来的问题。

586
00:45:27,540 --> 00:45:31,680
对于这种情况 有大于零小于零等于零三种情况

587
00:45:31,680 --> 00:45:34,200
你只考虑两种情况 这是出问题的地方

588
00:45:34,200 --> 00:45:38,180
这个题也考过 也有很多同学犯错

589
00:45:38,940 --> 00:45:40,940
我不知道期后会不会再出现这种题

590
00:45:40,940 --> 00:45:43,540
这种题都讲得太多了 可能也不需要再考了

591
00:45:44,700 --> 00:45:46,700
好 那我们再稍微可视化地看一看

592
00:45:46,700 --> 00:45:49,020
这个就比较简单了

593
00:45:49,020 --> 00:45:53,560
前面这些都直接只看到应用程序的一个感觉

594
00:45:53,560 --> 00:45:55,060
你写的是应用程序

595
00:45:55,060 --> 00:46:00,340
那OS的话,那你要知道还有一个内核态,内核态干什么事情,这个需要去知道

596
00:46:00,340 --> 00:46:04,860
你看这里面是大致说我们去针对你要一个用户进程在执行的时候

597
00:46:05,240 --> 00:46:10,280
其实它内核里面都有一个对应的PCB来管理它,需要管理它

598
00:46:10,280 --> 00:46:12,380
这一块是需要知道的

599
00:46:12,380 --> 00:46:17,620
然后当它到执行FOC的时候呢,你会发现内核里面创建了一个新的PC

600
00:46:17,620 --> 00:46:17,820
B

601
00:46:17,820 --> 00:46:21,120
这是一个,它会有一个新的PCB

602
00:46:21,600 --> 00:46:27,120
说对于内核它很清楚哪个程序就跑了这个应用程序

603
00:46:27,120 --> 00:46:28,640
哪个是执行程序哪个是附近程序

604
00:46:28,640 --> 00:46:30,520
这就是附近程序

605
00:46:30,520 --> 00:46:32,380
这个就是执行程序它很清楚

606
00:46:32,380 --> 00:46:35,620
因为内核里面这两个不同PCB来管理

607
00:46:35,620 --> 00:46:38,600
但是你后面又执行了一个EXEC

608
00:46:39,240 --> 00:46:41,200
执行EXEC的时候呢

609
00:46:41,200 --> 00:46:45,660
就在这里面就在这执行EXEC之后呢

610
00:46:45,660 --> 00:46:49,520
它会把它整个这个空间全部清掉

611
00:46:49,520 --> 00:46:51,900
重新加载 加载成什么

612
00:46:51,900 --> 00:46:55,060
加载成这个 Calculate

613
00:46:55,060 --> 00:46:57,520
就是我们的这个新的程序的

614
00:46:57,520 --> 00:46:59,060
它的代码段的内容

615
00:46:59,060 --> 00:47:00,840
所以你看它就全都没了

616
00:47:00,840 --> 00:47:02,920
但是还是有些东西保留

617
00:47:02,920 --> 00:47:04,100
比如这PID

618
00:47:04,100 --> 00:47:05,120
以前是PID是多少

619
00:47:05,120 --> 00:47:05,500
还是PID

620
00:47:05,500 --> 00:47:06,820
不会改PID

621
00:47:06,820 --> 00:47:08,780
只是其他的一些相关信息

622
00:47:08,780 --> 00:47:10,920
会有相应的改变

623
00:47:16,420 --> 00:47:17,860
好 那我们先休息一下

624
00:51:19,760 --> 00:51:22,720
东西稍早了这就过去了好谢谢

625
00:52:32,040 --> 00:52:46,580
好,我们继续上课

626
00:52:47,540 --> 00:52:49,400
就刚才说到这次

627
00:52:49,400 --> 00:52:49,460
我们在上课的时候

628
00:52:49,460 --> 00:52:54,520
EXEC它会把整个代码段数据段都给覆盖上

629
00:52:54,520 --> 00:53:02,720
其实就是我们的进程工程化里面的很多内容全都被更新了

630
00:53:02,720 --> 00:53:05,120
但是它的一些基本的像PID的一些信息

631
00:53:05,120 --> 00:53:06,240
并没有去改变

632
00:53:06,240 --> 00:53:07,660
这个大家需要去理解一下

633
00:53:11,620 --> 00:53:13,940
这是一个可视化的展现

634
00:53:13,940 --> 00:53:15,880
就是比如说我们实验这个之后

635
00:53:15,880 --> 00:53:18,460
一开始是温腾一样的

636
00:53:30,800 --> 00:53:38,780
这个是让大家能够站在一个比较高的角度来看它的一个变化情况

637
00:53:38,780 --> 00:53:40,660
具体怎么变 其实还有很多细节

638
00:53:40,660 --> 00:53:43,920
我们会在后面讲实验的时候再进一步介绍

639
00:53:43,920 --> 00:53:47,100
第二个 需要去理解这个Fox干啥

640
00:53:47,100 --> 00:53:48,440
我的Fox呢 创建了一个Fox的设备

641
00:53:48,440 --> 00:53:51,740
创建是为了创建紫禁程用的

642
00:53:53,000 --> 00:53:55,860
这里面给了一个经常出现的一道练习题

643
00:53:55,860 --> 00:53:57,380
又给大家做一道练习题

644
00:53:57,380 --> 00:53:59,520
现在练习基本上放到课上来讲一些

645
00:53:59,980 --> 00:54:01,220
这是一个典型的例子

646
00:54:01,220 --> 00:54:02,080
就是一个拨循环

647
00:54:02,080 --> 00:54:03,920
拨循环里面会嵌一个fork

648
00:54:04,640 --> 00:54:08,720
那么这个fork意味着它会去创建紫禁程

649
00:54:10,000 --> 00:54:13,440
循环loop次loop比方在循环了三次或者四次

650
00:54:14,520 --> 00:54:15,620
每次里面会有一个fork

651
00:54:15,620 --> 00:54:22,380
那请问一共会有多少个进程出现?这是一道也是经常考的题。

652
00:54:23,700 --> 00:54:31,000
然后一个直接的观察是说放个多一个,那我N次放个多N个,就不是这么一

653
00:54:31,000 --> 00:54:31,120
回事。

654
00:54:31,260 --> 00:54:40,560
因为你要对……对,它是分叉,不是一个线性的,是指数级的增长,是这么一个……

655
00:54:41,740 --> 00:54:48,760
如果零次,没有一次循环,那就是这个进程字体,只有一个,就2的零次吧。

656
00:54:49,620 --> 00:54:55,900
如果只有一次,只循环一次,那我只是一个hawk,那也就2的1次吧。

657
00:54:56,300 --> 00:55:09,720
但是你再往下走会发现,循环两次的时候,你那个子径层还要去判断一个

658
00:55:09,720 --> 00:55:10,440
子径层。

659
00:55:10,560 --> 00:55:17,240
你不进层,还会产生直进层,所以它就变成了二子房,变成了四个,

660
00:55:17,620 --> 00:55:21,120
这是一个需要大家更考虑的。

661
00:55:21,480 --> 00:55:27,940
同学说是不是我老师讲过了,这些我肯定会做,不一定,老师会在那里

662
00:55:27,940 --> 00:55:28,800
面做点变化,

663
00:55:28,920 --> 00:55:34,600
比如说在这里面加个义服循环判断,这个义服结果大家语货的关系如果

664
00:55:34,600 --> 00:55:37,260
搞不明白的话,其实有考边层,你可能又会出错。

665
00:55:39,060 --> 00:55:46,160
所以这个你要去理解这个Fock怎么产生的,这个我觉得只是一个比较tricky的一道

666
00:55:46,160 --> 00:55:52,000
计算题,如果能明白这个Fock的大致的语意的话,就不会出现这个问题,就会正

667
00:55:52,000 --> 00:55:52,940
确地解决这个问题。

668
00:55:53,820 --> 00:55:59,160
好,接下来我们讨论一下Fock这个,这段爆发的时间比较迟,因为它是我们超

669
00:55:59,160 --> 00:56:04,280
系统里面非常独特的一个系统调用,别的系统调用就是发个请求,在

670
00:56:04,280 --> 00:56:05,960
OS做,做了之后返回就完了。

671
00:56:06,960 --> 00:56:10,960
只有这个性能调用是我发了个请求,它多产生了一个进程。

672
00:56:12,200 --> 00:56:15,760
只有它才做这个事情,其他性能调用都没有干的事情。

673
00:56:17,160 --> 00:56:22,920
那Fork的开销在哪儿呢?我们要考虑开销,因为它创建新的进程之

674
00:56:22,920 --> 00:56:24,200
后需要办很多事情,

675
00:56:24,360 --> 00:56:30,220
所以它一定有开销。比如说我要复制一份地址空间,复制很多内存,就大量

676
00:56:30,220 --> 00:56:32,000
内存拷贝,叫分配内存。

677
00:56:33,340 --> 00:56:39,280
这个就是一个开较很大的用户,特别是我紧接的这个Fock都做了XXX,

678
00:56:39,400 --> 00:56:42,260
那副字全都没用了,我特别全丢弃了。

679
00:56:42,340 --> 00:56:46,960
这是一个多余的工作,这就使得大家很质疑我们为什么要去做这个Fock。

680
00:56:47,560 --> 00:56:55,920
刚才我其实在之前已经解释过问题,这个Fock,如果是要进行新的程序的话,你

681
00:56:55,920 --> 00:56:57,110
那个副字完全没有意义。

682
00:56:58,850 --> 00:57:01,710
这是一个你要说开药大做的有意义的事情也行

683
00:57:01,710 --> 00:57:03,570
你开药大还做的没有意义的事情

684
00:57:03,570 --> 00:57:04,790
这有一点不可接受了

685
00:57:07,830 --> 00:57:11,970
我们经过调研发现在99%的情况下

686
00:57:11,970 --> 00:57:13,630
我们的Fock后面都跟在一起

687
00:57:13,630 --> 00:57:17,090
只有1%的情况下Fock后面仨不跟

688
00:57:17,890 --> 00:57:21,510
那你这个在Fock操作内存复制是没有作用的

689
00:57:21,510 --> 00:57:23,210
是不是没有作用 确实没有作用

690
00:57:24,030 --> 00:57:31,970
为什么?因为它被覆盖了,一直也没用。用了一点点,在那个地方还是用了一点。

691
00:57:32,670 --> 00:57:37,950
第二个,我们虽然没有讲文件和网络连接,这后面会讲,网络里面也在

692
00:57:37,950 --> 00:57:42,070
学。学过了网络,还正在学吗?学过了,OK。

693
00:57:42,370 --> 00:57:48,110
一个进程可以发出网络连接,你可以跟其他主流连接。第二个,一个进程可以打

694
00:57:48,110 --> 00:57:48,910
开读写文件。

695
00:57:49,670 --> 00:57:54,130
你打开这些文件的时候,你这个紫禁城,它是要复制复禁城的那些内

696
00:57:54,130 --> 00:58:02,050
容。你这个打开了文件或者网络链接,四楼也要复制,虽然没有讲,但你们

697
00:58:02,050 --> 00:58:08,710
可以思考一下,大家觉得紫禁城是不是应该复制,还是应该关闭,不能复制。

698
00:58:13,270 --> 00:58:19,170
有的人说应该复制。好,就会出现一个问题。附近的紫禁城都能看到这个文

699
00:58:19,170 --> 00:58:27,310
件,或者都能看到这个网络的桩口。对这个文件和桩口都发出一个写操作,

700
00:58:28,490 --> 00:58:34,270
但请问你写的文件是不是乱了?谁来保证他们的先后顺序,谁来保证

701
00:58:34,270 --> 00:58:35,470
谁应该先,谁应该后续?

702
00:59:05,750 --> 00:59:09,090
你就可以避免它,因为我们不共享它,行吗?

703
00:59:09,230 --> 00:59:11,610
我们共享之后还没有其他手段的情况下,我们先不共享。

704
00:59:11,670 --> 00:59:14,790
这意味着你要不然附近的三方指令车把它关了,

705
00:59:14,970 --> 00:59:19,450
把你这个拥有的可能会产生冲突的资源给它,共享资源给关掉之

706
00:59:19,450 --> 00:59:21,070
后,就避免这个问题。

707
00:59:21,410 --> 00:59:24,690
这为什么可能要关闭,你要知道为什么要关闭。

708
00:59:24,730 --> 00:59:29,230
当然,你如果后面有了更进一步的、同步估计的更高级的一些功能之

709
00:59:29,230 --> 00:59:30,430
后,你可以不关闭。

710
00:59:30,770 --> 00:59:33,290
大家通过某种手段来保证可以这些的保护就OK。

711
00:59:33,290 --> 00:59:38,570
但现在在这种情况下,我们应该采取关闭的手段来避免我们潜在的一

712
00:59:38,570 --> 00:59:41,270
种对共产资源的访问冲突问题。

713
00:59:43,350 --> 00:59:47,850
这是一个要考虑的问题。第二个要考虑的问题,就是要提供效率。

714
00:59:47,890 --> 00:59:54,030
我们说这个成的情况下,它这个效率很低,是在于我创建了这个复制离号

715
00:59:54,030 --> 00:59:56,030
空间之后用不上。

716
00:59:56,470 --> 00:59:59,170
这是一个问题。我希望我复制完之后能用上。

717
01:00:00,870 --> 01:00:03,210
但是你大部分做EXE这些用不上怎么办

718
01:00:03,210 --> 01:00:04,510
这就是我们要考虑第二个问题

719
01:00:04,510 --> 01:00:05,850
第二个问题就是怎么解决呢

720
01:00:06,850 --> 01:00:09,170
那我能不能采取一种伪复制的方法

721
01:00:09,170 --> 01:00:11,250
所谓伪复制就是表面上看是复制了

722
01:00:11,250 --> 01:00:12,210
但其实没有真复制

723
01:00:13,350 --> 01:00:14,910
给一个例子就是

724
01:00:15,390 --> 01:00:17,810
我们在后续的这个Unix的发展过程中

725
01:00:17,810 --> 01:00:20,010
提出了一个新的一种名字叫V-Fog

726
01:00:20,010 --> 01:00:22,730
V是Mortally,是虚拟的一个Fog

727
01:00:22,730 --> 01:00:24,530
它的含义是说我其实不是真的Fog

728
01:00:24,530 --> 01:00:25,450
我是假的Fog

729
01:00:26,310 --> 01:00:27,950
所谓假的Fog就是说

730
01:00:27,950 --> 01:00:35,790
它仅仅是把死镜城的那个页表和复镜城的页表是一样的,禁止

731
01:00:35,790 --> 01:00:36,110
空间。

732
01:00:36,250 --> 01:00:42,030
那意味着什么?换句话来说,应该是死镜城它复制的一份复镜城

733
01:00:42,030 --> 01:00:47,550
的页表,但是没有复制复镜城里面的弹道和数据带所占的物理内

734
01:00:47,550 --> 01:00:48,090
容空间。

735
01:00:48,930 --> 01:00:53,330
因为我复制一份页表,那页表是一个页面是纸针,两个纸针只像同

736
01:00:53,330 --> 01:00:57,210
一个物理页而已,这种方式OK。

737
01:00:57,210 --> 01:01:01,990
那我其实没有做这个内存拷贝的开销,开销很小,我只是只是拷贝了业表。

738
01:01:02,690 --> 01:01:10,430
这是它的一个地方,或者甚至说更极端点,我可能在梦中可以把这个业表还是用一个

739
01:01:10,430 --> 01:01:13,640
共享的业表来搞定这件事情,那开销就更小了。

740
01:01:16,850 --> 01:01:23,590
如果这样的话,那意味着这两个父子进程是共享了一块地质空间,甚

741
01:01:23,590 --> 01:01:24,850
至是物理地质空间也是共享的。

742
01:01:27,910 --> 01:01:31,550
如果两个进程同时写一个例子,那怎么办?

743
01:01:32,330 --> 01:01:35,370
又出现这个问题,因为只有一半共享的耐力。

744
01:01:36,150 --> 01:01:42,230
为了能够解决这个问题,仅仅是做到共享一块物体对的空间还是不

745
01:01:42,230 --> 01:01:43,970
够的,我们还要有其他的招。

746
01:01:44,650 --> 01:01:47,790
这个招就是我们前面说的,要把我们的虚纯的技术给用上。

747
01:01:47,790 --> 01:01:52,890
我虚拳有一种就是按虚分页 或者说叫做Copy and Write

748
01:01:52,890 --> 01:01:55,470
我真正需要的时候 我来去做相应的操作

749
01:01:55,470 --> 01:01:57,650
这个需要什么 就是说

750
01:01:57,650 --> 01:02:01,570
我们一开始把它变成了两个进程

751
01:02:01,570 --> 01:02:03,570
共享了一块物理地址空间之后

752
01:02:03,570 --> 01:02:05,130
我还要做一个设计

753
01:02:05,130 --> 01:02:07,990
让所有的一地址空间变成什么 变成纸图的

754
01:02:09,330 --> 01:02:13,090
改了这个页表项 本来是可读写的 变成了纸图的

755
01:02:13,870 --> 01:02:19,570
如果这两个进程都是对大法大数据乱做出纸图或者执行的操作

756
01:02:19,570 --> 01:02:21,310
不会做任何改变

757
01:02:21,310 --> 01:02:23,310
那两个共享没有任何问题

758
01:02:23,310 --> 01:02:25,090
但是一旦说

759
01:02:25,670 --> 01:02:27,350
或者是配音层或者是指音层

760
01:02:27,350 --> 01:02:29,090
它就要做写操作

761
01:02:29,610 --> 01:02:32,310
由于你的页表像里面写的是纸图

762
01:02:32,310 --> 01:02:34,090
它就会干什么

763
01:02:36,150 --> 01:02:37,210
产生什么情况

764
01:02:40,710 --> 01:02:48,450
首先CPU要产生一个异常,这是第一步。这就知道这是一种异常,因为对一个子读

765
01:02:48,450 --> 01:02:51,990
业进行写操作会产生异常,这是第一步。

766
01:02:52,390 --> 01:02:57,770
然后产生异常之后才会碰到第二个问题,这个对子读业进行写操作是不是

767
01:02:57,770 --> 01:03:00,650
一个合法操作,谁来判断?

768
01:03:12,190 --> 01:03:18,910
这就需要大家把你们的思路再扯回去,看看当时我们讲地址空间的时候,怎么去针

769
01:03:18,910 --> 01:03:20,890
对一个任务建立它的地址空间的。

770
01:03:20,950 --> 01:03:22,850
那个地址空间里面有两个很重要的结构。

771
01:03:23,250 --> 01:03:27,270
Memory set和Memory set下面有一个叫做什么?Memory area。

772
01:03:28,130 --> 01:03:30,630
Memory area里面记录了所谓的一个程序的核心。

773
01:03:30,630 --> 01:03:35,630
合法的逻辑地址端的一个空间,其实还有一个属性,是可读可写的。

774
01:03:35,630 --> 01:03:40,270
那里面还有一个记录,可读可写,虽然页标里面写的是属性,但是我一查

775
01:03:40,270 --> 01:03:41,710
MathEdit里面写的,

776
01:03:41,710 --> 01:03:44,530
这个地址其实是可读可写的,它认为是合法的。

777
01:03:45,410 --> 01:03:50,490
这个情况下,可以判断出来,这个地址,这个操作,其实应用程序给的这个产能意识

778
01:03:50,490 --> 01:03:51,430
团不是应用程序的问题,

779
01:03:51,430 --> 01:04:00,570
也是我们OS偷懒造成的。所以看这种情况的时候,它会把针对内向做为一个复

780
01:04:00,570 --> 01:04:05,890
制,就是把内向拆开了,真正的拆开了,就是复兴层和止兴层有各自

781
01:04:05,890 --> 01:04:11,010
的一块独立的物理空间,然后在修改页面下把它变成可读可写的。

782
01:04:11,610 --> 01:04:15,010
OK 从这种方式就是实际上所谓的Copy-on-Line的技术

783
01:04:17,010 --> 01:04:19,390
这里面就用到 我再强调一下

784
01:04:19,390 --> 01:04:22,010
你会发现 我们说这些新功能

785
01:04:22,010 --> 01:04:25,790
你其实和前面的很多知识是混在一起的

786
01:04:25,790 --> 01:04:28,970
你需要把前面的知识和后面的知识综合在一起

787
01:04:28,970 --> 01:04:32,450
才能够深刻的理解 或者才能够全面的理解

788
01:04:32,450 --> 01:04:37,330
这个Fock或者这个VFock怎么能够有效

789
01:04:38,370 --> 01:04:39,730
这Copy-on-Line我讲完了

790
01:04:41,930 --> 01:04:49,390
然后这里面我就大致把Fork XTC创建紫进程,执行新程序,给大家简单

791
01:04:49,390 --> 01:04:50,430
地讲了。

792
01:04:50,590 --> 01:04:56,410
接下来大家讲的是说,那副紫进程之间既然有一个关系,我们还能把这个

793
01:04:56,410 --> 01:04:57,430
关系用一下吗?

794
01:04:57,550 --> 01:05:00,710
它确实有一个用,就是比如说它们也可能相互之间的等待过来,

795
01:05:00,810 --> 01:05:04,770
比如说我互进程要等紫进程结束,才能继续做一些事情。

796
01:05:05,190 --> 01:05:07,990
它们这个等就是一个wait,我们说这个wait操作。

797
01:05:08,630 --> 01:05:14,390
当然有的人说,我们好像时间里面有位置PID,这只是一个具体的表述,让我们大家

798
01:05:14,390 --> 01:05:15,030
知道含就行。

799
01:05:15,170 --> 01:05:19,450
位置就是用来完成复进层灯指进层的一个很重要的性能教育。

800
01:05:21,050 --> 01:05:23,990
那你指进层怎么能够通知到复进层呢?

801
01:05:25,410 --> 01:05:28,970
指进层有一个类似的性能教育,对应的性能教育比较类似,对应

802
01:05:28,970 --> 01:05:30,650
的性能叫Active退出。

803
01:05:35,130 --> 01:05:37,470
他会有这么一个退出操作

804
01:05:37,470 --> 01:05:39,090
这个退出操作也是系统调用

805
01:05:39,090 --> 01:05:41,250
他会通过这个系统调用

806
01:05:41,250 --> 01:05:42,830
同时我还执张OS

807
01:05:42,830 --> 01:05:44,850
转告我们的附近城说

808
01:05:45,290 --> 01:05:46,630
我退出了

809
01:05:46,630 --> 01:05:50,410
你就知道我已经截住了

810
01:05:50,410 --> 01:05:51,530
而且会把这个退出

811
01:05:51,530 --> 01:05:53,030
还专门有个返回值

812
01:05:53,450 --> 01:05:55,170
返回给这个附近城的位置

813
01:05:55,170 --> 01:05:56,130
让他也知道

814
01:05:56,130 --> 01:05:57,150
这个退出

815
01:05:57,150 --> 01:05:58,770
我还得到一个退出的消息

816
01:05:58,770 --> 01:05:59,990
比如说我给一个

817
01:05:59,990 --> 01:06:00,630
退出返回的消息

818
01:06:00,630 --> 01:06:04,050
那我认为这个指令层可能有一个异常退出的

819
01:06:04,050 --> 01:06:07,850
如果访问是个0,我可能认为它是一个正常退出的

820
01:06:07,850 --> 01:06:11,950
这样的话,我对父亲层或者指令层的阴阴状态有一个观察

821
01:06:11,950 --> 01:06:14,990
这就是他们之间的一个关系的操作

822
01:06:14,990 --> 01:06:20,610
就是所谓的等待和退出这一堆系统调用他们要干的事情

823
01:06:24,270 --> 01:06:31,210
我们稍微再细一点 看看这个wait操作

824
01:06:31,210 --> 01:06:38,350
我们这个wait操作还有些比较需要注意的地方 这里面有两个

825
01:06:38,910 --> 01:06:42,250
就是当一个紫禁城紫金退出操作

826
01:06:42,250 --> 01:06:46,050
还没有来得及被复形成wait到的时候

827
01:06:46,050 --> 01:06:48,470
那么这时候它已经退出了 那么它变成什么进程

828
01:06:48,470 --> 01:06:50,730
变成了一个所谓的僵尸进程

829
01:06:50,730 --> 01:06:51,870
因为它还没被回收

830
01:06:51,870 --> 01:06:53,470
它只是退出了 还没有

831
01:06:53,470 --> 01:06:55,790
就把它收了才行

832
01:06:55,790 --> 01:06:57,670
这个收的过程是由复进程来完成

833
01:06:57,670 --> 01:06:59,510
复进程通过Wid的性能

834
01:06:59,510 --> 01:07:01,450
才能把它彻底收掉

835
01:07:01,450 --> 01:07:02,690
不然的话

836
01:07:02,690 --> 01:07:04,930
它还是有一些残余部分

837
01:07:04,930 --> 01:07:06,450
留在了内核里面

838
01:07:06,450 --> 01:07:08,630
这残余是什么呢

839
01:07:08,630 --> 01:07:10,470
就是TCB

840
01:07:11,210 --> 01:07:12,290
就是纸进程的TCB

841
01:07:12,930 --> 01:07:14,470
还在内核里面

842
01:07:15,190 --> 01:07:16,270
通过Wid的操作

843
01:07:16,270 --> 01:07:18,030
可以把紫禁城TGP也给收掉

844
01:07:19,590 --> 01:07:20,830
那么第二个

845
01:07:21,430 --> 01:07:23,790
还有一个叫孤儿进城

846
01:07:23,790 --> 01:07:24,750
什么叫孤儿进城

847
01:07:25,810 --> 01:07:26,930
这很好理解

848
01:07:26,930 --> 01:07:28,430
父亲先先完蛋

849
01:07:29,250 --> 01:07:30,270
那就是孤儿

850
01:07:30,950 --> 01:07:33,170
紫禁城还在后头才完蛋

851
01:07:33,170 --> 01:07:35,810
你总要有一个要把它收了吧

852
01:07:35,810 --> 01:07:36,990
谁收呢

853
01:07:36,990 --> 01:07:38,390
我们就说第一个进城

854
01:07:39,230 --> 01:07:42,910
我们假定第一个进城不会被搞掉

855
01:07:42,910 --> 01:07:44,050
它不会死掉

856
01:07:44,050 --> 01:07:45,970
它的主要事情就是要回收那些

857
01:07:45,970 --> 01:07:47,730
没有父亲的那些过敏

858
01:07:47,730 --> 01:07:49,990
就root 主动把这项土掀

859
01:07:49,990 --> 01:07:51,230
他来负责回收

860
01:07:51,930 --> 01:07:53,610
所以你会看到

861
01:07:53,610 --> 01:07:55,690
子进程他如果是孤儿的话

862
01:07:55,690 --> 01:07:57,790
他会把他的父进程指向这个root

863
01:07:57,790 --> 01:07:58,910
在内核这个实验里面

864
01:07:58,910 --> 01:08:01,490
他这样才能使得root能够知道

865
01:08:01,490 --> 01:08:02,570
他有哪些子进程

866
01:08:02,570 --> 01:08:04,230
然后做进一步的回收操作

867
01:08:05,790 --> 01:08:07,210
所以你要理解

868
01:08:07,210 --> 01:08:09,690
僵尸进程和孤儿进程什么含义

869
01:08:09,690 --> 01:08:11,750
以及对应的一些操作的一些方式

870
01:08:11,750 --> 01:08:14,490
这是这一块的过程

871
01:08:14,490 --> 01:08:19,110
在退出的时候其实有很多资源

872
01:08:19,110 --> 01:08:21,350
退出就是要把这些资源给回收掉

873
01:08:21,350 --> 01:08:23,230
有很多资源要回收

874
01:08:23,230 --> 01:08:25,130
比如说我们还没有讲到的

875
01:08:25,130 --> 01:08:29,130
所有的打开的文件要关闭掉

876
01:08:29,130 --> 01:08:31,450
内存要释放掉 地址空间要释放掉

877
01:08:31,450 --> 01:08:32,650
很多税据结构要释放掉

878
01:08:32,650 --> 01:08:34,650
但是它还需要保持一个TCB

879
01:08:34,650 --> 01:08:37,570
因为退出的防卫值

880
01:08:37,570 --> 01:08:40,230
这个防卫值也是TCB的一部分

881
01:08:40,230 --> 01:08:43,290
这个防卫值最重要要传给服务员之后

882
01:08:43,290 --> 01:08:45,610
才能够把它这个TDP才彻底的没用了

883
01:08:45,610 --> 01:08:49,450
所以这一块最后才能够回收起来

884
01:08:49,450 --> 01:08:52,550
也有可能梅拉基回收之前属于僵尸状态

885
01:08:53,030 --> 01:08:55,850
这是退出之后的一些要干的事情

886
01:08:55,850 --> 01:08:57,290
和可能处于的一个状态

887
01:08:58,790 --> 01:09:02,150
好 那这个可能大概对出就给大家介绍完毕

888
01:09:02,630 --> 01:09:05,190
那么进程的管理不仅仅是我们前面讲的

889
01:09:05,190 --> 01:09:07,170
最核心的那些系统材料

890
01:09:07,170 --> 01:09:12,210
还有一些是后面会讲到跟调度相关的NAS

891
01:09:12,210 --> 01:09:18,250
这个nice采用得非常好,就是把自己的优天机给降低了,让别人就有更

892
01:09:18,250 --> 01:09:22,250
好的、更多的占用CPU的时间,把它称作为nice。

893
01:09:23,790 --> 01:09:28,470
第二个呢,p-trace,也非常好的一个功能,大家都习惯了debug了,它其实在年

894
01:09:28,470 --> 01:09:30,410
龄市面就靠p-trace来帮助你去debug了。

895
01:09:31,130 --> 01:09:37,430
它能够完成父子进程之间的一个调试的支持,还有后面会实现的speed,你

896
01:09:37,430 --> 01:09:40,330
能够主动睡眠,等等。

897
01:09:40,330 --> 01:09:42,530
这些都是跟竞争管理相关

898
01:09:42,530 --> 01:09:47,330
我们这里面不太会去让大家去支持

899
01:09:47,330 --> 01:09:48,890
这种辟税是比较复杂的

900
01:09:48,890 --> 01:09:50,850
或者像Sleep是可以的

901
01:09:50,850 --> 01:09:52,010
这个Nice也是可以的

902
01:09:52,010 --> 01:09:55,590
但是我们没有专门去这一些实验给大家去做这个事情

903
01:09:56,290 --> 01:09:59,050
还有一些 这些我就后面碰到的时候

904
01:09:59,050 --> 01:10:00,470
我们会再给大家讲解

905
01:10:00,470 --> 01:10:01,650
这样给大家简单说明一下

906
01:10:02,170 --> 01:10:05,400
其实竞争管理是非常多的

907
01:10:06,630 --> 01:10:09,010
我们说系统利用层面非常多的一部分内容

908
01:10:09,010 --> 01:10:15,870
这一部分内容大家有所了解,有所了解就OK了

909
01:10:15,870 --> 01:10:16,710
好,再讲什么呢?

910
01:10:16,790 --> 01:10:20,630
再讲就是有了这些进程管理之后,你会发现这个进程其实状态在变

911
01:10:20,630 --> 01:10:20,750
化

912
01:10:20,750 --> 01:10:22,510
它运行过程的状态在变化

913
01:10:22,510 --> 01:10:26,590
而这个状态变化,前面我们其实已经讲过,就讲过一些任务的一些状态变化

914
01:10:26,590 --> 01:10:30,250
这里面再强调一下所谓的进程的状态

915
01:10:30,250 --> 01:10:31,510
这里面强调的是什么?

916
01:10:31,910 --> 01:10:34,510
进程状态和管理之间的关系

917
01:10:34,510 --> 01:10:37,970
就是说它处于某个状态和从一个状态变到另一个状态的时候

918
01:10:37,970 --> 01:10:40,350
实际上是由于某一些事件造成的

919
01:10:40,350 --> 01:10:41,810
这些事件可能是由于性能量的造成

920
01:10:42,350 --> 01:10:45,070
由于精神管理的原因造成的

921
01:10:45,070 --> 01:10:46,250
这我们要去了解到

922
01:10:46,250 --> 01:10:48,550
所以这边我们看到的

923
01:10:48,550 --> 01:10:50,170
典型的三状态图又出现了

924
01:10:50,170 --> 01:10:52,490
就续态、运行态、等待态

925
01:10:53,190 --> 01:10:55,270
由于我们到目前为止还不需要等待

926
01:10:55,270 --> 01:10:57,350
所以这个还没有

927
01:10:57,350 --> 01:10:58,790
在我们的后面的实验中还没看到

928
01:10:58,790 --> 01:11:00,350
但其实从原理上来讲

929
01:11:00,350 --> 01:11:02,370
它应该是具有这三个状态的

930
01:11:02,370 --> 01:11:04,030
最开始还有一个创建

931
01:11:04,030 --> 01:11:05,330
最后还有退出

932
01:11:06,610 --> 01:11:07,590
这是五个状态

933
01:11:08,430 --> 01:11:11,590
在整个运行过程中,重点是救救运行等待,这三个。

934
01:11:15,450 --> 01:11:18,550
那么结合了我们刚才讲的这几个性能,大家可以看看。

935
01:11:18,950 --> 01:11:23,290
比如说我从运行态到退出态,就是由于要执行这个,或者叫僵尸,

936
01:11:24,170 --> 01:11:26,310
是由于你执行了这个性能,exit退出。

937
01:11:27,410 --> 01:11:31,590
你如果等待,比如说我有一个sleep,刚才说了sleep,

938
01:11:31,690 --> 01:11:34,610
那可能是从运行到等待,这是wait或者sleep。

939
01:11:37,790 --> 01:11:42,670
在创建过程中会是一个创建的状态,创建完之后就变成旧训坛,

940
01:11:43,030 --> 01:11:47,630
放到旧训队列里面去,我们说有一个队列,这里面有一个队列,由任务管

941
01:11:47,630 --> 01:11:52,070
理器管理的,每一个代表一个TZB,旧训的TZB,这边有一个管理。

942
01:11:55,910 --> 01:11:59,550
然后这一块,那我的问题又来了,给大家提个小问题。

943
01:12:04,830 --> 01:12:14,910
在这里面 它是什么一个位置 应该在什么一个位置

944
01:12:19,350 --> 01:12:26,070
能看到吗

945
01:12:26,070 --> 01:12:28,770
运行 它会有没有一个状态变化

946
01:13:02,010 --> 01:13:07,510
我再问一下这个wait到底是不是处于一定是运行到等待的一个状态。我们说不形

947
01:13:07,510 --> 01:13:16,730
成等待的主义者是wait。是这样的吗?这是原理。实现和原理不是完全的m

948
01:13:16,730 --> 01:13:17,010
atch的。

949
01:13:17,010 --> 01:13:18,490
如果你们去看一下实验

950
01:13:18,490 --> 01:13:22,070
你会发现我们的实验不是这么来做的

951
01:13:22,070 --> 01:13:23,610
但它也完成了这个语役

952
01:13:25,690 --> 01:13:29,210
所以你要理解就是原理有很多不同的实验方式

953
01:13:30,750 --> 01:13:36,510
它是采取了字来回切的一种方式来搞定的wait

954
01:13:37,490 --> 01:13:39,490
它比较古怪的一种搞定方式

955
01:13:39,490 --> 01:13:42,290
原因是在于我们没有一个等待队列

956
01:13:42,970 --> 01:13:45,950
wait的一个q还没有设计

957
01:13:45,950 --> 01:13:48,230
我们现在就这两个状态

958
01:13:48,230 --> 01:13:49,870
我说前面说没有这个等待状态

959
01:13:49,870 --> 01:13:53,810
我们也能完成这些系统的一些知识

960
01:13:54,470 --> 01:13:56,170
这是原理和实现的一些差异

961
01:13:56,170 --> 01:14:00,170
大家需要去看看代码就可以理解了

962
01:14:00,170 --> 01:14:03,350
这是我一直强调的是它不是完全的对应

963
01:14:03,350 --> 01:14:05,250
它能够体现它的含义就OK

964
01:14:05,250 --> 01:14:09,170
我们的实现可以更加灵活

965
01:14:09,170 --> 01:14:11,570
最后再讲一下一个论文

966
01:14:11,570 --> 01:14:16,150
这是在一个操作系统的一个会议上

967
01:14:16,150 --> 01:14:16,830
叫Hot OS

968
01:14:16,830 --> 01:14:21,490
就是专门是欢迎大家提出一些新的idea的一个会议叫

969
01:14:21,490 --> 01:14:22,250
就是Hot OS

970
01:14:22,250 --> 01:14:24,610
这个在2019年的时候由微软

971
01:14:24,610 --> 01:14:25,550
来自于微软

972
01:14:25,550 --> 01:14:26,790
因为他们根本就没有用Fock

973
01:14:26,790 --> 01:14:28,230
一开始就没有用Fock

974
01:14:28,230 --> 01:14:30,150
这样子是Great Process

975
01:14:30,150 --> 01:14:33,210
专门发了一篇文章叫A Fock in the Road

976
01:14:34,990 --> 01:14:36,590
这个是取了一个相关语的意思

977
01:14:37,010 --> 01:14:38,710
就是本来路这么走的

978
01:14:38,710 --> 01:14:40,290
到这就分岔了

979
01:16:10,290 --> 01:16:17,690
大家其实在直线讲虚拙的时候都看到 而且Fork对于单地址空间不兼容

980
01:16:17,690 --> 01:16:21,470
什么叫单地址空间 我们现在一个进程是一个空间 是吧

981
01:16:21,470 --> 01:16:23,950
后面我们讲现成没有讲到 大家可以知道

982
01:16:23,950 --> 01:16:27,230
现成里面可能在现成里面会有多个执行流

983
01:16:27,230 --> 01:16:30,050
在这种情况下 这在一个地址空间下

984
01:16:30,050 --> 01:16:33,870
你这个Fork语意和这个多个执行流之间是有冲突的

985
01:16:33,870 --> 01:16:38,650
这就是问题 因为你有引用了新的更加灵活的一些机制之后

986
01:16:38,650 --> 01:16:41,730
和它的Fock本质的语义是不太一致的

987
01:16:41,730 --> 01:16:45,850
Fock incompatible不兼容和易购的硬件不兼容

988
01:16:45,850 --> 01:16:50,370
这易购的硬件是指的一些非传统的处理器

989
01:16:50,370 --> 01:16:55,450
比如说现在的一些 我们说这种嵌入式的MCU

990
01:16:56,190 --> 01:16:58,330
它就没有MMU 它就没有地址空间

991
01:16:58,330 --> 01:17:00,990
你这个Fock这里面就没有意义

992
01:17:00,990 --> 01:17:02,470
你为什么要用Fock 它没有地址空间

993
01:17:02,470 --> 01:17:05,250
你不需要去分配不同的地址空间

994
01:17:05,750 --> 01:17:07,670
而且Fock影响整个系统

995
01:17:07,670 --> 01:17:10,710
由于Fock它其实是说我要去让指令层

996
01:17:11,550 --> 01:17:14,630
复用复进层的所有的资源

997
01:17:14,630 --> 01:17:18,330
这个资源我们以前的资源只有CPU和Memory

998
01:17:18,330 --> 01:17:20,510
但随着你的这个OS的复杂

999
01:17:20,510 --> 01:17:23,130
你会发现这里面一个进程还包含什么

1000
01:17:23,130 --> 01:17:24,730
它是资源的一个管理单元

1001
01:17:24,730 --> 01:17:25,470
包含了文件

1002
01:17:25,470 --> 01:17:26,190
包含了网络

1003
01:17:26,190 --> 01:17:28,610
包含了各种各样的东西

1004
01:17:28,610 --> 01:17:30,870
那么你到底这个指令层一不应该Fock它

1005
01:17:30,870 --> 01:17:33,330
其实取决于你这个应用的特征

1006
01:17:33,330 --> 01:17:34,830
这都使得这个Fock

1007
01:17:36,010 --> 01:17:37,330
在复杂情况下

1008
01:17:37,330 --> 01:17:38,830
它也难以适用

1009
01:17:40,970 --> 01:17:43,330
这里面给出了一个性能的比较

1010
01:17:44,290 --> 01:17:48,170
这是一个新的性能 叫Posix Spawn

1011
01:17:48,170 --> 01:17:49,390
Posix Spawn

1012
01:17:49,390 --> 01:17:53,610
这是它的性能 这底下越小越好

1013
01:17:53,610 --> 01:17:56,050
而这是传统的Fox加EXEC

1014
01:17:56,450 --> 01:17:58,630
这是一个做了优化的Fox加EXEC

1015
01:17:58,630 --> 01:18:00,510
比如类似于V-Fox这种技术

1016
01:18:00,510 --> 01:18:03,710
那么可以看到 现在新的Posix Spawn

1017
01:18:03,710 --> 01:18:04,770
效率要高很多

1018
01:18:04,770 --> 01:18:06,630
因为它这边就是执行新程序

1019
01:18:06,630 --> 01:18:09,510
需要注意 它不是说执行老程序 而是执行新程序

1020
01:18:09,510 --> 01:18:12,470
但是发现用这个新的性能调用要好很多

1021
01:18:13,130 --> 01:18:15,210
而这个新的性能调用

1022
01:18:15,630 --> 01:18:18,250
Posix Spore 其实它认为

1023
01:18:18,250 --> 01:18:22,290
它们认为这就是符合它们Windows的quite process的一个语意

1024
01:18:22,290 --> 01:18:25,250
它们是一类的 这是看到的一个情况

1025
01:18:25,250 --> 01:18:29,610
那大家就想 为什么要出现Fog这个东西

1026
01:18:29,610 --> 01:18:31,710
那你要理解这两位

1027
01:18:32,470 --> 01:18:36,870
这两位Unix创建者,他们怎么来考虑问题的?

1028
01:18:37,590 --> 01:18:39,710
他们也不是平白无故拍脑袋就出来的

1029
01:18:42,050 --> 01:18:46,810
他写的Unix,他发明的C语,他们俩怎么就把Fock搞出来了?

1030
01:18:49,810 --> 01:18:55,490
这有一篇paper讲了Fock初始的情况

1031
01:18:55,490 --> 01:18:59,850
因为发现首先第一个,Fock并不是Unix第一个出现的

1032
01:18:59,850 --> 01:19:03,010
在放之前,在unix之前,还有一个操作系统

1033
01:19:05,510 --> 01:19:10,830
这个操作系统,GNIN,这个OS提出了Fock的语意

1034
01:19:11,850 --> 01:19:16,210
然后Kent Thompson就看了这个论文之后,他觉得Fock这个idea很好

1035
01:19:16,210 --> 01:19:19,330
于是他就在他的unix里面实现了Fock

1036
01:19:19,330 --> 01:19:24,050
而他实现了Fock的时候,他发现他实现的Fock和我们实现的Fock是

1037
01:19:24,050 --> 01:19:25,310
很不一样的

1038
01:19:25,310 --> 01:19:27,810
他第一版的unix是用什么写的

1039
01:19:27,810 --> 01:19:29,890
绘编那还没有谁远 用绘编写的

1040
01:19:30,610 --> 01:19:32,610
用绘编写 记者要绘编的情况下

1041
01:19:33,310 --> 01:19:39,650
他还仅仅用了27条绘编语句就把这Fog实现了

1042
01:19:39,650 --> 01:19:41,890
完成了我们现在的大部分的功能

1043
01:19:44,130 --> 01:19:46,210
所以他的那个Fog确实简单

1044
01:19:46,210 --> 01:19:50,090
因为他27条绘编语句就可以完成一个Fog的基本语义

1045
01:19:52,090 --> 01:19:56,630
那时候的Memory不是以业为单位来进行换入换出的

1046
01:19:56,630 --> 01:20:01,510
是以整个程序以程序为单位换入换出的

1047
01:20:01,510 --> 01:20:04,730
所以这个Fock它不用考虑非常复杂的

1048
01:20:04,730 --> 01:20:06,350
跟虚纯的一个打交道的问题

1049
01:20:07,970 --> 01:20:12,470
而且这个Fock完之后是

1050
01:20:14,030 --> 01:20:15,970
这个指进程继续执行

1051
01:20:15,970 --> 01:20:18,090
我们那个指进程自然就等待在那儿

1052
01:20:18,090 --> 01:20:19,270
等着指进程执行完毕

1053
01:20:20,830 --> 01:20:22,450
这个父子关系的执行关系

1054
01:20:22,450 --> 01:20:24,870
也是非常自然的就认为是存在的

1055
01:20:24,870 --> 01:20:26,930
而当时的exec这个程序还不存在

1056
01:20:26,930 --> 01:20:28,870
没有exec

1057
01:20:28,870 --> 01:20:31,310
他的所有的exec的语义

1058
01:20:31,950 --> 01:20:32,950
是在用户台

1059
01:20:32,950 --> 01:20:34,910
用share程序来实现的

1060
01:20:34,910 --> 01:20:36,230
他share来实现的exec语

1061
01:20:36,230 --> 01:20:37,870
不像现在在Lag里面实现

1062
01:20:37,870 --> 01:20:40,050
所以他这个fork其实和exec

1063
01:20:40,050 --> 01:20:41,670
之间并不是都Lag的一对

1064
01:20:41,670 --> 01:20:43,510
而是fork在Lag他

1065
01:20:43,510 --> 01:20:45,490
另外是二期调汇编实现的

1066
01:20:45,490 --> 01:20:47,970
这个exec是用在

1067
01:20:47,970 --> 01:20:50,890
是在share这个用户台的程序里面

1068
01:20:51,450 --> 01:20:53,210
根据他的一个需求

1069
01:21:23,790 --> 01:21:25,210
这是他说的话

1070
01:21:26,110 --> 01:21:27,710
我们要stop teaching students

1071
01:21:27,710 --> 01:21:29,310
fork is good design

1072
01:21:31,710 --> 01:21:33,390
我觉得他说得有一定道理

1073
01:21:33,950 --> 01:21:35,370
有一定道理

1074
01:21:35,370 --> 01:21:37,510
你们应该有一个

1075
01:21:37,510 --> 01:21:39,830
就是更全面的观点

1076
01:21:39,830 --> 01:21:41,870
正反两方面的去看这个fork

1077
01:21:41,870 --> 01:21:43,310
为什么要提出fork以及fork

1078
01:21:43,310 --> 01:21:45,850
它的好在哪不好的地方在哪

1079
01:21:46,530 --> 01:21:48,850
它的起因是怎么来的

1080
01:21:48,850 --> 01:21:50,210
这个我想你对这个

1081
01:21:51,050 --> 01:21:53,410
这篇文章或者对FOC本身的一个design

1082
01:21:53,410 --> 01:21:54,810
会有更清楚的了解

1083
01:21:58,150 --> 01:22:00,810
OK 这是我很认可这句话

1084
01:22:01,450 --> 01:22:02,590
就是讲FOC的时候

1085
01:22:02,590 --> 01:22:04,150
其实你要知道它的来龙去脉

1086
01:22:04,150 --> 01:22:05,850
而不是直接就出现一个FOC

1087
01:22:05,850 --> 01:22:07,090
不知道它怎么来的

1088
01:22:08,130 --> 01:22:09,790
但其实我们很难做到这一步

1089
01:22:09,790 --> 01:22:11,270
因为这个历史比较悠久

1090
01:22:11,730 --> 01:22:14,970
我们很难把每一个细节都讲到

1091
01:22:14,970 --> 01:22:16,230
什么来龙去脉都讲那么清楚

1092
01:22:16,230 --> 01:22:18,610
我们尽量讲到 OK

1093
01:22:18,610 --> 01:22:25,090
这个就是我们的关于进程管理这一块,就给大家介绍完毕。

1094
01:22:25,270 --> 01:22:29,530
稍微再总结一下,你可以看到,进程管理主要讲的是怎么去创建新的进程,

1095
01:22:29,970 --> 01:22:33,350
怎么去结束一个进程,主要是两方面。

1096
01:22:33,930 --> 01:22:39,570
创建,那就会涉及到 talk 和 EXEC,结束涉及到 exit 和 wait。

1097
01:22:40,190 --> 01:22:45,170
中间还有其他一些变化,那么在整个具体实验中,你会发现它和我们的

1098
01:22:45,170 --> 01:22:45,550
异常,

1099
01:22:45,550 --> 01:22:48,970
和我们的文件 和我们的这个进程管理

1100
01:22:48,970 --> 01:22:51,250
如果后面讲到文件和文件管理都有关系

1101
01:22:51,250 --> 01:22:55,030
这是它的一些进程管理的一些特点

1102
01:22:55,030 --> 01:22:58,150
原因是在于进程已经变成了一个资源的一个集合

1103
01:22:59,330 --> 01:23:01,370
这是为什么它复杂的原因

1104
01:23:01,370 --> 01:23:03,750
它资源越多 你管理得越多

1105
01:23:05,570 --> 01:23:11,050
好 那第二节我们要讲的就是另外一个话题

1106
01:23:11,050 --> 01:23:14,550
什么最充分的合理的使用处理器的问题

1107
01:23:15,830 --> 01:23:18,050
首先我们考虑,第一个问题是单处理器调度

1108
01:23:18,690 --> 01:23:20,690
假设我们的教研机系统里面只有一个处理器

1109
01:23:20,690 --> 01:23:23,050
就是所谓的单处理器调度的问题

1110
01:23:24,630 --> 01:23:27,010
这里面会讲一系列的知识点

1111
01:23:27,010 --> 01:23:29,550
这里面先是一个原理的讲解

1112
01:23:31,210 --> 01:23:33,010
就是处理器调度的一些基本概念

1113
01:23:33,750 --> 01:23:36,710
以及相应的一些策略和相应的算法

1114
01:23:36,710 --> 01:23:37,670
怎么去评价它

1115
01:23:37,670 --> 01:23:38,970
那么这里面的调度

1116
01:23:38,970 --> 01:23:42,250
就专门把这个实时调度给领出来讲

1117
01:23:42,250 --> 01:23:43,830
在实时调度里面还有一个

1118
01:23:49,370 --> 01:23:51,470
那么对这种情况我们怎么去解决

1119
01:23:51,470 --> 01:23:56,670
这就是整体来说我们对处理器调度要讲的一部分内容

1120
01:23:56,670 --> 01:23:58,130
这是单处理器调度

1121
01:23:58,130 --> 01:24:00,010
下面还要讲多处理器调度

1122
01:24:00,010 --> 01:24:04,010
这是先从简单的开始说

1123
01:24:04,510 --> 01:24:04,870
好

1124
01:24:05,330 --> 01:24:06,190
那处理器调度

1125
01:24:06,190 --> 01:24:06,970
那为什么处理器调度

1126
01:24:06,970 --> 01:24:09,290
是在于我们其实需要充分的利用CPU

1127
01:24:09,290 --> 01:24:10,790
让CPU不要闲下来

1128
01:24:10,790 --> 01:24:13,170
让CPU尽量的充分地在run

1129
01:24:14,410 --> 01:24:19,630
有些进程的执行,它可能在某些地方需要去停下来。这时候如果占用处理

1130
01:24:19,630 --> 01:24:21,590
器的话,资源流率就不高了。

1131
01:24:21,730 --> 01:24:25,490
所以我们发现有这种情况,就需要切换这几个。

1132
01:24:25,510 --> 01:24:34,410
第二个呢,有可能有的进程它运行时间过长,其他等的进程也就绪了,

1133
01:24:34,410 --> 01:24:35,330
但它没有机会执行。

1134
01:24:35,470 --> 01:24:39,850
所以这时候我们需要去保证一个所谓的公平性,让其他等了太久的进程

1135
01:24:39,850 --> 01:24:41,930
也有机会去执行,这也为社交进程切换。

1136
01:24:43,590 --> 01:24:48,890
切换的过程我们都是讲过,这是一种机制。这种机制说,我能够确保两

1137
01:24:48,890 --> 01:24:55,990
个进程都有机会去通过切换来执行它的控制逻辑。

1138
01:24:56,690 --> 01:25:00,230
但是怎么去选择这个策略问题呢?就是我们这个讲的调度。

1139
01:25:02,470 --> 01:25:07,670
你要从旧续对链,除了CPU其他资源都已经满足的情况下,要选择一个

1140
01:25:07,670 --> 01:25:09,370
进程去占用处理器执行。

1141
01:25:09,370 --> 01:25:13,070
那怎么去选择,就是我们调度的一个策略和算法问题

1142
01:25:14,610 --> 01:25:16,830
你要做一种策略,你一定要有一个评价标准

1143
01:25:16,830 --> 01:25:19,830
前面讲的那个页面自动算法

1144
01:25:19,830 --> 01:25:21,590
那很重要的评价标准是缺页率

1145
01:25:21,590 --> 01:25:24,150
就是你这个缺页异常的次数

1146
01:25:24,150 --> 01:25:27,370
那你这个调度程序,那你的标准是啥

1147
01:25:27,370 --> 01:25:31,610
你怎么确保你这个调度策略,调度算法是优的还是不优的

1148
01:25:31,610 --> 01:25:35,090
那取决于你基于什么原则来评判

1149
01:25:35,090 --> 01:25:37,550
你的评判标准是啥,这个是需要去了解的

1150
01:27:10,370 --> 01:27:13,590
进程在执行过程中的一个特点

1151
01:27:13,590 --> 01:27:14,690
现在进程

1152
01:27:14,690 --> 01:27:19,690
现在其实大部分是在CPU计算或者Io操作间交替进行

1153
01:27:19,690 --> 01:27:23,370
比如说现在我给大家讲这个slides的时候

1154
01:27:23,370 --> 01:27:27,290
它是典型的这种结构图

1155
01:27:29,070 --> 01:27:30,750
就是代表CPU利用率

1156
01:27:30,750 --> 01:27:32,070
大部分是空闲的

1157
01:27:32,070 --> 01:27:33,690
一小部分是CPU忙得很

1158
01:27:33,690 --> 01:27:34,170
什么时候呢

1159
01:27:39,190 --> 01:27:45,650
但是我没点的时候,它在等待,所以它就属于CPU耗得很低,这种状态。

1160
01:27:46,750 --> 01:27:51,350
这是我们通常看到的一种情况,它们也还有一种计算密集型的情况。

1161
01:27:51,430 --> 01:27:56,330
比如说咱们做天气预报计算,它大量的耗CPU,它不需要交互,那也是

1162
01:27:56,330 --> 01:27:56,630
一种。

1163
01:27:56,650 --> 01:28:02,430
那可能它就是看的是持续地在高端这么去,这么一直在占用在执行。

1164
01:28:02,630 --> 01:28:04,150
这是另一种不理性的情况。

1165
01:28:04,930 --> 01:28:06,170
那么我们需要就是

1166
01:28:06,850 --> 01:28:07,450
在这种情况下

1167
01:28:07,450 --> 01:28:08,830
如果你有多个程序要去跑的话

1168
01:28:08,830 --> 01:28:12,090
你要给别的进程一些机会去执行

1169
01:28:12,090 --> 01:28:13,890
这都是我们说这个处理器

1170
01:28:13,890 --> 01:28:14,910
资源的使用模式

1171
01:28:14,910 --> 01:28:16,190
有多种不同的情况

1172
01:28:19,310 --> 01:28:20,270
好 既然有多种不同的情况

1173
01:28:20,270 --> 01:28:21,370
我还是要去比较它

1174
01:28:21,370 --> 01:28:22,050
怎么来比较呢

1175
01:28:22,050 --> 01:28:24,410
我们一定要有一些量化的一些指标

1176
01:28:24,410 --> 01:28:25,590
比如说

1177
01:28:25,590 --> 01:28:27,330
在一段时间之内

1178
01:28:27,670 --> 01:28:29,150
这个处理器的

1179
01:28:29,970 --> 01:28:31,170
就CPU的使用率

1180
01:28:32,270 --> 01:28:36,170
如果有很多进程都在等待处理器执行

1181
01:28:36,170 --> 01:28:38,250
但这个处理器的使用率只有30%

1182
01:28:39,910 --> 01:28:42,330
那70%干啥了 浪费了

1183
01:28:42,850 --> 01:28:44,270
所以这个使用率要高才行

1184
01:28:44,930 --> 01:28:46,350
第二个指标 撑土量

1185
01:28:46,350 --> 01:28:48,110
这个在一年的角度来考虑

1186
01:28:48,110 --> 01:28:50,250
第二个撑土量是站在软件的角度来考虑

1187
01:28:50,850 --> 01:28:53,910
我们一些进程它是以比如说以发送数据包

1188
01:28:53,910 --> 01:28:56,310
比如网络数据包我发送的量

1189
01:28:56,310 --> 01:28:57,850
数据包的量代表一种撑土量

1190
01:28:57,850 --> 01:28:59,010
撑土量越大越好

1191
01:28:59,010 --> 01:29:00,010
待会时间越大越好

1192
01:29:00,010 --> 01:29:01,170
这是一个指标

1193
01:29:01,710 --> 01:29:02,950
周短时间

1194
01:29:02,950 --> 01:29:04,390
那也是站在软件上考虑

1195
01:29:04,390 --> 01:29:06,970
就进程从初始到结束的总时间

1196
01:29:07,810 --> 01:29:09,330
就是所谓初始的创建进程

1197
01:29:10,130 --> 01:29:11,370
创建进程要开始执行了

1198
01:29:11,370 --> 01:29:12,590
到它最后结束

1199
01:29:12,590 --> 01:29:13,870
这个时间到底是多少

1200
01:29:13,870 --> 01:29:15,730
这也作为一个平凡标准

1201
01:29:15,730 --> 01:29:17,330
还有什么就续等待时间

1202
01:29:17,330 --> 01:29:18,710
什么叫就续等待时间

1203
01:29:18,710 --> 01:29:20,410
我前面说有一个就续对列

1204
01:29:21,390 --> 01:29:23,570
这是从对列头里面去选择去执行

1205
01:29:23,570 --> 01:29:24,770
那你是诸葛牌的对列尾

1206
01:29:24,770 --> 01:29:25,890
你在这个地方

1207
01:29:26,270 --> 01:29:27,910
那你是不是要等待这么长时间

1208
01:29:27,910 --> 01:29:29,290
才能够一个一个的等

1209
01:29:29,290 --> 01:29:30,490
才能过去执行

1210
01:29:30,490 --> 01:29:33,610
那你这个时间 从这儿到这儿的一个等待时间

1211
01:29:34,070 --> 01:29:35,190
太长了也不好

1212
01:29:35,190 --> 01:29:37,950
我当然希望就业时间的等待时间越小越好

1213
01:29:37,950 --> 01:29:40,390
这是一个指标

1214
01:29:40,390 --> 01:29:41,850
还有什么 响应时间

1215
01:29:41,850 --> 01:29:43,930
响应时间是怎么响应时间就是

1216
01:29:43,930 --> 01:29:46,430
从提交请求到产生响应时花的时间

1217
01:29:46,430 --> 01:29:47,810
什么叫提交请求呢

1218
01:29:48,630 --> 01:29:52,250
这个请求更多的是说是来自于我们的外设

1219
01:29:52,250 --> 01:29:53,810
Device

1220
01:29:53,810 --> 01:29:56,690
发出一个中断 到超系统

1221
01:29:57,190 --> 01:30:00,610
然后最后操纵给了某个应用 让它去响应

1222
01:30:00,610 --> 01:30:05,770
那么这一段时间从产制中段到我们这个应用程序响应的中段

1223
01:30:07,050 --> 01:30:10,650
的这个时间叫做响应时间 还有公屏

1224
01:30:11,890 --> 01:30:13,970
我们有很多程序要运行

1225
01:30:14,490 --> 01:30:16,470
那么一定是CPU少 程序多

1226
01:30:17,210 --> 01:30:19,570
如果CPU多 程序少不需要掉的

1227
01:30:19,570 --> 01:30:21,750
我们只要给每个程序分配一个CPU就好了

1228
01:30:22,410 --> 01:30:27,630
但是绝大部分情况下是程序旧序的进程多

1229
01:30:27,630 --> 01:30:28,910
我们的CPU少

1230
01:30:28,910 --> 01:30:31,690
那你怎么能确保大家都有机会去占用CPU

1231
01:30:31,690 --> 01:30:32,970
这是公平性问题

1232
01:30:34,350 --> 01:30:37,290
这就是我们说的调度要设计的问题

1233
01:30:37,290 --> 01:30:40,650
和我们这张生活中的调度是一个大致是类似的

1234
01:30:40,650 --> 01:30:42,730
只是我们把它用在了计算机这个领域

1235
01:30:43,870 --> 01:30:44,950
这些都是指标

1236
01:30:46,010 --> 01:30:47,670
大家觉得指标里面有矛盾

1237
01:30:50,250 --> 01:30:55,590
有毛动啊,不是说这些指标都能满足,你强调满足某一个时候,可能下一个

1238
01:30:55,590 --> 01:30:59,230
就满足不了或者满足不了差,这是一个。

1239
01:30:59,390 --> 01:31:01,750
第二,这些指标够吗?

1240
01:31:04,430 --> 01:31:08,210
有些情况下这些指标多了,有些应用根本不需要这些指标,比如说我

1241
01:31:08,210 --> 01:31:13,650
刚才说的一个天气预报的计算程序,它根本不考虑响应时间,它就

1242
01:31:13,650 --> 01:31:14,550
能耗CPU。

1243
01:31:15,090 --> 01:31:16,950
也有可能这些指标不够

1244
01:31:16,950 --> 01:31:20,050
比如说你们手机

1245
01:31:20,790 --> 01:31:22,510
它评判标准很重要的标准什么

1246
01:31:22,510 --> 01:31:24,550
还有一个电量 power

1247
01:31:25,110 --> 01:31:31,130
电量 你这个一直耗CPU

1248
01:31:31,130 --> 01:31:32,470
那这个电量很快就耗完了

1249
01:31:32,470 --> 01:31:34,770
我们当然希望手机能撑的时间越长越好

1250
01:31:34,770 --> 01:31:36,610
那我们家手机最多也就撑一天不到

1251
01:31:37,630 --> 01:31:38,770
如果你一直耗CPU的话

1252
01:31:38,770 --> 01:31:40,170
可能两个小时就耗完了

1253
01:31:40,170 --> 01:31:41,710
说怎么去省电

1254
01:31:41,710 --> 01:31:44,170
是它的一个掉入的重要的指标

1255
01:32:44,170 --> 01:32:49,530
通常用那个小的水龙头,开出来的水量很小,但是一开就有水了,这个颜

1256
01:32:49,530 --> 01:32:52,070
值就很小,它吞吐量很大。

1257
01:32:52,270 --> 01:32:59,530
这就是一个矛盾,你可能很难兼顾到说,我用一个吞吐量很大的水龙头,然后

1258
01:32:59,530 --> 01:33:06,310
又可以及时的得到一个响应,这其实很难。

1259
01:33:36,590 --> 01:33:38,510
如果它这两个都是需要 那就尽量拿

1260
01:33:38,510 --> 01:33:40,430
如果某个应用只需要这个

1261
01:33:40,430 --> 01:33:42,870
只要行动一点 那我可以不考虑

1262
01:33:42,870 --> 01:33:50,110
低延迟 我只考虑个高带环也是可能的

1263
01:33:50,110 --> 01:33:51,310
响应时间这一块呢

1264
01:33:51,950 --> 01:33:53,310
特别是对于我们现在的

1265
01:33:54,130 --> 01:33:55,610
很多应用长角度非常重要

1266
01:33:55,610 --> 01:33:57,590
比如我们的手机 比如我们的

1267
01:33:57,590 --> 01:33:59,370
PC机 它非常care响应时间

1268
01:33:59,370 --> 01:34:01,310
我点一下 结果这半天没动静的话

1269
01:34:01,850 --> 01:34:02,910
那我体验就非常不好

1270
01:34:02,910 --> 01:34:05,510
但这个service还是不错 现在感觉

1271
01:34:05,510 --> 01:34:06,910
买起来之后还没白买

1272
01:34:08,190 --> 01:34:09,350
响应还是很灵敏的

1273
01:34:11,270 --> 01:34:13,470
就是这样的话就你的用户体验

1274
01:34:14,450 --> 01:34:15,850
这一点就非常重要了

1275
01:34:15,850 --> 01:34:18,870
现在的手机几乎不考虑CPU是啥

1276
01:34:18,870 --> 01:34:20,550
考虑的是屏幕好不好

1277
01:34:21,110 --> 01:34:22,510
然后交互灵不灵活

1278
01:34:22,510 --> 01:34:24,230
这是它考虑的重点

1279
01:34:24,830 --> 01:34:27,150
这就是典型的飞机上的用户考虑问题

1280
01:34:27,490 --> 01:34:28,690
如果对于竞争机用户而言

1281
01:34:28,690 --> 01:34:30,550
你就要知道这里面的CPU是啥

1282
01:34:30,550 --> 01:34:31,650
如果是华为的CPU的话

1283
01:34:31,650 --> 01:34:34,410
就华为应该是啥来的

1284
01:34:35,750 --> 01:34:38,450
它的麒麟处理器 但现在已经没了

1285
01:34:39,030 --> 01:34:41,850
现在被禁了之后 现在是变成了骁龙

1286
01:34:42,890 --> 01:34:44,250
对 高通的骁龙处理器

1287
01:34:44,250 --> 01:34:45,870
但我们还希望能看到

1288
01:34:45,870 --> 01:34:47,790
现在听说国内14纳米也有

1289
01:34:47,790 --> 01:34:49,410
所以麒麟处理器还会出现

1290
01:34:49,410 --> 01:34:51,210
可能用不到手机上

1291
01:34:51,210 --> 01:34:53,170
手机这个还是耗的比较厉害

1292
01:34:53,170 --> 01:34:54,630
可能但是我们可以用到PC上

1293
01:34:54,630 --> 01:34:58,050
我们已经看到了PC的麒麟的笔记本

1294
01:34:58,050 --> 01:35:00,390
这个还有服务器都有

1295
01:35:01,630 --> 01:35:02,610
所以怎么说呢

1296
01:35:02,610 --> 01:35:06,030
就是说交互性是某一类应用特别强调

1297
01:35:08,750 --> 01:35:10,270
只是某一类不是所有的

1298
01:35:13,030 --> 01:35:13,750
吞吐量

1299
01:35:13,750 --> 01:35:15,570
吞吐量主要用在哪儿呢

1300
01:35:15,570 --> 01:35:16,930
不要care的领域

1301
01:35:16,930 --> 01:35:19,450
主要是我们的服务器里

1302
01:35:19,450 --> 01:35:23,010
后续有大量的网络操作和文件Io操作

1303
01:35:23,010 --> 01:35:24,430
这里面特别强调吞吐量

1304
01:35:24,430 --> 01:35:26,570
当然也强调这个低延迟

1305
01:35:26,570 --> 01:35:29,550
但相对而言我们看到的这种所谓的纯属设备

1306
01:35:29,550 --> 01:35:31,310
那么它对吞吐量是非常高的

1307
01:35:32,850 --> 01:35:35,690
那如果你们一有吞吐量,一有交互怎么办呢

1308
01:35:35,690 --> 01:35:37,690
那你就要设计一个比较巧妙的调度算法

1309
01:35:37,690 --> 01:35:41,630
来帮助你能够应对这种交互和吞吐量都存在的情况

1310
01:35:41,630 --> 01:35:43,230
那后面看到一些算法

1311
01:35:43,230 --> 01:35:48,630
是能够坚固吞吐量和用户交互的相应时间的

1312
01:35:48,630 --> 01:35:50,510
这是这一块需要去理解一下

1313
01:35:51,410 --> 01:35:51,950
公屏

1314
01:35:51,950 --> 01:35:55,870
这公屏就比较难以定义

1315
01:35:55,870 --> 01:35:56,690
什么叫公屏

1316
01:35:57,090 --> 01:36:03,850
我目前的工程是以用户为一个前提的

1317
01:36:04,290 --> 01:36:05,790
对你们单机用户来说

1318
01:36:05,790 --> 01:36:08,510
咱们现在像我这个Windows

1319
01:36:08,510 --> 01:36:10,570
它可能就我自己在用

1320
01:36:10,570 --> 01:36:12,510
别的没有不是一个多用户系统

1321
01:36:12,510 --> 01:36:14,670
所以用户的感觉不是很深刻

1322
01:36:14,670 --> 01:36:15,770
大家其实也是一样的

1323
01:36:15,770 --> 01:36:16,890
用手机也好

1324
01:36:17,690 --> 01:36:18,970
用你们的笔记本也好

1325
01:36:18,970 --> 01:36:20,750
用户的体验不多

1326
01:36:20,750 --> 01:36:22,510
但是对于服务器而言

1327
01:36:22,510 --> 01:36:25,550
其实它是一个多用户的一个计算机系统

1328
01:36:25,550 --> 01:36:27,270
在这里面用户就很重要了

1329
01:36:27,270 --> 01:36:30,350
那我是一个root用户和一般的guest用户

1330
01:36:31,870 --> 01:36:35,090
那么在分配它们的这个字跃它们是不一样的

1331
01:36:35,830 --> 01:36:39,570
所以root用户可能我应该要占90%的处理器时间

1332
01:36:39,570 --> 01:36:41,910
给guest只分配了10%

1333
01:36:41,910 --> 01:36:43,070
他认为这是公平的

1334
01:36:43,070 --> 01:36:44,990
这是一个它们本来就有一个权重的问题

1335
01:36:44,990 --> 01:36:45,990
我的权力更大

1336
01:36:45,990 --> 01:36:46,990
它权力小一点

1337
01:36:46,990 --> 01:36:48,050
那你要保证

1338
01:36:48,050 --> 01:36:49,950
你要保证确实给到了90%

1339
01:36:49,950 --> 01:36:51,850
不能由于我定了90%

1340
01:36:51,850 --> 01:36:53,310
90%到10%之后

1341
01:36:53,310 --> 01:36:57,370
你结果结果我的guest占了50%

1342
01:36:57,370 --> 01:36:58,350
这是不合理的

1343
01:36:58,810 --> 01:37:02,190
我的guest占了0%也是不合理的

1344
01:37:02,190 --> 01:37:05,890
你要去按照这个权重比例来进行分配

1345
01:37:05,890 --> 01:37:09,930
但这一点能达到这一点其实也是对我们的一个

1346
01:37:09,930 --> 01:37:11,910
调度器的一个考验

1347
01:37:15,670 --> 01:37:17,250
好 大家先休息一下

1348
01:37:53,450 --> 01:38:03,390
位都标识的问题,是吧,如果在具体来说,应该是把代码段的读写列

1349
01:38:03,390 --> 01:38:13,490
改成纸,代码,哦不,说错了,数据段,数据段的那个读写,读写,可读可

1350
01:38:13,490 --> 01:38:19,630
写的,对,有些数据单就是纸,可读可写的改成纸,对,改成纸,对,但是你

1351
01:38:19,630 --> 01:38:22,170
那个 map iron 还是不变的,对对对。

1352
01:42:28,630 --> 01:42:31,030
好 我们继续上课

1353
01:42:31,030 --> 01:42:33,510
讲完这个前面的这些准则之外

1354
01:42:33,510 --> 01:42:35,530
可以看到这些准则这样多

1355
01:42:35,530 --> 01:42:37,330
而这个准则呢

1356
01:42:37,330 --> 01:42:39,590
第一 可能会存在潜在的一些矛盾

1357
01:42:39,590 --> 01:42:40,850
第二呢

1358
01:42:40,850 --> 01:42:42,170
你要达到这个目标

1359
01:42:42,170 --> 01:42:43,450
可能会引力开销

1360
01:42:43,450 --> 01:42:45,470
就跟我们前面讲的那个

1361
01:42:45,470 --> 01:42:46,530
一面对外算法一样

1362
01:42:46,530 --> 01:42:49,190
你要提出一个所谓的一个算法

1363
01:42:49,190 --> 01:42:50,490
实际上它是有开销的

1364
01:42:50,490 --> 01:42:52,090
所以我们看一下这些

1365
01:42:52,090 --> 01:42:53,030
我们列出了一些

1366
01:43:24,850 --> 01:43:26,930
然后进行进入等待会结束状态的时候

1367
01:43:26,930 --> 01:43:30,250
就得用下一个进程占用处理器

1368
01:43:31,750 --> 01:43:34,870
这是FCFS的一个情况

1369
01:43:35,370 --> 01:43:39,190
那么评价FCFS我们可以用周转时间来评价

1370
01:43:39,190 --> 01:43:41,230
这是一个评价指标

1371
01:43:41,230 --> 01:43:43,610
这里面给出了例子

1372
01:43:43,610 --> 01:43:44,390
所谓周转时间

1373
01:43:44,830 --> 01:43:49,610
理解 周转时间就是从它开始创建它

1374
01:43:49,610 --> 01:43:51,290
到它最后执行完毕的一个时间

1375
01:43:51,290 --> 01:43:52,230
叫周转时间

1376
01:43:52,230 --> 01:43:55,610
那这个给了一个例子 三个进程

1377
01:43:55,610 --> 01:43:58,030
大家都在同一个时间 差不多几乎同一个时间到达

1378
01:43:58,030 --> 01:44:00,170
但还是有个顺序是P1 P2 P3

1379
01:44:00,170 --> 01:44:02,290
那P的它的直径时间是12

1380
01:44:02,290 --> 01:44:04,510
P2和P3的直径时间是3

1381
01:44:04,510 --> 01:44:06,010
那么这样的话我们把P1放前头

1382
01:44:06,010 --> 01:44:08,690
P2在第二个 P3在第三个

1383
01:44:08,690 --> 01:44:09,950
那么它的多转时间一算

1384
01:44:10,550 --> 01:44:13,130
那就是第一个是0就开始到了嘛

1385
01:44:13,130 --> 01:44:14,110
就是0就是12

1386
01:44:14,110 --> 01:44:18,690
而第二个 第二个它的到达时间也是0

1387
01:44:18,690 --> 01:44:22,130
但它的结束时间是15

1388
01:44:23,650 --> 01:44:28,770
第三个它的到达时间也是0

1389
01:44:28,770 --> 01:44:30,390
结束时间是18

1390
01:44:30,390 --> 01:44:32,130
有没有问题 没问题吧

1391
01:44:32,130 --> 01:44:34,950
所以它的周转时间平均周转时间

1392
01:44:34,950 --> 01:44:37,650
就是这三个加起来除以3等于15

1393
01:44:39,910 --> 01:44:41,810
但如果这个顺序倒了一下

1394
01:44:41,810 --> 01:44:44,850
就是我到达顺序是p2 p3 p1的话

1395
01:44:45,590 --> 01:44:48,210
你会发现它就是3618除以3

1396
01:45:18,250 --> 01:45:20,370
很多情况下 特别这种情况下

1397
01:45:20,370 --> 01:45:21,130
它就是不好

1398
01:45:22,270 --> 01:45:25,630
就是平均等待时间有可能波动很大

1399
01:45:25,630 --> 01:45:26,670
而且会出现

1400
01:45:26,670 --> 01:45:29,710
我本来可以很快执行的进程

1401
01:45:29,710 --> 01:45:31,990
但由于你放在后头了

1402
01:45:31,990 --> 01:45:32,910
稍微靠好了一点

1403
01:45:32,910 --> 01:45:34,590
就要等待前面的长进程

1404
01:45:34,590 --> 01:45:36,530
去结束之后才能执行

1405
01:45:36,530 --> 01:45:38,710
Io资源和CPU资源利用力比较低

1406
01:45:38,710 --> 01:45:42,050
CPU密集形进程会导致Io设备闲滞

1407
01:45:42,050 --> 01:45:43,710
Io密集形进程也会等待

1408
01:45:43,710 --> 01:45:46,830
这都是一些它的缺点

1409
01:45:46,830 --> 01:45:56,370
优点有一个,简单。那我想问一下,有没有适合大陆场景?

1410
01:46:56,370 --> 01:47:01,190
我这个吞口量是指整个系统的吞口量,如果整个系统吞口量的话,没

1411
01:47:01,190 --> 01:47:01,610
啥问题。

1412
01:47:02,970 --> 01:47:06,350
然后再想想我们之前讲的计算机系统,我们说计算机系统发了一个过程,

1413
01:47:06,690 --> 01:47:10,450
前面有一个P处理系统,直行完一个再下一个,直行完一个再下一个,这就是

1414
01:47:10,450 --> 01:47:14,670
FIFO,我们讲前面那个P处理系统的调度就是FIFO。

1415
01:47:15,890 --> 01:47:21,610
挺好啊,所以对于P处理系统来说FIFO这种方式就适合,而适

1416
01:47:21,610 --> 01:47:24,130
合P处理系统的这种应用模式也存在。

1417
01:47:24,130 --> 01:47:29,490
比如说我们说离线的数据存储

1418
01:47:29,990 --> 01:47:33,330
然后这种大规模长时间的计算

1419
01:47:33,330 --> 01:47:36,290
它们每一个任务跑起来都要跑个几天

1420
01:47:36,670 --> 01:47:39,470
那你切换它也没有意义 反正它要跑几天

1421
01:47:39,470 --> 01:47:41,470
就这么两三个任务都是要跑几天的程序

1422
01:47:41,470 --> 01:47:42,870
那大家能不能跑就行了

1423
01:47:42,870 --> 01:47:45,610
最后的结果才是重要的 中间没有结果

1424
01:47:45,610 --> 01:47:47,550
对于这种情况下来说

1425
01:47:49,930 --> 01:47:53,590
这个FCFS就是一个很好的一个调度算法

1426
01:47:53,590 --> 01:47:55,590
OK 它有它适合的场景

1427
01:47:56,570 --> 01:47:58,750
但是如果这个任务再变得灵活一点

1428
01:47:58,750 --> 01:48:01,270
就出现了这个任务之间长短不一

1429
01:48:01,270 --> 01:48:04,450
它不是一种比较均匀的情况

1430
01:48:04,450 --> 01:48:08,370
那这时候短任务就受到吃的亏要大一些

1431
01:48:08,370 --> 01:48:12,270
所以这也是为什么提出来说的short job post

1432
01:48:13,010 --> 01:48:15,390
就是短作业优先

1433
01:48:15,390 --> 01:48:18,730
短作业优先的job就是早期的一个历史的一个词

1434
01:48:18,730 --> 01:48:21,750
它是等同于我们现在的进程

1435
01:48:21,750 --> 01:48:24,170
只是当时的力度比较粗叫叫

1436
01:48:24,170 --> 01:48:26,930
但是说从很早期的时候

1437
01:48:28,090 --> 01:48:30,710
一个作业意味着把这个程序放到

1438
01:48:31,410 --> 01:48:34,450
那个叫做读卡器里面加入内存

1439
01:48:34,450 --> 01:48:37,390
最后把这个算出来写回一个打印机

1440
01:48:37,390 --> 01:48:38,370
输出结果

1441
01:48:38,370 --> 01:48:39,410
这叫一个作业

1442
01:48:39,410 --> 01:48:42,950
其实也是等于我们现在的一个进程的执行过程

1443
01:48:42,950 --> 01:48:45,630
只是一种不同的表述方式

1444
01:48:45,630 --> 01:48:47,250
那这种短作业又显得好

1445
01:48:47,250 --> 01:48:49,190
那意味着在这里面

1446
01:48:49,830 --> 01:48:52,330
就大家差不多一个时候来的这个进程

1447
01:48:52,330 --> 01:48:53,450
我是要做一个排序

1448
01:48:53,450 --> 01:48:54,810
看谁的执行时间短

1449
01:48:54,810 --> 01:48:56,490
我把谁放前头

1450
01:48:56,490 --> 01:48:57,850
基于这种方式

1451
01:48:57,850 --> 01:49:00,550
那我们前面的这个平均作用时间

1452
01:49:00,550 --> 01:49:02,970
我们是以平均作用时间作为一个评价指标的话

1453
01:49:02,970 --> 01:49:05,090
你会发现这个短作用最优先

1454
01:49:05,090 --> 01:49:07,830
特别适合于平均作用时间这个指标

1455
01:49:07,830 --> 01:49:11,410
就是它可以得到一个非常小的平均作用时间

1456
01:49:11,410 --> 01:49:15,350
具有所谓的一种最优平均作用时间的一个特点

1457
01:49:16,330 --> 01:49:19,110
那这个特点就是你看到这里面排好序了

1458
01:49:19,110 --> 01:49:21,050
这实际上是把它变成数学问题

1459
01:49:21,630 --> 01:49:24,430
P1到P6按照它的执行时间来排序

1460
01:49:24,430 --> 01:49:26,550
然后再去算这段时间

1461
01:49:26,550 --> 01:49:28,030
这种情况一定是最小的

1462
01:49:28,030 --> 01:49:30,070
它比其他你把这里面任意两个

1463
01:49:30,070 --> 01:49:31,790
调换个位置之后算出来的要小

1464
01:49:34,230 --> 01:49:35,090
这是数学问题

1465
01:49:35,090 --> 01:49:38,270
大家可以去试着去推导一下

1466
01:49:38,270 --> 01:49:40,170
是否是最优的

1467
01:49:40,170 --> 01:49:41,110
最优就是最小的意思

1468
01:49:41,110 --> 01:49:44,270
这个是最小的

1469
01:49:44,270 --> 01:49:46,590
结论确实是你只要稍微推导之后

1470
01:49:46,590 --> 01:49:49,090
就得出一个结论是对的

1471
01:50:19,110 --> 01:50:23,830
第二个问题是在于进程 它怎么知道它的执行时间

1472
01:50:25,870 --> 01:50:32,230
有同学说 这好办 执行一遍不就知道了吗

1473
01:50:33,170 --> 01:50:37,890
这是一个有效的解决办法 是吧 执行一遍就知道了

1474
01:50:37,890 --> 01:50:41,190
早期的CWD系统里面 它确实每个程序的执行时间大部分是确

1475
01:50:41,190 --> 01:50:42,770
定的 比如说我要创举登成

1476
01:50:42,770 --> 01:50:47,690
我第一遍刷第二遍 我就知道它不是就这个时间 没问题 但是

1477
01:50:48,990 --> 01:50:55,710
现在的程序变了,像我这个十二子什么时候关我也不知道,下课的我也不关,取决

1478
01:50:55,710 --> 01:51:05,850
于人的一个心情。所以现在的很多程序,第一,你就感觉它不会停下来,第二,什么时候停

1479
01:51:05,850 --> 01:51:09,450
不确定,这就使得你很难估计它的执行时间了。

1480
01:51:09,450 --> 01:51:14,930
那你所谓这个执行时间到底长和短,就不确定了。既然不确定,你没法

1481
01:51:14,930 --> 01:51:17,190
去预知未来,你就没法去做这个事情。

1482
01:51:19,230 --> 01:51:23,310
这里面也给了一些简单办法,其实说让用户提供。

1483
01:51:25,410 --> 01:51:31,910
如果你谎报这个时间说很长,你就把它K了掉。这都是一些可能的办法,但并不是特别

1484
01:51:31,910 --> 01:51:32,450
实际。

1485
01:51:32,450 --> 01:51:33,550
并不是特别实际

1486
01:51:33,550 --> 01:51:36,230
所以这个算法只适合于

1487
01:51:36,230 --> 01:51:38,930
你确实知道这个作业或者进程

1488
01:51:38,930 --> 01:51:39,850
它的执行时间的情况下

1489
01:51:39,850 --> 01:51:40,610
它是有效的

1490
01:51:40,610 --> 01:51:42,170
但一旦脱离了这一点

1491
01:51:42,170 --> 01:51:43,490
它就不有效了

1492
01:51:45,750 --> 01:51:47,050
怎么来解决

1493
01:51:47,530 --> 01:51:49,530
我们可以去扩展一下

1494
01:51:49,530 --> 01:51:50,790
我们去预估一下

1495
01:51:50,790 --> 01:51:52,550
这是我们通常类似URO一样

1496
01:51:52,550 --> 01:51:54,710
用历史的方法来预知未来

1497
01:51:54,710 --> 01:51:56,030
这通常的一种方法

1498
01:51:56,030 --> 01:51:57,790
这也是我们早期的Unix

1499
01:51:57,790 --> 01:51:59,410
采取一种方法

1500
01:51:59,410 --> 01:52:04,210
它也采用了这种短作业优先的方式

1501
01:52:04,210 --> 01:52:06,730
但是它这个执行时间是每一次

1502
01:52:06,730 --> 01:52:09,470
每一个所有竞争执行的一个周期里面

1503
01:52:09,470 --> 01:52:11,130
去预估了一下下一个周期

1504
01:52:11,130 --> 01:52:13,250
它的执行时间是多少 然后再进行排序

1505
01:52:13,250 --> 01:52:14,470
最主要是有的

1506
01:52:14,470 --> 01:52:16,510
这是它的一个典型的公式

1507
01:52:16,510 --> 01:52:22,770
比如说 套N加1等于Alpha TN

1508
01:52:22,770 --> 01:52:23,990
加上E减就Alpha套N

1509
01:52:23,990 --> 01:52:27,130
这套N代表的是第N次的CPU计算时间

1510
01:52:28,330 --> 01:52:33,730
这个tn是实际的指引时间,而这个tau是预估时间,这两件事有差异

1511
01:52:33,730 --> 01:52:34,350
的。

1512
01:52:34,350 --> 01:52:41,310
那我是根据当前的指引时间和当前的预估时间预测的下一次的指引

1513
01:52:41,310 --> 01:52:41,630
时间。

1514
01:52:42,270 --> 01:52:48,370
就这种方式,这是我们超级统经常用到的一种学习和人工智能还

1515
01:52:48,370 --> 01:52:51,670
没出现的时候,我们做的一种人工的预测,很有效。

1516
01:52:52,690 --> 01:53:00,630
这就是我们看到的一些场景,就是用这种方式来预测进程的执行时间。这是短

1517
01:53:00,630 --> 01:53:06,110
缀优先的一个算法的进一步的改进,预测。它并不是提前知道,而实验

1518
01:53:06,110 --> 01:53:06,810
是预测出来的。

1519
01:53:08,510 --> 01:53:14,630
这里面,即使能预测的时候,还存在一个问题。什么问题呢?就是说,你能不能允许切换

1520
01:53:14,630 --> 01:53:16,490
的问题,或者能不能强制打断的问题。

1521
01:53:16,490 --> 01:53:20,870
前面我们讲的这个短作用心是不允许强,不允许强制打断

1522
01:53:20,870 --> 01:53:26,110
这意味着当前我正在执行的这个作业或者进程

1523
01:53:26,110 --> 01:53:29,450
它的执行时间,比如说我执行了3秒

1524
01:53:29,450 --> 01:53:33,470
它的执行时间是10秒,那意味着它还剩下7秒才能结束

1525
01:53:33,470 --> 01:53:37,650
但这时候我来了一个更小的

1526
01:53:37,650 --> 01:53:42,490
比如说我只有一个4秒的一个短的一个进程进来了

1527
01:53:42,490 --> 01:53:46,730
那请问你要不要把当前资产运行机能给暂停一下

1528
01:53:46,730 --> 01:53:48,370
让这个更短的去执行

1529
01:53:48,370 --> 01:53:50,270
如果是基于前面的短作业优先

1530
01:53:50,270 --> 01:53:51,890
它不允许抢占

1531
01:53:51,890 --> 01:53:53,550
所以它没法做到这一步

1532
01:53:53,550 --> 01:53:56,290
那这就显得不够灵活

1533
01:53:57,290 --> 01:54:01,870
所以又提出了一个叫做SRT的一个最短剩余时间算法

1534
01:54:01,870 --> 01:54:02,970
这个成绩取得很不错

1535
01:54:02,970 --> 01:54:03,650
SRT

1536
01:54:04,830 --> 01:54:06,970
这个SRT就是最短剩余时间

1537
01:54:08,070 --> 01:54:09,890
但是我刚才那个刚刚举了个例子

1538
01:54:09,890 --> 01:54:13,950
最短剩余时间正在运行的那个最短剩余时间是7,而我吸引进来的

1539
01:54:13,950 --> 01:54:19,910
一个是4,所以这时候它就应该要去做切换,完成这个切换的过程。

1540
01:54:19,930 --> 01:54:27,970
要切换要支持抢占掉,那如果你的OS支持抢占掉的话,就可以去实现一个所谓的

1541
01:54:27,970 --> 01:54:29,890
最短剩余时间的调度算法。

1542
01:54:31,990 --> 01:54:44,610
这是关于抢占和不抢占,就形成了SJF和SRT这两种有点

1543
01:54:44,610 --> 01:54:51,910
差异的短时间和优先的进程调度算盘,这是这一块。

1544
01:54:51,910 --> 01:55:01,810
还有一个呢,其实前面讲的基本上没有考虑什么,没有考虑等待。我们说的等待,我们

1545
01:55:01,810 --> 01:55:06,010
记得我们说过这个等待时间怎么等待,等待是几种等待?

1546
01:55:06,410 --> 01:55:10,970
我说等待的时候,其实全体应该带个前缀。你是在救需队里面等待呢,还是

1547
01:55:10,970 --> 01:55:12,430
你在等待队里面等待?

1548
01:55:12,430 --> 01:55:18,090
所谓等待队列,比如说利斯利德,你等待我们资源没有拿到,你没法执

1549
01:55:18,090 --> 01:55:23,190
行,那个叫在等待队列或者阻射队列里面去等待。

1550
01:55:23,330 --> 01:55:28,610
还有一个叫就绪队列里面等待,大家都有机会去执行处理器。但是调度器

1551
01:55:28,610 --> 01:55:33,990
只选择了其中一个,其他的即使能执行也不得不等,那个在就绪队列

1552
01:55:33,990 --> 01:55:35,970
里面等待。这两个等待是不一样的。

1553
01:55:35,970 --> 01:55:39,430
那这里面想说的最高响应比优先呢

1554
01:55:39,430 --> 01:55:42,630
就是对前面说的FCFS和SCF的一个综合考虑

1555
01:55:42,630 --> 01:55:45,030
他考虑了每个作业的等待时间和估计的运行时间

1556
01:55:45,030 --> 01:55:47,770
这里面的等待是只是在就绪队里面的等待时间

1557
01:55:47,770 --> 01:55:49,070
这个需要注意

1558
01:55:49,930 --> 01:55:53,110
所以他给出了一个新的一个评价指标

1559
01:55:53,110 --> 01:55:57,190
叫做响应比这个R

1560
01:55:57,950 --> 01:55:58,610
R是什么意思

1561
01:55:58,610 --> 01:56:02,930
R是等于W加S就是在就绪队里面的等待时间

1562
01:56:03,450 --> 01:56:07,110
S是它的执行时间,就占用CPU执行了多少时间

1563
01:56:07,110 --> 01:56:11,810
把这个W加S除以S,得到了一个值叫R

1564
01:56:11,810 --> 01:56:17,230
那么R越大,我就意味着我要优先去调度它

1565
01:56:17,230 --> 01:56:20,050
为什么要优先调度它,在于你看这里面

1566
01:56:21,070 --> 01:56:24,130
其实如果你的等待在旧系列里面等待时间越长

1567
01:56:24,130 --> 01:56:25,930
这个R就可能会越大

1568
01:56:25,930 --> 01:56:31,990
从这种方式使得在旧系列里面等待时间长的这个进程

1569
01:56:31,990 --> 01:56:37,150
就有机会去执行,这个就防止了一些进程被饥饿

1570
01:56:37,750 --> 01:56:43,130
这是所谓的最高响应笔优先的一个调度算法

1571
01:56:43,130 --> 01:56:46,790
这是对这个短作业优先的进一步的改进,避免饥饿

1572
01:56:50,490 --> 01:56:57,470
前面的这个SJF或者说是SRT或者是最高响应笔

1573
01:56:58,230 --> 01:57:02,330
都是真正这种CPU密集性的,没有考虑到Io的情况

1574
01:57:03,930 --> 01:57:08,690
如果随着GLG的发展,我们说这个Io交互越来越重要的情况下

1575
01:57:08,690 --> 01:57:12,590
光靠前面的算法,发觉有一个问题就是交互性不够

1576
01:57:12,590 --> 01:57:17,170
就是我们希望要提高交互,要尽量地让大家

1577
01:57:17,170 --> 01:57:20,730
就是我们敲一下键盘,敲一下鼠标,对方们及时响应

1578
01:57:20,730 --> 01:57:25,570
那这种情况下,我们怎么能够让那些进程有机会去执行

1579
01:57:25,570 --> 01:57:28,970
特别是有交互请求这些进程去执行的

1580
01:57:28,970 --> 01:57:32,590
这有了新的一个转法 称之为Round robin

1581
01:57:32,590 --> 01:57:35,190
Round robin第一是考虑到了这种交互性

1582
01:57:35,190 --> 01:57:36,210
第二考虑到了供给性

1583
01:57:36,210 --> 01:57:38,810
就是通过这种实验片的方法

1584
01:57:38,810 --> 01:57:43,310
来使得大家能够分时共享处理器

1585
01:57:43,310 --> 01:57:44,970
这是它一个基本辞录

1586
01:57:44,970 --> 01:57:46,950
那这边有个实验片

1587
01:57:46,950 --> 01:57:48,990
这里面给的例子就是

1588
01:57:48,990 --> 01:57:50,750
给每个进程分了实验片

1589
01:57:50,750 --> 01:57:52,450
单一个进程DKM进行完毕之后

1590
01:57:52,450 --> 01:57:53,850
它就不能继续执行了

1591
01:57:53,850 --> 01:57:57,130
他需要把这个处理器占给其他的进程去执行

1592
01:57:57,130 --> 01:58:00,510
把他自己的会挂到那个救需队的尾巴上去

1593
01:58:00,510 --> 01:58:02,670
等待下游的执行时间

1594
01:58:02,670 --> 01:58:04,530
这是我们说这个

1595
01:58:05,430 --> 01:58:08,530
Round Robin的一个调路算法的一个基本的一个思路

1596
01:58:09,170 --> 01:58:14,850
那这给出了一个他的一个执行的一个情况

1597
01:58:14,850 --> 01:58:17,790
那么这里面的等待时间是在救需队那边的等待时间

1598
01:58:17,790 --> 01:58:20,510
你可以看出来怎么来算的

1599
01:58:20,510 --> 01:58:23,350
P1 P2 P3 P4 这给出了执行时间了

1600
01:58:23,350 --> 01:58:26,570
如果我们把时间片设置成一个固定的值

1601
01:58:26,570 --> 01:58:29,850
这里面设了多少 设的是20

1602
01:58:29,850 --> 01:58:31,090
20套时间片

1603
01:58:31,630 --> 01:58:33,850
那么P1虽然它需要我们三个时间

1604
01:58:34,530 --> 01:58:38,130
那么我们也会在它执行完20个时间大部分的时候

1605
01:58:38,130 --> 01:58:40,970
把它抢占 让第二个技能去执行

1606
01:58:40,970 --> 01:58:41,990
第二个技能只有8

1607
01:58:41,990 --> 01:58:43,670
那它执行到8的时候 没到20

1608
01:58:43,670 --> 01:58:45,150
它时间片还没用完 它就结束了

1609
01:58:45,150 --> 01:58:46,810
没关系 我们就给P3

1610
01:58:46,810 --> 01:58:47,750
P3是68

1611
01:58:47,750 --> 01:58:49,490
那P3执行到20的时候

1612
01:58:49,490 --> 01:58:51,910
就是28到48的时候呢

1613
01:58:51,910 --> 01:58:54,310
它也会让出来 被强制让出来

1614
01:58:54,310 --> 01:58:57,130
被我们的超级统通过通转方式强制让出来

1615
01:58:57,130 --> 01:58:58,350
让PC去仔细

1616
01:58:58,350 --> 01:59:01,190
这就是所谓分时的一个

1617
01:59:01,190 --> 01:59:02,990
基于时间片的一个轮转调的算法

1618
01:59:03,890 --> 01:59:06,550
其实我们之前的那个

1619
01:59:06,550 --> 01:59:09,190
抢单式调度在任务那个章节的时候

1620
01:59:09,190 --> 01:59:10,590
就已经用到这种算法

1621
01:59:10,590 --> 01:59:12,530
其实非常简单 这期也非常简单

1622
01:59:13,790 --> 01:59:15,250
这里面的好处就在于

1623
01:59:15,250 --> 01:59:18,450
大家都有机会 都有机会去执行

1624
01:59:18,450 --> 01:59:19,530
那它的坏处是什么

1625
01:59:21,210 --> 01:59:26,230
发现每一个进程都会等一段时间才能结束,比如这个P1在哪儿结束,

1626
01:59:26,290 --> 01:59:32,810
在125才结束,本来它只需要53,意味着如果全是它执行的话,它53个时间

1627
01:59:32,810 --> 01:59:39,770
段会结束,但它现在不得不在125,这是公平和它的效率,它个人效率之

1628
01:59:39,770 --> 01:59:41,390
间的一个矛盾。

1629
01:59:41,390 --> 01:59:46,690
我们为了整个系统的供应性,我们觉得这种方法更合理,这样使得比如P

1630
01:59:46,690 --> 01:59:53,130
2可以迅速地得到执行,这种8的这种可以迅速地得到执行,但是它

1631
01:59:53,130 --> 01:59:56,490
就会使得其他的一些进程会比较长的实验室得到执行。

1632
01:59:56,790 --> 02:00:02,990
这是一个我们说的实验片轮转带路算法的基本的一个思路。在这个设计里

1633
02:00:02,990 --> 02:00:09,130
面,还需要注意几点,就是你其实是基于中段来进行切换的,那么中段就会

1634
02:00:09,130 --> 02:00:10,030
以上下文切换。

1635
02:00:10,530 --> 02:00:15,110
这个上下文切换包含了我们说的Trap上下文的保存有恢复,还有任

1636
02:00:15,110 --> 02:00:16,910
务的保存有恢复,这两个切换。

1637
02:00:17,150 --> 02:00:20,530
这两个切换如果还进一步涉及到进程的话,那么还有进程的页表的切

1638
02:00:20,530 --> 02:00:25,230
换,这有不同的切换,这些切换都需要开销的。这些开销就额外的上

1639
02:00:25,230 --> 02:00:25,990
下文切换开销。

1640
02:00:26,470 --> 02:00:31,850
你切换的频度越多,那你这开销就沉起来,开销就越来越大。这是

1641
02:00:31,850 --> 02:00:32,110
一个。

1642
02:00:32,110 --> 02:00:38,930
第二个,我怎么能减少开销,我可以减少次数,让实验片变得更大。

1643
02:00:39,270 --> 02:00:41,410
变得更大,这个次数就自然减少了。

1644
02:00:41,490 --> 02:00:46,050
但实验片变得更大的时候,在极端情况下变成了FCFS。

1645
02:00:46,630 --> 02:00:50,950
当实验片无穷大的时候,就退化成了FCFS。

1646
02:00:51,270 --> 02:00:54,590
所以说,R和FCFS并不是没有任何关系的。

1647
02:00:54,990 --> 02:00:57,730
它们都有关系,取决于你这个实验片的设置。

1648
02:00:58,510 --> 02:01:03,910
太小就会有太大量的商量和切换,有额外的开销。

1649
02:01:06,350 --> 02:01:13,830
所以这个时间片应该怎么设置,这个value应该怎么设置,怎么叫一个合适的。

1650
02:01:17,130 --> 02:01:20,830
这是我们超级种里面另外一个经常碰到的一个理解。

1651
02:01:21,270 --> 02:01:26,510
有同学觉得,你看到这边写的经验,经验是什么经验,人的经验,就是开发

1652
02:01:26,510 --> 02:01:27,490
者的经验。

1653
02:01:27,550 --> 02:01:31,970
开发者在他的开发文中,他根据他运行的情况来给予一个经验值。

1654
02:01:32,690 --> 02:01:35,830
要维持CNL开发在百分之一以下。

1655
02:01:36,810 --> 02:01:46,590
所以看到现在的比如说Elixir为例,他的切换的频度有两种选择。

1656
02:01:46,590 --> 02:01:51,310
一个是1毫秒 一个是10毫秒

1657
02:01:52,230 --> 02:01:54,050
1ms还有10ms

1658
02:01:54,050 --> 02:01:56,450
1毫秒是针对什么呢 针对桌面系统

1659
02:01:56,450 --> 02:01:57,950
针对桌面系统它设成1毫秒

1660
02:01:57,950 --> 02:02:00,070
就切换频度更高一点

1661
02:02:00,070 --> 02:02:02,550
这样可以让响应更好一点

1662
02:02:02,550 --> 02:02:04,930
而10毫秒是针对什么 针对服务器系统

1663
02:02:04,930 --> 02:02:06,930
服务器系统更强调分布量

1664
02:02:06,930 --> 02:02:10,390
它设成10毫秒降低了格外的上远切换的开销

1665
02:02:11,230 --> 02:02:12,490
它分布量增加了

1666
02:02:12,490 --> 02:02:14,150
这是两种不同的设计思路

1667
02:02:15,170 --> 02:02:18,250
早期的Linux就是蛮设计的

1668
02:02:18,250 --> 02:02:23,890
所以这个经验值并没有一个绝对的一个

1669
02:02:24,630 --> 02:02:26,090
哪个字是好的

1670
02:02:27,470 --> 02:02:31,670
其实这个值在后期的Linux的这个掉落算法里面

1671
02:02:31,670 --> 02:02:33,130
我们后面会讲实际掉落算法里面

1672
02:02:33,130 --> 02:02:35,270
比如CFS

1673
02:02:35,870 --> 02:02:37,730
这个实验片都是一个动态变化

1674
02:02:37,730 --> 02:02:39,290
它都不是一个固定值

1675
02:02:39,290 --> 02:02:40,290
变成一个动态变化值

1676
02:02:40,290 --> 02:02:42,390
这样的话就更加的灵活

1677
02:02:42,390 --> 02:02:48,770
但依然要确保它的开销 总体开销足够小才行

1678
02:02:48,770 --> 02:02:51,790
如果开销大的话 确实就得不偿失了

1679
02:02:54,910 --> 02:02:59,970
这里面给了一些关于 FCFS 和 RR 的一个计算

1680
02:02:59,970 --> 02:03:03,610
可以看出来 我们如果把平均等待时间

1681
02:03:03,610 --> 02:03:05,190
作为一个衡量标准的话

1682
02:03:07,890 --> 02:03:10,450
你看到一些很有趣的一些结果

1683
02:03:13,610 --> 02:03:15,770
RR来说它大部分比较均匀

1684
02:03:16,890 --> 02:03:21,390
都是在60到66之间的一个平均等待时间

1685
02:03:21,390 --> 02:03:23,190
这填了什么 填了一种公平性

1686
02:03:23,190 --> 02:03:24,170
大家都有机会

1687
02:03:24,170 --> 02:03:27,710
但对于FCFS而言 它确实有波动性

1688
02:03:27,710 --> 02:03:29,590
最好和最坏差别非常大

1689
02:03:29,590 --> 02:03:31,570
最好的时候它可以达到31.25

1690
02:03:31,570 --> 02:03:32,530
这个平均等待时间

1691
02:03:32,530 --> 02:03:34,790
最差的时候是83.5

1692
02:03:36,910 --> 02:03:37,970
所以怎么说呢

1693
02:03:37,970 --> 02:03:40,530
就是说如果以平均等待时间来衡量的话

1694
02:03:43,650 --> 02:03:49,550
那么这个RR并不是一个感觉特别合适的一个调路创法

1695
02:03:50,170 --> 02:03:52,970
但是我们如果换成其他的一些评价指标

1696
02:03:52,970 --> 02:03:56,410
比如说我们前面说的Latency 延迟

1697
02:03:56,410 --> 02:04:02,910
那么在这上面可能就是我们的RR会比F7S要好很多

1698
02:04:02,910 --> 02:04:05,170
这取决于我们的应用场景

1699
02:04:05,170 --> 02:04:08,830
这里面给出的应用场景还是纯粹的一个CPU计算时间

1700
02:04:09,410 --> 02:04:11,330
在纯粹CPU进展的情况下

1701
02:04:11,330 --> 02:04:13,230
那你这个平均等待时间

1702
02:04:14,990 --> 02:04:18,610
能够反映出来的这个RR的优势就不大

1703
02:04:18,610 --> 02:04:19,950
我们这样反映RR的优势

1704
02:04:19,950 --> 02:04:21,590
其实更多要有IO的一点

1705
02:04:21,590 --> 02:04:23,570
这里面其实并没有把IO给引进来

1706
02:04:23,570 --> 02:04:27,470
IO的一些操作给引进来

1707
02:04:27,470 --> 02:04:32,850
好 那这个RR出来之后呢

1708
02:04:32,850 --> 02:04:34,990
我们又觉得这个RR还不够灵活

1709
02:04:34,990 --> 02:04:36,710
为什么不够灵活呢

1710
02:04:37,490 --> 02:04:40,990
因为它考虑了这种所谓的这种大家均分的情况

1711
02:04:40,990 --> 02:04:44,230
大家均分一个处理器 大家都有机会去执行

1712
02:04:44,230 --> 02:04:45,550
但是有的时候

1713
02:04:46,490 --> 02:04:47,730
这个Io再考虑深入一点

1714
02:04:47,730 --> 02:04:49,610
Io说它其实这说法本来就没在执行

1715
02:04:49,610 --> 02:04:50,550
它应该是slip的

1716
02:04:51,670 --> 02:04:54,190
但是slip完之后 它应该能够迅速的

1717
02:04:54,190 --> 02:04:56,190
希望比如说我正在等待

1718
02:04:56,190 --> 02:04:58,850
我点了一下鼠标 点了一下手写笔之后

1719
02:04:58,850 --> 02:05:01,090
它应该迅速的能够响应

1720
02:05:01,090 --> 02:05:03,350
画出一个圈 画出一个点来

1721
02:05:03,350 --> 02:05:06,490
那这个集字性 用RR其实也做不到

1722
02:05:06,490 --> 02:05:08,750
因為 R 的話它是按照實際面來分的

1723
02:05:09,770 --> 02:05:13,770
那這時候你有沒有辦法把 IO 引入之後呢

1724
02:05:13,770 --> 02:05:17,450
能夠得到一個更好的一個 其實相應的一個算法

1725
02:05:18,530 --> 02:05:23,030
這裡面就逐步的從 Multi-Q 進化到了是 Multi-Level Feedback

1726
02:05:23,030 --> 02:05:25,010
這種更高級的一級道路算法

1727
02:05:25,010 --> 02:05:26,130
首先看 Multi-Q

1728
02:05:26,130 --> 02:05:29,010
前面的算法呢 都有一個同樣的問題什麼的

1729
02:05:29,830 --> 02:05:33,470
它對進程的優先體系沒有進行區分

1730
02:05:33,470 --> 02:05:35,490
就是說大家都是一個優先體系

1731
02:05:35,490 --> 02:05:36,810
但其实进程有不同

1732
02:05:37,470 --> 02:05:41,170
我处理这种鼠标键盘的和处理文件存储的

1733
02:05:41,170 --> 02:05:44,190
处理网络的 还有只是处理计算的

1734
02:05:44,190 --> 02:05:46,190
他们其实应该设置成不同线级

1735
02:05:46,190 --> 02:05:48,770
来提高所谓的一些需要

1736
02:05:48,770 --> 02:05:50,350
其实响应的一些能力

1737
02:05:50,350 --> 02:05:52,050
那这里面就有两类

1738
02:05:52,050 --> 02:05:55,250
比如说我们把这个运行在前面这个前台

1739
02:05:55,250 --> 02:05:57,170
就是运行在这个显示器上这个程序

1740
02:05:57,170 --> 02:05:58,510
称之为前台进程

1741
02:05:58,510 --> 02:06:01,550
和后台进程你要区分开来

1742
02:06:01,550 --> 02:06:04,370
CPU运行它不考虑响应性的

1743
02:06:04,370 --> 02:06:07,650
我们称之为后台进程 考虑响应线的称之为前台进程

1744
02:06:07,650 --> 02:06:13,390
那么我们把这两类做个区分 只分这两类就是搞成两个对立

1745
02:06:13,810 --> 02:06:16,370
首先我们要去优先调过的是前台进程

1746
02:06:17,490 --> 02:06:21,350
然后前台进程没有就绪的了 我再去调过所谓的后台进程

1747
02:06:21,350 --> 02:06:25,430
这样可以至少确保我这些强调响应线的这些进程

1748
02:06:25,430 --> 02:06:28,150
可以优先得到执行 更高得到执行

1749
02:06:28,150 --> 02:06:30,810
这所谓它需要订好两个规则

1750
02:06:30,810 --> 02:06:33,890
如果是前台进程的话 它们优先级要设得高一点

1751
02:07:34,670 --> 02:07:36,850
我们说占的时间太多的情况下

1752
02:07:36,850 --> 02:07:39,630
你其实要有一个考虑要把它降下来

1753
02:07:39,630 --> 02:07:41,050
而这个等的时间太长的情况下

1754
02:07:41,050 --> 02:07:42,290
要把它升上去

1755
02:07:42,290 --> 02:07:44,890
要有这么一个考虑才是一个合理的考虑

1756
02:07:46,730 --> 02:07:49,690
这是我们说这个MultiQ的多机对联里面

1757
02:07:49,690 --> 02:07:53,170
它现在目前这个固定优先级带来一个

1758
02:07:53,170 --> 02:07:54,930
潜在的一个还不太理想的地方

1759
02:07:57,730 --> 02:08:02,530
至于这个CNP和轮转这一块其实和前面定义是一样的

1760
02:08:02,530 --> 02:08:08,170
对于交互进程而言,它这个对列可以实现的很准,这没问题,只是在里面

1761
02:08:08,170 --> 02:08:13,090
分辨比例,比如说你在里面多分辨点,少分辨点也OK,也能OK,但是总体

1762
02:08:13,090 --> 02:08:20,770
来说我们觉得这个后台进程,如果常天大暴执行也是一个问题,这是我们需要去想想

1763
02:08:20,770 --> 02:08:29,830
办法去解决的,所以在62年的时候,这也是历史,62年的时候MIT的一个教授叫

1764
02:08:29,830 --> 02:08:30,410
Kobako,

1765
02:08:30,410 --> 02:08:33,790
他提出了一个多级反馈队列

1766
02:08:33,790 --> 02:08:35,010
这个人很厉害

1767
02:08:35,010 --> 02:08:39,610
他也是matics OS一个主要的负责人

1768
02:08:39,610 --> 02:08:42,050
他也获得了图灵奖

1769
02:08:42,050 --> 02:08:44,050
他提出了多级反馈队列

1770
02:08:44,050 --> 02:08:48,250
就想解决同时解决我们前面提到的一系列的问题

1771
02:08:48,250 --> 02:08:50,250
就是前面说什么饥饿问题

1772
02:08:50,650 --> 02:08:51,690
不能及时响应

1773
02:08:51,690 --> 02:08:52,830
挣脱量不高的问题

1774
02:08:52,830 --> 02:08:54,230
把这个问题合在一起

1775
02:08:54,230 --> 02:08:56,150
因为所谓的多级反馈队列

1776
02:08:56,150 --> 02:08:56,650
重点是什么

1777
02:08:56,650 --> 02:08:58,150
重点是反馈

1778
02:08:58,150 --> 02:08:59,750
他如果根据情况动态调整

1779
02:09:01,530 --> 02:09:04,730
这个进程的优先级会动态调整这个情况

1780
02:09:04,730 --> 02:09:07,030
是基于它的某种运行状态

1781
02:09:07,030 --> 02:09:08,790
来得到反馈之后来调整优先级

1782
02:09:08,790 --> 02:09:09,970
可能降可能升

1783
02:09:09,970 --> 02:09:11,490
这是它最大的特点

1784
02:09:11,490 --> 02:09:14,570
可以应用于所谓的这个P处理

1785
02:09:14,570 --> 02:09:18,050
或者是江湖式系统的一个综合的一个情况

1786
02:09:18,050 --> 02:09:20,290
就是你这个系统里面既有P处理程序

1787
02:09:20,290 --> 02:09:21,790
适合于FFO的

1788
02:09:21,790 --> 02:09:23,630
或者适合于RunRobin的

1789
02:09:23,630 --> 02:09:25,450
这两个程序我都能够去应对

1790
02:09:25,450 --> 02:09:28,210
它就要想体现这个好处

1791
02:09:28,210 --> 02:09:29,010
两个好处都拿得到

1792
02:09:29,010 --> 02:09:30,770
所以提出了一个所谓的multi-level feedback

1793
02:09:30,770 --> 02:09:35,490
这么一个多对列的一个有反馈的调度算法

1794
02:09:35,490 --> 02:09:37,370
我们看看它怎么做到的

1795
02:09:41,030 --> 02:09:41,870
它的问题是什么呢

1796
02:09:42,550 --> 02:09:44,770
就是前面 我们看这个

1797
02:09:47,070 --> 02:09:50,210
SGF就是short job force

1798
02:09:50,210 --> 02:09:54,110
那个它需要一些先期的一些知识

1799
02:09:54,110 --> 02:09:55,310
或者先期的一些事实

1800
02:09:55,310 --> 02:09:56,750
你要知道那个指引时间

1801
02:09:57,390 --> 02:09:58,790
你就能够做出一个合理的调度

1802
02:09:58,790 --> 02:10:03,690
但是现在,我们现在说这个进程拥有Io的引入,有交互的引入,

1803
02:10:04,230 --> 02:10:13,490
是他曾经是未知的,所以他没法去预知来感知到底这个进程是属于

1804
02:10:13,490 --> 02:10:14,370
响应密集型的呢,

1805
02:10:14,370 --> 02:10:16,950
就是Io密集型的呢,还是一个CPU密集型的呢,他不知道。

1806
02:10:17,510 --> 02:10:22,510
那既然不知道怎么办,还是一样,从历史中学习。

1807
02:10:22,690 --> 02:10:25,530
就是我们通过历史看它之前怎么样,能预估它后来怎么样。

1808
02:10:56,570 --> 02:11:01,630
这里面有一系列的进程奈跑,这有一系列的进程奈跑,这是1N级,比如这是

1809
02:11:01,630 --> 02:11:03,270
1,这是3。

1810
02:11:03,810 --> 02:11:09,430
那么如果1N级1里面有就绪的进程,我们就先让它执行。执行完毕

1811
02:11:09,430 --> 02:11:12,070
之后,再去执行DN级的进程。

1812
02:11:12,270 --> 02:11:16,690
只有这里面没有就绪了,我才执行到DN级。这是它的一个继承的Multi-

1813
02:11:16,690 --> 02:11:17,890
Q的调度原子。

1814
02:11:19,130 --> 02:11:22,890
但是前前后后很重要的点在于这个进程之间不会往下走

1815
02:11:23,950 --> 02:11:27,890
高限制进程不往下走 第二进程不往上走 而它就要解决这个问题

1816
02:11:29,210 --> 02:11:31,990
它怎么来解决 可以看它怎么变化 这个菲律伯怎么变化

1817
02:11:31,990 --> 02:11:38,150
它基本上的原则是当一个进程进入到救星队内的时候

1818
02:11:38,150 --> 02:11:40,710
它会把它放到最高限制 放到最高的地方

1819
02:11:40,710 --> 02:11:46,170
我们说就是这里面的最高的地方就放在这个地方

1820
02:12:48,310 --> 02:12:50,970
CMP大小的随分级级别增加而增加

1821
02:12:50,970 --> 02:12:51,910
因为越到下面来说

1822
02:12:51,910 --> 02:12:52,810
越是有CPU密集型

1823
02:12:52,810 --> 02:12:54,390
我其实不需要那么平衡的调子

1824
02:12:54,390 --> 02:12:55,730
我可以把CMP给拉长

1825
02:12:57,570 --> 02:13:02,170
从RR向FCFS在渐变

1826
02:13:03,490 --> 02:13:06,130
这是我们说这一步的想要达到的目标

1827
02:13:06,130 --> 02:13:07,350
这是它基本的准则

1828
02:13:07,350 --> 02:13:08,490
但这个准则里面

1829
02:13:08,490 --> 02:13:11,910
你还发现它要不然是停留在原地不动

1830
02:13:11,910 --> 02:13:13,010
在这纯定的原地不动

1831
02:13:13,010 --> 02:13:14,510
或者是往下走

1832
02:13:16,190 --> 02:13:19,870
或者是这个DNA级往下走,但好像还缺少一种往上走的过程。

1833
02:13:21,390 --> 02:13:25,270
有没有一个DNA级的进程往上面的DNA级越迁的过程?

1834
02:13:25,910 --> 02:13:27,310
有没有这种可能性?

1835
02:13:29,530 --> 02:13:32,730
其实是应该有的,但是我们现在没有看到。

1836
02:13:34,050 --> 02:13:40,990
我们现在只是按照刚才我们说的这几点来执行。

1837
02:14:40,990 --> 02:14:43,550
请问这个应用程序有什么办法可以选择用到高压面积

1838
02:14:44,150 --> 02:14:46,990
它是CPU应用程序的 但它就不会降

1839
02:14:50,890 --> 02:14:52,890
Yield yes

1840
02:14:53,990 --> 02:14:56,590
我处理器我每次执行到5秒

1841
02:14:56,590 --> 02:14:59,450
1ms是一个CNP

1842
02:14:59,450 --> 02:15:02,990
我每次执行到0.9ms的时候 我就主动放弃一下

1843
02:15:04,090 --> 02:15:05,970
放弃下之后你就留在那了

1844
02:15:05,970 --> 02:15:08,290
你就留在高压面积不变了

1845
02:15:08,290 --> 02:15:11,630
所以我写一个应用程序 我只要写成0.9

1846
02:15:11,630 --> 02:15:13,770
我就压力一下 就放弃一下

1847
02:15:13,770 --> 02:15:16,930
这样的话就使得我可以持续的留在高原集团

1848
02:15:16,930 --> 02:15:19,270
这所谓的恶意程序

1849
02:15:19,270 --> 02:15:21,590
当然也不一定是恶意 反正他就想占用CPU

1850
02:15:21,590 --> 02:15:26,610
这种情况下 我们这个Material Feedback这种Q 这种算法

1851
02:15:27,210 --> 02:15:30,850
他不会意识到 他会就让这个程序跑到高原集团去

1852
02:15:31,390 --> 02:15:33,430
他就会拼命的占用处理去执行

1853
02:15:33,430 --> 02:15:36,970
其实下面的这些程序得到执行的时间非常小

1854
02:15:36,970 --> 02:15:41,470
这是他的一个问题 怎么来解决

1855
02:15:43,610 --> 02:15:45,550
大家有什么解决办法

1856
02:15:46,090 --> 02:15:48,450
我一定要想办法往上提才行

1857
02:15:48,450 --> 02:15:50,540
就是你想你有什么办法往上走

1858
02:15:52,550 --> 02:15:54,870
如果大家都在最底下肯定是有事

1859
02:15:56,570 --> 02:15:59,010
什么时候才能往上走 大家想一想

1860
02:16:00,470 --> 02:16:01,870
下面太多了就往上走

1861
02:16:03,410 --> 02:16:06,190
这个我看看有没有讲 这给了一条

1862
02:16:07,090 --> 02:16:09,550
给了两个准则来避免这种问题

1863
02:16:10,310 --> 02:16:12,610
经过一段时间之后将系统中所有的工作

1864
02:16:12,610 --> 02:16:13,840
重新加到最高人机

1865
02:16:14,670 --> 02:16:15,970
就是重新分配

1866
02:16:16,910 --> 02:16:18,390
这是一个等于重置

1867
02:16:18,390 --> 02:16:19,330
可以这么来理解

1868
02:16:19,810 --> 02:16:20,890
这个一点是不妄

1869
02:16:20,890 --> 02:16:22,370
但确实管用

1870
02:16:23,070 --> 02:16:24,370
还有一个办法是

1871
02:16:25,030 --> 02:16:26,450
一旦一个工作

1872
02:16:26,450 --> 02:16:27,850
就是一个进程用完了

1873
02:16:27,850 --> 02:16:29,210
其他模拟车时间配合

1874
02:16:29,210 --> 02:16:30,490
你虽然一样的了

1875
02:16:30,490 --> 02:16:31,090
你放弃了

1876
02:16:31,090 --> 02:16:33,590
但是你的配合用完了

1877
02:16:33,590 --> 02:16:34,930
时间配合用完了

1878
02:16:34,930 --> 02:16:35,850
我还是要给你降

1879
02:17:05,870 --> 02:17:08,270
其实我们可以记录下来的

1880
02:17:08,270 --> 02:17:10,750
我们超级统可以记录出它的等待时间

1881
02:17:12,150 --> 02:17:13,950
所以这里面都没有考虑

1882
02:17:13,950 --> 02:17:16,970
在等待队列里面的等待时间

1883
02:17:17,510 --> 02:17:19,110
如果把等待队列的等待时间

1884
02:17:19,110 --> 02:17:21,010
作为一个指标的话

1885
02:17:21,010 --> 02:17:23,470
我会根据它的等待时间来调整

1886
02:17:23,470 --> 02:17:26,230
比如它等了2ms

1887
02:17:26,230 --> 02:17:28,010
我就可以认为你只要等2ms

1888
02:17:28,010 --> 02:17:28,850
我就会往上调

1889
02:17:29,550 --> 02:17:31,570
这样给它一个提升的机会

1890
02:17:31,570 --> 02:17:34,410
它就可以再逐步的往高压进去走

1891
02:17:34,410 --> 02:17:38,310
所以在等待队列里面的等待时间越长

1892
02:17:38,310 --> 02:17:43,190
它提升的月签就越高

1893
02:17:43,190 --> 02:17:48,410
但是这种方式使得这种Io密集型的等待时间越长的进程

1894
02:17:48,410 --> 02:17:50,350
越有机会优先执行

1895
02:17:50,350 --> 02:17:52,090
这是一种提升的一种手段

1896
02:17:52,090 --> 02:17:54,970
当然这里面我们并没有这么去细讲

1897
02:17:54,970 --> 02:17:56,890
这都是一些调度的一些策略

1898
02:17:56,890 --> 02:17:58,690
我只是给大家提醒一下

1899
02:17:58,690 --> 02:18:00,750
这种所谓的提升不止一种方式

1900
02:18:00,750 --> 02:18:02,330
你有多种方式可以去提升

1901
02:18:03,230 --> 02:18:05,590
当然也一样 下降 我们讲的一个下降

1902
02:18:05,590 --> 02:18:11,930
也不是只有一种下降的模式 你还有其他不同的模式去下降

1903
02:18:11,930 --> 02:18:17,230
好 最后一个是叫做公平调度

1904
02:18:17,230 --> 02:18:25,630
公平调度算法 它的意思还是有一个用户的概念

1905
02:18:25,630 --> 02:18:29,050
因为我们的不同的 甲铃铛系统里面有多个用户

1906
02:18:29,050 --> 02:18:31,910
每个用户可以拥有不同的进程

1907
02:18:31,910 --> 02:18:34,550
在这种情况下 如果我们以进程为单位

1908
02:18:34,550 --> 02:18:36,730
以进程为单位作为一个评价

1909
02:18:36,730 --> 02:18:38,710
以进程来进行 比如这个进程有多少10片

1910
02:18:38,710 --> 02:18:40,270
那个进程有多少10片的话

1911
02:18:40,270 --> 02:18:44,050
那很明显我这个用户拥有多的进程

1912
02:18:44,050 --> 02:18:45,370
我就占优先了

1913
02:18:46,930 --> 02:18:48,470
我们希望达到的是说

1914
02:18:48,470 --> 02:18:51,330
你这个U1到UN这个用户

1915
02:18:51,330 --> 02:18:52,390
你可以有不同的进程

1916
02:18:52,390 --> 02:18:55,750
但是我给每个用户拥有的资源是一样的

1917
02:18:55,750 --> 02:18:56,550
这个用户只能分

1918
02:18:56,550 --> 02:19:00,130
比如说这里面有N个只能有N分之一的CPU时间

1919
02:19:00,130 --> 02:19:05,130
那达到这一步就要重新设计所谓的对它的实验片的分配

1920
02:19:05,130 --> 02:19:07,510
大家可能会说那是不是把这个里面再除一个

1921
02:19:07,510 --> 02:19:09,790
这边有P一个那么每个进程里面都是

1922
02:19:11,670 --> 02:19:14,690
这里面的每个用户他有P一个进程的NP分之一

1923
02:19:14,690 --> 02:19:16,770
来代表这个进程所拥有的这个实验片

1924
02:19:16,770 --> 02:19:18,510
用的时间配额

1925
02:19:18,510 --> 02:19:19,730
这是一种方法

1926
02:19:20,110 --> 02:19:24,430
但是这种方法还怎么说不够精准

1927
02:19:24,430 --> 02:19:26,570
就是我们其实后面会讲到一个

1928
02:19:26,570 --> 02:19:27,990
零零死的一个掉落上面叫CFS

1929
02:19:29,810 --> 02:19:31,490
它做了一个非常巧妙的设计

1930
02:19:31,490 --> 02:19:34,090
使得大家基于一个同样的一个指标

1931
02:19:34,090 --> 02:19:36,970
来公平的分配所谓的实验片

1932
02:19:36,970 --> 02:19:39,350
但它那个实验片已经不是我们的物理实验片了

1933
02:19:39,350 --> 02:19:41,410
我们这边给到的时间都是一个物理实践

1934
02:19:41,410 --> 02:19:43,730
它为了能够精确的表达这种不同类型

1935
02:19:43,730 --> 02:19:45,870
比如说不同的用户甚至不同的进程组

1936
02:19:45,870 --> 02:19:47,750
用户图这些不同的概念

1937
02:19:47,750 --> 02:19:51,690
它提出了一个所谓的virtual的一个time

1938
02:19:51,690 --> 02:19:56,630
通过博士产来统一规划了大家时间的进度

1939
02:19:56,630 --> 02:20:01,390
从而可以提升它的公平性

1940
02:20:02,050 --> 02:20:03,690
这是一些新的调度算法

1941
02:20:03,690 --> 02:20:06,330
包括你们现在在做实验中用的

1942
02:20:06,870 --> 02:20:09,110
这一次实验应该是这一次了

1943
02:20:09,110 --> 02:20:14,470
Stride 这个所谓的不藏的调度算法

1944
02:20:14,470 --> 02:20:15,430
其实也是一个道理

1945
02:20:15,430 --> 02:20:19,270
它也是达到了某种公平调度的一个考虑

1946
02:20:19,270 --> 02:20:22,550
这个大家在做实验中也可以体验到这个公平性

1947
02:20:22,550 --> 02:20:26,010
大家的公平性做得有多精细

1948
02:20:26,010 --> 02:20:28,730
这个是不一样的 和这个CFS是不太一样

1949
02:20:28,730 --> 02:20:31,850
大家可以体会一下 它们都号称是公平调算法

1950
02:20:31,850 --> 02:20:33,310
这是给大家做个介绍

1951
02:20:35,990 --> 02:20:39,610
好 那我就比较快地给大家

1952
02:20:39,610 --> 02:20:42,990
把这个基本的一些调算法给大家做个介绍

1953
02:20:48,190 --> 02:20:53,730
但是它的实现简单,它的竞争切换的开销小

1954
02:20:53,730 --> 02:20:57,410
它适合于大家都差不多,不太care这种交互性

1955
02:20:57,410 --> 02:20:59,070
不太care这种极致响应

1956
02:20:59,070 --> 02:21:02,570
那么FCFS是有它的适用场景的

1957
02:21:02,570 --> 02:21:05,230
短缀邮件它有一个非常好的一点

1958
02:21:05,230 --> 02:21:06,810
就是平均作坊时间是最小的

1959
02:21:06,810 --> 02:21:08,890
它有一个证明可以证明它是最小的

1960
02:21:08,890 --> 02:21:11,750
但是它的缺陷是它需要精确预测时间

1961
02:21:11,750 --> 02:21:12,970
不允许小账犯导致饥饿

1962
02:21:42,970 --> 02:21:45,410
我们要有一个实验品轮转 大家轮流使用处理器

1963
02:21:45,410 --> 02:21:47,650
这所谓的实验品轮转算法

1964
02:21:47,650 --> 02:21:50,730
但它平均等待时间就比较弱一些

1965
02:21:50,730 --> 02:21:53,730
而且它对Io的这种操作

1966
02:21:54,270 --> 02:21:57,290
Io的密集型的这种处理器考虑不周

1967
02:21:57,290 --> 02:21:58,830
或者是不灵活

1968
02:21:58,830 --> 02:22:00,410
所以我们还有一个多级返回对链

1969
02:22:00,410 --> 02:22:04,950
能够同时考虑throughput和这所谓的低延迟

1970
02:22:04,950 --> 02:22:06,710
这是多级返回对链的一个设计

1971
02:22:06,710 --> 02:22:08,570
那么它重点强调的是说

1972
02:22:09,430 --> 02:22:12,130
一个进程它的优先级

1973
02:22:12,130 --> 02:22:15,410
再随着它的自行对它动态的运行的特征

1974
02:22:15,410 --> 02:22:16,950
来动态的调整它的邮件集

1975
02:22:16,950 --> 02:22:19,790
从而可以使得这种所谓IO密集的任务

1976
02:22:19,790 --> 02:22:22,770
可以更有效的 更有机会先执行

1977
02:22:22,770 --> 02:22:25,710
而这种所谓CPU密集的任务 不需要交互的

1978
02:22:25,710 --> 02:22:29,210
在下面 开始交互的 在下面可以去执行

1979
02:22:29,210 --> 02:22:32,030
这样就做了一个动态的调整

1980
02:22:32,030 --> 02:22:34,810
这是多级反过对列

1981
02:22:34,810 --> 02:22:38,890
在里面的 具体的某一个邮件集里面的对列

1982
02:22:38,890 --> 02:22:40,250
比如在这里面的对列

1983
02:22:40,250 --> 02:22:43,350
那基本上可以一般选择的是RR来进行执行

1984
02:22:43,350 --> 02:22:45,490
所以它可以称之为一种多种算法的集成

1985
02:22:45,490 --> 02:22:47,630
因为它也集成了这个RR算法在它里头

1986
02:22:49,150 --> 02:22:51,430
然后最后一个讲的是公平调度算法

1987
02:22:51,430 --> 02:22:55,490
那就意味着我们会有不同的这种公平的指标和公平的对象

1988
02:22:55,490 --> 02:22:57,130
对于这种不同的公平指标和公平对象

1989
02:22:57,130 --> 02:23:00,230
你单单的基于进程来进行调布是不够的

1990
02:23:00,230 --> 02:23:02,330
你需要基于这个对象本身的特征

1991
02:23:02,330 --> 02:23:06,610
比如用户来进行一个选择或者是一个进程组

1992
02:23:06,610 --> 02:23:08,950
来进行公平的一个制定

1993
02:23:08,950 --> 02:23:12,250
还是合理的,那所谓公平的就是要考虑的

1994
02:23:12,250 --> 02:23:19,710
当然这些算法其实只是一小部分

1995
02:23:19,710 --> 02:23:23,250
我们现在真实的超级统计调的算法比这些要复杂不少

1996
02:23:23,250 --> 02:23:31,410
第二,它的一些评价指标也是不仅仅局限于CPU的一个使用率

1997
02:23:31,410 --> 02:23:33,070
或者吞头量或者低延迟

1998
02:23:33,070 --> 02:23:34,770
还有更多的一些因素

1999
02:23:34,770 --> 02:23:37,750
前面我已经举到例子,比如power、能耗

2000
02:23:38,510 --> 02:23:40,350
说冷话 大家还能举个什么例子

2001
02:23:41,350 --> 02:23:42,750
新的一些需求

2002
02:23:44,070 --> 02:23:45,150
能想到吗

2003
02:23:46,490 --> 02:23:49,370
还有很多的需求

2004
02:23:51,730 --> 02:23:53,930
就是我的理解

2005
02:23:53,930 --> 02:23:55,770
像现在的调度算法

2006
02:23:55,770 --> 02:23:57,490
他要考虑易构型

2007
02:23:57,490 --> 02:23:59,290
我再稍微扩展一点

2008
02:23:59,290 --> 02:24:00,210
什么意思

2009
02:24:00,210 --> 02:24:04,330
CPU加GPU或者加TPU

2010
02:24:04,330 --> 02:24:06,390
那么你这个应用程序

2011
02:24:06,390 --> 02:24:08,550
其实有不同的不同的特点

2012
02:24:08,550 --> 02:24:10,110
你那时候应该放在CPU上执行

2013
02:24:10,110 --> 02:24:11,450
你那时候应该放在GPU上执行

2014
02:24:11,450 --> 02:24:12,910
放在GPU上执行

2015
02:24:12,910 --> 02:24:14,150
你需要有一种选择

2016
02:24:15,670 --> 02:24:17,150
这个也是一种调度

2017
02:24:18,370 --> 02:24:18,730
OK

2018
02:24:18,730 --> 02:24:20,930
那么把它扩展出来是单机调度

2019
02:24:20,930 --> 02:24:22,890
那你如果到多机系统

2020
02:24:22,890 --> 02:24:23,970
怎么去调度

2021
02:24:23,970 --> 02:24:25,730
还有我们后面讲的这个多数系统调度

2022
02:24:25,730 --> 02:24:27,710
那都是需要去进一步去考虑的问题

2023
02:24:29,610 --> 02:24:30,330
OK 好

2024
02:24:30,330 --> 02:24:34,310
那这个调度算法就给大家简单介绍完毕

2025
02:24:34,970 --> 02:24:35,910
有问题吗

2026
02:24:46,530 --> 02:24:53,650
实时调度是对于单机处理器的一个特殊的一个领域做的一个介绍

2027
02:24:53,650 --> 02:24:56,210
前面讲的都是针对的是我们的通用系统

2028
02:24:56,210 --> 02:24:58,050
比如服务器 桌面系统

2029
02:24:58,050 --> 02:25:01,330
那这个实时调度呢 针对更多的是这种嵌入式系统

2030
02:25:01,330 --> 02:25:04,130
它应用领域也非常广泛

2031
02:25:04,130 --> 02:25:06,370
比我们飞机 导弹 飞机 机器 机器 机器

2032
02:25:07,290 --> 02:25:11,350
航天器还有什么水电站等等

2033
02:25:11,350 --> 02:25:13,670
这都是一些实时系统

2034
02:25:14,130 --> 02:25:19,550
实时系统它用到的超级统叫我们称之为实时超级统

2035
02:25:19,950 --> 02:25:23,350
实时超级统它有很重要的指标是deadline

2036
02:25:23,350 --> 02:25:24,930
你看这个指标就已经变了

2037
02:25:24,930 --> 02:25:26,510
我们先说有新的指标

2038
02:25:26,510 --> 02:25:29,410
这个deadline就是说你一定要保证任务或者进程

2039
02:25:29,410 --> 02:25:31,210
它一定要在这个deadline之前完成

2040
02:25:31,650 --> 02:25:32,830
就像教作业一样

2041
02:26:02,830 --> 02:26:04,970
你都在一秒内就完成了

2042
02:26:04,970 --> 02:26:06,830
你的deadline是10秒

2043
02:26:07,450 --> 02:26:09,050
你90%时间是一秒就完成

2044
02:26:09,050 --> 02:26:11,870
但是有1%的时间你花了20秒才完成

2045
02:26:11,870 --> 02:26:14,490
所以你的最快执行时间是20秒

2046
02:26:14,490 --> 02:26:15,370
20秒的话

2047
02:26:15,370 --> 02:26:17,650
那你这个实际性就不够好

2048
02:26:17,650 --> 02:26:18,730
如果这么来评价它

2049
02:26:18,730 --> 02:26:20,510
你这个软件写了就不行

2050
02:26:20,910 --> 02:26:21,970
当然不仅是软件问题

2051
02:26:21,970 --> 02:26:23,970
还涉及到超级总调度问题

2052
02:26:24,830 --> 02:26:25,910
它的特点就是什么

2053
02:26:25,910 --> 02:26:27,470
时间约束的可预则性

2054
02:26:27,470 --> 02:26:30,930
一个进程什么时候必须要完成

2055
02:26:31,510 --> 02:26:33,510
或者一个阶段性的任务必须要在什么阶段完成

2056
02:26:33,510 --> 02:26:34,670
它有一个约束

2057
02:26:34,670 --> 02:26:38,590
这是实时系统里面重点要考虑的问题

2058
02:26:39,410 --> 02:26:40,870
对于实时系统而言

2059
02:26:40,870 --> 02:26:41,770
它有两类

2060
02:26:41,770 --> 02:26:42,790
一类叫软实时

2061
02:26:42,790 --> 02:26:43,970
一类叫硬实时

2062
02:26:43,970 --> 02:26:45,810
软实时是大家可能见得到的

2063
02:26:45,810 --> 02:26:48,430
比如说你们在看电影的时候

2064
02:26:49,290 --> 02:26:50,750
在电脑上看电影的时候

2065
02:26:50,750 --> 02:26:52,450
它可能有时候有些跳针

2066
02:26:53,250 --> 02:26:54,790
不影响 体验不太好

2067
02:26:54,790 --> 02:26:56,070
但是一会就没了

2068
02:26:56,070 --> 02:26:57,030
这就属于软实时

2069
02:26:57,030 --> 02:26:59,990
就是你产生偶尔的没有及时的

