1
00:00:00,380 --> 00:00:02,600
因为看到这一点 包括我们的进程管理

2
00:00:02,600 --> 00:00:03,740
就是一个典型的例子

3
00:00:03,740 --> 00:00:05,120
我们上一堂课讲进程管理的时候

4
00:00:05,120 --> 00:00:06,960
重点讲到的是这些功能

5
00:00:06,960 --> 00:00:09,800
比如进程切换 进程创建复制

6
00:00:09,800 --> 00:00:11,480
加载执行 等待退出

7
00:00:11,480 --> 00:00:14,460
这些功能 按道理来说

8
00:00:14,460 --> 00:00:16,240
前面的OS我们能做到

9
00:00:16,240 --> 00:00:18,060
但我们前面没有讲是在于

10
00:00:18,060 --> 00:00:21,040
我们的应用并没有那么强的需求

11
00:00:21,040 --> 00:00:22,580
需要这种能力

12
00:00:22,580 --> 00:00:24,180
而这些能力是给了我们应用

13
00:00:24,180 --> 00:00:26,540
去直接去控制我们的超级统

14
00:00:26,540 --> 00:00:30,100
让我们参与我们来帮助应用去创建新的应用

15
00:00:30,100 --> 00:00:32,860
去和应用之间进行建立某种

16
00:00:32,860 --> 00:00:35,260
比较到目前为止还是比较简单的一种构成

17
00:00:35,260 --> 00:00:37,340
他们之间需要去比如说

18
00:00:37,340 --> 00:00:38,700
附近人要等待指令层

19
00:00:38,700 --> 00:00:42,220
这种关系的建立是提供出来之后

20
00:00:42,220 --> 00:00:45,580
给我们的应用有更大的灵活性

21
00:00:45,580 --> 00:00:48,020
在这个角度来体现的

22
00:00:48,020 --> 00:00:50,580
所以这里面就引入了所谓的进程

23
00:00:50,580 --> 00:00:54,360
这个进程更多的是体现出应用对OS的一种期望

24
00:00:55,200 --> 00:00:56,380
这是一个角度

25
00:00:56,940 --> 00:00:57,860
第二个角度

26
00:00:58,680 --> 00:01:01,000
我们上一课还讲到调路算法

27
00:01:01,000 --> 00:01:02,620
调路算法本身来说

28
00:01:02,620 --> 00:01:04,240
它也是希望能够两点

29
00:01:04,240 --> 00:01:06,100
就是要满足我们应用的一些需求

30
00:01:06,100 --> 00:01:08,900
比如说它的响应时间要尽量的短

31
00:01:08,900 --> 00:01:10,900
然后等待时间要尽量的少

32
00:01:10,900 --> 00:01:12,220
存储量要尽量的大

33
00:01:12,220 --> 00:01:13,860
这是一些不同的指标

34
00:01:13,860 --> 00:01:19,440
而这个指标其实有适合不同的算法

35
00:01:19,440 --> 00:01:22,080
包括我们讲的对于先来先扶这种算法

36
00:01:22,080 --> 00:01:24,140
其实在某些场景上它还是很好

37
00:01:24,720 --> 00:01:26,340
这场景是比较特定而已

38
00:01:26,340 --> 00:01:27,960
但如果你的场景足够灵活

39
00:01:27,960 --> 00:01:30,780
你会发现我们前面讲的先来先服务

40
00:01:30,780 --> 00:01:34,140
短缀优先 最短剩余时间等等

41
00:01:34,140 --> 00:01:36,440
这些算法相对而言

42
00:01:36,440 --> 00:01:38,060
它很难在高效

43
00:01:38,060 --> 00:01:42,220
我们高效指的是尊普量 低延迟

44
00:01:42,220 --> 00:01:43,500
还有一个公平性

45
00:01:43,500 --> 00:01:45,600
这三方面能达到一个折衷

46
00:01:45,600 --> 00:01:49,660
这种折衷我们在这里面提前了两个方面比较好

47
00:01:49,660 --> 00:01:51,760
一个是桌际反馈对立

48
00:01:51,760 --> 00:01:53,580
一个是公平共享调度

49
00:02:23,580 --> 00:02:28,040
那是一个典型的一个非常精简的一个公平带路算法

50
00:02:28,040 --> 00:02:29,120
你通过做这个算法

51
00:02:29,120 --> 00:02:31,480
你会对这种公平性有一个更深刻的体统

52
00:02:31,480 --> 00:02:36,280
这个是我们说在

53
00:02:36,280 --> 00:02:39,380
应该说是在基本概念和基本原理层面

54
00:02:39,380 --> 00:02:41,820
给大家做了一个介绍

55
00:02:44,100 --> 00:02:50,220
这是对上堂课的一个简单的回顾

56
00:02:50,220 --> 00:02:52,240
再接下来我们这堂课讲的

57
00:02:52,240 --> 00:02:53,220
上上可以开了个头

58
00:02:53,220 --> 00:02:55,480
就是实质管理和调度

59
00:02:58,460 --> 00:03:00,020
这个更多的是说

60
00:03:00,020 --> 00:03:04,900
针对一种在现有场景里面

61
00:03:04,900 --> 00:03:05,960
不是和人打交道

62
00:03:05,960 --> 00:03:08,280
而是和这种设备打交道

63
00:03:08,280 --> 00:03:09,980
和一些工业设备

64
00:03:09,980 --> 00:03:11,540
工业机器自己打交道的时候

65
00:03:11,540 --> 00:03:13,420
它用到的一些新的一些feature

66
00:03:13,420 --> 00:03:14,600
这所谓的一个实时操作

67
00:03:15,340 --> 00:03:16,980
它的一个应用的背景

68
00:03:16,980 --> 00:03:18,080
这次背景里面

69
00:03:18,080 --> 00:03:20,340
它的一个很重要的一个调度的指标

70
00:03:20,340 --> 00:03:22,220
和我们前面讲的指标已经不一样了

71
00:03:22,240 --> 00:03:25,820
它不是说快,而是说确定,它强调的是确定性

72
00:03:25,820 --> 00:03:30,100
这种确定性就是对你们体现了一个指标叫做时间约束的及时性

73
00:03:30,100 --> 00:03:33,580
这个deadline,就是你一定要在deadline之前完成这个工作

74
00:03:33,580 --> 00:03:37,100
至于你是强点完成的还是提前了很长时间完成的

75
00:03:37,100 --> 00:03:39,800
这个它并不做出一个优先的判断

76
00:03:39,800 --> 00:03:42,680
它只要保证在deadline之前完成

77
00:03:42,680 --> 00:03:45,100
那么大家都是一样的一个效果,都认为是不错的

78
00:03:45,100 --> 00:03:50,300
你如果完不成,那就会有所谓的一个后果

79
00:03:50,300 --> 00:03:51,700
这后果就涉及到两点

80
00:03:51,700 --> 00:03:55,940
一个叫做弱时时或者软时时

81
00:03:55,940 --> 00:03:58,680
这个就意味着你完不成没关系

82
00:03:58,680 --> 00:04:01,000
就我们受到一定的干扰或者影响体验不好

83
00:04:01,000 --> 00:04:03,660
或者说是有些任务没完成

84
00:04:03,660 --> 00:04:04,680
效果不好

85
00:04:04,680 --> 00:04:05,700
但只是不好

86
00:04:05,700 --> 00:04:08,220
但是还有一类属于强时时候的硬时时的话

87
00:04:08,220 --> 00:04:09,000
那就不是不好

88
00:04:09,000 --> 00:04:10,860
而是说是灾难

89
00:04:10,860 --> 00:04:12,760
灾难性的后果

90
00:04:12,760 --> 00:04:18,780
这种情况就使得我们需要在考虑

91
00:04:18,780 --> 00:04:20,780
在设计OS的时候你要怎么去设计

92
00:04:20,780 --> 00:04:23,380
比如说我问大家

93
00:04:23,380 --> 00:04:24,700
我们现在都用到的

94
00:04:24,700 --> 00:04:28,560
我们现在手都用到的是Windows

95
00:04:28,560 --> 00:04:29,740
或者是Linux

96
00:04:29,740 --> 00:04:32,540
或者是你们的手机里面跑的安卓或者iOS

97
00:04:32,540 --> 00:04:36,140
你们觉得它应该是属于这里面的哪一类超级的

98
00:04:40,660 --> 00:04:42,020
强实水

99
00:04:43,980 --> 00:04:45,240
这个每个都没有安存

100
00:04:45,240 --> 00:04:46,660
你会把这机器砸了吗

101
00:04:46,660 --> 00:04:47,260
不会吧

102
00:05:17,620 --> 00:05:22,060
你要区别我刚才讲的灾难的一个体会

103
00:05:22,060 --> 00:05:27,740
这种典型的例子一般不是我们和人直接导致人机交互式的例子

104
00:05:27,740 --> 00:05:32,020
更多的是在有什么水电站核电站什么导弹飞机

105
00:05:32,020 --> 00:05:35,240
这些场景里面会需要这种强实时硬实时

106
00:05:35,240 --> 00:05:36,980
包括你们现在也会接触到了

107
00:05:36,980 --> 00:05:38,980
将来再过几年你们会发现你们的车

108
00:05:38,980 --> 00:05:40,200
你们将来长大了

109
00:05:40,200 --> 00:05:41,080
你们会买车

110
00:05:41,080 --> 00:05:45,620
那个车底下的实时系统也是强实时的一个系统

111
00:05:45,620 --> 00:05:48,500
它控制了车的刹车等等

112
00:05:48,500 --> 00:05:50,060
以前是靠机械电子设备

113
00:05:50,060 --> 00:05:51,400
现在要靠软件

114
00:05:51,400 --> 00:05:52,300
一旦是软件的话

115
00:05:52,300 --> 00:05:54,060
你就会失效这种

116
00:05:54,060 --> 00:05:55,340
我们讲的这些知识

117
00:05:56,000 --> 00:05:57,360
所以你要去理解一下

118
00:05:57,360 --> 00:05:59,500
我们这样子给大家做一个介绍

119
00:06:01,520 --> 00:06:06,500
对于在这里面执行的应用软件而言

120
00:06:06,500 --> 00:06:08,540
其实我们也可以用进程来表示

121
00:06:08,540 --> 00:06:10,100
刚才进程它有一个特点

122
00:06:10,100 --> 00:06:13,000
它是一个相当于是周期性的一个进程

123
00:06:13,000 --> 00:06:14,240
什么叫周期性呢

124
00:06:14,800 --> 00:06:17,440
它的还有一系列的周期性的任务来组成

125
00:06:17,980 --> 00:06:22,740
就是你看这里面就是我的任务每隔十秒钟产生一次

126
00:06:22,740 --> 00:06:23,640
要完成一个任务

127
00:06:23,640 --> 00:06:25,980
完成一个时间的统计和完成一个控制

128
00:06:25,980 --> 00:06:28,060
那这个周期就是一个什么

129
00:06:28,060 --> 00:06:31,160
这里面就是这里面从这儿到这儿一个

130
00:06:31,160 --> 00:06:32,520
这个叫一个周期

131
00:06:32,520 --> 00:06:33,120
我看看

132
00:06:35,560 --> 00:06:36,800
这是一个周期

133
00:06:36,800 --> 00:06:38,900
在周期里面它有一个指引时间

134
00:06:38,900 --> 00:06:40,780
只要你在这个周期里面完成

135
00:06:40,780 --> 00:06:41,600
那都是OK的

136
00:06:41,600 --> 00:06:43,440
就是在Line之前完成 这是OK的

137
00:06:43,440 --> 00:06:45,240
所以这里面看到两个重要的指标

138
00:06:45,240 --> 00:06:46,880
一个叫做周期 一个叫做指引时间

139
00:06:49,220 --> 00:06:52,760
我们定义了一个周期 一个指引时间

140
00:06:55,000 --> 00:06:57,660
还有一个第三个指标 叫做使用率

141
00:06:57,660 --> 00:06:58,980
使用率就是1除以P

142
00:06:58,980 --> 00:07:01,880
就是我们说指引时间除以周期

143
00:07:01,880 --> 00:07:04,240
但这个使用率更多的是针对我们计算机系统而已

144
00:07:04,240 --> 00:07:05,860
系统的一个使用率怎么样

145
00:07:05,860 --> 00:07:06,840
CPU的使用率怎么样

146
00:07:08,100 --> 00:07:09,180
如果使用率高

147
00:07:09,180 --> 00:07:11,040
在满足这个deadline

148
00:07:11,040 --> 00:07:12,440
就是说实质性的前提下

149
00:07:12,440 --> 00:07:15,540
你使用率越高 耐用率越好 职业利用率更充分

150
00:07:15,540 --> 00:07:19,040
但是首先我们要确保的是 你要能满足 满足实际性

151
00:07:19,040 --> 00:07:23,080
所以一定要说 就是你这个执行时间不能越过这个周期

152
00:07:23,660 --> 00:07:26,020
比如说你这儿 我在这儿执行

153
00:07:26,020 --> 00:07:28,520
我其实也是执行了这么一个时间单位

154
00:07:28,520 --> 00:07:30,440
但是我说这儿才开始执行

155
00:07:30,440 --> 00:07:32,000
那你就越过了它的一个data line

156
00:07:32,000 --> 00:07:33,400
比如它这个5是一个它的data line

157
00:07:33,400 --> 00:07:34,500
一个周期了吧

158
00:07:34,500 --> 00:07:35,540
所以这就不行

159
00:07:35,540 --> 00:07:38,320
你要确保的是 我们一定要在这个周期之前

160
00:07:38,320 --> 00:07:41,640
完成属于这个周期的任务

161
00:07:41,640 --> 00:07:46,060
在这个里面,你在这儿都算完成,但这儿就不行了,这儿都OK

162
00:07:46,500 --> 00:07:52,040
这是我们说的对周期执行时间使用率的一个解释

163
00:07:52,040 --> 00:07:55,500
第二个解释就是我们今天讲的调度算法

164
00:07:55,500 --> 00:08:00,680
调度什么叫实时可调度,可这个含义很重要的

165
00:08:01,340 --> 00:08:03,520
我们设计的调度算法有可能不可调度

166
00:08:03,940 --> 00:08:07,940
就是你没法满足需求,就没法完成所谓的

167
00:08:07,940 --> 00:08:10,120
一定要在在line之前完成这么一个需求

168
00:08:10,120 --> 00:08:17,040
如果是可调的,理论上来说,你只要所有的任务,所有的任务没有把它这个周

169
00:08:17,040 --> 00:08:21,580
期里面,在一个周期里面所有任务没有把它占满,那都是可调的。

170
00:08:21,780 --> 00:08:29,040
比如说你在一种极端情况下,我确实有六个任务,每个任务都要占一个

171
00:08:29,040 --> 00:08:32,120
实验单位,但这个周期是五个周期。

172
00:09:02,120 --> 00:09:06,540
就一切的进程 它能否在这个实施系统里面

173
00:09:06,540 --> 00:09:09,240
它的实施进程和实施任务 它能否调度

174
00:09:09,240 --> 00:09:10,440
这取决于多个因素

175
00:09:10,440 --> 00:09:13,780
取决于你任务的数量 你的周期的设置

176
00:09:13,780 --> 00:09:15,780
你的调度算法 这几个合在一起

177
00:09:15,780 --> 00:09:17,840
决定了 你是否可调度

178
00:09:17,840 --> 00:09:20,880
不能单纯的认为只是一个调度算法的问题

179
00:09:25,740 --> 00:09:29,700
OK 既然有前面讲的对硬实施 软实施的前面

180
00:09:29,700 --> 00:09:32,320
就一个相对在里面硬实现

181
00:09:32,320 --> 00:09:34,540
你们最终要去求解的

182
00:09:34,540 --> 00:09:37,740
就是一个hard deadline和soft deadline

183
00:09:38,620 --> 00:09:41,740
我们这里面讲的没有去考虑后果

184
00:09:41,740 --> 00:09:44,500
我们只讲这个算法它能不能满足实质性

185
00:09:44,500 --> 00:09:45,780
这是我们要讲的这一点

186
00:09:47,220 --> 00:09:48,500
那讲到算法

187
00:09:48,500 --> 00:09:51,300
我们一般来说把这个大的都分类成两类

188
00:09:51,300 --> 00:09:52,380
一类是静态

189
00:09:52,980 --> 00:09:54,400
静态有限级调度

190
00:09:54,840 --> 00:09:57,160
就是这次一类算法

191
00:09:57,160 --> 00:09:57,740
静态

192
00:09:57,740 --> 00:09:58,960
第二个强调动态

193
00:09:58,960 --> 00:10:04,060
进胎动态有什么区别?进胎动态就是说,我在这个任务执行之前,它的调度优

194
00:10:04,060 --> 00:10:07,620
先级已经确定了,我订好了,运行之前我就订好了这个任务的优先级,而且这个优

195
00:10:07,620 --> 00:10:12,300
先级在执行过程中不会改变,这是进胎的调度。

196
00:10:13,160 --> 00:10:18,260
动态的调度是在指引过程中它的优先机会改变,这是动态的调度。

197
00:10:19,420 --> 00:10:20,780
这是两类不同的调度上法。

198
00:10:21,340 --> 00:10:25,460
虽然它是用在实质系统里面的,但这两个分类其实我们也可以用在哪?

199
00:10:25,500 --> 00:10:31,560
我们前面讲的一般的general OS,general powers OS,通用超级统里面,也可以这么来

200
00:10:31,560 --> 00:10:31,600
说。

201
00:10:31,980 --> 00:10:37,600
那我举个简单的问题,我们前面讲的先来先服务调度上法,你觉得是

202
00:10:37,600 --> 00:10:38,300
近代还是动态?

203
00:10:50,000 --> 00:11:00,940
所以它是一个静态的。但是我们后面讲到的,比如说Ron Robbins这种动态,因为随

204
00:11:00,940 --> 00:11:03,680
着它的执行,它会调整它的顺序。

205
00:11:03,960 --> 00:11:08,280
这就是静态动态的一个理解,或者说它是一个静态动态。

206
00:11:08,280 --> 00:11:11,220
我们的多级反馈队列

207
00:11:11,220 --> 00:11:13,240
那也是一个动态的调度

208
00:11:14,580 --> 00:11:16,200
ok 这个概念理解之后

209
00:11:18,580 --> 00:11:21,880
那么至于这个实时调度算法其实有很多

210
00:11:21,880 --> 00:11:23,880
我们这里面只提三种

211
00:11:24,280 --> 00:11:26,580
我们现在先给两种一个定义

212
00:11:26,580 --> 00:11:29,200
典型的代表就是进态的

213
00:11:29,200 --> 00:11:33,280
进态的就是这给的一个算法叫做

