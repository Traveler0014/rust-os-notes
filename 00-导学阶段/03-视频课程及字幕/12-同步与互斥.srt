1
00:02:04,480 --> 00:02:15,420
好,我们开始上课。今天已经到了我们的第15周的课,所以过得很快,一下16周马上

2
00:02:15,420 --> 00:02:15,980
就到了。

3
00:02:18,340 --> 00:02:26,560
那其实也到了我们的,我应该说超级统课的很重要的一部分内容,就关于

4
00:02:26,560 --> 00:02:30,760
这个线程以及对应的同步物次的一些内容。

5
00:02:30,860 --> 00:02:36,040
那今天这堂课我们会把线程讲完,同时开启我们的同步物次这部分内

6
00:02:36,040 --> 00:02:37,260
容的一个讲解。

7
00:02:38,380 --> 00:02:41,640
首先我们简单回顾一下上次课的内容

8
00:02:41,640 --> 00:02:46,300
上次课我们重点讲的是跟这一块相关的就是线程这一块

9
00:02:46,300 --> 00:02:48,080
我们讲线程为什么要有线程

10
00:02:48,080 --> 00:02:51,500
也提到了线程是可以更方便的进行共享

11
00:02:51,500 --> 00:02:53,740
虽然共享我们还没有讲到怎么去共享

12
00:02:53,740 --> 00:02:56,460
那是我们在后面那个同步护士会议讲到的

13
00:02:56,460 --> 00:02:59,200
怎么去正确高效的共享

14
00:02:59,200 --> 00:03:01,720
第二个就是它更轻量级

15
00:03:02,400 --> 00:03:04,360
相对于进程而言

16
00:03:04,360 --> 00:03:08,500
它在切换创建管理方面

17
00:03:08,500 --> 00:03:14,440
它都会比我们说的进程要轻量很多

18
00:03:14,440 --> 00:03:17,420
而且我们在这里面讲现成的实现的时候

19
00:03:17,420 --> 00:03:19,100
讲了好几种模式

20
00:03:19,100 --> 00:03:21,600
有这种纯用户态的

21
00:03:21,600 --> 00:03:25,720
还有内核态管理用户态运行的等等

22
00:03:25,720 --> 00:03:30,000
这几种模式也是希望大家能够去理解

23
00:03:30,000 --> 00:03:34,860
特别在我们后面还今天这堂课里面会讲这个现成的实现里面

24
00:03:34,860 --> 00:03:36,000
还会就这些问题呢

25
00:03:36,000 --> 00:03:38,100
再做进一步的深入的一个讲解

26
00:03:38,100 --> 00:03:41,000
这是我们上堂课的主要的内容

27
00:03:42,080 --> 00:03:44,120
那上堂课后面部分呢

28
00:03:44,120 --> 00:03:46,200
也开了个头讲这个斜程

29
00:03:46,200 --> 00:03:48,440
斜程一样道理就是斜程

30
00:03:48,440 --> 00:03:49,520
为什么要有斜程

31
00:03:49,520 --> 00:03:55,200
那是由于看到了现成的一些或者是函数的一些潜在的一些不足

32
00:03:55,200 --> 00:03:57,760
做了一个更加灵活的一个设计

33
00:03:57,760 --> 00:04:01,220
它主要是针对这种所谓的这种Io密集型的一种操作场景

34
00:04:01,220 --> 00:04:01,980
里面

35
00:04:01,980 --> 00:04:04,020
设计出一个所谓的邪神的概念

36
00:04:04,020 --> 00:04:06,800
那这邪神再简单回顾一下

37
00:04:06,800 --> 00:04:09,380
邪神是什么呢 邪神是一种程序的组件

38
00:04:09,380 --> 00:04:13,820
从这点来说 它和我们的编程语言有比较大的紧密联系

39
00:04:13,820 --> 00:04:17,440
那它是一种对我们传统意义上的函数的一种放话

40
00:04:17,440 --> 00:04:19,940
我们传统意义上函数只有一个入口点

41
00:04:19,940 --> 00:04:21,940
邪神只返回一次

42
00:04:21,940 --> 00:04:24,500
就执行完毕之后 那你下次再重新调语

43
00:04:24,500 --> 00:04:26,760
这是这所谓的函数 但邪神不一样

44
00:04:26,760 --> 00:04:30,940
协程是有一个入口点 但是协程有不叫一个入口点

45
00:04:30,940 --> 00:04:31,980
应该有多个入口点

46
00:04:31,980 --> 00:04:34,800
因为它这个 你看这里面简单的说协程里面

47
00:04:34,800 --> 00:04:38,160
它可以从这儿出去之后 从这个地方再进来

48
00:04:38,160 --> 00:04:42,480
所以它的入口点是多个 它的出口点也是多个

49
00:04:42,480 --> 00:04:47,460
这一点来说就是协程和函数是有不同的

50
00:04:48,520 --> 00:04:50,840
而为了能实现有效的这种管理

51
00:04:50,840 --> 00:04:54,240
我们希望这个协程 离开这一点是主动离开

52
00:04:54,240 --> 00:05:00,200
所谓主动就是说我们编程我们开发开发者主动的放弃这个函数的执

53
00:05:00,200 --> 00:05:00,800
行

54
00:05:00,800 --> 00:05:05,220
那这和我们之前讲的这个叫做主动的调度是一个道理

55
00:05:05,220 --> 00:05:08,100
它不是一种被动的被抢占式的那种调度

56
00:05:08,100 --> 00:05:10,740
而是一种协作式的那种调度

57
00:05:10,740 --> 00:05:12,320
那这其实也是一个idea

58
00:05:12,320 --> 00:05:14,320
只是它调度的力度更小而已

59
00:05:14,320 --> 00:05:19,580
就针对我们之前很早以前讲P处理之后讲的那个多道程序设计

60
00:05:20,280 --> 00:05:21,960
以及分析复用的时候呢

61
00:05:21,960 --> 00:05:23,720
也会提到这种所谓怎么去调度的问题

62
00:05:24,140 --> 00:05:28,440
本身来说这也是一种调度,只是它的力度是在函数这个来往来进行调

63
00:05:28,440 --> 00:05:28,720
度。

64
00:05:30,260 --> 00:05:37,680
OK,这是刚才讲的这个协程的这个泛化问题,

65
00:05:38,100 --> 00:05:41,720
就是它实际上是我们的普通函数的泛化,这刚才已经提到过了。

66
00:05:43,400 --> 00:05:47,820
那相对于我们上上下讲的地方,相对于线程而言,

67
00:05:47,820 --> 00:05:50,900
协程它因为它的切换实际上是函数级的切换

68
00:05:51,440 --> 00:05:54,880
所以它的切换力度会比这个线程更加小

69
00:05:54,880 --> 00:05:59,660
它不需要,我们它也不考虑,它并没有考虑多线程,就是说

70
00:05:59,660 --> 00:06:00,620
我们要让

71
00:06:00,620 --> 00:06:04,880
多个线程在多个处理上去执行,如果在多个情况下,这种情况它也不

72
00:06:04,880 --> 00:06:05,660
需要考虑

73
00:06:05,660 --> 00:06:07,580
它考虑在一个线程里面

74
00:06:07,580 --> 00:06:10,240
我怎么能够去迅速的切换

75
00:06:10,240 --> 00:06:11,620
协程这么一个概念

76
00:06:11,620 --> 00:06:14,280
这里面它不存在这种所谓的同步物资的问题

77
00:06:14,280 --> 00:06:16,240
它的自行效率所以比线程要

78
00:06:16,760 --> 00:06:21,180
要更加高 它的开销也会小一些

79
00:06:21,180 --> 00:06:23,800
这里面给出了一个简单的例子

80
00:06:23,800 --> 00:06:27,140
你可以看到对于普通函数而言

81
00:06:27,780 --> 00:06:29,960
如果要执行这么一个函数的话

82
00:06:29,960 --> 00:06:32,240
那么它会直接把ABC给打出来

83
00:06:34,020 --> 00:06:38,300
但是对于下面这个斜程的函数而言

84
00:06:38,300 --> 00:06:40,380
它printA之后 它会一二了一下

85
00:06:40,380 --> 00:06:46,220
一二了一下意味着会把A和B中间执行给打断了

86
00:06:46,620 --> 00:06:51,880
在这个样子出现之后会被另外一个函数去执行一些利用之后

87
00:06:51,880 --> 00:06:55,220
然后再回来 从这点再回来 才去打印B

88
00:06:55,220 --> 00:06:56,120
这意味着什么呢

89
00:06:56,120 --> 00:07:00,720
A和B之间并不像这个函数一样是一个连续执行的

90
00:07:00,720 --> 00:07:04,340
它是一种阶段性 间断执行这么一个效果

91
00:07:04,340 --> 00:07:06,600
这是所谓的这个具体的例子

92
00:07:06,600 --> 00:07:08,560
那么怎么去区分它

93
00:07:09,880 --> 00:07:11,300
其实2004年的时候

94
00:07:12,380 --> 00:07:14,900
那个Lua是一种编程语言 也是脚本式的语言

95
00:07:14,900 --> 00:07:21,000
他的作者发表了一篇很有名的paper,叫revisiting coroutines,提出了基于三

96
00:07:21,000 --> 00:07:24,860
个因素来对邪神进行分类。

97
00:07:30,960 --> 00:07:38,220
因为我现在讲也看不到同学啊,如果有什么问题的话,大家可以直接在这个腾讯会议里

98
00:07:38,220 --> 00:07:44,260
面,或者说这个微信群里面来来发一下言,这样可以我知道随时比如网断了等等,

99
00:08:14,260 --> 00:08:17,220
它需要有自己独立的站站,还是不需要有自己独立站站

100
00:08:17,220 --> 00:08:19,700
第三个是编程语言中的第一类对象

101
00:08:19,700 --> 00:08:22,560
你就类比于变量,变量就是第一类对象

102
00:08:22,560 --> 00:08:23,620
那你这个,你这个

103
00:08:24,200 --> 00:08:25,780
协程算不算是一种

104
00:08:26,300 --> 00:08:29,940
变量,是不是像变量一样的,有所谓第一类的一种对象

105
00:08:29,940 --> 00:08:32,080
第一类对象就是因为它这个待遇很高

106
00:08:32,080 --> 00:08:33,840
我们有很多对它的一些支持

107
00:08:33,840 --> 00:08:37,060
那基于这三个分类呢,我们其实可以把这个再做细分

108
00:08:37,060 --> 00:08:37,740
第一个

109
00:08:38,820 --> 00:08:40,620
控制传递,机制

110
00:08:41,000 --> 00:08:42,620
那么一种是叫对称协程

111
00:08:42,620 --> 00:08:46,760
这类比什么,类比我们的线程,咱们如果把线程看出来,这线程和线程之

112
00:08:46,760 --> 00:08:51,680
间,它们是一个对等关系,它们不是一个函数调用关系,这就是所谓对称

113
00:08:51,680 --> 00:08:56,480
写成的一个基本含义,而非对称写成什么意思呢,这就是函数Color和Colly

114
00:08:56,480 --> 00:09:02,140
的关系,它们这边不是对称的,Color调Colly,而不是Colly调Color,这是所

115
00:09:02,140 --> 00:09:06,460
谓非对称写成,那么继续这种方式呢,我们可以把它分成两类,一类称之

116
00:09:06,460 --> 00:09:10,740
为对称写成,一类称之为非对称写成,这是有两类的实现方式。

117
00:09:12,900 --> 00:09:15,240
那为什么要这么来分类呢

118
00:09:15,240 --> 00:09:18,100
是其实为了能够实现更加灵活的这种

119
00:09:19,380 --> 00:09:20,700
协称的管理

120
00:09:20,700 --> 00:09:24,000
比如说我们要想彻底在函数体来实现

121
00:09:24,000 --> 00:09:26,480
基于一种函数的方形扩动方式来实现的话

122
00:09:26,480 --> 00:09:29,220
那么用所谓的协称方式就是比较灵活

123
00:09:29,220 --> 00:09:31,540
就是所谓的这个非对称方式比较灵活

124
00:09:31,540 --> 00:09:33,720
但是你要实现像线程量的管理的话

125
00:09:33,720 --> 00:09:38,020
那你可要选择对称的这种协称来进行这种控制

126
00:10:08,420 --> 00:10:13,080
而有债協成是什么意思呢 它就是像现成一样有这些的债

127
00:10:13,080 --> 00:10:18,860
所以从公主意义上来说 有债协成其实就是一种用物态管理并运行

128
00:10:18,860 --> 00:10:20,020
的一种现成

129
00:10:21,300 --> 00:10:23,900
这里面我们现在的编程语言需要注意

130
00:10:23,900 --> 00:10:25,600
我们前面说的用物态管理的什么意思呢

131
00:10:25,600 --> 00:10:30,920
就是说我们现在的编程语言它支持有债协成 比如够语言等等

132
00:10:30,920 --> 00:10:34,760
这些有债协成其实它叫有债协成

133
00:10:34,760 --> 00:10:37,120
在我们看来是一种用物态管理并运行的现成

134
00:10:37,920 --> 00:10:42,360
至于这里面的概念,其实大家可能就有点混淆,你一会说协成,一会是现

135
00:10:42,360 --> 00:10:44,240
场,那到底它是现场还是协成?

136
00:10:44,520 --> 00:10:50,880
我觉得这里面我们不是简单的以这个名字来做一个区分,我们是看它内在的实

137
00:10:50,880 --> 00:10:54,780
现,就比如说它是否需要独立的上下门空间站。

138
00:10:55,820 --> 00:11:02,560
如果我在做协成切换的时候,我不需要切换所谓的协成的站的话,那么它是一种

139
00:11:02,560 --> 00:11:03,700
无站协成的概念。

140
00:11:04,560 --> 00:11:08,920
如果我需要切换属于这个协称的占,那是有占协称的概念

141
00:11:08,920 --> 00:11:15,220
是以这个来作为衡量的话,你可能更清楚就是什么叫有占协称,什么叫无占协

142
00:11:15,220 --> 00:11:15,980
称

143
00:11:15,980 --> 00:11:21,700
那在这里面,在目前我们现在这个设计里面,有占协称就等同于用物态管

144
00:11:21,700 --> 00:11:22,820
理并运行的现成

145
00:11:22,820 --> 00:11:29,420
就像我们上一节的这个概念是一样的,它都是具有自己独立的上下文

146
00:11:29,420 --> 00:11:30,160
空间

147
00:11:30,160 --> 00:11:35,500
那为什么出现这么多种概念是在于我们现在的这种编程语言操作系统

148
00:11:35,500 --> 00:11:37,860
之间的很多的概念

149
00:11:38,520 --> 00:11:44,160
它并没有一个统一的一个管理或者规定使得各说各话

150
00:11:44,160 --> 00:11:47,260
比如够语言它自己的go routing它叫go routing

151
00:11:47,260 --> 00:11:49,560
那其实通过我们的分析

152
00:11:49,560 --> 00:11:52,180
我们认为它就其实是这种本质上是一种有债卸成

153
00:11:52,180 --> 00:11:54,700
也就因为它是一种用来管理批运型的现成

154
00:11:56,640 --> 00:11:59,480
那这就是关于这个有债无债的一个解释

155
00:11:59,480 --> 00:12:04,220
第三个呢就是是不是first class语言对象

156
00:12:04,220 --> 00:12:09,160
那么这里面的有两个一类你说是它属于first class对象

157
00:12:09,160 --> 00:12:11,080
第二呢是不是那不是的

158
00:12:11,080 --> 00:12:15,400
意味着它这个它在语言编程上面是有一定限制的

159
00:12:15,400 --> 00:12:16,540
比如说有同学比较好

160
00:12:16,540 --> 00:12:19,560
其实是说我们刚才讲就是有些谐称的知识

161
00:12:19,560 --> 00:12:23,200
好像没有提到在语言及这个语言没有提到C语言

162
00:12:23,200 --> 00:12:26,840
那C语言难道就不能够实现谐称吗

163
00:12:27,480 --> 00:12:28,360
其实可以的

164
00:12:28,880 --> 00:12:31,000
C 语言可以在酷这个level来实现协程

165
00:12:31,000 --> 00:12:32,820
但在酷这个level来实现协程的话

166
00:12:32,820 --> 00:12:36,760
其实它并没有在语言层面上有对这个协程的直接支持

167
00:12:38,780 --> 00:12:41,400
所以它实际上是一种所谓的受限协程

168
00:12:41,400 --> 00:12:42,660
既然你在酷这个level实现的话

169
00:12:42,660 --> 00:12:46,040
其实你所有的这个编程就受制于酷

170
00:12:48,580 --> 00:12:51,060
语言对它的帮助是比较小的

171
00:12:51,060 --> 00:12:55,900
这就使得你在使用上面就有一定的限制或者一定的麻烦

172
00:12:55,900 --> 00:13:03,340
但比如说像Go和Rust,这种所谓的鞋成本身来说是作为语言的

173
00:13:03,340 --> 00:13:05,220
一个内在的一个知识的一个对象

174
00:13:05,220 --> 00:13:11,020
所以它可以被穿置传递,可以被直接的编程表达,可以被编辑做各种优化

175
00:13:11,020 --> 00:13:13,980
这样就使得它称之为first class头等仓的感觉

176
00:13:13,980 --> 00:13:19,020
这种就有很好的知识之后,你在编程上面对开发者来说就非常友好

177
00:13:19,020 --> 00:13:22,560
这是所谓的first class对象和受限鞋成的一个区分

178
00:13:22,560 --> 00:13:24,520
这个就给大家简单介绍一下

179
00:13:24,520 --> 00:13:28,060
简单我们再说一下什么叫第一类原对象

180
00:13:28,060 --> 00:13:29,360
可以被复制给一个变量

181
00:13:29,360 --> 00:13:30,580
可以嵌到数据结构中

182
00:13:30,580 --> 00:13:32,340
可以作为参数传递的函数

183
00:13:32,340 --> 00:13:34,060
可以作为值被函数返回

184
00:13:34,060 --> 00:13:36,680
这其实说的是跟变量类似的一种体验

185
00:13:37,020 --> 00:13:38,720
就是你可以把它当成一个变样来使

186
00:13:38,720 --> 00:13:41,900
这就是我们说的这个first class原对象的一个

187
00:13:41,900 --> 00:13:44,040
简单的一个描述

188
00:13:44,040 --> 00:13:45,300
好 前面已经说到了

189
00:13:45,300 --> 00:13:46,280
有了这些

190
00:13:46,280 --> 00:13:47,080
为什么需要协谈

191
00:13:47,080 --> 00:13:48,060
就是协谈轻量

192
00:13:48,060 --> 00:13:49,060
所以我们需要

193
00:13:49,960 --> 00:13:53,800
为了能够提升所谓的这种Io密集型那种操作的一种性能

194
00:13:53,800 --> 00:13:55,560
我们就需要引入谐承

195
00:13:55,960 --> 00:13:57,500
但是引入谐承之后

196
00:13:57,500 --> 00:13:58,700
它这种异步调度

197
00:13:58,700 --> 00:13:59,960
异步的这种编程机制

198
00:14:00,600 --> 00:14:02,760
其实会使得我们的编程比较麻烦

199
00:14:04,500 --> 00:14:06,040
所以通过语言的帮助

200
00:14:06,040 --> 00:14:08,400
我们可以按照同步的思维来编写异步代码

201
00:14:08,400 --> 00:14:09,020
所谓同步思维

202
00:14:09,020 --> 00:14:10,920
你还是按照从上到下一步一步的走

203
00:14:10,920 --> 00:14:12,840
这里面又出现了同步和异步

204
00:14:12,840 --> 00:14:14,740
这个不同的词的含义

205
00:14:14,740 --> 00:14:15,820
这里有同步的意思

206
00:14:15,820 --> 00:14:17,220
就是说我写了一个函数

207
00:14:17,220 --> 00:14:18,940
1函数2函数3

208
00:14:18,940 --> 00:14:22,020
这么从上到下来写这个函数

209
00:14:22,020 --> 00:14:22,820
我们这里面说

210
00:14:25,360 --> 00:14:28,180
写了一个卖函数里面

211
00:14:28,180 --> 00:14:31,900
这里面调了一个f1 f2 f3

212
00:14:31,900 --> 00:14:33,820
那么这是顺序执行的

213
00:14:33,820 --> 00:14:36,380
那么这就是所谓的执行f1之后才能执行f2

214
00:14:36,380 --> 00:14:37,660
执行f2之后才能执行f3

215
00:14:37,660 --> 00:14:39,380
这是所谓的同步思维

216
00:14:39,380 --> 00:14:40,540
异步思维什么意思呢

217
00:14:40,540 --> 00:14:41,800
我还是这么来写

218
00:14:41,800 --> 00:14:43,300
写出来这么一个效果

219
00:14:43,300 --> 00:14:45,200
就是编程是这么来编写的

220
00:14:45,200 --> 00:14:47,460
但它的执行是执行f1之后

221
00:14:47,460 --> 00:14:49,740
我可能会跳下去执行一个fn

222
00:14:49,740 --> 00:14:51,900
资讯完一分钟再回来的资讯F2

223
00:14:51,900 --> 00:14:55,420
所以他这个什么时候资讯F2取决于我的调度

224
00:14:55,420 --> 00:14:59,760
所以这就是所谓的同步编写 异步执行的一个项目

225
00:14:59,760 --> 00:15:01,420
这个大家稍微理解一下

226
00:15:02,520 --> 00:15:05,600
好 那么切换这一块呢

227
00:15:05,600 --> 00:15:07,140
我们看到稍微做一个比较

228
00:15:07,780 --> 00:15:09,060
就是协成 现成 进程

229
00:15:09,060 --> 00:15:11,240
切换这一块 对于进程而言

230
00:15:11,240 --> 00:15:15,180
你除了切换这个所谓的它的context

231
00:15:15,180 --> 00:15:17,180
进程的context之外呢 还有很多的

232
00:15:17,180 --> 00:15:22,100
这里面包含的页表,地址空间,文件等等,这里面都要去切换

233
00:15:22,100 --> 00:15:27,900
把整个所谓的进程控制块都给换掉了

234
00:15:27,900 --> 00:15:29,820
使得完全执行一个新的程序

235
00:15:30,240 --> 00:15:31,740
对于现场而言

236
00:15:31,740 --> 00:15:33,900
如果是同一个进程里面的现场

237
00:15:34,260 --> 00:15:35,760
那么它这些资源

238
00:15:35,760 --> 00:15:37,420
比如说我们说的这个打开的文件

239
00:15:38,020 --> 00:15:40,480
打开的文件这些东西,那其实它不需要切换

240
00:15:41,140 --> 00:15:44,960
地址空间,我们的页表不需要切换,切换什么?切换的是这个

241
00:15:44,960 --> 00:15:50,980
现真所自己拥有的占和现成的那个执行上下文context,我们叫task context

242
00:15:51,320 --> 00:15:53,300
这是现成切换效果的事情

243
00:15:53,300 --> 00:15:59,680
对于协成而言,假定是无占协成,那么一个占也没了

244
00:15:59,680 --> 00:16:03,820
它切了什么?只能切这些计算器,跟这个是一样的

245
00:16:03,820 --> 00:16:05,240
切了计算器

246
00:16:05,240 --> 00:16:08,800
所以看到它切换的力度是越来越小

247
00:16:09,180 --> 00:16:14,000
创建的力度也是越来越小,这样它的执行效率就会增高

248
00:16:15,040 --> 00:16:21,240
而且占空间小也是有效提升整体系统性能的很重要的一个因素

249
00:16:22,700 --> 00:16:25,360
所以 协成是个什么场景呢 就是Io密集型场景

250
00:16:25,360 --> 00:16:27,500
我们说这个Io密集型

251
00:16:30,280 --> 00:16:33,680
那 线程能不能做到 对Io密集型的支持呢 可以

252
00:16:33,680 --> 00:16:34,920
进程可没做到也可以

253
00:16:34,920 --> 00:16:40,480
只是由于它的创建 它的管理 它的切换 这个开销比较大

254
00:16:40,480 --> 00:16:46,240
然后占的内存比较大,使得鞋层更适合于IOMI-IN场景的处

255
00:16:46,240 --> 00:16:46,460
理。

256
00:16:47,060 --> 00:16:51,260
而且,其实本上来说,这三者之间是一个结合的关系。

257
00:16:51,540 --> 00:16:54,280
线程是属于进程的,鞋层是属于线程的。

258
00:16:55,680 --> 00:16:59,420
所以,鞋层并不会独立于线程和进程而存在。

259
00:16:59,560 --> 00:17:02,160
这点大家需要注意,它们这些项目配合。

260
00:17:04,220 --> 00:17:09,140
这里面看到的已经支持鞋层的编程语言有很多种。

261
00:17:09,140 --> 00:17:18,080
这里面有几类,像这是一类,这一类什么特点呢?这一类实际上都是属于

262
00:17:18,080 --> 00:17:19,740
编译型的,就声称二机制code。

263
00:17:20,360 --> 00:17:27,780
而这一类呢,相对来说,它是有一定的所谓的动态二机制翻译,高

264
00:17:27,780 --> 00:17:33,360
效的一种翻译型的执行,一边执行一边翻译。

265
00:17:33,760 --> 00:17:37,120
而这个呢是解释型的,这几类是解释型的。

266
00:17:37,120 --> 00:17:40,640
相对而言 解释型的描述型语言

267
00:17:40,640 --> 00:17:42,920
它更容易实现这种携程机制

268
00:17:42,920 --> 00:17:48,260
因为所有的运行都是在它的Runtime的管理和控制之下

269
00:17:48,260 --> 00:17:49,620
但这个就稍微难一些

270
00:17:49,620 --> 00:17:52,100
就是对Rust Go和CIA++20来说

271
00:17:52,100 --> 00:17:53,260
什么叫CIA++20

272
00:17:53,260 --> 00:17:54,180
你们要好奇

273
00:17:54,180 --> 00:17:55,080
CIA++不是CIA++吗

274
00:17:55,080 --> 00:17:57,080
为什么叫CIA++20呢

275
00:17:57,080 --> 00:17:58,440
这我们简单解释一下

276
00:17:58,440 --> 00:18:04,860
这是说是2020年CIA++的标准化组织

277
00:18:05,380 --> 00:18:09,100
对CIGR提出了一个更新,对它的规范,标准提出了更新

278
00:18:09,100 --> 00:18:11,460
在这里面引入了,第一次引入了鞋城

279
00:18:12,280 --> 00:18:15,080
那这个什么时候,这也是比较早

280
00:18:15,080 --> 00:18:19,320
大约是在18年或者更早一点引入了鞋城

281
00:18:19,320 --> 00:18:20,560
Go一开始就有

282
00:18:20,560 --> 00:18:21,880
但是这边需要区别

283
00:18:21,880 --> 00:18:24,760
这边基本上按照有战无战来做的区别

284
00:18:25,260 --> 00:18:26,700
对RUS来说是无战鞋城

285
00:18:26,700 --> 00:18:27,880
而Go是有战鞋城

286
00:18:27,880 --> 00:18:29,320
CIGR是无战鞋城

287
00:18:29,320 --> 00:18:32,400
所以这两者本上来说他们是很类似的

288
00:18:32,400 --> 00:18:36,280
只是在一些语法 优化上面还有些不同

289
00:18:37,040 --> 00:18:40,760
OK 由于这个描述语言比较灵活

290
00:18:40,760 --> 00:18:42,340
可以寄给实验友战 给实验母战

291
00:18:42,340 --> 00:18:44,080
就是点击的例子排斥

292
00:18:45,280 --> 00:18:46,960
这个大家稍微了解一下就OK了

293
00:18:46,960 --> 00:18:49,020
我并不是希望大家说把这些语言都搞明白

294
00:18:49,020 --> 00:18:50,680
只是你看到了说

295
00:18:50,680 --> 00:18:54,800
现在有很多的常用的语言都支持这种写成

296
00:18:56,160 --> 00:18:58,080
那也许同学就问了

297
00:18:58,080 --> 00:19:01,400
你讲的是语言 我们是上的OS课 这有啥关系

298
00:19:01,900 --> 00:19:03,780
OS的语言来编写的

299
00:19:03,780 --> 00:19:04,860
所以我们现在

300
00:19:05,380 --> 00:19:07,640
我们的OS研究小组里面

301
00:19:07,640 --> 00:19:11,080
就有用把这个斜程用来写kernel

302
00:19:11,620 --> 00:19:12,900
用斜程来写kernel

303
00:19:12,900 --> 00:19:14,060
当然掉入单位是斜程

304
00:19:14,060 --> 00:19:15,620
不是我们现在所谓的线程

305
00:19:15,620 --> 00:19:16,840
这就是一种探索

306
00:19:16,840 --> 00:19:18,240
这个其实已经看到了

307
00:19:18,240 --> 00:19:19,120
就是说

308
00:19:19,120 --> 00:19:19,960
斜程概念呢

309
00:19:19,960 --> 00:19:23,620
也可以用来跟OS有个紧握的一个结合

310
00:19:23,620 --> 00:19:25,400
这也是我们看到的一种发展趋势

311
00:19:27,140 --> 00:19:27,500
好

312
00:19:27,500 --> 00:19:29,620
那这里面给了一些简单的例子

313
00:19:29,620 --> 00:19:31,800
协程,这是Go的协程

314
00:19:31,800 --> 00:19:33,520
Go呢,Go routing,我们说的

315
00:19:33,520 --> 00:19:35,820
Go routing怎么来定义呢?加个前缀,Go就行了

316
00:19:35,820 --> 00:19:37,080
这个非常简单

317
00:19:37,460 --> 00:19:39,340
然后这个还是正常的一个函数

318
00:19:39,340 --> 00:19:41,640
有它之后呢,没有加这个的

319
00:19:41,640 --> 00:19:43,880
比如Direct,这里面的012

320
00:19:43,880 --> 00:19:46,840
它就没有被打断,中间就没有被换出去

321
00:19:46,840 --> 00:19:47,760
没有被调度出去

322
00:19:47,760 --> 00:19:49,620
因为协程调度出去,它就是连续的

323
00:19:50,860 --> 00:19:52,200
但是你一旦

324
00:19:52,200 --> 00:19:54,220
加了一个Go routing之后呢

325
00:19:54,220 --> 00:19:55,420
那接下来就不一样了

326
00:19:55,420 --> 00:19:57,740
你看它这里面就会

327
00:19:57,740 --> 00:20:00,860
因为你这里面streams实际上是这两个,这两个是不太一样的

328
00:20:00,860 --> 00:20:03,220
grotting0的时候呢,就会被YAR了一下

329
00:20:03,220 --> 00:20:05,660
就是说你被让出去之后呢,才能到1

330
00:20:05,660 --> 00:20:09,500
它已经之间是一个,就不是一个顺序执行这种同步的方式

331
00:20:09,500 --> 00:20:10,340
而是一种义务方式

332
00:20:10,340 --> 00:20:13,260
这就是我们看到的这种

333
00:20:13,640 --> 00:20:15,680
呃,构语言的一个鞋城

334
00:20:15,680 --> 00:20:16,860
它是友战鞋城

335
00:20:16,860 --> 00:20:20,060
也就是我们通常说的这个用户态管理的现场

336
00:20:21,120 --> 00:20:22,880
Python,这里面给出了Python的例子

337
00:20:22,880 --> 00:20:25,500
这里面我们都给了这个先的测试用例

338
00:20:26,020 --> 00:20:29,940
有兴趣的同学也可以去去去下载

339
00:20:29,940 --> 00:20:31,260
下载去运行一下

340
00:20:33,100 --> 00:20:34,260
这个也挺有意思

341
00:20:34,260 --> 00:20:36,780
就是他在这里面就是通过这种

342
00:20:36,780 --> 00:20:39,280
访问网访问网页得到一个UID

343
00:20:39,700 --> 00:20:41,160
那其实典型的Io操作

344
00:20:41,160 --> 00:20:43,340
频繁的大规模的就是

345
00:20:43,340 --> 00:20:47,500
发出很多的这个网络请求来获得UID

346
00:20:47,500 --> 00:20:49,480
那么你用异步的方式来实现

347
00:20:49,480 --> 00:20:50,900
其实也是类似

348
00:20:50,900 --> 00:20:53,880
在这个方式里面的前面加了个Async

349
00:20:53,880 --> 00:20:59,880
前面加了Go,再加了Async,加了Async之后,就意味着这是一个异步的

350
00:20:59,880 --> 00:21:01,560
函数,也就是所谓的协程。

351
00:21:01,800 --> 00:21:07,480
那么既然是异步函数的协程,就会有一个异步的调度,来完成对整个

352
00:21:07,480 --> 00:21:11,040
牵套的调度的一个执行过程。

353
00:21:11,240 --> 00:21:15,200
你会发现它这个执行效率会比较高,这后面是执行时间的一个统计,

354
00:21:15,440 --> 00:21:18,160
后面还会有一个比例讲Python的一个例子。

355
00:21:18,160 --> 00:21:23,540
RUS的语言类似,RUS的语言你看前面,它这里面有一个Async

356
00:21:24,340 --> 00:21:27,560
有个Async的话,那其实也是意味着这是一个携程

357
00:21:27,560 --> 00:21:29,720
如果不加Async,那就是一个函数

358
00:21:30,280 --> 00:21:33,720
这是我们说非常直白的一个区分

359
00:21:33,720 --> 00:21:37,100
那么通过这种Block-on-future来实现

360
00:21:37,700 --> 00:21:42,980
你看它当成一个变量,我们说first class的一个语言结构

361
00:21:42,980 --> 00:21:46,020
通过Block-on-future来对它进行一个调度

362
00:21:46,020 --> 00:21:47,580
调度和管理

363
00:21:47,580 --> 00:21:52,000
这是一个非常简单的一个就是在Rust原来写的一个例子

364
00:21:52,700 --> 00:21:55,020
好 我们再看看执行时间

365
00:21:55,020 --> 00:22:01,360
我们选择了一个大家可能相对来说比较容易去了解的一个语言Python来做

366
00:22:01,360 --> 00:22:02,480
的一个比较

367
00:22:02,480 --> 00:22:06,160
那么第一个是单进程

368
00:22:06,160 --> 00:22:09,560
所谓单进程就是只跑在一个处理器上 只跑了一个进程

369
00:22:09,560 --> 00:22:11,840
比如说你即使多核 它也只用了一个处理器

370
00:22:12,340 --> 00:22:16,240
它花了时间 比如说这里面执行了100次

371
00:22:16,240 --> 00:22:19,760
100次去取那个取这个uid

372
00:22:19,760 --> 00:22:20,720
啊整100次

373
00:22:20,720 --> 00:22:22,660
然后得到一个返回值

374
00:22:22,660 --> 00:22:24,300
然后就会打印出来

375
00:22:24,300 --> 00:22:25,640
打印了100次之后呢

376
00:22:25,640 --> 00:22:28,760
它会得到一个总体的实行时间的一个统计

377
00:22:28,760 --> 00:22:31,080
通过这个Timer的一个帮助

378
00:22:31,080 --> 00:22:33,540
那么会发觉算出来是28秒啊

379
00:22:33,540 --> 00:22:35,420
这个时间是相当比较慢的

380
00:22:36,060 --> 00:22:36,960
你如果用多进程

381
00:22:36,960 --> 00:22:38,420
多进程就是SMP了

382
00:22:38,420 --> 00:22:40,340
就是一个进程跑在一个处理器

383
00:22:40,340 --> 00:22:41,180
处理器上面

384
00:22:41,180 --> 00:22:42,680
或者是Multi-Core

385
00:22:42,680 --> 00:22:44,640
这里面然后7秒啊

386
00:22:44,640 --> 00:22:45,960
大约是4倍

387
00:22:45,960 --> 00:22:49,360
这是一个四核四核的处理器

388
00:22:49,360 --> 00:22:50,540
那这在哪测的

389
00:22:50,540 --> 00:22:52,740
就在我这个笔记本上测的

390
00:22:52,740 --> 00:22:56,000
这笔记上测出来就是比较比较友好

391
00:22:56,000 --> 00:22:58,440
因为这个其实这个美资访还是挺慢的

392
00:22:58,440 --> 00:23:00,680
所以这个四核能充分发射效果

393
00:23:00,680 --> 00:23:02,600
大概得到了一个四倍的提升

394
00:23:02,600 --> 00:23:03,860
就是多进程

395
00:23:03,860 --> 00:23:05,180
那你如果现成呢

396
00:23:05,180 --> 00:23:06,580
多现成呢

397
00:23:06,580 --> 00:23:07,660
现成它也是一样

398
00:23:07,660 --> 00:23:09,640
就是其实也是占了四个处理器

399
00:23:09,640 --> 00:23:10,860
四个处理器

400
00:23:10,860 --> 00:23:13,940
但是它这个切换的开销更小一点

401
00:23:13,940 --> 00:23:19,120
所以你看到,相对于前面这个7秒来说,它进一步压缩,变成了什么呢?变

402
00:23:19,120 --> 00:23:20,060
成了4秒

403
00:23:21,560 --> 00:23:25,240
整个干的事情都是一样的,这个函数的主体是一样的

404
00:23:25,240 --> 00:23:28,500
只是这个函数是以进程的方式来执行的,还是以线程的方式来执行

405
00:23:28,500 --> 00:23:30,440
的,还是以协程的方式来执行

406
00:23:30,440 --> 00:23:32,580
那如果是协程,又快了

407
00:23:33,080 --> 00:23:41,180
这里面是用协程方式,我们前面的async.io-run这么一个库来加上Py

408
00:23:41,180 --> 00:23:42,120
thon的语言支持

409
00:23:42,480 --> 00:23:45,520
来实现一个所谓的鞋层的一个调度

410
00:23:45,520 --> 00:23:46,780
它的切换开调更小

411
00:23:47,440 --> 00:23:49,220
这是我查的是用的是无站鞋层

412
00:23:49,220 --> 00:23:50,380
所以它用的是两秒

413
00:23:51,160 --> 00:23:54,160
所以可以看到这个提升是还是很显著的

414
00:23:55,200 --> 00:23:55,560
OK

415
00:23:56,840 --> 00:23:59,780
也许同学我们这里介绍性子比较多

416
00:23:59,780 --> 00:24:02,920
因为同学对这个里面那些细节比较感兴趣

417
00:24:02,920 --> 00:24:05,680
我们这里面给了一系列这个参考信息

418
00:24:05,680 --> 00:24:08,740
大家有感兴趣的同学可以进一步去学习一下

419
00:24:08,740 --> 00:24:17,000
OK,那我就比较快速的把这个corouting,就是携程这一块,给他做了一个介绍,

420
00:24:17,680 --> 00:24:25,820
大家理解,就是现成,携程,进程,他们现在的关系是什么,他们的区别是什么,这个是

421
00:24:25,820 --> 00:24:26,860
需要大家去了解的。

422
00:24:27,580 --> 00:24:35,240
OK,那我们再看这个,接下来就是支持现成携程的OS,这就讲实验,这是偏实

423
00:24:35,240 --> 00:24:36,680
验这一块内容。

424
00:24:37,880 --> 00:24:45,680
我们并没有去让大家去设计一个什么新的线程线,但是你要去了解它这个具体怎么

425
00:24:45,680 --> 00:24:46,760
去实现的。

426
00:24:46,800 --> 00:24:52,340
相对于之前的那个我们说的IPC的OS而言,它增加什么东西呢?增加这

427
00:24:52,340 --> 00:24:52,680
一块。

428
00:24:54,020 --> 00:25:02,960
增加这一块,和内核里面的一个管理,TCB,还这一块。

429
00:25:03,840 --> 00:25:08,940
这一块什么意思呢 这一块就是说我可以让这个线程 所谓的线程在用户

430
00:25:08,940 --> 00:25:10,680
台进行管理 在用户台执行

431
00:25:10,680 --> 00:25:18,660
这是我们说的user type做管理 user type去run这么一个方式

432
00:25:18,660 --> 00:25:24,520
对于这种情况而言 其实说这个是kernel type 变成kernel type去管理 用

433
00:25:24,520 --> 00:25:25,300
户台去run

434
00:25:25,780 --> 00:25:28,180
这是一种方式 我们会讲这两种方式

435
00:25:28,180 --> 00:25:31,760
那至于协程呢,我们给的例子啊,我们这边并不会讲,大家有兴趣的同学

436
00:25:31,760 --> 00:25:37,500
可以去看一下我们在这个给的这个第八章的代码里面,它有一个叫Stacklist Cor

437
00:25:37,500 --> 00:25:46,000
outine的一个user的一个application,你可以去看一下它的实现,它大致可以了解一下,怎么能够

438
00:25:46,000 --> 00:25:51,320
去在用户台实现一个类似于这样的一个协程的一个管理的一个,协训切

439
00:25:51,320 --> 00:25:55,220
换和协训管理的一个机制,它也是在用户台去做的。

440
00:25:55,900 --> 00:26:02,220
好,其实这就是我们这个实验要讲的内容,就是怎么去实现一个这么一个东西和这么

441
00:26:02,220 --> 00:26:02,740
一个东西。

442
00:26:09,200 --> 00:26:16,840
这是我们之前的越来越多的OS,一步一步在提升,进化到了这一块支持线

443
00:26:16,840 --> 00:26:17,100
程。

444
00:26:17,920 --> 00:26:21,980
所谓知识线程就是要在用户态或者内核态

445
00:26:21,980 --> 00:26:23,420
我们这里面还强调线程

446
00:26:23,420 --> 00:26:26,360
这些程只是赶信息同学去看一看

447
00:26:26,360 --> 00:26:30,640
在用户态内核态去管理多个在用户态执行的控制流

448
00:26:30,640 --> 00:26:31,700
那同学可能好奇

449
00:26:31,700 --> 00:26:36,960
我们前面也讲过在内核态也可以有thread吧

450
00:26:36,960 --> 00:26:38,320
确实内核态可以thread

451
00:26:38,320 --> 00:26:40,600
只是我们在这里面并不特别强调而已

452
00:26:40,600 --> 00:26:43,540
如果有赶信息同学可以看一下我们那个实现的分支里面

453
00:26:43,540 --> 00:26:45,340
确实也可以在内核态实现所谓的可能thread

454
00:26:49,100 --> 00:26:51,340
那么同学要干什么呢?同学要理解任务

455
00:26:52,260 --> 00:26:54,080
这里面我们其实已经提了很多概念

456
00:26:54,580 --> 00:26:56,660
就是进程、现程、携程

457
00:26:56,660 --> 00:26:58,740
那我们把它抽象成同样的一个任务

458
00:26:58,740 --> 00:26:59,440
来理解的话

459
00:26:59,440 --> 00:27:00,820
这样就可以更好地看到

460
00:27:00,820 --> 00:27:05,140
他们之间可以有一个相同的东西

461
00:27:05,140 --> 00:27:07,220
就是一个控制流的执行

462
00:27:07,220 --> 00:27:09,500
至于是控制流在function level

463
00:27:09,500 --> 00:27:11,460
还是在所谓的thread level

464
00:27:11,460 --> 00:27:12,720
还是在process level

465
00:27:12,720 --> 00:27:15,460
那是取决于我们的设计实现

466
00:27:15,460 --> 00:27:16,800
但你不管那种设计实现

467
00:27:16,800 --> 00:27:19,180
其实是指令流的一个执行

468
00:27:19,960 --> 00:27:20,320
OK

469
00:27:20,320 --> 00:27:21,440
那我们就要去理解什么

470
00:27:21,440 --> 00:27:23,380
理解他们的实现运行机制

471
00:27:23,380 --> 00:27:25,640
而这里面比较重要的就是switch

472
00:27:26,880 --> 00:27:27,700
要能切

473
00:27:27,700 --> 00:27:31,740
从这个控指令流切到下一个指令流

474
00:27:31,740 --> 00:27:32,700
或者再下一个指令流

475
00:27:32,700 --> 00:27:35,620
你能拿回在他们之间进行切换

476
00:27:36,700 --> 00:27:38,420
这是理解的一个关键

477
00:27:38,420 --> 00:27:41,340
从而可以能够写出有这么功能的一个OS

478
00:27:42,240 --> 00:27:44,820
这是这一块的一个支持

479
00:27:44,820 --> 00:27:46,680
这是一个迅猛龙的一个OS

480
00:27:47,480 --> 00:27:48,180
叫迅猛龙

481
00:27:48,180 --> 00:27:49,480
刚才取了名字迅猛龙OS

482
00:27:49,480 --> 00:27:50,540
讨的快

483
00:27:51,480 --> 00:27:51,840
好

484
00:27:51,840 --> 00:27:53,880
这里面就看到了Task

485
00:27:53,880 --> 00:27:55,380
Task里面其实有我们说的

486
00:27:55,380 --> 00:27:57,300
其实Task表是什么一个抽象呢

487
00:27:57,920 --> 00:27:59,780
就是对这边执行的一个抽象

488
00:27:59,780 --> 00:28:01,580
就是控制流执行的一个抽象

489
00:28:04,640 --> 00:28:06,080
执行的一个抽象

490
00:28:06,080 --> 00:28:07,400
那么你执行

491
00:28:07,400 --> 00:28:08,460
你既然要切换

492
00:28:08,460 --> 00:28:09,840
第二个重要概念是切换

493
00:28:09,840 --> 00:28:12,600
你要切换的话就存在一个所谓的这个context

494
00:28:12,600 --> 00:28:14,280
这task的context

495
00:28:14,280 --> 00:28:16,560
它最核心的就是那些继承器

496
00:28:16,560 --> 00:28:17,600
你执行到一定阶段

497
00:28:17,600 --> 00:28:20,440
你那个继承器的集合

498
00:28:20,440 --> 00:28:23,280
IGS集合就是代表了它这个你要切换

499
00:28:23,280 --> 00:28:25,480
切换的时候要把这个保存在某个地方

500
00:28:25,480 --> 00:28:26,720
换到另一个地方

501
00:28:26,720 --> 00:28:28,120
恢复一个继承器

502
00:28:28,620 --> 00:28:30,920
从这context里面把它保存进去

503
00:28:30,920 --> 00:28:33,980
然后从另一个context里面恢复回去

504
00:28:33,980 --> 00:28:36,360
让另一个执行流可以去执行

505
00:28:36,360 --> 00:28:38,900
因为这context里面这些继承器决定了它的走向

506
00:28:38,900 --> 00:28:45,040
比如说它里面很重要的几个技能器,PC,比如Stack,SP,Stack Pointer

507
00:28:45,040 --> 00:28:48,380
这些就其实决定了怎么去执行

508
00:28:48,380 --> 00:28:53,200
而里面其他通过技能器决定了这些词怎么去算,怎么去计算一些结

509
00:28:53,200 --> 00:28:54,080
果的保存

510
00:28:54,080 --> 00:29:02,120
所以这个task我认为是一个对协程、线程和进程的一个筹项,统一的一个

511
00:29:02,120 --> 00:29:02,700
筹项

512
00:29:02,700 --> 00:29:07,180
那么同时也看到进程里面其实包含了线程

513
00:29:07,180 --> 00:29:10,560
县城共用了这个进城的地址空间

514
00:29:10,560 --> 00:29:12,260
但是县城有自己的控制流

515
00:29:12,260 --> 00:29:14,260
有自己的这个所谓的contest

516
00:29:14,720 --> 00:29:16,280
还有它的一个站

517
00:29:16,280 --> 00:29:18,380
对于邪城而言

518
00:29:18,380 --> 00:29:19,520
那它属于一个县城

519
00:29:19,520 --> 00:29:21,900
你看这里面是一层一层的牵套关系

520
00:29:21,900 --> 00:29:23,460
县城 属于一个县城

521
00:29:23,460 --> 00:29:25,340
它自己有自己的一个控制流

522
00:29:25,340 --> 00:29:27,020
和它的一个contest

523
00:29:27,700 --> 00:29:29,600
这就是我们看出来他们之间的一个

524
00:29:30,160 --> 00:29:31,660
关系区别

525
00:29:32,260 --> 00:29:35,440
和他们的共性的这么一个结构

526
00:29:35,440 --> 00:29:37,900
这是这一块给大家做个介绍

527
00:29:37,900 --> 00:29:39,460
那我们这里面重点讲两个

528
00:29:39,460 --> 00:29:40,420
一个是用户态

529
00:29:40,420 --> 00:29:41,500
我们先理解什么

530
00:29:41,500 --> 00:29:43,580
第二理解什么

531
00:29:43,580 --> 00:29:45,500
理解这个用户态管理怎么去实现

532
00:29:45,500 --> 00:29:46,740
然后这个类合态管理怎么去实现

533
00:29:47,420 --> 00:29:49,440
就是这一块怎么去实现

534
00:29:51,020 --> 00:29:52,040
然后下面再讲

535
00:29:52,040 --> 00:29:53,880
底下那一块类合一块怎么去管理

536
00:29:53,880 --> 00:29:55,440
先用户态管理

537
00:29:57,500 --> 00:29:59,620
用户态管理就是这里面

538
00:29:59,620 --> 00:30:00,580
其实已经看到了

539
00:30:00,580 --> 00:30:01,880
最核心什么呢

540
00:30:01,880 --> 00:30:02,720
你要切换它

541
00:30:02,720 --> 00:30:04,220
你一定会有什么context

542
00:30:04,220 --> 00:30:10,120
我们说要有一个context 来保存你要切换这个线程的这么一个它的一个上下文

543
00:30:10,120 --> 00:30:12,780
第二呢 你还要去管理什么呢 管理它们的不同的站

544
00:30:12,780 --> 00:30:15,980
你切了 不管要切context 还要把这个站也要切了

545
00:30:15,980 --> 00:30:21,500
所以它这个有各自独立的站 这里面你要知道这里面不同线程站在哪

546
00:30:21,500 --> 00:30:28,620
然后呢 这个线程它这个在running 这个在available 可用 这是空闲的

547
00:30:28,620 --> 00:30:34,460
然后还有一个什么的,还有一个所谓的ready,那是属于这种在这个它所谓的这个一个

548
00:30:34,460 --> 00:30:35,340
list上面

549
00:30:36,380 --> 00:30:41,400
不同的任务的一个状态,如果这个现成执行完毕,那么它本来对应的那个t

550
00:30:41,400 --> 00:30:43,220
ask这面一项变成什么,变成available了

551
00:30:43,760 --> 00:30:49,720
没了,结束了,如果正在运行,那么这个是它是一个running,如果说它没有运行

552
00:30:50,520 --> 00:30:54,080
它是一个R-E-A-T-Y,这是RUN,这不一样

553
00:30:54,660 --> 00:30:58,540
Ready,等着被切换,那就是Ready,这属于它的状态的不同

554
00:30:59,760 --> 00:31:02,940
有了这么一个关键的结构之后,就可以把它管起来之后

555
00:31:02,940 --> 00:31:06,340
自然就可以把它给它的一个有效的管理了

556
00:31:06,340 --> 00:31:10,000
当然这里面还有很多细节,这会逐一给大家简单展开讲一讲

557
00:31:10,640 --> 00:31:14,220
看这里面的结构的核心内容,其实也是一样

558
00:31:14,220 --> 00:31:19,600
这ID,这里面说的我们说的用户它有管理的限制,它有自己的ID

559
00:31:19,600 --> 00:31:25,760
这里面ID就是线程ID,它有ID号,有自己的Stack,有它的Context,有它的State

560
00:31:25,760 --> 00:31:27,600
我们前面就少说了一个ID

561
00:31:30,680 --> 00:31:33,600
那么你要去试的话,就用这个程序

562
00:31:35,380 --> 00:31:39,520
这是用它的一个程序,它是宁愿包含了它的Runtime

563
00:31:39,520 --> 00:31:41,600
包含了我们说的线程管理的Runtime

564
00:31:41,600 --> 00:31:43,700
或者叫做有站鞋程

565
00:31:43,700 --> 00:31:45,780
反正可以看看这个鞋程怎么去进行管理

566
00:31:45,780 --> 00:31:47,320
这是我们要去讲的重点

567
00:31:47,320 --> 00:31:49,700
你运行之后发现它这里面其实有多个task

568
00:31:49,700 --> 00:31:51,220
这里面写了4个task

569
00:31:51,220 --> 00:31:56,860
每个task在执行一个累加的显示

570
00:31:57,820 --> 00:31:58,880
这是这么一块

571
00:31:58,880 --> 00:32:01,600
然后你可以看到怎么来创建呢

572
00:32:01,600 --> 00:32:02,280
有个主函数

573
00:32:02,280 --> 00:32:03,920
mine是我们的主函数

574
00:32:04,420 --> 00:32:08,260
那主函数会创建这spawn

575
00:32:08,260 --> 00:32:10,040
就是创建我们说的线程

576
00:32:10,040 --> 00:32:11,280
创建线程

577
00:32:11,280 --> 00:32:12,820
这线程在执行过程中

578
00:32:12,820 --> 00:32:18,820
它会主动让出当前的执行

579
00:32:20,100 --> 00:32:22,080
然后下次回来之后再被切回来

580
00:32:22,080 --> 00:32:23,640
从这个地方再继续往下走

581
00:32:24,180 --> 00:32:25,100
这是一个循环

582
00:32:25,100 --> 00:32:27,000
所以它这里面会让出好几次

583
00:32:27,000 --> 00:32:29,380
让出4次

584
00:32:31,080 --> 00:32:32,760
然后每让出之前

585
00:32:32,760 --> 00:32:36,600
它会打一个它的一个编号

586
00:32:36,600 --> 00:32:39,280
它自己的ID和它执行多少次的一个技术

587
00:32:39,280 --> 00:32:40,080
所以这里面看到

588
00:32:40,080 --> 00:32:50,000
这里面执行的一次,它counter是0,不,这是task1,task1,task1,这个点不

589
00:32:50,000 --> 00:32:57,080
上了,task1,0次执行,就叠带了第0次,ok,这里面task0是一个特

590
00:32:57,080 --> 00:33:03,200
殊的,代表runtime,我们说的主线程,大家简单理解可以以为是主线程,

591
00:33:03,700 --> 00:33:10,060
那么这个runtime的run就开始调度执行各个线程,这是它的一个大致的一个执

592
00:33:10,060 --> 00:33:10,060
行,

593
00:33:10,960 --> 00:33:14,340
一个展现就我们写程序大致上就很容易创建了

594
00:33:14,820 --> 00:33:17,640
就是spawn一下然后就调一个runtime的run就ok了

595
00:33:17,640 --> 00:33:20,020
这是站在用户的角度来理解它

596
00:33:20,020 --> 00:33:24,300
那么这里面我们前面已经讲了这个

597
00:33:24,300 --> 00:33:25,960
他要管理的是这些东西

598
00:33:25,960 --> 00:33:27,940
这里面比较稍微比较特殊的

599
00:33:27,940 --> 00:33:29,700
就是或者说比较复杂一点的

600
00:33:29,700 --> 00:33:32,400
就是这个所谓的pass context

601
00:33:32,400 --> 00:33:34,460
我们前面已经说了一堆技能器

602
00:33:34,460 --> 00:33:35,800
一堆技能器

603
00:33:35,800 --> 00:33:40,080
这机器里面保存了就是它下次要执行所需要的

604
00:33:41,460 --> 00:33:45,980
比如说PC值啊,比如说它那个站指针啊等等啊,在这里面就会保存

605
00:33:46,980 --> 00:33:49,760
这大家其实再回顾一下,我们讲这个

606
00:33:50,700 --> 00:33:53,800
之前的进程管理,进程切换和现成切换,其实

607
00:33:53,800 --> 00:33:57,060
那实际上在内核里面,其实这个和那个是基本上是一样的

608
00:33:57,060 --> 00:33:58,080
就是要切换控制流

609
00:33:58,780 --> 00:34:02,320
那么这个state呢,比较简单,available代表是当前这个

610
00:34:02,820 --> 00:34:06,580
它有一个任务的一个管理或者线程管理的一个对垫

611
00:34:06,580 --> 00:34:09,660
这个对垫里面我如果创建一个新线程

612
00:34:09,660 --> 00:34:14,800
那我要从这个对里面找一个available空写的一个来用

613
00:34:16,600 --> 00:34:17,920
哎呀 写不出来了

614
00:34:19,620 --> 00:34:20,660
那么就是available

615
00:34:20,660 --> 00:34:25,340
那么如果当前这个任务对垫或者线程对垫里面

616
00:34:26,020 --> 00:34:28,160
那个对应的线程正在running

617
00:34:28,160 --> 00:34:29,060
正在在用处理器执行

618
00:34:29,060 --> 00:34:30,600
它就转到这边是running台

619
00:34:30,600 --> 00:34:33,840
否则就是reddit台,这是三种不同的方式

620
00:34:37,880 --> 00:34:38,240
OK

621
00:34:41,280 --> 00:34:48,080
好,那么我们再看看它整个设计实现一个整体流程

622
00:34:48,080 --> 00:34:52,100
T流程就是new,就是我要把这个Runtime,就是线程管理的

623
00:34:52,100 --> 00:34:55,900
本身这个实体给找出来,就是所谓的Runtime的new

624
00:34:55,900 --> 00:34:57,880
这Runtime的new其实有三个步骤

625
00:34:57,880 --> 00:35:00,880
设置主线程,就是Runtime自己,其实也代表一个线程

626
00:35:00,880 --> 00:35:02,480
它把TID设成0

627
00:35:03,600 --> 00:35:05,720
自己,当前自带运行嘛,所以它是running

628
00:35:05,720 --> 00:35:11,220
然后设置调录列,所谓调录列就是各个它要管的任务的一个list

629
00:35:11,220 --> 00:35:12,500
这个list呢

630
00:35:12,500 --> 00:35:15,120
这里面有空闲的available的,也有可能

631
00:35:15,120 --> 00:35:16,820
你能够处于ready的

632
00:35:17,780 --> 00:35:23,820
和running的,这是它的不同的任务,它的一个状态的一个表示

633
00:35:24,880 --> 00:35:27,300
然后设置当前current,current是当前

634
00:35:28,380 --> 00:35:32,520
CUR,当前的这个限制是什么呢?是0,就当天是我在运行

635
00:35:33,360 --> 00:35:34,960
这是NEO设置的散布

636
00:35:34,960 --> 00:35:38,060
那做完NEO之后呢,还要再做一个处置化

637
00:35:38,060 --> 00:35:41,980
这个处置化是进一步的去做一个更新什么的

638
00:35:41,980 --> 00:35:46,620
就是把这个Runtime结构的变量地址付给全局变量Runtime

639
00:35:46,620 --> 00:35:51,200
这样我们在做切换的时候会通过这个全局变量来找到

640
00:35:51,200 --> 00:35:53,600
这个里面的结构体从而可以更方便的去执行

641
00:35:53,600 --> 00:35:55,260
它里面那些管理的一些函数

642
00:35:55,260 --> 00:35:57,700
毕竟它是一个单一的一个程序来执行

643
00:35:58,580 --> 00:36:01,060
所以我们的卖函数一开始要干的事情

644
00:36:01,060 --> 00:36:03,220
促使的话就要先调这个Round 10的New

645
00:36:03,220 --> 00:36:04,760
再调Round 10的NIT

646
00:36:04,760 --> 00:36:08,220
才能完成整个用户台线程管理运行时

647
00:36:08,820 --> 00:36:10,100
这是这一块

648
00:36:10,100 --> 00:36:12,480
做完这个之后才会去做创建线程

649
00:36:12,480 --> 00:36:13,780
一些后续的工作

650
00:36:14,740 --> 00:36:16,660
这是创建线程怎么spawn

651
00:36:16,660 --> 00:36:17,780
我们先前看到了

652
00:36:17,780 --> 00:36:20,480
用户台要去创建线程就要通过spawn来创建

653
00:36:20,480 --> 00:36:22,780
那么线程的主体是什么呢

654
00:36:22,780 --> 00:36:24,040
是这个函数

655
00:36:24,040 --> 00:36:25,120
就是一个function

656
00:36:25,120 --> 00:36:26,560
这个function是一个函数

657
00:36:28,180 --> 00:36:34,980
那么我知道这个线程的主题在哪之后,我还要去把他那个线程的那些所

658
00:36:34,980 --> 00:36:40,560
谓的那个一些叫什么task,task就是我们说的结构

659
00:36:41,460 --> 00:36:46,460
叫任务控制块或者叫线程控制块,这里面的信息给填完整了

660
00:36:46,460 --> 00:36:51,780
首先要找一个state available的,这些是空闲的,找到之后呢,我要做一系列设置

661
00:36:51,780 --> 00:36:55,160
最主要是把那个ctx,叫做context填对了

662
00:36:55,160 --> 00:36:56,860
这里面填对了,一开始执行的时候

663
00:36:56,860 --> 00:36:58,460
你那些通讯器还不用管

664
00:36:58,460 --> 00:36:59,840
但是有几个需要注意的

665
00:36:59,840 --> 00:37:01,440
就是你从头开始执行

666
00:37:01,440 --> 00:37:03,320
你就站在那,这两个要确定

667
00:37:03,320 --> 00:37:04,340
这是设置站的

668
00:37:04,340 --> 00:37:06,680
这是设置它从头开始执行的

669
00:37:06,680 --> 00:37:08,600
这是两个很重要的信息

670
00:37:08,600 --> 00:37:10,760
设完之后还有一个状态

671
00:37:10,760 --> 00:37:12,820
状态是ready,它不是running

672
00:37:13,280 --> 00:37:14,340
因为只是就绪了

673
00:37:14,340 --> 00:37:16,660
等于说挂到这个就绪队里面去了

674
00:37:17,440 --> 00:37:19,440
这一项挂下去了

675
00:37:19,440 --> 00:37:21,060
它是ready的

676
00:37:21,620 --> 00:37:22,540
Reddit 意味着什么呢

677
00:37:22,540 --> 00:37:25,460
下面我们要做switch 要做切换的时候

678
00:37:25,460 --> 00:37:28,420
就可以从Reddit里面选一个来进行切换

679
00:37:28,420 --> 00:37:31,860
这是我们说先要创建现场

680
00:37:33,000 --> 00:37:36,120
这里面有几个重要的函数

681
00:37:36,120 --> 00:37:37,480
那么这里面除了这个function之外

682
00:37:37,480 --> 00:37:38,260
还有一个guard

683
00:37:38,260 --> 00:37:39,480
这guard干什么呢

684
00:37:39,480 --> 00:37:40,940
guard后面会有介绍

685
00:37:40,940 --> 00:37:42,300
然后还有一个

686
00:37:42,300 --> 00:37:44,980
这是开始出事化的时候很重要的三个

687
00:37:44,980 --> 00:37:47,340
这主要是关注的是一个

688
00:37:47,340 --> 00:37:49,420
函数现成进行完之后怎么返回的问题

689
00:37:49,940 --> 00:37:55,360
这是等于是线程入口的一个地址,这是线程在执行过程中所需要的站,

690
00:37:55,900 --> 00:37:59,920
这是三块,最主要的这个内容需要填好。

691
00:38:00,440 --> 00:38:04,780
那么这个Guard可以看到这里面Guard干什么,掉了一个Return。如果掉了Guard之后,

692
00:38:04,920 --> 00:38:06,040
它最终会掉一个Return。

693
00:38:06,200 --> 00:38:11,620
Return干什么呢?就做了一个线程执行完毕的回收操作,把我自己的

694
00:38:11,620 --> 00:38:17,380
状态设成,就这个就续,我们说任务对链里面的那某一项,

695
00:38:17,380 --> 00:38:21,180
Current的一项把State是Available等于清空了

696
00:38:21,180 --> 00:38:21,720
我自己没用

697
00:38:21,720 --> 00:38:23,000
然后再Yard一下

698
00:38:23,000 --> 00:38:28,120
Yard一下就要switch到另外一个Ready的Task上面去

699
00:38:28,120 --> 00:38:29,020
这就干这个事情

700
00:38:29,020 --> 00:38:31,360
所以它最后现在完成了一个收尾工作

701
00:38:31,360 --> 00:38:34,600
就类似我们前面讲的线程或者进程的一个回收

702
00:38:34,600 --> 00:38:36,380
PCB的回收工作一样

703
00:38:36,780 --> 00:38:38,000
但是它非常简单

704
00:38:38,000 --> 00:38:41,900
所以它这边只有这一点就OK了

705
00:38:43,660 --> 00:38:47,760
这是我们说怎么去创建需要注意的问题

706
00:38:47,760 --> 00:38:49,520
创建完之后叫running

707
00:38:49,520 --> 00:38:53,740
running的话就是我们这个runtime会选择某一个去执行

708
00:38:53,740 --> 00:38:55,900
所谓选择就掉了一个所谓的yard

709
00:38:55,900 --> 00:38:59,900
yard这样就是来完成了一个切换

710
00:39:00,780 --> 00:39:03,020
yard的最核心是掉什么,掉switch

711
00:39:03,940 --> 00:39:06,980
switch完成了两个线程的暂缓上下缓的切换

712
00:39:08,900 --> 00:39:10,980
这是tyard的一个实现

713
00:39:10,980 --> 00:39:27,140
可以看到,我要放弃我自己,我看看这里面,这是新的,这是新的要切换的那个,要切换

714
00:39:27,140 --> 00:39:35,580
的那个线程,这是老的,要被换出的那个线程,所以既然它新的话,它会把它装

715
00:39:35,580 --> 00:39:40,600
在这个running台,然后就是做一个switch,那核心看看switch是什么东西。

716
00:39:41,440 --> 00:39:44,960
Switch就是完成当前指令指针的切换

717
00:39:44,960 --> 00:39:46,920
完成占指针的切换

718
00:39:46,920 --> 00:39:48,120
完成通过计程器集合的切换

719
00:39:48,120 --> 00:39:49,220
就干这三个事情

720
00:39:49,220 --> 00:39:51,960
Switch本身是一个涉及到的是汇编

721
00:39:52,340 --> 00:39:54,780
涉及到的是一系列的计存器的操作

722
00:39:54,780 --> 00:39:57,320
所以它本身是一个比较特殊的函数

723
00:39:57,320 --> 00:39:58,700
它是一个汇编型的函数

724
00:39:58,700 --> 00:40:00,880
这和我们之前讲的那个

725
00:40:00,880 --> 00:40:03,020
现成进程管理的Switch是一回事

726
00:40:03,020 --> 00:40:03,740
几乎一回事

727
00:40:03,740 --> 00:40:04,960
但它更简单一点

728
00:40:05,820 --> 00:40:07,820
可以看到它这里面就是

729
00:40:09,220 --> 00:40:15,180
把我们的task的context,保存在context里面的那些

730
00:40:15,780 --> 00:40:19,780
context里面的那些集成器,这就是context的集成器,一个一个恢复到

731
00:40:21,560 --> 00:40:26,080
这是sd,这是存,等于是把old存进去,存到context里面去

732
00:40:26,080 --> 00:40:29,780
然后存完之后,到这一步,那开始什么,开始load

733
00:40:30,360 --> 00:40:34,440
开始恢复,把new这一块的new的恢复到这个集成器里面去,最后再tr

734
00:40:34,440 --> 00:40:35,280
new

735
00:40:35,280 --> 00:40:38,320
那就是跳到它的新的地址去执行就完了

736
00:40:38,320 --> 00:40:42,660
这就是JR这类是基于基因器里面存的这个内容

737
00:40:42,660 --> 00:40:44,080
作为地址跳转

738
00:40:44,080 --> 00:40:46,160
基于基因器跳转这么一个过程

739
00:40:46,160 --> 00:40:47,640
所以在这里面可以看出来

740
00:40:47,640 --> 00:40:50,880
当执行完这个Switch函数之后

741
00:40:50,880 --> 00:40:53,060
我们再出来之后

742
00:40:53,060 --> 00:40:55,280
已经到了这个

743
00:40:56,100 --> 00:40:58,380
Cast-Context所对应的那个thread

744
00:40:58,380 --> 00:41:00,000
NewThread去执行

745
00:41:01,740 --> 00:41:05,040
这就是我们说这个Switch函数完成的功能

746
00:41:05,040 --> 00:41:07,960
就是说你一堆技能器的保存与恢复

747
00:41:08,440 --> 00:41:11,160
那最后你看掉RUN 掉12就完了

748
00:41:11,160 --> 00:41:15,560
所以最后会把所有的处于旧序Tie的

749
00:41:15,560 --> 00:41:18,380
你Sponsor穿成一个旧序的一个现场执行完毕

750
00:41:18,380 --> 00:41:19,660
没有现场执行完之后

751
00:41:19,660 --> 00:41:20,800
它就会退出

752
00:41:20,800 --> 00:41:23,900
然后所有任务执行完毕就结束了

753
00:41:23,900 --> 00:41:28,160
这是整个用户Tie管理的一个设计实现

754
00:41:28,160 --> 00:41:32,660
这里面比较麻烦的还是在于对这个站的理解

755
00:41:32,660 --> 00:41:34,700
怎么去和这context理解

756
00:41:34,700 --> 00:41:39,300
能够去把这个集机生器来和这个switch会面函数

757
00:41:39,300 --> 00:41:43,480
来完成对两个线程的切换

758
00:41:43,480 --> 00:41:46,900
我觉得这是需要大家再进一步去理解

759
00:41:46,900 --> 00:41:48,460
看看代码去理解的一个过程

760
00:41:49,340 --> 00:41:49,700
好

761
00:41:49,700 --> 00:41:50,820
那第二个讲什么

762
00:41:50,820 --> 00:41:52,860
讲内核态的管理的用户线程

763
00:41:53,740 --> 00:41:58,040
那我们之前讲的是进程来做这个切换

764
00:41:58,040 --> 00:42:00,320
那现在我们要把这个进程进步拆分成

765
00:42:00,320 --> 00:42:05,820
就从所谓的进程的单线程变什么的,变成多线程,那就涉及到内

766
00:42:05,820 --> 00:42:10,340
核里面怎么去管理多线程的问题,你这个进程已经是有一个多线程的管

767
00:42:10,340 --> 00:42:20,900
理,这一个就是我们需要在哪,内核态管理这一块呢,你要把这里面的这些里

768
00:42:20,900 --> 00:42:27,780
面的多个线程全都放在一个线程控制块的集合里面,来完成一个管

769
00:42:27,780 --> 00:42:29,220
理,这是我们进程要干的事情。

770
00:42:29,620 --> 00:42:30,820
这是它的一个重点

771
00:42:30,820 --> 00:42:35,400
就是要对现有的这个进一步的一个重构形成这么一个结构

772
00:42:35,400 --> 00:42:36,440
就是PCB里面

773
00:42:36,440 --> 00:42:41,640
PCB的进程红绘画会有个TCBS就是一个list来管所有的线程

774
00:42:43,300 --> 00:42:46,780
这是内核台管理里面的一个最重要的一个重构

775
00:42:46,780 --> 00:42:47,680
我认为是一种重构

776
00:42:47,680 --> 00:42:51,080
有了重构之后就可以基于线程来进行调度了

777
00:42:51,080 --> 00:42:52,460
而不是基于进程来进行调度

778
00:42:54,760 --> 00:42:56,380
TCB-T是thread

779
00:42:56,940 --> 00:43:03,600
OK,那么整个这个内核管理的用户现成的任务控制块,其实和我们第七

780
00:43:03,600 --> 00:43:07,660
讲的那个任务控制块很类似。

781
00:43:08,120 --> 00:43:13,640
当时我们那个还没有进程的概念的时候,其实也没有地主空间的时候,那某种程度

782
00:43:13,640 --> 00:43:18,800
上就是一种现成,就是一种内核管理的现成。

783
00:43:20,000 --> 00:43:27,260
这里面可以看到,在process里面它会有一个tasks,这就是我们说的这个现成的列

784
00:43:27,260 --> 00:43:27,800
表。

785
00:43:30,680 --> 00:43:34,440
你要去尝试一下,这里面其实已经给出了这个相应的例子来执行。

786
00:43:34,920 --> 00:43:39,840
这个例子给出了它的执行过程,slide1,slide2,它们分别显示不同的

787
00:43:39,840 --> 00:43:45,200
内容,然后执行密度之后再退出,这是它大致的一个执行过程。

788
00:43:47,060 --> 00:43:54,180
看看代码,对于线程而言,你可以通过这种所谓的SelectCreate,这是一个系统

789
00:43:54,180 --> 00:43:54,500
调用

790
00:43:55,100 --> 00:43:57,960
跟刚才不一样,刚才是函数,这是系统调用

791
00:43:57,960 --> 00:44:02,500
它要进入内核里面,让我们的PCB知道说你创建了新的线程

792
00:44:02,500 --> 00:44:07,220
然后呢,创建完线程之后,接下来的事情就不用管了,只管创建

793
00:44:07,220 --> 00:44:10,020
然后由超级组来负责进行调度

794
00:44:10,020 --> 00:44:15,060
到我进行完之后,最后你这个线程需要注意,你会掉一个线程的一个退出,

795
00:44:15,280 --> 00:44:22,980
线程的退出,从而可以让我们的主线程,这边没有负指线程这种意思,就是

796
00:44:22,980 --> 00:44:27,900
线程,线程这些是对等的,除了第一个,这个MAT代表主线程,主线程

797
00:44:27,900 --> 00:44:37,200
会支付Width TID,你创建一个线程就会返回一个TID,这个TID,T

798
00:44:37,200 --> 00:44:40,000
ID就是会等,跟那个Width PID是类似的。

799
00:44:40,020 --> 00:44:46,740
等它结束,这就是我们说这个线程编写的时候最基本的一个操作方式

800
00:44:46,740 --> 00:44:50,620
这是一个应用程序,包含线程体

801
00:44:50,620 --> 00:44:55,460
然后Swipe Create来把这个线程体的这个函数给放进去

802
00:44:55,460 --> 00:44:57,180
然后它可能还会有参数

803
00:44:57,180 --> 00:44:57,940
然后呢

804
00:44:57,940 --> 00:44:59,520
最后等待它结束

805
00:44:59,520 --> 00:45:03,360
这就是一个标准的一个多线程应用的一个编写方式

806
00:45:05,320 --> 00:45:06,040
在这里面

807
00:45:06,040 --> 00:45:08,340
我们需要去理解几个很重要的这个系统调用

808
00:45:38,340 --> 00:45:49,100
省一点这个开销,这是这一块,第二个就是WidTID这一块。WidTID呢,主

809
00:45:49,100 --> 00:45:55,460
线程会负责通过WidTID来等待它创建的线程,结束并回收

810
00:45:55,460 --> 00:45:57,460
它在核中的资源。

811
00:45:58,220 --> 00:46:03,860
这一点其实和负进程等待止进程是一个道理,这没什么区别。

812
00:46:04,920 --> 00:46:09,240
但有一个问题,是跟之前的负止进程的退出不太一样。

813
00:46:09,520 --> 00:46:16,580
我们也存在一种情况,说主线程先掉就退出,如果它退出之后,那其他的

814
00:46:16,580 --> 00:46:19,480
那些新创新的线程怎么办?

815
00:46:21,880 --> 00:46:26,180
正常情况下,你这个线程属于进程,你这个主线程退出意味着进程退

816
00:46:26,180 --> 00:46:26,380
出。

817
00:46:26,380 --> 00:46:30,000
所以技能退出里,这些所有的线程也应该跟着退出,所以它会把这些

818
00:46:30,000 --> 00:46:37,800
线程,也需要把它的资源回收掉,然后才能够完成最终的这个退出,这是关于

819
00:46:37,800 --> 00:46:41,080
退出这一块有些不太一样。

820
00:46:42,360 --> 00:46:48,000
OK,好,我听到铃声响了,我们稍微先休息一下,过五分钟我们继续上课。

821
00:52:43,500 --> 00:52:46,180
好 我们继续开始上课啊

822
00:52:46,180 --> 00:52:48,280
刚才应该到点

823
00:52:49,080 --> 00:52:51,280
我刚才说到进程

824
00:52:51,280 --> 00:52:55,020
进程里面其实需要管理一系列的

825
00:52:55,020 --> 00:52:55,720
线程性的List

826
00:52:55,720 --> 00:52:56,360
所以这里面线程性的List

827
00:53:27,560 --> 00:53:30,820
刚才是说到这儿了 关于这个退出这一块

828
00:53:34,860 --> 00:53:40,660
好 那引入现成之后 虽然我们之前进程这个Fog

829
00:53:40,660 --> 00:53:44,220
exec with PID在结构上没有变化

830
00:53:44,220 --> 00:53:46,240
所谓结构的变化就是你的传递的一些参数

831
00:53:46,240 --> 00:53:47,420
写信用程序参数没有变化

832
00:53:48,540 --> 00:53:51,980
但是OS在内部去完成的功能要有一定的扩展

833
00:53:51,980 --> 00:53:54,540
毕竟你多了多了个东西 以前没有现成的

834
00:53:54,540 --> 00:53:56,960
现在有了线程 而且线程又属于进程

835
00:53:56,960 --> 00:54:02,080
所以你这个线程的管理是要进程要管起来

836
00:54:03,640 --> 00:54:06,020
那哪些变化大家可以看一看

837
00:54:06,020 --> 00:54:08,540
第一个就是你那个PCB要裁分一下

838
00:54:08,540 --> 00:54:13,540
PCB里面要把这个调度切换相关的部分变成一个

839
00:54:13,540 --> 00:54:17,280
我们前面看到tasks 变成一个tasks

840
00:54:17,280 --> 00:54:19,120
有单个的tasks

841
00:54:19,120 --> 00:54:23,800
就是所谓的这个线程来完成对它的一个切换

842
00:54:23,800 --> 00:54:31,760
第二,Fog创建了一个进程,也就意味着创建了一个主线程

843
00:54:33,360 --> 00:54:39,180
之后还要再创建新的线程,这是在Fog的时候需要注意的

844
00:54:39,180 --> 00:54:43,000
这都是由于你把这个PTB的结构改了

845
00:54:43,000 --> 00:54:47,240
同理也是一样,exec和withPID这两个要做的改动,但是改动稍微小

846
00:54:47,240 --> 00:54:47,800
一点

847
00:54:49,300 --> 00:54:51,280
最主要是GitPID这一块需要注意

848
00:54:51,280 --> 00:54:52,660
GitPID这一块需要注意

849
00:54:55,040 --> 00:54:59,080
它需要去回收的那些是以线程为单位进行回收的

850
00:54:59,660 --> 00:55:00,280
所以总体上来说

851
00:55:00,280 --> 00:55:07,100
你看到我们在这里面进程里面包含了一系列的线程T

852
00:55:07,100 --> 00:55:10,140
这是P 这是进程里面的一项

853
00:55:10,520 --> 00:55:11,900
要管一系列的线程

854
00:55:11,900 --> 00:55:16,020
这个变化是引起了你要做相应的一些处理

855
00:55:16,480 --> 00:55:23,280
从结构上来说,我们先关心了数据结构,再关心具体的控制逻辑,

856
00:55:23,460 --> 00:55:30,140
对于线程而言,我们已经说把它分出去了,分成了一个线程List,

857
00:55:30,380 --> 00:55:36,480
在线程List里面,其实单个而言就是TCB,我们说这个单个就是TCB,TCB

858
00:55:36,480 --> 00:55:40,100
形成一起,就是一个Task Manager来管这个线程的集合。

859
00:55:40,100 --> 00:55:50,220
然后对于正在运行的线程,我们把它放在processor这个结构里面,跟刚才之前

860
00:55:50,220 --> 00:55:56,500
的那个进程是一样的,这是我们说的三个核心的数据结构,它都是面向

861
00:55:56,500 --> 00:56:03,380
线程的,这里面给出了一个大致的定义,看这里面有什么线程所属的进

862
00:56:03,380 --> 00:56:06,100
程,只是要进程线程的关系,这里面是第一个。

863
00:56:07,560 --> 00:56:10,280
第二个需要注意的是我们以前说的

864
00:56:10,280 --> 00:56:12,080
其实进程有进程的内核站

865
00:56:12,080 --> 00:56:14,040
线程也有线程的内核站

866
00:56:14,040 --> 00:56:16,600
进了内核之后也需要有自己的一个站

867
00:56:16,600 --> 00:56:22,020
来完成相应的一些函数调用所需要的一些状态保存与恢复

868
00:56:22,020 --> 00:56:23,360
然后还有什么

869
00:56:23,360 --> 00:56:26,520
还有一个所谓的可变的结构就是

870
00:56:26,520 --> 00:56:29,820
这里面包括了它里面分配的一些资源

871
00:56:29,820 --> 00:56:31,560
它做切换的时候需要

872
00:56:31,560 --> 00:56:34,540
需要注意这里面它的切换其实也是需要一个

873
00:56:34,540 --> 00:56:37,440
特权级切换和这个任务本身的切换

874
00:56:37,440 --> 00:56:41,740
说他这里面的之前我们看到的trap context和touch context都

875
00:56:41,740 --> 00:56:43,800
挪到了线程这个level来

876
00:56:43,800 --> 00:56:46,500
然后线程的执行状态

877
00:56:46,500 --> 00:56:48,300
这这里面有一个有一个表示

878
00:56:48,300 --> 00:56:50,920
比如他知道是running还是available

879
00:56:50,920 --> 00:56:55,700
还是后面还有所谓的那个wait或sleep或者是suspend等等

880
00:56:55,700 --> 00:56:57,480
那他有他的自己的退出码

881
00:56:57,480 --> 00:57:02,200
这就是把这个进程控制化做了一个重构之后

882
00:57:02,200 --> 00:57:04,320
形成了线程控制化的一个类别

883
00:57:04,320 --> 00:57:11,920
然后对于竞争工作而言,很重要一点在于它有一个task,它形成一个链接关

884
00:57:11,920 --> 00:57:18,620
系,它指向了一个线程列表,而每一个线程又指向它所处的那个竞争,

885
00:57:19,840 --> 00:57:26,980
这是这一块,那么我们同时还有一个就是recycler,实际上它是一个pid的一个

886
00:57:26,980 --> 00:57:33,040
升级版,可以用来分配什么的,这里面以前只是分配pid,现在除了分配pid

887
00:57:33,040 --> 00:57:33,600
之外,还分配

888
00:57:34,280 --> 00:57:41,880
线程内核站,因为我们以前的process只有一个内核站,但现在你这个process里面会有多

889
00:57:41,880 --> 00:57:46,820
个thread,每个thread有自己的内核站,所以你还存在这个进程中线程内

890
00:57:46,820 --> 00:57:53,040
核站的分配管理过程,都在它的这个里面,这是一个设计上的一个距离实

891
00:57:53,040 --> 00:57:53,600
现了。

892
00:57:55,760 --> 00:57:59,300
在线程创建的时候,我们全部都叫线程create

893
00:57:59,300 --> 00:58:04,800
那么在线程创建的时候呢,需要注意其实就是对线程公司块相关的部分要做一个

894
00:58:04,800 --> 00:58:09,100
做好相应的处置化工作,还要同时建立好竞争线程的关系

895
00:58:09,100 --> 00:58:12,320
所以处置化工作是什么呢?线程,它有自己的用户站

896
00:58:12,320 --> 00:58:16,500
有它那个trapcom test,还有第二个有内壳站

897
00:58:16,500 --> 00:58:22,060
trapcom test在这儿,跳板页里面,能够确保用户台内壳台的切换

898
00:58:22,460 --> 00:58:29,020
然后还有自己进到内核里面之后,我们要会完成一个switch,这里面又是一个ITCH,

899
00:58:30,320 --> 00:58:37,100
对,switch,这个switch实际上就是完成了在内核里面的两个线程的切换,

900
00:58:37,300 --> 00:58:41,880
那最终是在哪儿执行呢,一定是要是到用户台去,才能跳回到用

901
00:58:41,880 --> 00:58:48,320
户台通过这儿,跳回到用户台去,用户台去执行,这是我们说它关键

902
00:58:48,320 --> 00:58:50,340
几个点,大家需要去了解,

903
00:58:50,340 --> 00:58:56,540
其实你可以看出来,所自己理解的在于,你首先要清楚核心数据结构,然后再清楚对

904
00:58:56,540 --> 00:58:58,360
这些核心数据结构的一个处理。

905
00:59:01,960 --> 00:59:07,480
那这里面可以看到我们前面讲的那几步骤,在这个具体的函数里面能够

906
00:59:07,480 --> 00:59:13,540
看到,比如说我们在创建thread的时候,这个函数实际上是在一个进程里面,假设

907
00:59:13,540 --> 00:59:17,920
我们第一个进程来执行的话,那么进程面执行这个,所以它会创建一个task。

908
00:59:18,420 --> 00:59:22,220
这个task最终会挂到一个list里面去

909
00:59:22,220 --> 00:59:23,860
这是挂到我们做task list里面去

910
00:59:23,860 --> 00:59:25,660
就task list里面去

911
00:59:25,660 --> 00:59:31,740
然后再会去针对它去创建它这个trap contest

912
00:59:32,340 --> 00:59:37,400
和它的相应的一些内核里面的一些内容

913
00:59:37,400 --> 00:59:44,280
比如说它的kernel token是它的页表的内容

914
00:59:44,280 --> 00:59:49,740
还有一些比如它那个用户站的一个信息

915
00:59:49,740 --> 00:59:53,300
这个是我们说现成的入口地址

916
00:59:53,300 --> 00:59:55,980
Entry等等这些一系列的操作工程

917
00:59:55,980 --> 00:59:58,560
都在这个Swipe Create里面会去完成

918
00:59:58,560 --> 01:00:02,360
实际上就是完成我们前面说的关键数据结构的一个处置化

919
01:00:03,140 --> 01:00:05,220
第一个是创建 第二个退出

920
01:00:05,220 --> 01:00:09,260
退出其实就和我们前面说那个退出差不多的

921
01:00:09,260 --> 01:00:12,640
就是靠它自己会把自己的部分内容给回收掉

922
01:00:12,640 --> 01:00:14,060
比如说用户站给回收掉

923
01:00:14,540 --> 01:00:20,020
但是内核里面的那个thread control block是由主线程来回收

924
01:00:20,020 --> 01:00:24,260
因为你会掉一个wait,wait TID,TID会完成这个回收

925
01:00:24,260 --> 01:00:25,160
整个的回收

926
01:00:26,520 --> 01:00:31,160
但如果是主线程本身发出的退出这个信用调的话

927
01:00:31,160 --> 01:00:34,460
那么它会把整个管理的所有线程都要回收点

928
01:00:34,460 --> 01:00:35,620
这是这一块

929
01:00:37,980 --> 01:00:39,340
退出可以看出来

930
01:00:39,340 --> 01:00:43,000
这里面是一个退出的一个大字字英处理过程

931
01:00:43,560 --> 01:00:45,260
然后在这里面会掉

932
01:00:45,800 --> 01:00:47,700
然后如果TID等于0什么意思

933
01:00:47,700 --> 01:00:49,040
我们前面说TID等于0

934
01:00:49,040 --> 01:00:50,160
因为它是主线层

935
01:00:50,160 --> 01:00:51,540
如果主线层的话

936
01:00:51,540 --> 01:00:56,440
那么它会把当前线层所有资源给释放掉

937
01:00:57,260 --> 01:00:59,740
这是这里面的一个实现

938
01:00:59,740 --> 01:01:03,100
那么主线层等待

939
01:01:03,100 --> 01:01:04,220
这等待现在结束

940
01:01:04,220 --> 01:01:06,660
WidthTID这一块

941
01:01:07,180 --> 01:01:09,290
它主要是清空什么的

942
01:01:11,310 --> 01:01:15,990
这个TID的线程分化,这就是完成整个的一个退出,然后同时还得到这个线

943
01:01:15,990 --> 01:01:22,170
程退出码,知道线程到底是正常退出的还是出错了退出,这都是和我们之前

944
01:01:22,170 --> 01:01:24,290
的进程退出是很类似的。

945
01:01:25,050 --> 01:01:37,230
可以看出来这里面,wait会查它那个线程里面的那些退出码是否存在

946
01:01:37,230 --> 01:01:44,290
如果有退出码,如果这个线程不存在了,那会return-1是一个错误

947
01:01:46,590 --> 01:01:51,810
如果这个线程本身来说还正在执行,或者说属于ready状态

948
01:01:51,810 --> 01:01:54,790
那么它是返回负2,也是返回回去了

949
01:01:54,790 --> 01:01:58,610
就在这种情况下,是属于这个线程已经退出了

950
01:01:58,610 --> 01:01:59,950
还得到了一个退出码

951
01:01:59,950 --> 01:02:04,150
得到这个码之后,它就可以把这个做进一步的处理

952
01:02:04,150 --> 01:02:06,370
这里面的清空,做进一步的处理

953
01:02:06,370 --> 01:02:10,210
把这个退出码给返回给我们这边需要的这个

954
01:02:12,930 --> 01:02:14,710
这是它的一个处理过程

955
01:02:14,710 --> 01:02:18,330
那么它怎么能知道这个task在哪儿呢

956
01:02:18,330 --> 01:02:20,090
因为你这边有个参数tid

957
01:02:20,090 --> 01:02:23,910
所以有了TID之后,我去查这个进程里面的Tasks,

958
01:02:24,170 --> 01:02:31,630
看它这里面是否,Tasks里面是有每一个Tasks所对应的PID的,

959
01:02:31,630 --> 01:02:35,950
所以我可以查出来是否它已经退出了,这可以查出来。

960
01:02:39,190 --> 01:02:41,390
对于切换而言,

961
01:02:41,730 --> 01:02:49,330
这个切换和我们之前讲的第四讲和第七讲讲这个任务切换和进程调

962
01:02:49,330 --> 01:02:49,910
度中的切换,

963
01:02:50,470 --> 01:02:55,990
是几乎是一样的,这里面我们就不再进一步展开讲解,大家能够再回

964
01:02:55,990 --> 01:03:04,530
顾一下,等于这一部分内容实际上是回顾一下就知道了。

965
01:03:04,610 --> 01:03:11,690
OK,那这就是我们对这个实验部分的讲解,就是你可以看到在这里面,你能够知道我们为

966
01:03:11,690 --> 01:03:17,930
了能够完成对用户太管理,用户现成的功能,你需要怎么去创建那个R

967
01:03:17,930 --> 01:03:18,350
untime,

968
01:03:18,910 --> 01:03:23,350
以及基于Runtime来创建所谓的用户线程

969
01:03:23,350 --> 01:03:25,950
调度用户线程 切换用户线程

970
01:03:25,950 --> 01:03:28,270
这是这一块需要做的事情

971
01:03:28,270 --> 01:03:31,310
那么在内核泰也一样

972
01:03:31,310 --> 01:03:34,150
内核泰其实我们前面已经经历了大量这种尝试

973
01:03:34,150 --> 01:03:37,110
所以内核泰来说有一部分内容是重复的

974
01:03:37,110 --> 01:03:40,530
包括怎么去在内核里面做task switch

975
01:03:40,530 --> 01:03:41,790
但是也有不同的地方

976
01:03:41,790 --> 01:03:45,810
就是PCB我们说的竞争方块做了进一步的改进

977
01:03:45,810 --> 01:03:48,390
使它能够支持在竞争里面支持多个线程

978
01:03:49,070 --> 01:03:53,270
好 这里面我留一个小问题

979
01:03:54,790 --> 01:03:59,210
Fog 这个Fog 我们前面说Fog是非常重要的一个

980
01:03:59,210 --> 01:04:01,410
frk-fog是创建竞争的

981
01:04:02,550 --> 01:04:06,010
那么我们一开始创建竞争 复兴创建竞争的时候

982
01:04:06,010 --> 01:04:09,210
如果还没有执行所谓的thread-create的时候

983
01:04:09,210 --> 01:04:11,350
那么这意味着这个竞争是一个单

984
01:04:11,350 --> 01:04:13,230
什么什么 是一个单竞争

985
01:04:13,230 --> 01:04:15,070
但是如果在Fog之前

986
01:04:15,070 --> 01:04:25,270
我已经用thread,t-h-r-e-a-d,create,创建了一堆线程,

987
01:04:25,590 --> 01:04:37,450
然后再进行fog,请问,这是附近城,这是parent,那么请问紫禁城,chard,它这个紫

988
01:04:37,450 --> 01:04:44,050
禁城是否要把这个附近城的所有这些thread也要创建一遍,

989
01:04:44,050 --> 01:04:47,330
使得直径层比如这里面创建的直径层有三个thread

990
01:04:47,330 --> 01:04:50,230
那么直径层里面是不是也是有三个thread

991
01:04:50,230 --> 01:04:53,050
包含主行程本身有三个thread

992
01:04:54,670 --> 01:04:58,930
这个问题请同学们考虑一下

993
01:05:00,150 --> 01:05:02,210
应该怎么来回答

994
01:05:02,210 --> 01:05:07,130
我希望同学就是直接在聊天里面就可以回答

995
01:05:09,630 --> 01:05:10,630
私聊也行

996
01:05:10,630 --> 01:05:11,990
公共聊也行

997
01:05:11,990 --> 01:05:15,370
这个就是给大家稍微想一想

998
01:05:15,370 --> 01:05:16,630
就是我讲了一堆

999
01:05:16,630 --> 01:05:19,570
其实大部分的还是一种整个操作流程

1000
01:05:19,570 --> 01:05:21,730
比较比较细一点

1001
01:05:21,730 --> 01:05:24,770
但是还有一些原则上的事情需要大家去考虑

1002
01:05:24,770 --> 01:05:26,230
就是比如说这个fork

1003
01:05:26,230 --> 01:05:29,450
因为进程和现成毕竟还是两个不同的东西

1004
01:05:29,450 --> 01:05:32,810
而且我们先有fork再有thread create

1005
01:05:32,810 --> 01:05:36,430
而在实际的历史发展过程中也是一样

1006
01:05:37,190 --> 01:05:38,930
我没看到同学回答

1007
01:05:38,930 --> 01:05:41,090
好的 这个问题留给大家

1008
01:05:41,090 --> 01:05:42,350
我也不回答

1009
01:05:42,890 --> 01:05:43,910
有一个同学要回答

1010
01:05:43,910 --> 01:05:45,410
要看距离事先

1011
01:05:45,410 --> 01:05:46,850
这话就是我通常说的

1012
01:05:46,850 --> 01:05:49,850
你要有一个前提

1013
01:05:51,070 --> 01:05:52,170
我这个前提很简单

1014
01:05:52,170 --> 01:05:54,090
就是我们自己这个R code tutorial

1015
01:05:54,090 --> 01:05:56,410
有同学可能说我是用mute code

1016
01:05:56,410 --> 01:05:57,010
没错

1017
01:05:57,010 --> 01:05:58,750
你到时候mute code还是R code

1018
01:05:58,750 --> 01:05:59,430
不一样

1019
01:05:59,430 --> 01:06:01,370
那么如果是R code tutorial的话

1020
01:06:02,410 --> 01:06:03,770
怎么来做的

1021
01:06:03,770 --> 01:06:04,470
看一下代码

1022
01:06:04,470 --> 01:06:05,610
我们前面已经说到了

1023
01:06:05,610 --> 01:06:07,350
对于R code tutorial的话

1024
01:06:07,350 --> 01:06:18,510
那其实它这个有多个线程的进程做了这个fork之后

1025
01:06:18,510 --> 01:06:23,630
它的那个纸进程一样会把它那个多个线程也给复制一遍

1026
01:06:23,630 --> 01:06:26,310
所以它也是一个多的就是这里面有

1027
01:06:26,310 --> 01:06:27,710
前面说的这里面有三个的话

1028
01:06:28,610 --> 01:06:30,470
那么三个thread的话

1029
01:06:30,470 --> 01:06:32,310
那你创建的纸进程也有三个thread

1030
01:06:33,730 --> 01:06:35,630
这是一种实现

1031
01:06:35,630 --> 01:06:37,890
这是R code tutorial的实现

1032
01:06:39,510 --> 01:06:43,990
但是Linux的实现是不一样的

1033
01:06:43,990 --> 01:06:45,550
Linux实现为什么不一样呢

1034
01:06:45,550 --> 01:06:48,650
Linux实现里面的它的所谓的thread

1035
01:06:49,030 --> 01:06:51,910
是一种special的process

1036
01:06:52,770 --> 01:06:55,970
意味着它在它的PCB里面

1037
01:06:55,970 --> 01:06:58,570
并没有我们通常意义上说的那个tasks

1038
01:06:58,570 --> 01:07:00,330
就是所谓的现成的那个list

1039
01:07:00,330 --> 01:07:01,630
它不存在

1040
01:07:02,550 --> 01:07:03,990
在他眼里来说

1041
01:07:03,990 --> 01:07:08,850
所谓的thread只是两个PCB

1042
01:07:09,710 --> 01:07:11,170
PCB意味着是一个进程

1043
01:07:11,170 --> 01:07:14,490
两个进程同样指向了同一个地址空间而已

1044
01:07:18,270 --> 01:07:20,890
所谓的现场,比如说我这里面

1045
01:07:20,890 --> 01:07:22,050
create一个thread的话

1046
01:07:22,710 --> 01:07:25,210
我创建的也是创建了PCB

1047
01:07:25,210 --> 01:07:29,590
只是这个PCB和这个PCB指向了同一个页表,他们用同一个页表

1048
01:07:30,110 --> 01:07:30,910
仅此而已

1049
01:07:31,450 --> 01:07:31,850
所以

1050
01:07:31,850 --> 01:07:40,370
对于这点来说,你会发现,对于Linux而言,它由于没有这么一种层

1051
01:07:40,370 --> 01:07:40,710
次结构,

1052
01:07:40,950 --> 01:07:45,690
就是PCB里面管多个Tasks,形成一个线程类似的情况,

1053
01:07:46,170 --> 01:07:53,350
那么它在创建Fock的时候,它只是把当前的发输Fock的这个线程,

1054
01:07:53,390 --> 01:08:01,150
也就是进程,复制了一份,然后它的页表是共享的。

1055
01:08:01,150 --> 01:08:09,110
所以在这里面看出来,意味着如果我这个PCB里面还有其他的PCB,他们号称都是

1056
01:08:09,110 --> 01:08:10,850
共享的同一个页表的话,

1057
01:08:11,170 --> 01:08:16,450
那么我在这里面做了一个Fock,创建了紫禁城,也就是这么一个新的一个,这是一个New

1058
01:08:16,450 --> 01:08:17,410
的PCB而已。

1059
01:08:17,750 --> 01:08:23,330
只它多了一个页表,那这个PCB多了一个,并不会出现说,因为这个结构都不

1060
01:08:23,330 --> 01:08:30,910
存在,所以不会出现说我这个这个和这个都属于同一个页表,

1061
01:08:30,910 --> 01:08:33,610
那么他们试验是不是要把所有这些PCB全复制一遍

1062
01:08:33,610 --> 01:08:34,670
不是这么回事

1063
01:08:34,670 --> 01:08:35,970
他只是

1064
01:08:35,970 --> 01:08:37,190
简单的

1065
01:08:37,190 --> 01:08:38,830
简单的把这个PCB

1066
01:08:38,830 --> 01:08:40,370
重新创建了一个新的

1067
01:08:40,370 --> 01:08:42,090
然后这两个PCB共享一个页表

1068
01:08:42,090 --> 01:08:43,390
他们这边就是一个

1069
01:08:43,390 --> 01:08:45,790
共享页表的进程的关系

1070
01:08:46,430 --> 01:08:46,790
所以

1071
01:08:46,790 --> 01:08:47,750
某种程度上来说

1072
01:08:47,750 --> 01:08:50,750
我们把Linux里面的slide称之为什么呢

1073
01:08:50,750 --> 01:08:52,010
叫lightweight process

1074
01:08:52,010 --> 01:08:53,210
就是轻量级的

1075
01:08:53,950 --> 01:08:54,610
进程

1076
01:08:54,610 --> 01:08:55,310
这一点

1077
01:08:55,310 --> 01:08:56,470
就是这位

1078
01:08:56,470 --> 01:08:57,310
同学说的

1079
01:08:57,310 --> 01:08:59,250
要看具体操作的实现

1080
01:08:59,250 --> 01:09:00,590
这里面又说明了什么问题呢

1081
01:09:01,430 --> 01:09:05,250
操作系统是先有实现,再有概念

1082
01:09:05,250 --> 01:09:08,850
我根据一个实现可以给出一个概念

1083
01:09:08,850 --> 01:09:11,350
跟着概念给出一个解释

1084
01:09:13,010 --> 01:09:14,950
所以大家在处理这些问题的时候

1085
01:09:14,950 --> 01:09:17,430
需要再考虑的更加仔细一点

1086
01:09:18,290 --> 01:09:20,230
很谢谢这位同学的回答

1087
01:09:20,870 --> 01:09:24,030
这块我就算是提完问了

1088
01:09:24,510 --> 01:09:26,250
接下来我们进入下一个环节

1089
01:09:26,250 --> 01:09:28,030
就是到了我们的下一个

1090
01:09:28,030 --> 01:09:31,470
应该是比较困难的一个内容

1091
01:09:31,470 --> 01:09:35,430
这个困难不是难在设计实现上面

1092
01:09:35,430 --> 01:09:39,910
而是难在这个理解和原理上面

1093
01:09:39,910 --> 01:09:42,750
这是同步固次的一个特点

1094
01:09:42,750 --> 01:09:45,870
它更多的需要你和笔和纸就能搞明白的

1095
01:09:45,870 --> 01:09:48,890
确实也不太需要像我们前面一定要去coding

1096
01:09:48,890 --> 01:09:51,130
但你把这个想明白也不太容易

1097
01:09:51,130 --> 01:09:51,870
因为这设计上什么

1098
01:09:51,870 --> 01:09:56,490
就是一个我们称之为并行编程

1099
01:09:56,490 --> 01:10:02,390
进行编程的一个设计

1100
01:10:02,390 --> 01:10:03,070
而并一编程

1101
01:10:03,070 --> 01:10:04,930
我一直强调说超级动物里面

1102
01:10:04,930 --> 01:10:06,410
其实正儿八经就碰了

1103
01:10:06,410 --> 01:10:09,150
我们现在还很少有课程去

1104
01:10:09,150 --> 01:10:09,710
设计到这一块

1105
01:10:09,710 --> 01:10:10,630
所以它是一个难点

1106
01:10:10,630 --> 01:10:13,370
希望大家能够把最后两盘课上好

1107
01:10:13,370 --> 01:10:15,990
能够把这一块能够处理得更加清楚

1108
01:10:15,990 --> 01:10:19,770
从能够应对我们最终的期末考试和检查

1109
01:10:20,570 --> 01:10:20,890
好

1110
01:10:20,890 --> 01:10:22,870
我们讲同步互斥这一块

1111
01:10:22,870 --> 01:10:24,970
那为什么要同步互斥

1112
01:10:25,750 --> 01:10:33,430
那首先要理解,进程线程怎么回事。我们以前在讲这一节之前,虽然我们建立

1113
01:10:33,430 --> 01:10:39,710
了线程,我们之前有进程,其实这个进程线程之间,他们之间共享信息不方

1114
01:10:39,710 --> 01:10:39,930
便。

1115
01:10:40,130 --> 01:10:44,970
我们前面说进程,共享信息和IPC,线程其实已经有了同样的一个地址

1116
01:10:44,970 --> 01:10:49,630
空间了,应该可以更方便,但这种怎么去方便这一块呢,我们并没有给出

1117
01:10:49,630 --> 01:10:50,970
一个有效的手段。

1118
01:10:50,970 --> 01:10:56,110
如果没有给一个有效手段的情况下,多个县城访问所谓的共享资源,简

1119
01:10:56,110 --> 01:11:00,070
单上说我们的共享资源就是一个全球变量,对全球变量的访问就会

1120
01:11:00,070 --> 01:11:00,750
出现一些问题。

1121
01:11:01,290 --> 01:11:08,990
如果这两个县城或者县城之间没有任何需要共享的资源的话,那么很好,它可以

1122
01:11:08,990 --> 01:11:10,030
有确定性。

1123
01:11:10,430 --> 01:11:15,030
相互之间不干扰,所谓的不共享意味着不干扰,所以它执行起来,

1124
01:11:15,150 --> 01:11:19,070
每次这个结果是确定的,可以重现,调入顺序不重要。

1125
01:11:19,890 --> 01:11:25,250
这是好处。但是不好的地方在于,你如果不共享的话,那么你之间各个进程之间

1126
01:11:25,250 --> 01:11:28,250
它能够共同完成的事情的能力就非常有限。

1127
01:11:28,650 --> 01:11:34,610
那如果共享了,你的能力增强了,但是就这三点来说会出现问题,会出现

1128
01:11:34,610 --> 01:11:38,310
不确定性,错误可能不可重现,或者很难重现。

1129
01:11:38,310 --> 01:11:41,390
这个是我们说碰到这个问题,为什么碰到这个问题呢?

1130
01:11:42,070 --> 01:11:47,110
就是在于我们对共享资源缺少一种有效的同步物资的机制来保

1131
01:11:47,110 --> 01:11:47,850
证它的正确性。

1132
01:11:49,710 --> 01:11:56,050
由于我们会在这个过程中不停地调度、切换现场,使得它执行这个序

1133
01:11:56,050 --> 01:11:56,610
列,

1134
01:11:56,610 --> 01:11:59,650
随时会被打断,执行下一个序列。

1135
01:11:59,950 --> 01:12:04,630
那么导致他们对同一个共享资源进行访问的时候,就会出现各种错误。

1136
01:12:05,090 --> 01:12:09,290
这简单举个例子,比如这个new PID,这什么时候做的事情?

1137
01:12:09,550 --> 01:12:14,490
这new PID就是给我们的新创建的进程申请一个新的PID,这就是new P

1138
01:12:14,490 --> 01:12:14,650
ID。

1139
01:12:15,830 --> 01:12:20,010
简单实现就是next PID,下一个PID++,这实际上就是我们通常给new P

1140
01:12:20,010 --> 01:12:24,490
ID,给一个新进程,设置新的PID的时候一个通常的做法。

1141
01:12:24,650 --> 01:12:30,750
看起来是一条指令,其实这是一条CC的语句,翻译成机器语言的话,其实

1142
01:12:30,750 --> 01:12:32,090
可能等于这么四条语句。

1143
01:12:32,890 --> 01:12:39,270
那4条鱼意味着什么呢?在这个每条鱼之间是可能会被切换出去的

1144
01:12:39,270 --> 01:12:42,810
一旦被切换出去的时候可能就会有些奇怪的现象发生,就是说这里面的现象

1145
01:12:42,810 --> 01:12:44,550
会出现

1146
01:12:51,190 --> 01:12:57,530
这里面看一下可能的bug或者错误

1147
01:12:57,530 --> 01:12:59,730
进程A和进程B我们都要执行

1148
01:12:59,730 --> 01:13:03,410
就是我们创建了两个进程

1149
01:13:03,410 --> 01:13:05,510
创建进程A 创建进程B

1150
01:13:05,510 --> 01:13:09,410
那么进程A和进程B在执行的时候

1151
01:13:09,410 --> 01:13:13,310
它们都会执行前面说的那个new PID

1152
01:13:13,310 --> 01:13:15,590
等于next PID++那么一个操作

1153
01:13:15,590 --> 01:13:17,850
那我们期望是进程A执行完之后

1154
01:13:17,850 --> 01:13:21,030
它的new PID会变成一个新的值

1155
01:13:21,990 --> 01:13:24,150
然后如果假设A先执行

1156
01:13:24,150 --> 01:13:25,290
B后执行的话

1157
01:13:25,290 --> 01:13:26,510
那比如new PID是100

1158
01:13:26,950 --> 01:13:29,330
那么进程B的new PID应该是101

1159
01:13:30,450 --> 01:13:31,890
C信号怎么回事

1160
01:13:31,890 --> 01:13:32,890
我们看一看

1161
01:13:32,890 --> 01:13:37,090
假订next PID是100

1162
01:13:37,090 --> 01:13:38,330
初始值的时候是100

1163
01:13:40,270 --> 01:13:44,370
那么load的next PID到继承器1里面去

1164
01:13:44,370 --> 01:13:46,830
再把继承器1复制给它

1165
01:13:46,830 --> 01:13:48,150
所以这一步完成之后

1166
01:13:48,150 --> 01:13:50,330
它就应该是100了

1167
01:13:51,070 --> 01:13:53,610
但是做完这一步之后

1168
01:13:53,610 --> 01:13:54,610
完成了一个切换

1169
01:13:54,610 --> 01:13:56,790
我们超级组有一某种原因

1170
01:13:56,790 --> 01:13:57,970
时钟到了等等

1171
01:14:27,970 --> 01:14:29,370
不一样 为什么不一样

1172
01:14:29,370 --> 01:14:31,030
是在于后面两步还没做

1173
01:14:31,030 --> 01:14:32,730
如果说这个执行是

1174
01:14:32,730 --> 01:14:33,850
这四步执行完毕之后

1175
01:14:33,850 --> 01:14:35,270
再去执行这一步

1176
01:14:35,270 --> 01:14:36,070
那不会有问题

1177
01:14:36,470 --> 01:14:38,210
因为像这四步连续执行

1178
01:14:39,490 --> 01:14:40,790
就是一板 这是一板

1179
01:14:40,790 --> 01:14:43,230
然后这个增加技能器

1180
01:14:43,230 --> 01:14:45,350
就变成101了 加了1

1181
01:14:45,350 --> 01:14:46,970
然后再把这个放到next PID

1182
01:14:46,970 --> 01:14:48,990
next PID已经变101了

1183
01:14:48,990 --> 01:14:49,670
然后在这时候

1184
01:14:49,670 --> 01:14:50,250
在过去的时候

1185
01:14:50,250 --> 01:14:51,810
load PID到技能器1的时候

1186
01:14:51,810 --> 01:14:54,810
这时候这是101复制给它

1187
01:14:54,810 --> 01:14:55,770
那么再计算出来

1188
01:14:55,770 --> 01:14:57,290
你这个new PID应该是101

1189
01:16:27,290 --> 01:16:29,430
做出一定的一些帮助

1190
01:16:29,430 --> 01:16:32,150
这里面我们又会引入一些新的硬件机制

1191
01:16:32,150 --> 01:16:34,470
很久没有引入这个新的硬件机制了

1192
01:16:34,470 --> 01:16:35,890
在这里面又会引入

1193
01:16:36,270 --> 01:16:37,290
大家到时候可以看一下

1194
01:16:41,750 --> 01:16:45,250
好,我们先看看日常生活中的同步故事的例子

1195
01:16:45,250 --> 01:16:47,770
是不是能做到所谓的原子操作

1196
01:16:47,770 --> 01:16:50,390
这里面取了一个日常生活中的例子

1197
01:16:50,390 --> 01:16:51,250
A和B

1198
01:16:51,250 --> 01:16:53,770
A和B是两位同学

1199
01:16:54,110 --> 01:16:56,950
他们有一个冰箱,在住在一个宿舍里面

1200
01:16:57,550 --> 01:16:59,310
然后他们睡觉睡得比较晚

1201
01:16:59,310 --> 01:17:00,170
3点钟起床

1202
01:17:00,170 --> 01:17:02,150
是下午3点

1203
01:17:02,990 --> 01:17:05,150
起床之后先看肚子饿了

1204
01:17:05,150 --> 01:17:06,650
看一下冰箱有没有面包

1205
01:17:06,650 --> 01:17:07,970
如果没面包怎么办

1206
01:17:07,970 --> 01:17:09,650
离家 离开家

1207
01:17:09,650 --> 01:17:11,570
应该离开宿舍去商店

1208
01:17:11,570 --> 01:17:12,570
购买面包

1209
01:17:12,570 --> 01:17:15,210
然后再把面包放到冰箱里面去

1210
01:17:15,210 --> 01:17:18,610
如果这个过程是原子操作

1211
01:17:18,610 --> 01:17:21,510
那么意味着这过程中不会被B干扰

1212
01:17:21,510 --> 01:17:22,210
那B还干什么

1213
01:17:22,210 --> 01:17:23,350
B还在睡觉

1214
01:17:23,350 --> 01:17:25,070
B到3点20之后睡醒了之后

1215
01:17:25,070 --> 01:17:25,750
再去查一下面箱

1216
01:17:25,750 --> 01:17:27,750
这时候面包已经放进去了 那就没问题

1217
01:17:28,570 --> 01:17:31,010
但是有可能在执行过程中它不是原子操作

1218
01:17:31,010 --> 01:17:35,110
在这一点B在3点10分的时候就已经醒了

1219
01:17:35,110 --> 01:17:36,690
B在3点10分醒的时候需要注意

1220
01:17:36,690 --> 01:17:40,570
A已经离开了家 离开了宿舍去商店了

1221
01:17:40,570 --> 01:17:43,750
所以B一样回去查看冰箱没有面包

1222
01:17:43,750 --> 01:17:46,930
他还很主动去买面包 这样会导致什么

1223
01:17:46,930 --> 01:17:49,910
买虫了 没有保证互刺性

1224
01:17:49,910 --> 01:17:52,510
没有保证只买一份面包 买了两份面包

1225
01:17:52,510 --> 01:17:55,310
这是问题 这我们看到一个很简单的问题

1226
01:17:55,310 --> 01:17:57,830
我们希望没有面包没关系

1227
01:17:57,830 --> 01:17:58,250
我去买

1228
01:17:58,250 --> 01:17:59,190
但我只买一份

1229
01:17:59,190 --> 01:18:00,650
想要达到这么一个效果

1230
01:18:00,650 --> 01:18:02,070
那怎么办

1231
01:18:02,070 --> 01:18:03,390
贝壳币怎么配合一下

1232
01:18:07,850 --> 01:18:10,010
加一个锁和钥匙

1233
01:18:10,010 --> 01:18:11,190
这有点土

1234
01:18:11,190 --> 01:18:13,670
但是还是有一定效果

1235
01:18:13,670 --> 01:18:16,090
去买面包之前我锁住冰箱

1236
01:18:16,090 --> 01:18:17,470
这个锁后面会引入

1237
01:18:17,470 --> 01:18:19,430
会经常用到这个lock

1238
01:18:19,430 --> 01:18:20,670
锁住冰箱

1239
01:18:20,670 --> 01:18:23,370
锁住冰箱拿走钥匙

1240
01:18:23,370 --> 01:18:30,610
这样,第二个人就搞定了,他就打不开冰箱了,但是你锁得比较狠,人家

1241
01:18:30,610 --> 01:18:36,930
可能不一定要喝牛奶都可以吃西瓜,你锁之后导致会其他问题出现,这里面

1242
01:18:36,930 --> 01:18:44,610
是有问题的,但是我们先把这个问题简单点,假的就是面包,那怎么办,我们还可以用

1243
01:18:44,610 --> 01:18:52,450
另外一个方式,不用锁,稍微温柔一点,用标签,购买之前留一个标签,

1244
01:18:53,410 --> 01:18:58,770
买完之后移除标签,别人看到标签就不去购买面包了,这非常友好

1245
01:18:58,770 --> 01:19:04,410
那怎么来看呢,写成程序的话很简单,先看看冰箱里面有没有这个

1246
01:19:04,410 --> 01:19:08,990
有没有面包,没面包我留个也没有标签,就证明没有人出去吧

1247
01:19:08,990 --> 01:19:10,550
那我就留个标签

1248
01:19:10,550 --> 01:19:15,110
留了标签之后我去买面包,然后最后买回来之后我再移除

1249
01:19:15,110 --> 01:19:16,910
标签,这看起来很正常

1250
01:19:18,110 --> 01:19:18,970
这种方式

1251
01:19:19,770 --> 01:19:20,850
可行吗

1252
01:19:20,850 --> 01:19:21,710
大家想想

1253
01:19:52,010 --> 01:20:01,770
有问题,因为这个方法并没有保证,并没有保证说我们一定会只买一次面包。

1254
01:20:01,870 --> 01:20:05,750
比如说,这里面把他想的一个进程的话,两个人还是两个人。

1255
01:20:05,750 --> 01:20:21,750
如果,诶,这写什么,如果多了个1,no bread,如果no bread,那么如果no,no note,我就看了也没有,

1256
01:20:22,990 --> 01:20:27,330
没有,这怎么解释啊,拿正常日常生活来解释。

1257
01:21:27,330 --> 01:21:30,730
这个操作和拿面包操作不是原子的

1258
01:21:30,730 --> 01:21:33,730
进程B去买面包之前和进程A通讯一次

1259
01:21:34,410 --> 01:21:35,570
对你这点很重要

1260
01:21:35,570 --> 01:21:37,550
进程A和进程B要通讯一次

1261
01:21:37,550 --> 01:21:39,330
这个通讯用的是note才通讯

1262
01:21:40,030 --> 01:21:41,650
用note才通讯

1263
01:21:43,170 --> 01:21:44,230
它是这么一个操作

1264
01:21:44,230 --> 01:21:45,270
第二个就是原子操作

1265
01:21:45,270 --> 01:21:46,550
这里面还没有原子操作

1266
01:21:46,550 --> 01:21:49,190
所以我们还达不到原子性

1267
01:21:49,850 --> 01:21:51,090
就是我们并不能保证说

1268
01:21:51,090 --> 01:21:53,050
在这个执行过程中

1269
01:21:53,050 --> 01:21:53,830
不会被打断

1270
01:21:53,830 --> 01:21:55,030
它可能会被打断

1271
01:21:57,410 --> 01:22:02,870
那我们改进我们的方法,这个看这个标签挡不住,那我把标签往前提,我

1272
01:22:02,870 --> 01:22:09,790
先留标签再判断,我先起来,我先留标签,那就先留标签再判断,有

1273
01:22:09,790 --> 01:22:17,590
没有面包,没面包,我再也没有我自己的,没有标签再买这个,这个有点逻辑的

1274
01:22:17,590 --> 01:22:25,830
问题啊,这个这个你留了标签,所以,所以你这一步肯定执行不了,所以什么,所以他这个

1275
01:22:25,830 --> 01:22:27,310
肯定不会执行这个买面包的问题啊,这个肯定不会执行这个买面包的问题啊,

1276
01:22:57,670 --> 01:23:05,390
我是二,我个人是第二个,然后看看有没有标签一,证明第一个人没有留标签

1277
01:23:05,770 --> 01:23:11,290
第二个没有留标签,那么也没有bread,我就去买面包,这看起来挺好,这又没什么

1278
01:23:11,290 --> 01:23:11,450
问题

1279
01:23:14,670 --> 01:23:16,310
大家看一下这个代码

1280
01:23:20,490 --> 01:23:28,170
这里面给了一个逻辑,是有问题的,进程A代表是它是标签,它是人1,

1281
01:23:28,750 --> 01:23:35,670
进程B是人2,那么我留了这个标签,我留了这个标签,留了标签,然后一

1282
01:23:35,670 --> 01:23:41,590
留标签就切换,这留了标签,可以切换,任何一点都可以切换,这里面可以切

1283
01:23:41,590 --> 01:23:46,230
换,在这可以切换,切到这去之后,在这立文之后马上又切回来,

1284
01:23:46,230 --> 01:23:52,670
填回来之后就会去判断,这里面判断的是,进程A判断的是note2,所以这里

1285
01:23:52,670 --> 01:24:00,030
是note2这一块,if no note2,有啊,现在已经留了一个了,所以他认为,你是不是应

1286
01:24:00,030 --> 01:24:06,690
该去了,我就不去了,他这个就不会自信,然后最后还要把这个给移掉,同理也是一

1287
01:24:06,690 --> 01:24:11,690
样,他这里面if no note1,这也不满足,所以他也不会去自信。

1288
01:24:11,690 --> 01:24:19,690
到什么两个人又在那饿了,这这这就是我们说又饿了的问题,OK,还是不行,你

1289
01:24:19,690 --> 01:24:28,110
气势把这标签取了一个标识是谁的标签,依然不能让两个进程去

1290
01:24:28,110 --> 01:24:32,930
买这个面包,这所谓的我们就算了就是大家都在饥饿了饥饿状态。

1291
01:24:37,290 --> 01:24:44,350
这个也不行,那还有什么办法?增加标签也不行。

1292
01:24:44,770 --> 01:24:45,910
这是给出来不行。

1293
01:24:47,110 --> 01:24:50,310
那么这里面第四个方案,第四个方案就是采取不同的处理楼槽。

1294
01:24:51,170 --> 01:24:54,790
什么叫不同?不同就在于这儿,一个是while,一个是if。

1295
01:24:55,470 --> 01:24:58,670
如果是while和if的话,好像ok。为什么这么说?

1296
01:24:59,070 --> 01:25:04,490
while你看这leaveNode1,leaveNode2,如果在这切了,那它确实会在这

1297
01:25:04,490 --> 01:25:10,130
10等,因为Node2留在这,我啥也不做,它是10等,并不意味着要往

1298
01:25:10,130 --> 01:25:17,590
后走,它走不下去,而在这来说,你Node1,那你事儿没错,这是if判断,

1299
01:25:17,910 --> 01:25:25,190
所以第一次的时候,注意,我说的第一次的时候,这个是有的,所以它这个if执行不了,是有N

1300
01:25:25,190 --> 01:25:28,650
ode1的,所以它会到这来,到这来之后,它会remove,

1301
01:26:29,410 --> 01:26:32,630
第一个,谁应该做外务,谁应该做衣服,不知道。

1302
01:26:32,970 --> 01:26:35,270
第二个,那我还有其他进程来,怎么办。

1303
01:26:37,230 --> 01:26:40,590
第三个,三个进程来做这个事情,怎么办。

1304
01:26:42,270 --> 01:26:43,350
更麻烦了。

1305
01:26:43,650 --> 01:26:48,510
所以它对于这个情况,对于我们现在说的简单情况是OK的。

1306
01:26:48,970 --> 01:26:51,530
但是应对简单情况它写得比较复杂。

1307
01:26:52,190 --> 01:26:56,170
而且A还是一个盲等,进程多了,还要处理起来更加麻烦。

1308
01:26:56,170 --> 01:27:02,250
这都使得这种方案四不够通用,不够有效

1309
01:27:02,250 --> 01:27:05,190
这是方案四起点被排除了

1310
01:27:05,190 --> 01:27:06,570
终于到了方案五

1311
01:27:06,570 --> 01:27:13,390
其实我们就想到了把锁给用好,是不是就OK了

1312
01:27:13,390 --> 01:27:16,590
如果我们能够通过锁保证某种互斥

1313
01:27:16,590 --> 01:27:19,210
前面我们说给冰箱加锁,锁有点大

1314
01:27:19,210 --> 01:27:21,950
如果我们只针对面包能加一个锁

1315
01:27:21,950 --> 01:27:35,830
就是这个,针对这个bread,我们说这个bread,对它这儿有一个lock和一个unlock,取面包,读

1316
01:27:35,830 --> 01:27:42,850
面包,我要加一个锁,我不取不读,我不吃它了,我要解锁,如果有这么两个保证的话,

1317
01:27:42,970 --> 01:27:47,950
针对这个面包加一个锁,它其实就会很简单,那这种什么的锁机制,但锁

1318
01:27:47,950 --> 01:27:50,150
机制其实到现在,我们才现在第一次接触。

1319
01:27:50,730 --> 01:27:58,250
锁机是基本的思路,就是在如果我拿到了这个锁,那么我可以对这个锁所管理的

1320
01:27:58,250 --> 01:28:01,650
那个共享资源进行操作,读或者写。

1321
01:28:01,870 --> 01:28:05,070
别的不能去操作,所以它就有什么互斥性。

1322
01:28:05,490 --> 01:28:10,790
我把这个操作做完之后呢,我会release这个lock。release这个lock之后呢,就可以其

1323
01:28:10,790 --> 01:28:17,350
他想拿到对这个共享资源进行读写操作的人呢,他就可以去通过拿锁。

1324
01:28:17,350 --> 01:28:20,530
你只有Release之后可能别人才会有机会去拿锁

1325
01:28:20,530 --> 01:28:23,430
拿锁之后再进行同样的复制处理

1326
01:28:23,430 --> 01:28:25,410
所以这里面需要复制

1327
01:28:25,750 --> 01:28:32,250
这种机制其实有一些实验方法可以做到

1328
01:28:32,850 --> 01:28:34,090
在讲这些实验方法之前

1329
01:28:34,090 --> 01:28:36,710
我们需要去理解一些基本的一些概念

1330
01:28:36,710 --> 01:28:38,350
把这些概念清楚之后就比较清楚

1331
01:28:38,950 --> 01:28:39,990
后续的讲解

1332
01:28:39,990 --> 01:28:43,530
第一个就是所谓的拿锁在哪

1333
01:28:43,530 --> 01:28:50,610
这段代码现在所谓的这个进入,进入这个区,entry section,就是这边比如说local file,

1334
01:28:51,390 --> 01:28:56,570
就是我要,这是入口点,我要能够进去,进去有一定的准入条件,不是说想进就是

1335
01:28:56,570 --> 01:29:01,330
能进的,如果想进就能进的话就达不到互测了,一旦我拿到了锁,我就可以进

1336
01:29:01,330 --> 01:29:07,570
入所谓的这个所谓的临界区,critical section,这个临界区呢就是访问共享资

1337
01:29:07,570 --> 01:29:12,470
源那段代码叫临界区,一旦你访问中央这边访问完了之后,你还

1338
01:29:12,470 --> 01:29:13,150
要退出去,

1339
01:29:13,530 --> 01:29:19,430
退出就像释放锁,因为你不退出,你一直拿着锁,别人没法访问,所以你

1340
01:29:19,430 --> 01:29:24,270
一定要退出之后,使得别的进程或者线程有机会去执行,所以这个是Lock

1341
01:29:24,270 --> 01:29:31,870
erRelease,然后在后面是Reminder这个section,跟这个共享队没关的一堆代码,ok,

1342
01:29:32,350 --> 01:29:37,390
这实际上是形成了我们把这个程序抽象之后,形成了这么一个结构,重

1343
01:29:37,390 --> 01:29:43,510
点是什么呢?是这三部分,entry section,critical section和exit退出section,

1344
01:29:43,530 --> 01:29:55,390
这三部分,OK。这个重点呢,我们想看看怎么去实现这个entry section和exit section,就是拿锁

1345
01:29:55,390 --> 01:29:57,310
和释放锁的一个操作过程。

1346
01:29:57,430 --> 01:30:03,950
其实前面我们讲的那些都是在讲各种拿锁和释放锁的一个可能的实现,

1347
01:30:04,170 --> 01:30:07,950
但都实现得不够好,那我们看看有没有什么办法能够做到。

1348
01:30:09,330 --> 01:30:17,110
那如果你做到了,那其实你会发现,在进入这个critic section的时候呢,这里面有一些特点,

1349
01:30:17,270 --> 01:30:24,610
什么特点呢,就是说第一个特点是空闲折入,如果谁都没有拿到锁,那么第一个

1350
01:30:24,610 --> 01:30:29,130
去拿锁的一定是锁是空闲的,肯定会进去。

1351
01:30:29,630 --> 01:30:34,790
就是在这query session里面没有任何的slide的话,那么就是空闲的,那么这时候就是空

1352
01:30:34,790 --> 01:30:36,730
闲,一定要把这个空闲折入

1353
01:30:36,730 --> 01:30:41,450
不会说在这儿没有人在这个query session里面,我还进不去,不会有这种情况,空

1354
01:30:41,450 --> 01:30:42,510
闲折入的意思

1355
01:30:42,510 --> 01:30:47,850
第二就是忙着等待,如果这次query session里面有一个slide,或者有一个process在执行

1356
01:30:48,490 --> 01:30:53,150
那就在忙嘛,忙着是共享之间,忙的话那其他的12%只能在那儿等

1357
01:30:53,150 --> 01:30:57,410
但等的两种应用是忙等,一种是slip等,不管哪种等都是等

1358
01:30:57,410 --> 01:31:03,110
所以,如果这里面有实在在执行的话,那么其他线能均不能进入里面去。

1359
01:31:03,830 --> 01:31:06,550
那么这个等呢,也需要注意一点,叫有限等待。

1360
01:31:06,890 --> 01:31:12,810
你不能说等了,那我就一直等,你总要给我一点机会,让我能够可以长点,可以短

1361
01:31:12,810 --> 01:31:16,410
点,但是不能无限等,所以这个叫有限等待。

1362
01:31:17,630 --> 01:31:21,210
第四个叫让权等待。第四个让权等待就是释放CPU,前面我说的

1363
01:31:21,210 --> 01:31:25,610
盲等就是不释放CPU,我如果实力不等,那就是释放CPU。

1364
01:31:25,610 --> 01:31:31,570
这就属于这个让权党,那我不一定非要让权党,是个可选,你如果觉得释放

1365
01:31:31,570 --> 01:31:34,750
这些比如说整体的系统性能更高,那我就让权党。

1366
01:31:34,890 --> 01:31:39,650
但如果我确实觉得这个critic section很快会结束,那我肯定选择盲的,这只是

1367
01:31:39,650 --> 01:31:43,770
一种选择策略,所以第四点是一个可选项。

1368
01:31:44,390 --> 01:31:50,050
这是一些访问规则,大家需要去理解。如果做不到这些访问规则,那说明你这个

1369
01:31:50,050 --> 01:31:54,730
entry section和exit section是有问题的,这是我们说的保证表互斥。

1370
01:31:55,150 --> 01:32:00,370
那怎么来做这一步呢?实际上我们有三种方法,这里面先介绍简单的

1371
01:32:00,370 --> 01:32:04,530
方法,禁用硬件中断,然后再介绍稍微复杂点的方法,基于软件的

1372
01:32:04,530 --> 01:32:10,230
解构。第三个呢,介绍一些更高级的一些抽象的方法,这样可以应对更复杂

1373
01:32:10,230 --> 01:32:10,830
的一些场景。

1374
01:32:11,030 --> 01:32:16,590
这是我们要讲的三类方法,先看第一类方法,禁用中断。这个大家都能够理解,

1375
01:32:17,210 --> 01:32:22,890
就是我们前面说通过时钟中断可以打断程序的执行,让它们去完成切

1376
01:32:22,890 --> 01:32:23,050
换。

1377
01:32:54,950 --> 01:32:59,570
它能够禁用硬件中断吗,有同学能回答一下吗

1378
01:33:02,630 --> 01:33:06,170
Yes,这个同学答得很不错,它是私聊的方式,大家看不到是谁

1379
01:33:07,590 --> 01:33:13,870
内核给个性能调用,很棒,就是我是用户程序得不到一些特权操作

1380
01:33:13,870 --> 01:33:17,430
那是用户台,但是我可以给内核发个性能调用

1381
01:33:18,330 --> 01:33:21,450
上面写的叫Enable Interrupt,这是FizzCore

1382
01:33:21,450 --> 01:33:28,610
发射性调整之后,可以说是让当前的应用程序就是屏蔽终端了,或者

1383
01:33:28,610 --> 01:33:29,670
叫disable终端了。

1384
01:33:29,790 --> 01:33:34,990
进入终端之后,接下来我的执行就可以进入零件区了。

1385
01:33:35,010 --> 01:33:39,510
进入零件区之后,执行完毕之后再发射性调整,叫做enable终端,

1386
01:33:39,630 --> 01:33:40,610
又恢复终端。

1387
01:33:41,390 --> 01:33:45,410
那就是离开零件区。进入零件区就是禁止终端,离开零件区就是死人

1388
01:33:45,410 --> 01:33:45,810
终端。

1389
01:33:46,250 --> 01:33:53,590
通过这种方式就很方便的就能够实现,就是对这个在用户台去支持

1390
01:33:53,590 --> 01:33:56,650
这个所谓的这个critic section里面

1391
01:33:56,650 --> 01:34:02,770
一旦我进去之后呢,就别人就进不去了,我就可以保证我能够访问这个

1392
01:34:02,770 --> 01:34:03,890
铃铁区了,OK

1393
01:34:03,890 --> 01:34:08,610
别人根本没法执行,这是一个非常有效的办法

1394
01:34:09,090 --> 01:34:15,250
但是,好像你看看我们的实验或者操作操作里面,有没有给应用程序提供这

1395
01:34:15,250 --> 01:34:19,970
种所谓的这两个系统调用呢?没有,这说明为什么?

1396
01:34:24,050 --> 01:34:31,010
因为我们内核不相信我们的应用程序能够用好这两个系统调用,万一

1397
01:34:31,010 --> 01:34:34,410
它长时间不释放,中断产生不了,

1398
01:34:34,410 --> 01:34:38,810
意味着内核没法对这个用户态正在运行的这个线程进行管理和

1399
01:34:38,810 --> 01:34:40,090
进程进行管理和控制了

1400
01:34:41,410 --> 01:34:44,430
你这个就就是这个权限太大了

1401
01:34:45,270 --> 01:34:47,230
所以这种这种方式呢

1402
01:34:47,230 --> 01:34:48,530
第一用户态权限太大

1403
01:34:48,530 --> 01:34:49,710
不太适合

1404
01:34:49,710 --> 01:34:50,730
那么第二个

1405
01:34:52,350 --> 01:34:53,090
第二个呢

1406
01:34:53,730 --> 01:34:56,090
就是它还有很重要的就是不适合什么

1407
01:34:56,090 --> 01:34:57,170
不适合多核

1408
01:34:57,170 --> 01:34:58,410
因为我disable中断

1409
01:34:58,410 --> 01:35:00,550
enable中断只是针对当前处理器

1410
01:35:00,550 --> 01:35:08,990
我可以disable、A、B、L、E或者enable,但是你还有其他处理器,第二个处理器,你

1411
01:35:08,990 --> 01:35:13,950
只能把自己给关掉,你不能关另外一个处理器,我做disable,当前的我正在

1412
01:35:13,950 --> 01:35:17,950
用这个处理器关掉,别的处理器没关掉,如果它要进入零件区,你也

1413
01:35:17,950 --> 01:35:23,830
挡不住,所以它只适合单核,不适合多核,由于金融中断之后线程

1414
01:35:23,830 --> 01:35:28,970
无法停止,所以整个系统都可能会处于一种比较不稳定状态,其他

1415
01:35:28,970 --> 01:35:30,410
线程都处于饥饿状态。

1416
01:35:31,090 --> 01:35:34,670
你完全取决于线程的一个合理设计,这是不一定靠谱的。

1417
01:35:34,770 --> 01:35:39,290
所以这点来说,我们现在还并没有这种金融中断和Enable中断这种所谓

1418
01:35:39,290 --> 01:35:39,710
的系统标语。

1419
01:35:41,210 --> 01:35:45,630
这是一种可能的方式,但是并不是一种合适的方式。

1420
01:35:46,230 --> 01:35:47,390
第二,技术软件的检查。

1421
01:35:49,950 --> 01:35:53,570
既然我们不能用这种超级软件来帮我们,那我们还有什么办法能够做的?

1422
01:35:53,610 --> 01:35:57,650
我们能不能在用户台就把这个事情搞定?可以想一想。

1423
01:35:58,770 --> 01:36:00,650
我们尝试一下,用后来能不能搞定

1424
01:36:03,190 --> 01:36:07,150
这就是一个tent,加了一个tent的这么一个东西

1425
01:36:07,150 --> 01:36:09,930
这个tent的东西干什么呢?这个tent的东西是说

1426
01:36:10,630 --> 01:36:14,670
表示tent等于i,就意味着tent等于i就是第i个

1427
01:36:15,690 --> 01:36:18,070
线程允许进入临界区

1428
01:36:18,070 --> 01:36:19,450
就这么一个意思

1429
01:36:20,170 --> 01:36:22,590
好,那如果这个意思的话,那么

1430
01:36:23,370 --> 01:36:26,250
我看看,那我们现在怎么来做

1431
01:36:26,250 --> 01:36:28,860
看这里面是一个一个处理方式

1432
01:36:29,430 --> 01:36:30,710
当他们不点i的时候

1433
01:36:30,710 --> 01:36:32,990
那就不是我的不是轮到我们

1434
01:36:32,990 --> 01:36:34,370
那我就在这等

1435
01:36:35,430 --> 01:36:36,270
然后呢

1436
01:36:36,270 --> 01:36:38,810
critic section 如果等于 i 了

1437
01:36:38,810 --> 01:36:39,690
那就我可以进去了

1438
01:36:39,690 --> 01:36:41,850
是轮到我了

1439
01:36:41,850 --> 01:36:42,650
OK 哎呀

1440
01:36:44,050 --> 01:36:45,450
现在下课时间

1441
01:36:45,450 --> 01:36:46,900
大家先休息五分钟

1442
01:43:08,830 --> 01:43:16,090
好,我们开始上课。刚才有一位同学告诉我,说他看那个Accord代码,

1443
01:43:16,310 --> 01:43:26,230
好像那个Fock也是只创建了一个当前的线程,

1444
01:43:26,230 --> 01:43:39,790
只複习了一个代表当前线程的task结构体到task list里面去

1445
01:43:39,790 --> 01:43:41,410
这个我再进一步看一下

1446
01:43:41,410 --> 01:43:45,470
课后我会在微信区里面给大家再做进一步的解释

1447
01:43:45,470 --> 01:43:50,730
也许我看太晚还没看对 我再看看 好吧

1448
01:43:50,730 --> 01:43:52,430
好 谢谢这位同学的一个提醒

1449
01:43:53,710 --> 01:44:01,330
好,那我们再继续这一块的内容,就是关于这个软件解决方法,常识1,

1450
01:44:02,130 --> 01:44:09,170
就是这个啊,这个就是在这句话,就是我们说这个Wire这句话呢,实际上是它的L

1451
01:44:09,170 --> 01:44:17,110
ock,我们说要进入业区前的就EntrySection,那么它的它那个退出那个Section在

1452
01:44:17,110 --> 01:44:17,650
哪呢?

1453
01:44:17,650 --> 01:44:23,970
在这儿,tent.j,tent.j是什么一个退出的sumption。

1454
01:44:24,410 --> 01:44:30,110
OK,那请问这样能保证互斥吗?

1455
01:44:32,810 --> 01:44:36,790
能保证互斥,因为轮不到它的话,它没法进的连接区嘛,

1456
01:44:36,850 --> 01:44:40,710
只有轮到它自己才能进的连接区,这不是可以满足的。

1457
01:44:40,870 --> 01:44:43,270
能不能满足刚才我们说到那个忙着等待呢?

1458
01:44:57,270 --> 01:45:03,150
这个忙则等待也能满足,如果这里面有的话,那别的进不来,因为这时候Tun

1459
01:45:03,150 --> 01:45:10,810
可能等于某个I了,但是有一点满足不了,如果空闲了,这个ClipSession里面没有

1460
01:45:10,810 --> 01:45:16,890
了,就没有线上的执行,如果空闲的话,因为空闲折入这一点做不到,为什么空闲之

1461
01:45:16,890 --> 01:45:17,630
后做不到呢,因为空闲折入这一点做不到,因为空闲折入这一点做不到,因为空闲

1462
01:45:18,830 --> 01:45:23,750
大家想一想 只考虑两个现场 一个叫TI 一个叫TJ

1463
01:45:25,050 --> 01:45:26,610
如果TI不在领解区

1464
01:45:27,810 --> 01:45:29,630
TJ想要迅速执行

1465
01:45:33,430 --> 01:45:38,150
那必须要等到TJ进入过领解区后才会去执行

1466
01:45:38,150 --> 01:45:41,630
这什么意思 大家想一想

1467
01:45:45,250 --> 01:45:53,050
Ti,这是Ti,我们就Ti和Tj两个线程,Ti还没有执行,但是turn等

1468
01:45:53,050 --> 01:45:57,530
于i,虽然turn等于i,但Ti没有执行,这是有可能的,因为我们现在你超过了

1469
01:45:57,530 --> 01:46:02,250
没有其他的一些线程存在,我要调过其他线程,所以Ti没有执行。

1470
01:46:32,410 --> 01:46:35,510
一旦有空,当然需要迅速执行,这样才能提高整个效率

1471
01:46:36,510 --> 01:46:39,810
第二个,我用了另外一个标记,叫flag

1472
01:46:41,810 --> 01:46:48,990
flag标记呢,比如flag i等于1的话,意味着它在连接区

1473
01:46:48,990 --> 01:46:51,450
flag i等于0的话,意味着它不在连接区

1474
01:46:52,090 --> 01:46:56,410
那这样来判断的话,还是两个进程

1475
01:46:56,410 --> 01:47:01,030
两个进程是对于TJR而言,我给你们来写

1476
01:47:02,310 --> 01:47:06,230
就是while flag i 看flag i 是否等于1

1477
01:47:06,230 --> 01:47:10,850
如果flag i等于1 意味着这个i现场正在执行

1478
01:47:10,850 --> 01:47:12,230
所以它就是一直在那儿盲的

1479
01:47:14,370 --> 01:47:21,810
如果不等于1了 意味着现在的critic section里面空的了

1480
01:47:21,810 --> 01:47:23,470
因为只有两个 空的了

1481
01:47:23,470 --> 01:47:25,450
所以我就会把这个我自己设成1

1482
01:47:25,450 --> 01:47:27,090
因为我能进的页区

1483
01:47:27,090 --> 01:47:30,410
然后就去critic section 然后做完之后再设成0

1484
01:47:30,410 --> 01:47:32,330
把自己设成0就出来了

1485
01:47:32,330 --> 01:47:33,990
需要注意它设的是自己

1486
01:47:33,990 --> 01:47:36,630
这是跟刚才的一个改变

1487
01:47:36,630 --> 01:47:39,210
这种方式有没有问题

1488
01:47:40,510 --> 01:47:41,410
大家想一想

1489
01:47:42,710 --> 01:47:44,370
出手情况下两个都是0

1490
01:47:44,370 --> 01:47:45,240
都没进去

1491
01:47:49,410 --> 01:47:52,010
出手情况两个都是为0的情况下

1492
01:47:52,010 --> 01:47:53,210
那会有什么问题呢

1493
01:47:53,830 --> 01:47:54,790
看看这是T

1494
01:47:54,790 --> 01:47:56,930
假设是Ti 这是Tj

1495
01:47:56,930 --> 01:47:57,970
OK我们可以说

1496
01:47:57,970 --> 01:47:58,790
我们还很重要一点

1497
01:47:58,790 --> 01:47:59,550
强调的是这里面

1498
01:48:59,850 --> 01:49:08,370
我们说这一点,就是第二个方法保证不了互赐,所以就我们前面说多买了面包,

1499
01:49:08,510 --> 01:49:11,050
这种情况就不是我们期望的,这就是有问题。

1500
01:49:16,370 --> 01:49:27,410
那我们再看看第三个方案,我把wile和复制给它换个格,跟前面相比,

1501
01:49:27,510 --> 01:49:33,350
我就是把它换了个格,前面是先wile再复制,现在我先复制在wile,这样

1502
01:49:33,350 --> 01:49:34,030
行不行?

1503
01:49:37,610 --> 01:49:42,010
我这里面就不抽同学了

1504
01:49:42,010 --> 01:49:43,210
那我就直接讲

1505
01:49:43,210 --> 01:49:46,770
这样你看看我们还是想拿任何一点可以切换

1506
01:49:46,770 --> 01:49:48,370
所以我先执行这一点

1507
01:49:48,370 --> 01:49:50,310
在这个地方进行了切换

1508
01:49:50,310 --> 01:49:51,750
切到这来执行

1509
01:49:51,750 --> 01:49:52,890
flag j等于1

1510
01:49:52,890 --> 01:49:54,370
然后flag i执行在这

1511
01:49:54,370 --> 01:49:55,270
flag i等于1

1512
01:49:55,870 --> 01:49:56,810
flag i等于1之后

1513
01:49:56,810 --> 01:49:58,010
在计划下执行

1514
01:49:58,010 --> 01:49:58,690
flag j等于1

1515
01:49:58,690 --> 01:49:59,990
在这是4等

1516
01:50:00,390 --> 01:50:03,150
然后切换回来到这来

1517
01:50:03,150 --> 01:50:07,290
flag I也等于他们俩都失当了

1518
01:50:07,290 --> 01:50:08,050
这两个失当什么意思

1519
01:50:08,050 --> 01:50:09,650
大家都进不进零件区

1520
01:50:09,650 --> 01:50:11,150
大家死在这儿

1521
01:50:11,150 --> 01:50:12,230
饥饿现象出现

1522
01:50:13,450 --> 01:50:14,390
即使是空闲

1523
01:50:14,390 --> 01:50:15,570
他也得不到满足

1524
01:50:17,810 --> 01:50:20,190
所以这个尝试又一次失败

1525
01:50:20,190 --> 01:50:21,210
这看出来什么呢

1526
01:50:21,210 --> 01:50:24,730
就是光靠单个flag或者tun好像不足以解决问题

1527
01:50:24,730 --> 01:50:25,990
我们有没有更好的办法

1528
01:50:26,910 --> 01:50:28,490
在1981年的时候

1529
01:50:28,490 --> 01:50:30,730
一位专机科学家叫Peterson

1530
01:50:30,730 --> 01:50:32,570
他提出了所谓的Peterson算法

1531
01:50:32,570 --> 01:50:36,370
非常巧妙的把這個Term和Flag結合在一起

1532
01:50:37,490 --> 01:50:38,930
就解決了這個問題

1533
01:50:38,930 --> 01:50:41,570
這個問題怎麼來做呢

1534
01:50:42,170 --> 01:50:45,670
你看這個Term表示應該誰進入營業區

1535
01:50:45,670 --> 01:50:48,890
Flag表示是否準備好進入營業區

1536
01:50:48,890 --> 01:50:50,090
說這麼一個事情

1537
01:50:53,490 --> 01:50:57,550
對於我們說這個EntrySection這一塊

1538
01:50:57,550 --> 01:50:59,850
這是EntrySection這一塊的一個代碼

1539
01:50:59,850 --> 01:51:01,730
這是退出Section的一塊代碼

1540
01:51:01,730 --> 01:51:09,450
退出很简单,我退出之后,我就是把我自己设成force,我现在没有准备好进

1541
01:51:09,450 --> 01:51:16,770
入零件区,如果我要进入区的话,就entry这个section的话,那我会把自己设成true,

1542
01:51:17,050 --> 01:51:17,930
表明我已经准备好了。

1543
01:51:18,650 --> 01:51:24,490
但准备好之后呢,我还靠一个turn,谦虚一下,你先进入,另外一个先进入零

1544
01:51:24,490 --> 01:51:27,870
件区,表示该另外一个线程进入零件区。

1545
01:51:29,230 --> 01:51:38,530
然后如果另外一个线程它自己也想进入,那么它就有可能这个条件是满足的,这个

1546
01:51:38,530 --> 01:51:44,250
flag j是满足的,然后turn也等于j,所以它就会在这儿会在那儿死

1547
01:51:44,250 --> 01:51:44,570
的。

1548
01:51:44,750 --> 01:51:49,410
因为我签让了一下,这种签让就有点像孔洪让的一样,就是我们说我先

1549
01:51:49,410 --> 01:51:54,010
让一下,虽然我准备好了flag i等于true了,但是我还是让一下。

1550
01:51:54,670 --> 01:51:59,870
那大家说是不是都会导致两个都进不去呢?不会,为什么这么说?

1551
01:52:00,310 --> 01:52:02,350
我们看一看

1552
01:52:03,830 --> 01:52:07,770
这是把这个代码展开了之后看到的效果

1553
01:52:07,770 --> 01:52:11,010
这是第一个进程,进程i

1554
01:52:12,130 --> 01:52:15,190
这是进程j,进程i进程j

1555
01:52:15,190 --> 01:52:20,010
那么我们一开始两个都想进去,没错,我都给它复生处

1556
01:52:21,050 --> 01:52:24,770
两个都是错了,做了一次切换,两个都是错了。

1557
01:52:24,870 --> 01:52:29,690
第二个,再做一次切换,一个是j,一个是i。

1558
01:52:29,830 --> 01:52:31,130
没错,我可以再做一次切换。

1559
01:52:33,130 --> 01:52:39,050
这个需要注意,flag是一个数组,所以flag0和flag1都可以为出。

1560
01:52:39,890 --> 01:52:46,670
但是这个turn是一个变量,这个变量到底是为i还是为j,

1561
01:52:46,670 --> 01:52:51,110
取决于这个线程先执行还是这个线程先执行

1562
01:52:51,110 --> 01:52:53,050
如果这个线程先执行的话

1563
01:52:53,550 --> 01:52:53,910
那么

1564
01:52:53,910 --> 01:52:55,890
这个后执行的话,那么这个turn应该等于i

1565
01:52:57,010 --> 01:53:00,210
如果它先执行的话,那么应该turn等于j

1566
01:53:00,210 --> 01:53:02,430
它后执行它turn等于j,所以

1567
01:53:02,430 --> 01:53:03,670
不管这种方式

1568
01:53:03,670 --> 01:53:06,630
turn只能为一个字,或者i或者j

1569
01:53:07,690 --> 01:53:09,330
OK,然后

1570
01:53:09,330 --> 01:53:12,210
再接下来才到了wild循环这一块

1571
01:53:12,210 --> 01:53:13,290
wild循环这一块

1572
01:53:13,290 --> 01:53:18,070
flag i 和 j 都可能为true,所以这个条件都能满足

1573
01:53:18,810 --> 01:53:22,290
但是接下来的这个条件只会有一个成功

1574
01:53:23,530 --> 01:53:29,030
后面执行的那个会成功,比如说这里面我后置行

1575
01:53:29,030 --> 01:53:33,810
我借后置行,我tun等于i,tun等于i,那它就是死循环了

1576
01:53:34,370 --> 01:53:37,150
但是你一旦把tun等于i复制完之后

1577
01:53:37,150 --> 01:53:42,470
再一次切换,切换到这来之后,tun不会是j了,tun是i了

1578
01:53:42,470 --> 01:53:46,690
那这个条件不满足了,所以它签样成功,签样成功之后,它会进入零

1579
01:53:46,690 --> 01:53:51,810
业区去执行,我说的借签样I成功,使得I有机会进入零业区

1580
01:53:51,810 --> 01:53:57,390
去执行,它签样早了,这个签样的晚,签样晚的有优势,这样签样早的

1581
01:53:57,390 --> 01:54:04,070
那个限制性,所以它就会去,query session会进去执行,而且只有一个,因为这里面只有一个

1582
01:54:04,070 --> 01:54:09,730
可能会满足,满足完之后呢,再会把这个flag I复成false,那意味着

1583
01:54:09,730 --> 01:54:11,990
这条件会不满足。

1584
01:54:11,990 --> 01:54:16,850
所以它进去的原因并不是靠这个turn,而是靠这个flag id与force

1585
01:54:16,850 --> 01:54:20,610
flag id与force之后呢,使得这个不满足了

1586
01:54:20,610 --> 01:54:24,850
所以它会撬出这个外循环去做这个quick exception

1587
01:54:24,850 --> 01:54:28,430
然后它做完之后再把它的flag j复正force

1588
01:54:28,430 --> 01:54:31,090
意味着现在谁都不在这个临界区

1589
01:54:31,090 --> 01:54:34,170
然后再次调度的话,还会出现同样的效果

1590
01:54:34,590 --> 01:54:40,330
所以这种pattern算法呢,通过非常巧妙的把这个flag和turn呢

1591
01:54:40,330 --> 01:54:45,390
结合在一起,实现了一个基于纯软件的一个算法。

1592
01:54:46,190 --> 01:54:54,010
OK,这是我们说这个Pilsen算法实现的一个大致的一个讲解。

1593
01:54:54,410 --> 01:55:00,650
那么后面还有一个叫Dekker的一个科学家,他也做了一个类似的算法。

1594
01:55:01,110 --> 01:55:04,450
这个算法我并不讲解,给出了一个比较详细的注释。

1595
01:55:34,630 --> 01:55:43,370
一个能否大家两个县城都跳出了这个外有循环进入了这个临界区,如果

1596
01:55:43,370 --> 01:55:46,190
都进去的话,这意味着是保证不了互斥。

1597
01:55:46,390 --> 01:55:52,330
还有一种情况是两个都进不去,两个都进不去,使得即使这里零元区

1598
01:55:52,330 --> 01:55:55,250
是空闲的,也没有人进得来,就是大家的饥饿。

1599
01:55:55,870 --> 01:56:00,690
如果你通过这种逻辑分析发现这两种情况都不存在,那意味着它就是

1600
01:56:00,690 --> 01:56:02,190
一个可行的解法。

1601
01:56:02,550 --> 01:56:07,850
这是大致的一个分析的过程,就像我刚才分析的一样,你要推出矛盾,

1602
01:56:08,610 --> 01:56:13,690
你可以假定说,如果他进来了,结果发现这里面哪地方会有矛盾,其实刚才也是用

1603
01:56:13,690 --> 01:56:16,270
了类似于反正法的方式来给大家做讲解。

1604
01:56:16,550 --> 01:56:22,290
这个我们已经给出了比较详细的一个描述,大家可以去看一下。

1605
01:56:24,110 --> 01:56:31,510
这是这一块,OK,那么前面讲的只是两个线程需要注意,前面讲的两个线程,

1606
01:56:32,110 --> 01:56:36,350
如果第三个线程来第三个线程怎么样,我们这个方法就不管用了。

1607
01:56:36,370 --> 01:56:41,550
所以我们还应该有更简陋的方法,是N个线程出现去保持互斥,其实

1608
01:56:41,550 --> 01:56:47,310
N个线程还是在我们这两个线程的基础之上进行扩展得到的一个

1609
01:56:47,310 --> 01:56:47,910
算法。

1610
01:56:50,550 --> 01:56:57,550
这两个科学家合在一起,设计了这么一个算法,就是n线程的软件保证

1611
01:56:57,550 --> 01:56:59,150
同步物次的一个算法。

1612
01:56:59,370 --> 01:57:08,290
那这个大致的ID是一样,它也有个turn,但是里面有很多线程,所以我要确保

1613
01:57:08,290 --> 01:57:16,050
在,比如说这个i是代表我这个线程i,我看应该怎么来说。

1614
01:57:47,610 --> 01:57:53,390
其实flag要设成一个相应的标记,这里面也是靠flag和turn来表明,turn是

1615
01:57:53,390 --> 01:57:58,030
一个变量,flag是一个宿主,这是它的一个大致实现。

1616
01:57:58,210 --> 01:58:07,830
那么这种idea稍微复杂一点在于哪,它有一个idle,wait和active的一个设计。

1617
01:58:07,990 --> 01:58:11,250
idle意思我根本就没有想进入我临界区,wait是什么呢?

1618
01:58:11,250 --> 01:58:17,730
位置是说,我现在等待进入连接区,而这个Active是我现在正在进入连

1619
01:58:17,730 --> 01:58:24,590
接区,一开始的时候,大家都是idle,然后再还有一个复杂的算法,这个算法也一样,我们

1620
01:58:24,590 --> 01:58:32,930
并不会讲解,那同学就问了,就是这个算法比刚才还要复杂,我怎么看,我

1621
01:58:32,930 --> 01:58:38,350
这个东西是给有兴趣的同学去看,如果你对它感兴趣,我鼓励你深入

1622
01:58:38,350 --> 01:58:39,930
去了解一下,看看怎么来做的。

1623
01:58:39,930 --> 01:58:44,930
如果你确实觉得我没有时间 马上就期末考试了

1624
01:58:45,710 --> 01:58:49,210
那你不看 我们也能够理解

1625
01:58:49,210 --> 01:58:53,810
你就知道大致的idea还是gbflag和这个称

1626
01:58:53,810 --> 01:58:58,830
一起来判断 来看看是否能够进入了业区

1627
01:58:58,830 --> 01:59:01,350
或者在这个前面这个entry section里面

1628
01:59:01,350 --> 01:59:03,070
就等在某个wire循环里面

1629
01:59:03,070 --> 01:59:07,110
这是一个他的一个做法

1630
01:59:07,110 --> 01:59:10,390
我们在里面不会做深入的讲解

1631
01:59:10,390 --> 01:59:12,310
就是这一块给大家刷了

1632
01:59:14,530 --> 01:59:16,290
最初就是看这

1633
01:59:16,290 --> 01:59:17,250
flag等于idle

1634
01:59:18,370 --> 01:59:19,870
表面我放弃了

1635
01:59:19,870 --> 01:59:23,250
turn它其实已经设成了下一个

1636
01:59:23,250 --> 01:59:25,130
你看这里面index等于turn加1了

1637
01:59:25,130 --> 01:59:26,830
所以它把这个等于index

1638
01:59:26,830 --> 01:59:28,450
把它交给了下一个

1639
01:59:29,170 --> 01:59:32,170
下一个如果下一个自己设成了

1640
01:59:32,170 --> 01:59:34,130
自己是该轮到我了

1641
01:59:34,130 --> 01:59:35,710
且它的flags weight的话

1642
01:59:35,710 --> 01:59:38,150
他们就会获得这个数

1643
01:59:38,150 --> 01:59:41,410
就像这么一个轮子转这么一个过程

1644
01:59:41,410 --> 01:59:43,330
就我们前面看到的

1645
01:59:43,330 --> 01:59:46,850
这么一个轮流团地的一个解决方案

1646
01:59:46,850 --> 01:59:48,450
就这么一个图

1647
01:59:48,450 --> 01:59:49,150
轮到我了

1648
01:59:49,150 --> 01:59:49,730
我做完之后

1649
01:59:49,730 --> 01:59:50,630
我给你传下一个

1650
01:59:50,630 --> 01:59:51,650
下一个再去

1651
01:59:51,650 --> 01:59:52,970
如果他下一个正在围艇的话

1652
01:59:52,970 --> 01:59:54,050
那就他就得到了

1653
01:59:54,050 --> 01:59:55,130
如果不是我一点挨斗的话

1654
01:59:55,130 --> 01:59:56,030
再找下一个

1655
01:59:56,030 --> 01:59:58,090
找了一个围艇就给他

1656
01:59:58,090 --> 02:00:00,110
这么一个大致的一个处理过程

1657
02:00:00,570 --> 02:00:00,930
OK

1658
02:00:00,930 --> 02:00:04,270
这就比较快速的讲解了这个翻二的方法

1659
02:00:04,270 --> 02:00:07,510
方二呢,我们看的是一种纯软件的方式

1660
02:00:07,510 --> 02:00:10,250
我们其实也没看他用超级组,他不需要超级组

1661
02:00:10,250 --> 02:00:16,550
我们如果应用程序的话,那其实在用不太就可以把这个问题给解决掉

1662
02:00:16,550 --> 02:00:21,090
而且我们也看到了一个n线程的一个执行方式

1663
02:00:21,090 --> 02:00:22,910
他也可以困难到n个线程

1664
02:00:23,850 --> 02:00:26,590
但是复杂性很明显摆在这儿

1665
02:00:26,590 --> 02:00:29,230
我为了进入业区,我要写这么一大段代码

1666
02:00:33,530 --> 02:00:41,870
这代代码的开销非常大 和我们前面讲的这个中段一条指令比起来

1667
02:00:41,870 --> 02:00:43,050
差多了

1668
02:00:44,210 --> 02:00:48,290
所以软件这么复杂的情况下 我们的硬件能不能帮忙 是我们接下来要考

1669
02:00:48,290 --> 02:00:49,270
虑的问题

1670
02:00:49,810 --> 02:00:54,810
我们希望其实通过硬件的帮忙 我们第一能够让这个问题简化 不要那么复杂 不要

1671
02:00:54,810 --> 02:00:55,430
那么忙的

1672
02:00:56,630 --> 02:01:03,110
第二,我们超级统可以帮助一下,通过超级统和硬件的一些支持,使得我们应用

1673
02:01:03,110 --> 02:01:09,410
程序写出这种通过物质代码更加简洁,更加容易简化,这是我们要去

1674
02:01:09,410 --> 02:01:10,170
干的事情。

1675
02:01:11,510 --> 02:01:19,670
OK,我们来做。再分一下这个锁,其实我们就是确实我们前面那一对所谓的Entry

1676
02:01:19,670 --> 02:01:26,250
Section和这个最后的Exit退出的Section其实都是干这两个事,就是一个获取

1677
02:01:26,250 --> 02:01:27,570
锁和释放锁。

1678
02:01:29,250 --> 02:01:35,450
我们的硬锁也就是一个看起来用起来很简单的东西,但实际上没那么

1679
02:01:35,450 --> 02:01:35,870
复杂。

1680
02:01:35,870 --> 02:01:41,150
那为什么我们不能有一些办法来做到这么简单的一个像中断一样的一种处

1681
02:01:41,150 --> 02:01:42,630
理方式呢

1682
02:01:42,630 --> 02:01:46,870
其实要做这种方式的话,需要什么来做,需要我们硬件来做支持

1683
02:01:46,870 --> 02:01:49,870
硬件要做支持的话,其实重点就是在于

1684
02:01:52,670 --> 02:01:56,690
读、修改、改、写回

1685
02:01:57,410 --> 02:02:02,830
这三步,就是这个new,比如说我这个c等于c加1

1686
02:02:02,830 --> 02:02:08,690
这就是读,把C读出来,对C做个修改,再把C写回去,C是一个内存单元。

1687
02:02:09,010 --> 02:02:13,870
这三步能形成一个原子操作,偏不讲原子操作吗?原子操作。

1688
02:02:14,150 --> 02:02:19,830
如果有这么一个类似这样的操作,其实我就可以实验非常简洁的lock,怎么做到的我

1689
02:02:19,830 --> 02:02:20,950
看看。

1690
02:02:24,170 --> 02:02:28,690
现在CPU其实已经提供一些硬件级的支持,我们称之为原子操作指令。

1691
02:02:29,230 --> 02:02:38,170
比如说这是一条指令,需要注意,它不是一段函数,是一条指令,这段函数是

1692
02:02:38,170 --> 02:02:42,370
对这条指令它的操作逻辑的一个表示而已。

1693
02:02:42,630 --> 02:02:47,350
什么叫Test and Set?从某个类型单元,这是一个类型单元,从类型单元读

1694
02:02:47,350 --> 02:02:50,590
一个值,看看该值是否为1。

1695
02:02:54,310 --> 02:02:59,510
如果它其实也就所谓的看不看得到指针返回的这个值，如果是1就返回1，是0就返回0

1696
02:03:20,930 --> 02:03:26,250
按照这种逻辑,如果数是1的话,保持1,这个写1没有,也就是一样效果,返

1697
02:03:26,250 --> 02:03:26,930
回1。

1698
02:03:27,170 --> 02:03:29,770
这是它的一个指令的一个含义。

1699
02:03:30,210 --> 02:03:35,290
那这个0是意味着什么?就是force,或者说这个锁是空闲的。1呢,就意味着这个

1700
02:03:35,290 --> 02:03:37,730
锁已经被人家用到了。

1701
02:03:38,570 --> 02:03:42,330
那有了这个一条指令之后,我们怎么来设计刚才的代码?

1702
02:03:42,970 --> 02:03:51,770
这就是设计,这就是一个我们说的进入零件区的代码,就一条了,不,两条,

1703
02:03:51,810 --> 02:03:56,050
一个Wire循环,很简单,但是这里面是一条指令,这个Wire是一条指令,T

1704
02:03:56,050 --> 02:04:03,850
itan Set,那么这个Lock是代表一个类型单元,那我们这个离开怎么做,离开就是这

1705
02:04:03,850 --> 02:04:10,610
条语,来做个Force,就是退出这个零件区之后要做的事情,就这么简单,为什么

1706
02:04:10,610 --> 02:04:12,310
能做到这么简单,就在于有这么一条特殊的指令,

1707
02:04:42,730 --> 02:04:48,170
说一开始为0的情况下,别的线程在访问这个内存单元之前只能等了,

1708
02:04:48,230 --> 02:04:53,650
等他把这个做完,等这个指令做完,这个指令会把它变成1才返回。

1709
02:04:54,330 --> 02:04:59,190
那下一个线程再去访问这个内存单元,用kss访问的时候,那么那个字已经是

1710
02:04:59,190 --> 02:04:59,830
1了。

1711
02:05:00,170 --> 02:05:04,570
1意味着什么呢?1意味着这个腕圈出不来了,这段死等了,这是一个盲等。

1712
02:05:04,970 --> 02:05:10,110
只有第一个看到这个lock为0的线程才能够继续自行。

1713
02:05:10,110 --> 02:05:14,310
OK,这就是所谓特殊源头,一旦有这个指令之后,我们前面的一大堆软

1714
02:05:14,310 --> 02:05:20,750
件那种方式都可以不用了,非常简洁,而且它是适合多核,它不像我们前面

1715
02:05:20,750 --> 02:05:25,450
说的那个屏蔽中断一样,它不适合多核,这个是适合多核的,这个是它的

1716
02:05:25,450 --> 02:05:32,070
一个好处,这是它的一个实现,我觉得就很简单的讲到,那么其实不光这种指令,还有

1717
02:05:32,070 --> 02:05:38,150
其他一些指令,比如说Compare Swap,它也是类似的,你看虽然我这细节,你看

1718
02:05:38,150 --> 02:05:39,890
这边,这个也稍微讲讲,

1719
02:05:39,890 --> 02:05:47,330
后面就不再讲,刚才示范什么意思呢,就是说比较一下,如果这个value和这个old相

1720
02:05:47,330 --> 02:05:55,910
等的话,value和这个old如果它相等的话,那么会让这个value等于新,那old什么意思,比如说

1721
02:05:55,910 --> 02:06:04,430
这log是0的话,new是1的话,那意味着前面这个value是0,那我现在锁是free

1722
02:06:04,430 --> 02:06:09,210
的,那我就会把它制成1,return to就成功了。

1723
02:06:09,210 --> 02:06:18,270
就是我置成1了,我拿到这个锁了,如果这个value已经是1了,这个old是0的话,那么

1724
02:06:18,270 --> 02:06:19,110
意味着我return false。

1725
02:06:19,430 --> 02:06:22,810
我现在这个值已经被别人拿到了,我就return false。

1726
02:06:23,810 --> 02:06:30,050
所以你看到这里面它正好有这么一个符号,通过这种方式呢,可以说也完成了

1727
02:06:30,050 --> 02:06:32,330
这种所谓的加速和解锁的功能。

1728
02:06:32,330 --> 02:06:39,130
跟刚才一样,一个while循环值,它是用一个反的,还是一个非,非这么一个操作,来

1729
02:06:39,130 --> 02:06:46,290
完成这么一个事情,OK,这也可以做到,那前提是这是一条指令,这是一条机器指令,

1730
02:06:46,770 --> 02:06:48,770
再明确一下,OK。

1731
02:06:54,710 --> 02:07:06,470
我这里面虽然保证了互视性,但是我如果一个线程对某一个变量,对这个,这

1732
02:07:06,470 --> 02:07:14,950
叫ABA问题,什么叫ABA问题呢,就是说,一开始这个变量为A,结果呢,我一个线

1733
02:07:14,950 --> 02:07:18,750
程,thread1,t1,对这个,对这个的变量为A,对这个的变量为A,对这个的

1734
02:07:18,750 --> 02:07:23,070
这个变量做了个修改,对这个全球变量共享资源,改成了B。

1735
02:07:23,230 --> 02:07:26,770
按道理来说,我T2就应该看到B了。

1736
02:07:26,910 --> 02:07:30,910
但是改完B之后,我T1继续又把它改回了A,

1737
02:07:31,750 --> 02:07:37,050
使得T2不知道它这个变量经历了一个,比如这个value,

1738
02:07:37,410 --> 02:07:40,310
经历了一个A、B、A的变化过程,看不到。

1739
02:07:40,930 --> 02:07:42,450
这就会出现一些浅淡的问题。

1740
02:07:42,990 --> 02:07:46,650
为了解决这种问题,我们一般来说会有这个变量,

1741
02:07:46,650 --> 02:07:55,570
可以这个value加一个版本,加个版本使得它能够对此有一定的区分

1742
02:07:55,570 --> 02:08:00,630
可能看出来不是都是没变的,这两个是没变的,在中间还变化了一下

1743
02:08:00,630 --> 02:08:03,650
这1、2、3就是版本号的问题

1744
02:08:03,650 --> 02:08:15,010
这个大家了解一下就行了,这种并不会作为一个深入讲解的话题给大家展开讲

1745
02:08:15,010 --> 02:08:15,190
解

1746
02:08:16,130 --> 02:08:23,930
OK,那既然有了這個所謂的這個用這種原子指令

1747
02:08:23,930 --> 02:08:25,530
TestSightSight,CombineSwipe這種東西

1748
02:08:25,530 --> 02:08:28,990
其實還有其他一些這個指令

1749
02:08:28,990 --> 02:08:31,530
這種並沒有全部介紹,只是介紹一部分

1750
02:08:31,530 --> 02:08:34,310
那麼可以實現所謂的這種自旋鎖

1751
02:08:35,190 --> 02:08:36,550
所謂的自旋鎖就是盲等鎖

1752
02:08:36,550 --> 02:08:39,390
因為它有個wild,它是不停的在探測它

1753
02:08:39,390 --> 02:08:40,410
不停的在執行它的語句

1754
02:08:40,410 --> 02:08:43,930
它並不會停下來,這就是盲等,或者叫自旋

1755
02:08:44,290 --> 02:08:47,990
Spin就代表转转圈嘛,这个转圈就意味着是一种所谓的那种自

1756
02:08:47,990 --> 02:08:49,290
旋的一个含义

1757
02:08:49,290 --> 02:08:53,250
那这就是我们通常说的是这种自旋锁的一个实现

1758
02:08:53,250 --> 02:08:57,030
那么这种自旋锁实现呢,需不需要超级统,大家想想

1759
02:08:57,030 --> 02:09:01,590
不需要,因为这是一条指令,这条指令并不是一条特权指令

1760
02:09:01,590 --> 02:09:04,530
就是Test and Set或者Companion Swap,不是一条特权指令

1761
02:09:04,530 --> 02:09:07,230
它可以在用户上实现,可以在用户上执行

1762
02:09:07,230 --> 02:09:11,810
所以既然这样的话,那么它就是一个,就是一个什么说的就是

1763
02:09:12,290 --> 02:09:17,910
不一定需要超级统就能够完成这种所谓的这个互斥的一个保证

1764
02:09:17,910 --> 02:09:19,770
这是这一块

1765
02:09:21,450 --> 02:09:24,830
但是如果一直在盲等的话 其实耗CPU耗的比较厉害

1766
02:09:24,830 --> 02:09:26,010
我们需要干什么呢

1767
02:09:26,010 --> 02:09:29,010
有时候还需要等一等 就是你能不能放弃一下

1768
02:09:29,010 --> 02:09:31,210
所以这里面所谓的放弃就是无盲等

1769
02:09:31,210 --> 02:09:33,910
能不能让它wait一下 把这CPU给放出来

1770
02:09:33,910 --> 02:09:38,890
大家需要注意 让CPU给其他处理器去执行

1771
02:09:38,890 --> 02:09:42,050
或者要让CPU给其他的线程性事情

1772
02:09:42,050 --> 02:09:43,950
那么从这换成T2

1773
02:09:43,950 --> 02:09:46,010
这个事情谁做 OS来做

1774
02:09:46,010 --> 02:09:48,390
所以要无盲等这种方式的话

1775
02:09:48,390 --> 02:09:50,730
那就需要我们的OS来引入了

1776
02:09:50,730 --> 02:09:53,170
所以OS会针对锁

1777
02:09:53,750 --> 02:09:55,490
会加一个等待对链

1778
02:09:55,910 --> 02:09:57,370
如果我等不到锁

1779
02:09:57,850 --> 02:10:00,210
我现在有进程在零件区

1780
02:10:00,210 --> 02:10:01,430
或现在在零件区

1781
02:10:01,430 --> 02:10:04,810
我其他的线程只好等在对链上面去

1782
02:10:04,810 --> 02:10:07,150
等待零件区退出之后

1783
02:10:07,150 --> 02:10:10,430
它把这个锁给释放之后呢 我从这个队列里面再唤醒它

1784
02:10:10,870 --> 02:10:14,910
这就是一个所谓的一个等待和唤醒的一个操作过程

1785
02:10:14,910 --> 02:10:17,950
而这个过程需要我们的OS介入

1786
02:10:18,470 --> 02:10:20,950
所以一定要实现这种方式的话 你会发现

1787
02:10:21,910 --> 02:10:24,830
这种纯用态的实现就不管用了

1788
02:10:24,830 --> 02:10:28,670
我们这个lock这个所谓的lock while的要进入内核

1789
02:10:28,670 --> 02:10:30,050
因为为什么要进入内核 你看

1790
02:10:30,630 --> 02:10:34,870
你要做这个要把这个当前的这个线程放到这个等待队列里面去

1791
02:10:34,870 --> 02:10:40,810
等待对列线程公司块这里面,都是内核里面结构,而且还要完成一次切换,

1792
02:10:41,210 --> 02:10:51,010
所以我这个Lock,比如我也叫一个Lock,加一个LockID的话,那么这个Lock是一个Sys

1793
02:10:51,010 --> 02:10:57,990
call,因为它自己在用台没法去做这种事情,它一定用Syscall的方式来帮

1794
02:10:57,990 --> 02:11:04,510
助我们的OS来完成这个获取数和释放数,这个可以纯用台。

1795
02:11:05,050 --> 02:11:14,530
而这个必须要类合它,这是我们说盲整锁和等待锁的一个区别,这个需要判

1796
02:11:14,530 --> 02:11:15,190
一下。

1797
02:11:17,310 --> 02:11:25,590
所以这种锁机制有它的好处,也有它的一些困难的地方。

1798
02:11:26,210 --> 02:11:32,150
特别是这种情况就是说,比如说盲整的方式就耗时比较厉害。

1799
02:11:32,470 --> 02:11:39,630
如果你处理不当的话,会出现说相间等待,或者相间都进不去,或者都进去

1800
02:11:39,630 --> 02:11:48,470
处理不当,说不当的情况下,那么会有这种情况,会出现死锁都进不去,

1801
02:11:48,810 --> 02:11:55,250
也有可能都进去了,就属于互试是达不到的,代码写得有问题,总之来说

1802
02:11:55,250 --> 02:11:59,350
就是它这个编程起来相对比较复杂,使用范围比较窄,它主要支持这

1803
02:11:59,350 --> 02:12:00,270
种互试操作。

1804
02:12:05,410 --> 02:12:08,270
好 那我就把这一部分给大家简单介绍完毕

1805
02:12:08,270 --> 02:12:10,350
这是三种方式

1806
02:12:10,350 --> 02:12:13,610
他们有他各自的适用范围和他们的一些特点

1807
02:12:13,610 --> 02:12:16,390
希望大家能够对他有一定的了解

1808
02:12:16,390 --> 02:12:18,810
特别是清楚就是我们现在说的支持

1809
02:12:18,810 --> 02:12:21,370
这个同步式是对谁同步式

1810
02:12:21,370 --> 02:12:23,650
是用户态的

1811
02:12:23,650 --> 02:12:25,250
在用户态执行的

1812
02:12:41,050 --> 02:12:48,210
这是我们要分析对它怎么去来通过静止中断软件方法或者锁来支持

1813
02:12:48,210 --> 02:12:51,130
有些用到了超级统的一些帮助

1814
02:12:51,130 --> 02:12:53,110
有些不用超级统的帮助都可以做到

1815
02:12:53,110 --> 02:12:55,230
有些用到硬件的原子指令的一些帮助

1816
02:12:55,650 --> 02:12:58,190
有些不需要用到硬件的原始指令

1817
02:12:58,190 --> 02:13:00,170
这都是不同的方式

1818
02:13:00,170 --> 02:13:01,810
大家需要去了解和掌握

1819
02:13:01,810 --> 02:13:05,770
这是关于同模同伺第一部分的内容

1820
02:13:05,770 --> 02:13:07,230
就给大家简单介绍到这

1821
02:13:09,050 --> 02:13:11,550
好 那我们再看一下第二部分 信号量

1822
02:13:11,550 --> 02:13:13,630
信号量是一个更加高级的

1823
02:13:13,630 --> 02:13:18,770
更加高级的一个同模同伺的一个机制

1824
02:13:18,770 --> 02:13:20,910
这个机制其实也很早起传

1825
02:13:22,210 --> 02:13:25,610
是迪杰斯克拉他在20世纪60年代就提出来了

1826
02:13:26,170 --> 02:13:26,990
主要用在什么呢

1827
02:13:26,990 --> 02:13:27,610
主要用在同步物资

1828
02:13:27,610 --> 02:13:29,570
因为他当时也设计了自己的OS

1829
02:13:30,090 --> 02:13:36,290
这个信号量实际上是核锁是算是一个level

1830
02:13:36,290 --> 02:13:38,370
但它比锁更加强大

1831
02:13:38,370 --> 02:13:39,070
更加强大

1832
02:13:39,070 --> 02:13:42,530
所以它可以到临界区去

1833
02:13:43,750 --> 02:13:45,090
这里面有同学又在提问

1834
02:13:46,070 --> 02:13:47,590
我欢迎同学提问

1835
02:13:48,010 --> 02:13:50,470
如果盲灯锁的wild因为每次做CGR

1836
02:13:50,470 --> 02:13:56,830
是不是和无盲灯锁就比较接近了

1837
02:13:56,830 --> 02:14:00,390
CCR 这取决于你的超级种实现

1838
02:14:00,390 --> 02:14:03,750
CCR的实现是把它挂到一个等待队里面去

1839
02:14:03,750 --> 02:14:06,510
还是把它挂在救需队的末尾

1840
02:14:06,510 --> 02:14:07,790
这是两种实现方式

1841
02:14:08,970 --> 02:14:12,970
挂救需队末尾实际上它还是是会缓一点

1842
02:14:12,970 --> 02:14:18,890
但它的开销会比挂在等待队里面会要稍微小一点

1843
02:14:19,350 --> 02:14:25,310
因为挂在等待队列里面,还涉及到一个从等待队列里面把这个线程

1844
02:14:25,310 --> 02:14:28,370
给放进去和拿出来的过程

1845
02:14:29,490 --> 02:14:33,170
以及从旧续队里面放进去和拿出来的过程,这个是两步操作

1846
02:14:33,170 --> 02:14:39,590
而对于我们说的刚才只是针对旧续队列做一个从头放到尾巴就这么

1847
02:14:39,590 --> 02:14:39,950
一个操作

1848
02:14:39,950 --> 02:14:42,110
相对来说开口会再大一点

1849
02:14:42,830 --> 02:14:44,530
这是两种实现方式

1850
02:14:44,530 --> 02:14:47,930
其实更合理的实现方式,对于这种通用超级统来说

1851
02:14:47,930 --> 02:14:51,010
我们应该把它放到就绪的等待队里面去

1852
02:14:51,810 --> 02:14:52,970
但无论那种方式

1853
02:14:52,970 --> 02:14:55,730
这种所谓的盲等不是真正的盲等

1854
02:14:55,730 --> 02:14:57,630
它其实还是放弃了处理器

1855
02:14:57,630 --> 02:14:58,890
主动放弃了处理器

1856
02:14:58,890 --> 02:15:00,250
因为掉了CCR

1857
02:15:00,250 --> 02:15:02,010
只是放弃处理器的等待时间

1858
02:15:02,010 --> 02:15:03,210
有长有短的问题

1859
02:15:03,570 --> 02:15:03,890
OK

1860
02:15:03,890 --> 02:15:07,310
我把一位同学的问题简单回答了一下

1861
02:15:09,210 --> 02:15:11,970
我们再说回这个信号量和锁

1862
02:15:11,970 --> 02:15:14,630
信号量和锁都是为了能够支持临界区

1863
02:15:14,630 --> 02:15:19,110
那零件区很重要的就是一个叫同步 一个叫互刺

1864
02:15:19,110 --> 02:15:21,910
这是两个东西 同步和互刺它都能够支持

1865
02:15:21,910 --> 02:15:26,890
而相对而言 信号量的支持更加全面和灵活

1866
02:15:26,890 --> 02:15:28,510
总的来说信号量是什么东西呢

1867
02:15:28,510 --> 02:15:31,730
前面我看到锁是一个内存单元

1868
02:15:31,730 --> 02:15:36,510
加上了一个wile循环或者是一个系统调用

1869
02:15:36,510 --> 02:15:39,990
来形成的一个对这个内存单元的一个原子操作

1870
02:15:39,990 --> 02:15:44,010
从而完成了一系列的互刺的保护

1871
02:15:44,010 --> 02:15:46,770
那么对于信号量而言 它也是一种数据结构

1872
02:15:46,770 --> 02:15:48,010
它也是一个整形

1873
02:15:48,010 --> 02:15:49,930
整形的取之范围并不是零和一

1874
02:15:49,930 --> 02:15:51,010
前面就是零和一

1875
02:15:51,530 --> 02:15:53,250
0代表现在没有人在零界区

1876
02:15:53,250 --> 02:15:55,510
1代表已经有人在零界区

1877
02:15:55,510 --> 02:15:57,790
这是很简单的零一操作

1878
02:15:57,790 --> 02:15:59,750
更适合表示互斥

1879
02:15:59,750 --> 02:16:01,450
但信号量它更加全面

1880
02:16:01,450 --> 02:16:02,390
它就是一个整形

1881
02:16:02,390 --> 02:16:04,990
而这个整形可以为附属

1882
02:16:04,990 --> 02:16:07,670
也可以为一个更大的正数

1883
02:16:08,790 --> 02:16:09,690
对于这个变量

1884
02:16:09,690 --> 02:16:13,430
它有两个对应的原子操作来对变量进行相应的

1885
02:16:14,550 --> 02:16:17,730
比如说这个P操作Prolag 荷兰语的意思

1886
02:16:17,730 --> 02:16:20,230
它代表的是减少这个Semaphore的值

1887
02:16:20,230 --> 02:16:23,590
就是SEM等于SEM-1

1888
02:16:23,590 --> 02:16:26,010
然后呢 做完这个简易操作之后

1889
02:16:26,010 --> 02:16:27,450
还有些会进一步判断

1890
02:16:27,450 --> 02:16:29,450
如果SEM小于0 只有等待

1891
02:16:30,830 --> 02:16:33,930
就等同于我们说放到等待队里面去了

1892
02:16:34,630 --> 02:16:35,650
否则就会继续

1893
02:16:35,650 --> 02:16:36,950
因为就意味着什么呢

1894
02:16:36,950 --> 02:16:37,950
如果不小于0

1895
02:16:37,950 --> 02:16:39,610
意味着现在这个资源还是够的

1896
02:16:39,610 --> 02:16:41,890
我可以继续进入林业区去执行

1897
02:16:43,070 --> 02:16:44,290
那这是一种情况

1898
02:16:44,290 --> 02:16:45,870
那v操作呢

1899
02:16:45,870 --> 02:16:47,450
SM对SM加1

1900
02:16:47,450 --> 02:16:50,230
如果加1之后你发现这个Semaphore是小1等于0的

1901
02:16:50,230 --> 02:16:53,810
那意味着一开始的Semaphore是等于至少是-1

1902
02:16:54,670 --> 02:16:55,930
那么那就意味着

1903
02:16:55,930 --> 02:16:58,310
至少是-1意味着有现成在那等

1904
02:16:58,850 --> 02:17:00,470
所以它会

1905
02:17:01,750 --> 02:17:03,790
如果小1等于0则进入等待

1906
02:17:03,790 --> 02:17:04,390
否则继续

1907
02:17:04,390 --> 02:17:07,130
这写错了 抱歉

1908
02:17:07,130 --> 02:17:10,810
如果小1等于0应该是要唤醒等待队列上的那个现成

1909
02:17:10,810 --> 02:17:16,770
让它去能够去尝试着是否能够继续执行

1910
02:17:17,810 --> 02:17:19,750
这是这句话写错了

1911
02:17:19,750 --> 02:17:20,930
这个是一个bug

1912
02:17:21,970 --> 02:17:24,170
就是Semaphore会相当于是要唤醒

1913
02:17:24,170 --> 02:17:25,930
把这个进入等待的这个

1914
02:17:26,490 --> 02:17:27,550
线程或者进程给唤醒

1915
02:17:27,550 --> 02:17:28,270
让它去执行

1916
02:17:28,270 --> 02:17:29,610
这是微操作要干的事情

1917
02:17:33,190 --> 02:17:34,230
如果是大于0的话

1918
02:17:34,230 --> 02:17:36,450
意味着现在没有线程等的这个

1919
02:17:36,450 --> 02:17:37,250
线程信号量上面

1920
02:17:37,250 --> 02:17:38,470
所以它会继续执行

1921
02:17:38,470 --> 02:17:40,110
这是对信号量的一个解释

1922
02:17:40,110 --> 02:17:42,390
那么这里有一个图怎么来解释呢

1923
02:17:42,390 --> 02:17:43,390
这个图是说

1924
02:17:44,590 --> 02:17:47,070
这个图是说这里面这个灯

1925
02:17:47,070 --> 02:17:48,590
这个信号灯就代表什么

1926
02:17:48,590 --> 02:17:49,990
代表这个变量

1927
02:17:50,690 --> 02:17:54,150
红灯意味着已经是小于0了

1928
02:17:54,150 --> 02:17:56,530
就这时候这里面这个信号量一开始

1929
02:17:56,530 --> 02:17:57,730
处值是2

1930
02:17:57,730 --> 02:18:00,150
所以第一辆车火车执行的时候

1931
02:18:00,150 --> 02:18:01,970
那三火减个1变成1了

1932
02:18:01,970 --> 02:18:03,270
第二辆火车再去执行的时候

1933
02:18:03,270 --> 02:18:05,590
这三火再去减1

1934
02:18:06,830 --> 02:18:09,430
就我看应该是三火应该处值之为

1935
02:18:40,250 --> 02:18:45,330
它会做什么,做加1操作,说这个时候负1加个1变什么,变成0。

1936
02:18:45,650 --> 02:18:50,710
如果三方小1等于0,意味着现在有这个线程,这个线程在那等,

1937
02:18:51,150 --> 02:18:55,130
所以它会把这个等待对线上的,针对这个信号量的,

1938
02:18:56,090 --> 02:19:01,990
等待对链上的那个线程给它换系,让它能够去进入零件区去执

1939
02:19:01,990 --> 02:19:02,150
行。

1940
02:19:02,390 --> 02:19:05,990
这就是我们说的一个,它大致的一个含义。

1941
02:19:05,990 --> 02:19:11,310
那这里面P操作 因为你会有一个等待 等待意味着阻射

1942
02:19:11,310 --> 02:19:15,830
V操作不会阻射 需要注意 V操作我只是换系 我自己不会阻射

1943
02:19:15,830 --> 02:19:19,170
然后这个PV操作是否是原子的

1944
02:19:19,170 --> 02:19:21,650
那实际上是由我们的超级桶 你的超级桶来实现的

1945
02:19:21,650 --> 02:19:29,030
因为PV是实验在内核里面的 不是说在应用台就像刚才那个盲灯

1946
02:19:29,030 --> 02:19:29,350
锁一样

1947
02:19:29,350 --> 02:19:33,170
在应用台就实现了 它是一个系统调用 它要进入内核来帮助它的

1948
02:19:33,170 --> 02:19:33,870
操作

1949
02:19:33,870 --> 02:19:37,010
而且通常情况下,我们认为信号量是公平的,所谓公平什么意思呢?

1950
02:19:37,110 --> 02:19:39,230
现成不会被无限期的组设在批准上面

1951
02:19:40,110 --> 02:19:45,250
你这里面总要除去,如果这不除去,那你的代码就有bug,不会无限期的组

1952
02:19:45,250 --> 02:19:45,710
设

1953
02:19:46,690 --> 02:19:50,430
而且假定信号量是按照等待的信号顺序来进行排队的

1954
02:19:50,430 --> 02:19:54,410
因为我们是等来对列嘛,所以先进来的可以排在对头,后进来的排在对

1955
02:19:54,410 --> 02:19:54,610
尾

1956
02:19:54,610 --> 02:19:58,290
所以可以自然有换系的时候呢,是按照从对头来一个一个的换系

1957
02:19:58,290 --> 02:20:02,630
那自然会满足一种所谓的先进先出的一个排序的一个公平性

1958
02:20:03,850 --> 02:20:10,450
这里面又留了一个问题,简单的问一下,我们前面讲的这个自选锁,就是基于C

1959
02:20:10,450 --> 02:20:17,750
AS或者Test and Set,Compare and Swap这种原子操作指令,它能否实现

1960
02:20:17,750 --> 02:20:18,630
先进先出。

1961
02:20:20,110 --> 02:20:26,270
有同学这里提了个小问题,我们这里面靠等待队也可以实现先出,我们这个自选

1962
02:20:26,270 --> 02:20:30,950
锁能实现先进先出这种效果吗?所谓的公平性能达到吗?

1963
02:20:32,090 --> 02:20:38,050
有同学能够回答一下吗

1964
02:20:38,050 --> 02:20:41,410
接近下课再给大家提两小问题

1965
02:20:44,530 --> 02:20:45,970
这里面的问题很多啊

1966
02:20:47,310 --> 02:20:49,290
你们不回答我也不回答

1967
02:20:49,290 --> 02:20:50,430
大家想一想

1968
02:20:50,430 --> 02:20:53,270
也许在某个时候需要大家回答

1969
02:20:54,430 --> 02:20:56,690
这是一个值得去思考的问题

1970
02:20:57,770 --> 02:20:58,210
好

1971
02:21:00,010 --> 02:21:05,690
有同学说不行,打个问号,那你还是不确定啊,到底行还是不行。

1972
02:21:06,710 --> 02:21:13,990
第一个,行还是不行,如果是根据我们考试的通常原则,行你要给一个理由,如果不行

1973
02:21:13,990 --> 02:21:15,590
你也要给个理由。

1974
02:21:15,810 --> 02:21:24,090
紧接着我还在问,如果不行的话,你能不能给出一种行的方案,也是数,也是盲

1975
02:21:24,090 --> 02:21:26,530
等,能不能给出一种行的方案。

1976
02:21:26,530 --> 02:21:29,710
这就是一个思考的问题

1977
02:21:29,710 --> 02:21:34,590
希望大家在课后能够有点时间思考一下老师在课上提的问题

1978
02:21:34,590 --> 02:21:37,550
因为时间有限 我们就往下讲

1979
02:21:37,550 --> 02:21:39,730
好 那我们还是讲这个信号量

1980
02:21:40,510 --> 02:21:42,070
那信号量怎么实现

1981
02:21:42,070 --> 02:21:44,670
前面那个靠tescent set这种原子操作来实现

1982
02:21:44,670 --> 02:21:45,330
加个wire讯号

1983
02:21:45,330 --> 02:21:47,330
这里面我怎么实现

1984
02:21:47,330 --> 02:21:48,770
这里面首先要明确一点

1985
02:21:48,770 --> 02:21:50,210
这是内核的每个数据结构

1986
02:21:50,210 --> 02:21:51,070
sample

1987
02:21:51,070 --> 02:21:52,530
这个结构放在哪

1988
02:21:58,530 --> 02:22:06,110
然后当我调了一个p操作,这是荷兰语,这我们一般用的是p,用的是down,减1

1989
02:22:06,110 --> 02:22:12,370
的意思,这用的是up,这英文,这是信号里面两个对应的一个字,那down的话,那么

1990
02:22:12,370 --> 02:22:21,550
我会把这个current,调这个的current,c,u,r的这个,它的这个进程的semaphore或者现成

1991
02:22:21,550 --> 02:22:22,510
的semaphore都会做一个减减操作

1992
02:22:22,510 --> 02:22:31,770
做检检操作,需要注意这个是属于一个共享资源,它本身也是一个在属于进

1993
02:22:31,770 --> 02:22:36,430
程里面的一个变量,变量的三万块减减,它就整形,如果这个三万块小

1994
02:22:36,430 --> 02:22:43,670
于零的话,会add this thread to Q,Q在哪,Q在这,把它加到这里面去,加到Q之

1995
02:22:43,670 --> 02:22:51,030
后呢,意味着它就当前的slide不会执行的,它会在block P,block T也应

1996
02:22:51,030 --> 02:22:52,490
该是block T,block T也应该是block T,

1997
02:22:52,490 --> 02:22:55,890
BlockT什么叫schedule一下

1998
02:22:55,890 --> 02:23:00,850
切换到切换下一个就续的thread去执行

1999
02:23:01,410 --> 02:23:05,150
所以这个BlockT实际上就是把自己设成主设状态

2000
02:23:05,150 --> 02:23:06,470
然后再schedule

2001
02:23:06,470 --> 02:23:10,710
这就是完成了一个所谓的一个等待的一个操作过程

2002
02:23:10,710 --> 02:23:12,930
当然如果Cemafor大于等于零

2003
02:23:12,930 --> 02:23:14,370
那就继续执行

2004
02:23:14,370 --> 02:23:15,010
回去就完了

2005
02:23:15,010 --> 02:23:17,330
就回到当前的线材继续执行

2006
02:23:17,330 --> 02:23:19,660
这是所谓的P操作的一个处理过程

2007
02:23:21,920 --> 02:23:27,620
好,那这个V操作怎么来做呢,Sample加加一下,这个整形加加一下,如果Sample小

2008
02:23:27,620 --> 02:23:34,280
一点于0,那么我们就一定是说这个Q里面会有一个会有等待的这个一个或多

2009
02:23:34,280 --> 02:23:41,700
个线程存在,那么换行比如说只换行一个,那换行最早的一个,当然如果我们还

2010
02:23:41,700 --> 02:23:46,640
想做一种措施,比如换行所有的挂在上面的那些线程,可不可以,可以啊,这是

2011
02:23:46,640 --> 02:23:47,880
另一种方案。

2012
02:23:48,340 --> 02:23:54,720
那如果有多个现场,大家再去重新去抢,看谁能抢到这个SIMUP,就看

2013
02:23:54,720 --> 02:24:00,000
谁先执行这个系统调用,做这个SIMUP检检,这是它的处理过程。

2014
02:24:00,260 --> 02:24:05,460
整个处理过程我们还是一样,是考虑单处理器这个情况,并没有把这个问题给

2015
02:24:05,460 --> 02:24:06,460
复杂到多数的情况。

2016
02:24:08,640 --> 02:24:12,800
好,这是一个P操作,这是一个V操作。

2017
02:24:42,800 --> 02:24:46,760
有没有可能虽然通过信用条用执行这个

2018
02:24:46,760 --> 02:24:47,900
在内壳里面执行这个操作之后

2019
02:24:47,900 --> 02:24:48,760
到这一点的时候

2020
02:24:48,760 --> 02:24:49,780
7.5剪剪的时候

2021
02:24:50,600 --> 02:24:52,300
产生了一次切换

2022
02:24:52,300 --> 02:24:54,200
切到了虽然的二执行

2023
02:24:54,200 --> 02:24:57,180
而虽然的二会执行这个7.5++

2024
02:24:57,180 --> 02:24:58,600
执行完7.5++这一步

2025
02:24:58,600 --> 02:24:59,500
还没执行EVE的时候

2026
02:24:59,500 --> 02:25:00,680
它又切回来了

2027
02:25:03,660 --> 02:25:04,580
到这来

2028
02:25:04,580 --> 02:25:06,000
会不会有这种情况出现

2029
02:25:07,300 --> 02:25:08,560
就是在这里面

2030
02:25:09,840 --> 02:25:11,880
做了多次的切换

2031
02:25:42,060 --> 02:25:46,000
超级种会保证,但是超级种怎么保证的?

2032
02:25:48,180 --> 02:25:50,900
这个紧接着我又提了个问题,观众段。

2033
02:25:53,400 --> 02:25:54,940
啊,这个同学说的有道理。

2034
02:25:57,460 --> 02:25:59,100
启发大家就是观众段。

2035
02:26:03,480 --> 02:26:06,400
内核里面能够观众段。

2036
02:26:08,580 --> 02:26:11,500
有同学说7号年不想振就行,我只是举个例子。

2037
02:26:11,880 --> 02:26:13,880
它一定有切换的时候影响这些的时候

2038
02:26:14,300 --> 02:26:18,080
因为这个sample本质来说会被多个现成都会访问到的东西

2039
02:26:18,080 --> 02:26:19,900
那意味着sample是一个共享的资源

2040
02:26:20,600 --> 02:26:21,120
咱们弄去

2041
02:26:21,880 --> 02:26:23,320
某种边界条件下

2042
02:26:23,320 --> 02:26:26,040
它就有可能,比如说这个sample简解,它就是3

2043
02:26:26,040 --> 02:26:29,180
我现在说一个证明操作是四条指令组成的

2044
02:26:29,180 --> 02:26:30,820
这有四条指令组成的

2045
02:26:30,820 --> 02:26:33,420
这四条指令中间我可以做切换,来回切

2046
02:26:33,420 --> 02:26:37,180
就跟那个newpid不一样了吗

2047
02:26:37,840 --> 02:26:39,780
newpid同样打同样的效果

2048
02:26:40,280 --> 02:26:40,980
那就会输出

2049
02:26:42,660 --> 02:26:46,980
OK 我提了问题 希望大家考虑一下

2050
02:26:47,620 --> 02:26:50,580
我给了一些 有朋友给了一些提示 这么一个

2051
02:26:51,540 --> 02:26:56,280
希望大家想一想 超级统凭什么能保证所谓的原子操作

2052
02:26:56,280 --> 02:26:58,820
把这么一个大操作变成原子操作

2053
02:26:59,820 --> 02:27:02,620
好 今天课就到这 谢谢大家

