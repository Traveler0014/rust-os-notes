1
00:00:11,920 --> 00:00:14,200
哟 放哪去了

2
00:00:14,200 --> 00:00:15,640
再見

3
00:00:53,240 --> 00:01:02,900
各位同学能听见我说话吗?我现在也不是很清楚,如果能听见的话,建议在聊

4
00:01:02,900 --> 00:01:10,740
天那写一个能,我看到有能了,挺好。这个聊天功能还是挺不错的。

5
00:01:11,280 --> 00:01:19,500
屏幕上我现在放的是一个四屏的,就是相当于是它是一页有两个,我不知道这样

6
00:01:19,500 --> 00:01:28,300
大家能不能看清楚,麻烦也在这个聊天里面有同学能不能说一下,如果能看清楚

7
00:01:28,300 --> 00:01:35,280
的话,我这次可以尝试一下用这种一页有四个的方式,这样,因为大家都对着屏

8
00:01:35,280 --> 00:01:38,900
幕嘛,所以看起来会容量更多一点,

9
00:01:38,900 --> 00:01:42,200
也可以更好地有一个前后的一个关联系

10
00:01:42,200 --> 00:01:46,500
所以我这样来做一下

11
00:01:46,500 --> 00:01:49,340
这样我觉得大家可能理解起来会更加好一点

12
00:01:52,680 --> 00:01:55,240
然后现在已经9点50了

13
00:01:55,240 --> 00:01:58,500
我们就开始上课

14
00:01:59,220 --> 00:02:00,700
确实由于疫情原因

15
00:02:00,700 --> 00:02:04,080
所以我们现在是线上上课

16
00:02:04,080 --> 00:02:06,560
这种方式以前也经历过

17
00:02:06,560 --> 00:02:08,780
所以大家也都不陌生

18
00:02:09,780 --> 00:02:12,320
我們就正式開始

19
00:02:14,040 --> 00:02:17,380
上一堂課我們講的是進程這一塊

20
00:02:17,380 --> 00:02:19,860
跟進程相關的內容就介紹完畢

21
00:02:19,860 --> 00:02:23,900
包含了進程的管理、進程的相關的調度等等

22
00:02:23,900 --> 00:02:28,980
還包括實際的一些操作項目中進程的一些處理

23
00:02:28,980 --> 00:02:34,760
進程其實已經成了我們一個很重要的資源的載體

24
00:02:35,580 --> 00:02:43,440
在前面章節裏面,我們還沒有提到一個很重要的內容,就是數據要放在一個

25
00:02:43,440 --> 00:02:46,680
持久保存的戒指上,這個數據怎麽也要管理起來。

26
00:02:47,080 --> 00:02:52,040
其實就涉及到我們這一次課的內容,就是文件系統這一塊。

27
00:03:23,180 --> 00:03:27,940
這個資源就是以文件的形式來呈現的

28
00:03:27,940 --> 00:03:29,980
這裡面是文件形式來呈現的

29
00:03:29,980 --> 00:03:32,220
我們大家其實都熟悉像這種圖

30
00:03:32,220 --> 00:03:33,500
我覺得大家都應該很熟悉

31
00:03:33,500 --> 00:03:38,160
無論是Windows Linux還是你們用過的一些操作系統

32
00:03:38,620 --> 00:03:42,380
這種文件目錄結構大家都看得很習慣

33
00:03:42,380 --> 00:03:44,020
但我們現在想關注的是說

34
00:03:44,020 --> 00:03:46,600
這個文件目錄結構是怎麼能夠去實現的

35
00:03:46,600 --> 00:03:48,660
這是我們需要注意的

36
00:03:48,660 --> 00:03:51,540
所以我們首先要講的是一個基本概念

37
00:03:51,540 --> 00:03:55,640
这基本概念里面主要是站在用户的角度

38
00:03:55,640 --> 00:03:59,960
应用的角度来看一下这个文件是具有什么样的一些特点

39
00:03:59,960 --> 00:04:06,020
然后再接下来我们会从这一块我们从设计开发的角度

40
00:04:06,020 --> 00:04:11,260
就是这一块其实已经讲到是说怎么去设计实现一个文件系统了

41
00:04:11,260 --> 00:04:16,680
在这个角度来看一下这个文件怎么能够呈现出来

42
00:04:16,680 --> 00:04:19,780
给我们应用去提供相应的一些服务

43
00:04:19,780 --> 00:04:22,960
这是我们第一节要讲的内容

44
00:04:22,960 --> 00:04:26,760
就是站在用户角度和站在内核实现角度

45
00:04:26,760 --> 00:04:29,680
两个角度来观察一下这个文件怎么回事

46
00:04:30,420 --> 00:04:32,520
这是第一节的主要内容

47
00:04:32,520 --> 00:04:36,220
那我们首先看一下这里面说文件和文件系统

48
00:04:36,220 --> 00:04:38,440
文件和文件系统 首先看文件

49
00:04:38,440 --> 00:04:39,360
当然我们可以知道

50
00:04:39,360 --> 00:04:41,200
很明显知道文件是文件系统的一部分

51
00:04:41,200 --> 00:04:42,740
但我们首先把文件拎出来

52
00:04:42,740 --> 00:04:45,520
因为这是我们和我们的进程直接打交道

53
00:04:45,520 --> 00:04:48,520
和我们应用直接打交道的一个资源

54
00:04:48,520 --> 00:04:51,080
那既然要打交道 这个资源怎么去表示它

55
00:04:51,080 --> 00:04:53,800
文件有相应的符号名字 这是一个

56
00:04:53,800 --> 00:04:57,180
文件的符号名字 还包括它的一些属性

57
00:04:57,180 --> 00:05:01,680
包括它什么呢 创建时间 它的这个类型等等

58
00:05:01,680 --> 00:05:04,040
这都是属于文件的这个原数据

59
00:05:04,040 --> 00:05:06,340
这些信息 其实我们都能够看到

60
00:05:06,340 --> 00:05:10,140
通过我们说显示文件的这个属性等等

61
00:05:10,140 --> 00:05:12,400
这都可以看到 这是一套

62
00:05:35,960 --> 00:05:39,620
文件系统其实包含了所有的这些文件的

63
00:05:39,620 --> 00:05:42,220
那么在文件系统里面呈现的就是

64
00:05:42,380 --> 00:05:43,800
一个所谓的普通文件

65
00:05:43,800 --> 00:05:46,220
我们通常看到的是普通文件

66
00:05:46,220 --> 00:05:47,120
就是这是一种方式

67
00:05:47,120 --> 00:05:48,600
第二种方式是目录文件

68
00:05:48,600 --> 00:05:50,180
这里面可以看出来我们通常说的目录

69
00:05:50,180 --> 00:05:51,680
也是一种文件形式

70
00:05:51,680 --> 00:05:53,760
而在Unix操作里面

71
00:05:53,760 --> 00:05:55,600
除了这两类最常见的之外

72
00:05:55,600 --> 00:05:58,440
我们还把其他一些资源表现成文件

73
00:05:58,440 --> 00:05:59,760
比如说我们的设备

74
00:05:59,760 --> 00:06:01,500
我们可以把设备变成文件

75
00:06:01,500 --> 00:06:05,160
我们还可以把网络传输也变成文件的方式

76
00:06:05,160 --> 00:06:06,260
来进行处理

77
00:06:06,260 --> 00:06:10,260
所以在Unix一个设计哲学里面说

78
00:06:10,260 --> 00:06:12,560
everything is fine,就是什么都是文件

79
00:06:12,560 --> 00:06:14,900
它主要是基于文件有一个读写属性

80
00:06:14,900 --> 00:06:17,800
使得我们可以把具有读写属性的资源

81
00:06:17,800 --> 00:06:20,160
都用文件的方式来进行表示

82
00:06:21,340 --> 00:06:22,920
这是一个比较有意思的一个特点

83
00:06:22,920 --> 00:06:24,140
是一切都是文件

84
00:06:27,040 --> 00:06:28,260
另一点也需要注意

85
00:06:28,260 --> 00:06:29,940
这文件的内容虽然它也是由

86
00:06:29,940 --> 00:06:31,580
比如说我们的字节来组成的

87
00:06:31,580 --> 00:06:33,640
但这个字节它的组成单位

88
00:06:33,640 --> 00:06:35,040
并不是一个单个的

89
00:06:35,040 --> 00:06:36,840
像我们在内存中访问的这个数据一样

90
00:06:36,840 --> 00:06:38,480
是单个的一个一个的byte

91
00:06:38,480 --> 00:06:40,680
而是一个一个的数据块

92
00:06:40,680 --> 00:06:43,300
这个数据块比Bit的容量要大一些

93
00:06:43,300 --> 00:06:45,320
这主要是应对到我们的存储介质

94
00:06:45,320 --> 00:06:49,120
它和RAM就是我们说的内存是不一样的

95
00:06:49,120 --> 00:06:50,480
内存是按字节选择

96
00:06:50,480 --> 00:06:52,720
但是对于我们的存储介质来说

97
00:06:52,720 --> 00:06:54,820
是以数据块来选择的

98
00:06:54,820 --> 00:06:55,800
数据块是一个抽象的概念

99
00:06:55,800 --> 00:06:57,460
对于具体的存储介质来说

100
00:06:57,460 --> 00:06:58,840
你可以是散区

101
00:06:58,840 --> 00:07:02,100
可以是一个SSD的一个块等等

102
00:07:02,100 --> 00:07:05,480
这都是一个说不同的处理方式

103
00:07:12,240 --> 00:07:18,260
既然你是对数据块进行处理,我们通常对数据块的处理方式有两

104
00:07:18,260 --> 00:07:21,820
个,一个是读文件,一个是写文件。

105
00:07:22,300 --> 00:07:27,200
读文件就是要把位于文件中的数据块从存储介质中,读到内存

106
00:07:27,200 --> 00:07:33,620
中来,写到相反的过程,把内存中的数据写回到数据块中去,这是

107
00:07:33,620 --> 00:07:36,560
大致的两个最基本的操作。

108
00:07:37,480 --> 00:07:42,580
但是由於這個磁盤是很大的,我們說後面以磁盤來代表存儲戒指,

109
00:07:42,720 --> 00:07:48,880
磁盤是很大的,你怎麽能夠定位到這個文件它的數據所在的數據塊

110
00:07:48,880 --> 00:07:50,120
的位置?

111
00:07:50,200 --> 00:07:55,680
這就需要一系列的一些處理,這裏面可以看到,我們說通過文件屬於某一個

112
00:07:55,680 --> 00:07:56,240
目錄,

113
00:07:56,460 --> 00:08:00,420
目錄裏面指向了一個文件,文件裏面還對應到它的一些數據塊,

114
00:08:00,920 --> 00:08:03,780
然後再具體哪個數據塊再把它寫進去,或者讀出來。

115
00:08:03,780 --> 00:08:08,580
这个过程其实是我们文件系统里面要去关注的

116
00:08:08,580 --> 00:08:09,780
就是它的一些基本操作

117
00:08:10,740 --> 00:08:17,260
即使是你在内存中你说我要读写文件的一个字节

118
00:08:17,260 --> 00:08:21,580
那其实也是要基于一个数据块的一个单位来进行操作

119
00:08:21,580 --> 00:08:23,600
这是需要说的一个内容

120
00:08:23,600 --> 00:08:28,140
这样的话也就意味着我们应该有一些有效的手段

121
00:08:28,140 --> 00:08:32,940
来避免这种不必要的数据的读或者写的操作

122
00:08:32,940 --> 00:08:38,120
这种通常意义上来说有一种很重要的优化技术,比如说延迟写、预先

123
00:08:38,120 --> 00:08:47,140
读等等,这都是为了能够减少这种所谓的磁盘上操作的次数,这个是

124
00:08:47,140 --> 00:08:48,940
后面讲优化的时候会给大家提到。

125
00:08:57,280 --> 00:09:03,100
那么在下面讲这个具体的这个访问呢,也需要注意一下,这个访问的方式有很多种,

126
00:09:03,200 --> 00:09:10,000
就是文件的访问方式,比如说有顺序访问、随机访问、读音访问,但是从

127
00:09:10,000 --> 00:09:15,520
文件本身的组织结构来说,其实文件它是一个,我们说是一个字节流,字

128
00:09:15,520 --> 00:09:18,920
节流,所以它里读是按照这个顺序读的,所以它里读是按照这个顺序读

129
00:09:48,920 --> 00:09:51,960
這個index會指向一個這個文件的一個位置

130
00:09:51,960 --> 00:09:55,420
那我通過讀這個位置知道它在第二個文件裡面

131
00:09:55,420 --> 00:09:58,000
從這開始讀或者寫操作

132
00:09:58,000 --> 00:10:00,100
那這所謂的這個鎖印訪問

133
00:10:00,100 --> 00:10:03,000
這也是通常屬於故宗的一些處理方式

134
00:10:03,000 --> 00:10:07,040
這就是所謂的這個訪問模式的一個簡單介紹

135
00:10:07,040 --> 00:10:09,340
然後在文件內部裡面呢

136
00:10:09,340 --> 00:10:13,380
早期的文件其實它裡面都可以有相應的一些數據結構

137
00:10:13,380 --> 00:10:19,500
比如说是JSON这种类似的这种结构化的一些数据

138
00:10:20,140 --> 00:10:24,040
然后OS就要负责对这个结构化数以进行一个解释

139
00:10:24,040 --> 00:10:25,480
那这是早期的一种处理方式

140
00:10:25,480 --> 00:10:28,960
那这种方式由于文件的类型会越来越多

141
00:10:28,960 --> 00:10:29,900
越来越复杂

142
00:10:29,900 --> 00:10:33,580
把这些负担全加一个OS是一种不是特别合适的方式

143
00:10:34,240 --> 00:10:36,840
所以后面就把这个对文件内容的解析

144
00:10:36,840 --> 00:10:41,220
具体内容是JSON是CSV或者其他比如word等等

145
00:10:41,220 --> 00:10:43,180
这些内容解析放给应用程序

146
00:10:43,180 --> 00:10:47,220
OS只是把这个文件看成我们正面说的一个字节流

147
00:10:47,220 --> 00:10:48,560
就是一个字节流

148
00:10:48,560 --> 00:10:53,780
这种字节流的话使得OS在处理文件内容的时候会更加简单

149
00:10:53,780 --> 00:10:55,940
然后我们的应用

150
00:10:55,940 --> 00:10:58,660
你具体要去读哪种格式的文件

151
00:10:58,660 --> 00:11:01,040
把内容给解析出来

152
00:11:01,040 --> 00:11:02,500
那是由应用来负责

153
00:11:03,180 --> 00:11:08,560
这是在内部的结构上面的应用和OS的分工

154
00:11:08,560 --> 00:11:09,980
这是在这一块

155
00:11:10,960 --> 00:11:14,400
然后再看另一方面就是

156
00:11:14,400 --> 00:11:18,320
其实文件是放在Disk上面的

157
00:11:18,320 --> 00:11:19,980
所以Disk上面是一个

158
00:11:21,060 --> 00:11:22,020
是一个大家可以

159
00:11:22,720 --> 00:11:26,560
不同进程可以共享的一个资源

160
00:11:26,560 --> 00:11:27,720
既然是共享资源

161
00:11:27,720 --> 00:11:30,120
只要是共享就会涉及到一些安全问题

162
00:11:30,600 --> 00:11:32,060
就是我这个用户

163
00:11:32,060 --> 00:11:34,120
user1创建的这个文件

164
00:11:34,120 --> 00:11:35,980
允不允许给user2读

165
00:12:06,000 --> 00:12:09,560
这都是记录在这个文件的原数据里面的

166
00:12:09,560 --> 00:12:11,980
那么形成一个所谓的文件访问控制表

167
00:12:11,980 --> 00:12:19,840
那么当这个用户通过某个进程来访问这个文件的时候

168
00:12:19,840 --> 00:12:23,420
他就会去判断一下

169
00:12:23,420 --> 00:12:27,100
看看这个进程所属的用户是否是同一个用户

170
00:12:27,100 --> 00:12:28,860
就是owner还是说是一个group

171
00:12:28,860 --> 00:12:33,140
从而可以根据owner和group的权限

172
00:12:33,140 --> 00:12:36,040
来决定它这次访问是否是被允许的

173
00:12:36,040 --> 00:12:38,540
这有所谓的文件安全访问控制的一个问题

174
00:12:39,440 --> 00:12:41,340
Unix里面就是这种方式

175
00:12:41,340 --> 00:12:46,060
就是我想这个其实大家应该也比较容易看到

176
00:12:46,060 --> 00:12:48,340
随便举个例子在这里面

177
00:12:54,500 --> 00:12:55,420
这个比较

178
00:12:56,980 --> 00:12:58,300
这是Linux里面的

179
00:12:58,300 --> 00:13:00,020
比如说到Temp目录下

180
00:13:01,060 --> 00:13:08,280
你看这里面的文件基本上就是Owner,这是Owner是谁创建的,它的属性,比如

181
00:13:08,280 --> 00:13:15,020
说这里面代表RWX就是读写执行,具有这个属性,这些代表属于同

182
00:13:15,020 --> 00:13:24,320
一组的和其他用户对这个特殊的,这是一个目录,地代表目录,对特殊

183
00:13:24,320 --> 00:13:26,680
的目录不具有这种访问权限。

184
00:13:26,680 --> 00:13:31,140
这是一个典型的一个在Linux里面看到的一个情况

185
00:13:31,140 --> 00:13:33,960
我觉得这个是比较直观的一个展现

186
00:13:35,500 --> 00:13:39,200
好 这是关于这个我们说这个安全这一块的一个介绍

187
00:13:43,260 --> 00:13:44,800
那么除了安全之外

188
00:13:44,800 --> 00:13:50,740
还有一点是这个所谓的这个访问的一个共享访问的一个权限

189
00:13:50,740 --> 00:13:52,080
假设我们允许它共享

190
00:13:52,080 --> 00:13:53,380
那其实也需要一些考虑

191
00:13:53,380 --> 00:13:58,040
就是當兩個進程訪問同一個文件的時候

192
00:13:58,040 --> 00:14:00,280
如果都對它進行寫操作的話

193
00:14:00,280 --> 00:14:03,480
其實不做相應的處理它會有一些問題

194
00:14:03,480 --> 00:14:07,620
這裡面涉及到所謂的一些同步互斥的一些操作的一些約束

195
00:14:07,620 --> 00:14:08,720
或者一些技術

196
00:14:08,720 --> 00:14:11,900
這些技術我們在後面會給大家講解

197
00:14:11,900 --> 00:14:13,940
這裡面我們就不展開講解

198
00:14:13,940 --> 00:14:15,420
就想大家知道

199
00:14:16,020 --> 00:14:17,520
文件是一種共享資源

200
00:14:17,520 --> 00:14:18,720
既然是共享資源

201
00:14:18,720 --> 00:14:22,780
那多个进程怎么有效准确的

202
00:14:22,780 --> 00:14:24,680
就是正确的访问这个共享资源呢

203
00:14:24,680 --> 00:14:26,800
也是一个需要重点关注的问题

204
00:14:26,800 --> 00:14:28,420
这在我们后面讲同步勿斥的时候

205
00:14:28,420 --> 00:14:29,760
会专门讲解他们的内容

206
00:14:32,560 --> 00:14:35,200
好 那简单来说

207
00:14:35,200 --> 00:14:36,100
我们这边简单来说

208
00:14:36,100 --> 00:14:37,720
对于共享访问这种情况呢

209
00:14:40,100 --> 00:14:41,240
我们对于文件而言

210
00:14:41,240 --> 00:14:43,820
当你就是打开一个文件

211
00:14:43,820 --> 00:14:45,400
然后对它进行写的操作

212
00:14:45,400 --> 00:14:45,980
写完之后

213
00:14:45,980 --> 00:14:47,180
在关闭文件之后呢

214
00:14:47,580 --> 00:14:54,500
其实你关闭之后,意味着这些数据就可以给其他的用户能看到了

215
00:14:54,500 --> 00:14:59,900
这点就是我们通常的文件系统的一种语意,就是怎么去访问

216
00:15:00,380 --> 00:15:02,920
我们的访问基本上是有这么一个流程

217
00:15:04,660 --> 00:15:08,500
我们看到的是叫做Open,打开一个文件

218
00:15:08,500 --> 00:15:10,620
打开一个文件之后,它进行什么?

219
00:15:11,340 --> 00:15:13,180
读或者是写

220
00:15:13,960 --> 00:15:17,100
读和写就是对文件内容进行相应的操作

221
00:15:17,100 --> 00:15:19,880
特别是写操作 当你写完之后呢 还有close

222
00:15:21,260 --> 00:15:27,740
这几个是我们说文件系统的一个最基本的操作语意

223
00:15:27,740 --> 00:15:30,400
你只有打开文件之后才能对文件进行读写

224
00:15:31,100 --> 00:15:34,900
把它关闭之后呢 才能确保别的文件能够看得到它

225
00:15:34,900 --> 00:15:40,920
这就是我们说的关于文件共享访问的一些基本语意的一个内容

226
00:15:40,920 --> 00:15:49,820
OK,既然我们提到了打开、Open、Read、Write、Close这几个基本的操作的步骤

227
00:15:49,820 --> 00:15:53,740
那我们可以看看我们的应用程序怎么来访问文件

228
00:15:53,740 --> 00:15:55,560
是不是按照这个方式来访问

229
00:15:55,560 --> 00:15:56,980
其实这里面已经列出来了

230
00:15:56,980 --> 00:16:00,020
像这里面给了个片段

231
00:16:00,460 --> 00:16:04,380
就是我如果要读一个文件的话

232
00:16:04,380 --> 00:16:05,860
首先我要知道文件名

233
00:16:05,860 --> 00:16:07,460
这是文件名字

234
00:16:07,460 --> 00:16:08,600
这个文件名字到之后

235
00:16:08,600 --> 00:16:10,980
根据文件名用,我可以打开

236
00:16:11,340 --> 00:16:12,440
Open这个性能调用

237
00:16:12,440 --> 00:16:14,640
然后这个性能调用会得到一个FD

238
00:16:14,640 --> 00:16:16,460
这个FD实际上是一个

239
00:16:16,460 --> 00:16:18,540
整形的竖

240
00:16:18,920 --> 00:16:20,040
然后这个整形竖

241
00:16:20,800 --> 00:16:22,780
这就代表一个文件了,可以做相应的

242
00:16:22,780 --> 00:16:24,320
读操作,读完之后

243
00:16:24,320 --> 00:16:26,680
最后关闭,就像你整个

244
00:16:26,680 --> 00:16:28,560
对这个文件读写的一个过程

245
00:16:28,560 --> 00:16:31,440
就结束了,这是最通常的

246
00:16:32,460 --> 00:16:33,680
在应用层

247
00:16:33,680 --> 00:16:35,480
对我们文件操作的

248
00:16:35,480 --> 00:16:36,440
一个过程

249
00:16:36,440 --> 00:16:39,000
这里面就看到很重要的一个信息是FD

250
00:16:39,000 --> 00:16:41,240
它并没有是基于名字来访问

251
00:16:41,240 --> 00:16:44,120
它是基于FD来访问 为什么基于FD呢

252
00:16:44,120 --> 00:16:47,740
其实这个FD是在我们内核里面的一个索引

253
00:16:47,740 --> 00:16:50,060
这里面看 这里面就这个东西

254
00:16:50,060 --> 00:16:51,400
这叫文件描述符

255
00:16:51,400 --> 00:16:54,320
它就是一个 我们说一个整形 IDX

256
00:16:54,320 --> 00:16:56,080
是一个索引字

257
00:16:56,080 --> 00:16:57,640
这个IDX为什么是索引字

258
00:16:57,640 --> 00:17:00,040
你看这里面它有个文件描述符的一个表

259
00:17:00,040 --> 00:17:02,640
而这个表属于我们的进程控制块

260
00:17:02,640 --> 00:17:05,580
PCB 进程控制块里面很重要的一个内容

261
00:17:07,740 --> 00:17:13,700
这个表里面就是代表进程当前打开的哪些文件来进行相应的操

262
00:17:13,700 --> 00:17:13,920
作

263
00:17:13,920 --> 00:17:15,200
有这么一个记录

264
00:17:15,700 --> 00:17:21,740
所以这个文件描述符其实是连通了我们的应用程序和我们内核的一个很

265
00:17:21,740 --> 00:17:30,420
重要的数据

266
00:17:32,240 --> 00:17:34,260
除了这个文件描述之外

267
00:17:34,260 --> 00:17:42,200
我们可以看到 这是在进程级的一个打开文件的一个结构

268
00:17:42,200 --> 00:17:44,060
还有一个什么呢 系统级的打开文件的结构

269
00:17:44,060 --> 00:17:47,720
就是整个系统中会记录一个打开文件的结构

270
00:17:47,720 --> 00:17:50,680
在这里面有很重要的一个信息

271
00:17:50,680 --> 00:17:52,840
就是比如说文件的偏移量

272
00:17:52,840 --> 00:17:54,760
文件偏移量就好比说你读这个文件

273
00:17:54,760 --> 00:17:55,580
读到什么位置

274
00:17:55,580 --> 00:17:58,240
你按照一个序列去读

275
00:17:58,240 --> 00:17:59,980
我一开始读 读到这儿来了

276
00:17:59,980 --> 00:18:01,300
那下一次我再调读的时候

277
00:18:01,300 --> 00:18:03,420
是从这个位置开始继续往后读

278
00:18:03,420 --> 00:18:08,480
那这个位置在哪呢?就在这个我们说的这个便宜量的地方,有个记录,这是一个

279
00:18:08,480 --> 00:18:12,040
打开文件表的一个设计,这是全局系统级的。

280
00:18:12,440 --> 00:18:18,000
那这为什么要在这里看出来,这点很重要在哪呢?其实我可以看到,我有这进程A,这是

281
00:18:18,000 --> 00:18:23,320
进程B,这两个进程都可以访问同一个文件,都可以访问同一个文件。

282
00:18:23,500 --> 00:18:28,720
所以它需要有这么一个方式来进一步减少了这种不必要的一些信息的

283
00:18:28,720 --> 00:18:31,100
一些记录,然后也可以便于共享。

284
00:18:31,100 --> 00:18:35,000
还有一点就在于实际的文件的内容

285
00:18:35,000 --> 00:18:36,600
其实它也没放在这里面

286
00:18:36,600 --> 00:18:38,580
它只记录了一个位置

287
00:18:38,580 --> 00:18:39,600
具体内容放哪里

288
00:18:39,600 --> 00:18:40,620
放在iNode里面

289
00:18:40,620 --> 00:18:41,820
这个iNode还没有讲到

290
00:18:41,820 --> 00:18:43,160
后面讲文件系统之后

291
00:18:43,160 --> 00:18:45,740
会知道iNode其实代表的就是一个

292
00:18:45,740 --> 00:18:49,200
具体的一个文件的一个管理的一个结构

293
00:18:49,200 --> 00:18:51,920
你想进程有一个所谓的进程控制框

294
00:18:51,920 --> 00:18:54,400
这里面这个iNode就类似于文件控制框

295
00:18:54,400 --> 00:18:56,640
FCB File Control Block

296
00:18:56,640 --> 00:18:58,340
可以大致上去对应了

297
00:18:58,340 --> 00:18:59,740
这是我简单现在说一下

298
00:18:59,740 --> 00:19:02,160
后面会进一步讲解

299
00:19:03,860 --> 00:19:06,940
这个说到的文件指针就在这里面

300
00:19:06,940 --> 00:19:10,240
这个指针指向这些信息 包括最近一次读写的位置

301
00:19:10,240 --> 00:19:13,260
然后每个镜头都有自己打开的指针

302
00:19:14,220 --> 00:19:16,760
这就是一个正常的设计

303
00:19:17,420 --> 00:19:20,560
这里面讲的其实有点像是实现了

304
00:19:20,560 --> 00:19:26,180
但大家需要注意实现的方式有很多种

305
00:19:26,180 --> 00:19:28,960
这只是一种通常的实现方式

306
00:19:29,380 --> 00:19:31,020
不是说是唯一的实践方式

307
00:19:31,020 --> 00:19:33,460
所以大家在理解这个时候呢

308
00:19:34,340 --> 00:19:36,500
不要觉得好像是老实讲的这个东西

309
00:19:36,500 --> 00:19:38,540
就一定是必须存在的

310
00:19:38,540 --> 00:19:39,900
必须要有这个东西

311
00:19:39,900 --> 00:19:41,500
你重点是要理解

312
00:19:41,500 --> 00:19:43,780
说我们在做这个相应的一个

313
00:19:43,780 --> 00:19:45,420
应用在做相应的操作的时候

314
00:19:45,420 --> 00:19:47,700
内核大致要完成哪些样的事情

315
00:19:48,140 --> 00:19:49,220
从而可以知道

316
00:19:49,220 --> 00:19:51,180
我们的应用怎么能够得到

317
00:19:51,180 --> 00:19:54,540
我们OS的服务来完成对文件的

318
00:19:54,540 --> 00:19:55,300
读写操作

319
00:19:57,060 --> 00:19:58,780
这是这一块的一个介绍

320
00:20:07,680 --> 00:20:15,320
当最后 你可以看到这里面我们前面讲的还有一个close操作

321
00:20:15,320 --> 00:20:16,860
就是这里面还有一个close操作

322
00:20:20,780 --> 00:20:22,380
就是这里面最后一个进程

323
00:20:22,380 --> 00:20:25,120
这里面因为多个进程都可以打开一个文件

324
00:20:25,120 --> 00:20:28,180
当最后一个进程关闭了这个文件的时候呢

325
00:20:28,180 --> 00:20:31,580
那其实这一项 这一项 比如大家都关闭了这一项了

326
00:20:31,580 --> 00:20:33,500
这一项其实就没有必要存在了

327
00:20:33,500 --> 00:20:36,560
它就会从这个打开的文件表中给移除

328
00:20:36,560 --> 00:20:38,860
这样可以把这个整个资源给回收了

329
00:20:38,860 --> 00:20:41,180
但需要注意 移除之前

330
00:20:41,180 --> 00:20:44,560
所有这些进程对这个文件的修改

331
00:20:44,560 --> 00:20:49,480
要写回到我们的这个磁盘里面

332
00:20:49,480 --> 00:20:51,400
这个过程也是需要注意的

333
00:20:51,400 --> 00:20:55,840
就是磁盘里面的那些数据能够正确的保存下来

334
00:20:56,580 --> 00:20:57,820
这是这一块

335
00:20:57,820 --> 00:20:59,760
那所有这些磁盘数据我们其实也说到

336
00:20:59,760 --> 00:21:01,860
就是文件的一些磁盘上的数据内容

337
00:21:01,860 --> 00:21:03,800
是放在这个inode这个结构里面来保存的

338
00:21:04,460 --> 00:21:08,400
这是大致的就是关于文件这一块的一个描述

339
00:21:08,400 --> 00:21:10,020
特别是关于文件描述符

340
00:21:10,360 --> 00:21:13,220
在内核里面的一些信息给大家介绍完毕

341
00:21:13,220 --> 00:21:15,800
再接下来我们介绍什么呢 介绍文件系统

342
00:21:16,840 --> 00:21:17,660
为什么要介绍文件系统

343
00:21:17,660 --> 00:21:21,320
就在于你这个文件最终是属于文件系统里面的

344
00:21:21,320 --> 00:21:27,580
所以我们除了对这个站在一个应用的角度来理解这个文件之外

345
00:21:27,580 --> 00:21:33,920
我们还需要站在一个更全面的就是文件系统的角度来理解文件

346
00:21:33,920 --> 00:21:40,480
这是两个不同维度来理解这个文件的一个视角不同

347
00:21:40,480 --> 00:21:44,860
这个视角不同会使得你对整个这个文件会有更全面的掌握

348
00:21:44,860 --> 00:21:47,860
就是我们讲文件并不是只是局限于文件系统

349
00:21:47,860 --> 00:21:50,120
我们还需要考虑进程

350
00:21:50,120 --> 00:21:53,840
但你只考虑竞争 不考虑文件系统 也没法对这个文件有一个全局

351
00:21:53,840 --> 00:21:54,480
的把握

352
00:21:54,480 --> 00:21:56,860
所以我们需要对这两方面都有一个了解

353
00:21:56,860 --> 00:22:02,160
那首先文件系统 文件系统其实它已经是我们OS的一个标准的一个子系统

354
00:22:02,160 --> 00:22:02,340
了

355
00:22:02,340 --> 00:22:05,640
就是它主要完成这个数据的持久的存储违法文

356
00:22:05,640 --> 00:22:08,900
但它这个数据是所有的文件它都要管理起来

357
00:22:08,900 --> 00:22:14,360
那由于这个对文件的或者对数据的管理有不同的需求

358
00:22:15,180 --> 00:22:17,900
以及这个数据所在的物理介质也有不同

359
00:22:18,380 --> 00:22:21,340
所以我们就有各种各样类型的不同的文件系统的存在

360
00:22:21,340 --> 00:22:25,380
比如说传统的这个面向存储界势的这个文件系统

361
00:22:25,380 --> 00:22:27,340
还有一些面向网络的文件系统

362
00:22:27,340 --> 00:22:32,740
甚至还有它根本就不是作为数据的存储来呈现的

363
00:22:32,740 --> 00:22:36,660
而是来作为一种信息的展现来呈现的一些special的一些文件系统

364
00:22:36,660 --> 00:22:36,920
等等

365
00:22:37,600 --> 00:22:39,900
这都是属于文件系统的不同类型

366
00:22:40,580 --> 00:22:43,320
但这种不同类型它都有一个好处在于

367
00:22:43,320 --> 00:22:45,100
它都有一个统一的一个接口

368
00:22:45,920 --> 00:22:48,560
这个接口我们称之为VFS这个东西

369
00:22:48,560 --> 00:22:49,180
Watch your fire system

370
00:22:49,820 --> 00:22:51,960
这个Watch your fire system定义到统一的互联

371
00:22:54,280 --> 00:22:56,740
这互联就是比如说我们通常说的

372
00:22:56,740 --> 00:23:00,240
前面说的Read-Write,Open-Close

373
00:23:00,240 --> 00:23:02,400
这些基本的访问接口

374
00:23:02,900 --> 00:23:06,880
在这一层是定义了一套一致的一个接口

375
00:23:06,880 --> 00:23:07,940
至于再往下

376
00:23:07,940 --> 00:23:11,100
再往下走的是比如说像Linux的XT3

377
00:23:12,040 --> 00:23:16,560
这种文件系统还是面向这种嵌制系统的GFS2

378
00:23:16,560 --> 00:23:20,240
还是我们后面说到的那些Special这些文件系统

379
00:23:20,240 --> 00:23:24,100
那其实都可以通过一套interface

380
00:23:25,240 --> 00:23:27,540
一套一字的interface来进行访问

381
00:23:27,540 --> 00:23:29,600
这样就可以简化我们的应用

382
00:23:29,600 --> 00:23:31,480
这应用开发就非常简单

383
00:23:31,480 --> 00:23:34,300
但是你完成的功能就非常的灵活

384
00:23:34,300 --> 00:23:37,860
这就是一个典型的超系统中

385
00:23:37,860 --> 00:23:40,240
应对各种复杂情况的一种设计思路

386
00:23:40,240 --> 00:23:44,080
就是把他们的复杂性通过一层抽象能表现出来

387
00:23:44,080 --> 00:23:48,400
给我们上层应用其中有更方便的一种访问的一种接口

388
00:23:49,160 --> 00:23:52,600
这是文件系统的一个它的一个比较大的一个特点

389
00:23:54,980 --> 00:23:57,020
那这是对应用提供的好处

390
00:23:57,020 --> 00:23:59,880
那么对于文件系统本身的管理来说

391
00:23:59,880 --> 00:24:02,620
我们重点现在车重是在这个传统的文件系统

392
00:24:02,620 --> 00:24:04,640
针对这种存储戒指的文件系统

393
00:24:04,640 --> 00:24:06,760
这里面它要考虑几方面的问题

394
00:24:06,760 --> 00:24:08,740
第一个是怎么组织不同的文件

395
00:24:08,740 --> 00:24:11,320
因为你这个一个磁盘这么大

396
00:24:11,320 --> 00:24:12,820
你哪一地方放文件

397
00:24:12,820 --> 00:24:14,340
哪一地方放文件的原数据

398
00:24:14,340 --> 00:24:15,820
这都需要有些设计

399
00:24:15,820 --> 00:24:17,560
所以就怎么去组织它是一个问题

400
00:24:17,560 --> 00:24:20,380
第二个怎么去给文件进行命名

401
00:24:20,380 --> 00:24:22,400
所谓的命名就是为了定位

402
00:24:22,400 --> 00:24:23,920
你要根据一个文件名

403
00:24:23,920 --> 00:24:26,160
找到这个文件所在的data

404
00:24:26,160 --> 00:24:27,780
那你这个文件名放哪

405
00:24:28,340 --> 00:24:30,400
文件名和data的链接放什么地方

406
00:24:30,400 --> 00:24:32,240
这都需要去文件系统

407
00:24:33,400 --> 00:24:35,740
需要去有效的去把它管理起来

408
00:24:35,740 --> 00:24:37,880
从而可以使得我们的应用程序

409
00:24:37,880 --> 00:24:45,180
只需通过一个文件名,就可以很方便地对文件进行读写了,这是我们说他

410
00:24:45,180 --> 00:24:46,880
要考虑的一些内容。

411
00:24:53,160 --> 00:24:59,040
另一方面就是前面提到的,除了说能够方便读写之外,文系统还有很

412
00:24:59,040 --> 00:25:01,620
重要的功能就是数据的可靠和安全性。

413
00:25:01,620 --> 00:25:11,360
这个安全前面已经讲到了,就是要保证不会被恶意的删除、创改,或者是信息泄

414
00:25:11,360 --> 00:25:13,120
露,这些都是要去避免的。

415
00:25:13,120 --> 00:25:18,020
我们有一些简单的方式,当然还有更强的方式,我们这里并不会展开讲解。

416
00:25:18,440 --> 00:25:21,520
这是安全这一块。可靠这一块,我们专门有一节来讲。

417
00:25:22,200 --> 00:25:27,840
可靠就是说,因为这个存储戒指里面的数据,我们希望永久保存,自然就有

418
00:25:27,840 --> 00:25:29,420
一个很重要的可靠性的保障。

419
00:25:30,940 --> 00:25:35,440
在掉电或者其他一些异常情况下,我怎么能够确保这个数据丢失的越少

420
00:25:35,440 --> 00:25:35,880
越好

421
00:25:35,880 --> 00:25:39,620
数据能够快速的恢复等等,这就是所谓的可靠性的一个保障

422
00:25:39,620 --> 00:25:43,160
这一块也是文件系统里面特别重视的一点

423
00:25:43,160 --> 00:25:48,040
早期的文件系统可能不太关注,但现在随着数据的重要性越来越大

424
00:25:48,040 --> 00:25:50,220
那其实对这一点的要求也越来越高

425
00:25:50,220 --> 00:25:54,880
这是我们后续也会专门有一节来给大家讲这个可靠性的问题

426
00:25:57,220 --> 00:26:03,420
这是我们说文件系统的功能,除了前面的三个基本功能之外,还有可靠

427
00:26:03,420 --> 00:26:08,800
性、安全性的一个更扩展的功能,这是它的一个需要完成的事情。

428
00:26:09,500 --> 00:26:14,260
在组织形式上来说,现在目前的文件组织形式基本上是分层的结构,

429
00:26:14,720 --> 00:26:18,540
这里面说文件系统的组织形式就是分层结构,主要是由目录和文

430
00:26:18,540 --> 00:26:19,740
件两部分组成。

431
00:26:19,740 --> 00:26:21,540
目錄裡面可以再欠它目錄

432
00:26:21,540 --> 00:26:24,200
這個大家其實看了都比較熟悉了

433
00:26:24,200 --> 00:26:26,200
對於文件而言 大家都知道

434
00:26:26,820 --> 00:26:28,780
打開文件就可以進行讀寫操作

435
00:26:28,780 --> 00:26:31,660
對於目錄而言 其實我們說目錄也是一種文件

436
00:26:31,660 --> 00:26:34,200
那目錄裡面存的內容是什麼呢

437
00:26:34,200 --> 00:26:37,860
它裡面的內容 它存的其實就是文件的那個

438
00:26:37,860 --> 00:26:40,740
就是屬於這個目錄的文件信息

439
00:26:41,440 --> 00:26:44,200
我可以通過這個目錄裡面的文件信息

440
00:26:44,200 --> 00:26:47,360
能夠定位到這個目錄中的文件的位置

441
00:26:47,360 --> 00:26:49,080
從而可以做出進一步的一些訪問

442
00:26:49,080 --> 00:26:52,080
所以你看到这里面强调的是什么呢

443
00:26:52,080 --> 00:26:53,900
说目录是一种特殊的文件

444
00:26:53,900 --> 00:26:56,560
目录的内容它其实就是一个随音表

445
00:26:56,560 --> 00:26:58,240
包含了什么包含了文件名

446
00:26:58,240 --> 00:26:59,060
文件名

447
00:26:59,620 --> 00:27:01,360
然后第二个指向文件的指针

448
00:27:02,120 --> 00:27:04,220
实际上就是我们前面说的inode

449
00:27:04,220 --> 00:27:06,060
这么一个类似于这么一个管理结构

450
00:27:06,060 --> 00:27:08,200
就F文件控制块

451
00:27:08,200 --> 00:27:10,080
通过文件控制块可以找到

452
00:27:10,080 --> 00:27:12,800
这进一步的这个文件的数据等等

453
00:27:12,800 --> 00:27:15,400
这就是我们说目录的一个很重要的一点

454
00:27:15,400 --> 00:27:16,980
那么对于目录的操作

455
00:27:18,200 --> 00:27:21,380
你可以比如说我们通常打开一个目录

456
00:27:21,380 --> 00:27:22,980
看看这目录里面到底有什么内容

457
00:27:23,760 --> 00:27:25,520
就是搜索文件

458
00:27:25,520 --> 00:27:27,120
可以在这个目录里面创建文件

459
00:27:27,120 --> 00:27:29,220
就等于创建这些索性表象

460
00:27:29,220 --> 00:27:30,980
然后重新命名文件

461
00:27:30,980 --> 00:27:32,080
改变这个文件名

462
00:27:32,720 --> 00:27:37,220
还可以再去做一些比如删除等等这些操作

463
00:27:37,220 --> 00:27:39,960
这都是说这个目录相关的操作

464
00:27:39,960 --> 00:27:43,520
你可以看到它和一般文件的操作类似

465
00:27:43,520 --> 00:27:45,260
但有它的一些独特的地方

466
00:27:45,920 --> 00:27:48,500
那既然是一个文件随意表 它内容是文件随意表

467
00:27:48,500 --> 00:27:51,660
这文件随意表怎么来组织也是一些需要去考虑的问题

468
00:27:51,660 --> 00:27:54,260
最简单的方式是一个线性表 就是我们的一个宿主

469
00:27:55,040 --> 00:27:57,620
这里面是一项一项 这是名字

470
00:27:57,620 --> 00:28:00,360
这是它的那个inode 就是文件控制块

471
00:28:00,360 --> 00:28:04,120
这就是一个简单的一个结构 那这种宿主结构可能会有些问题

472
00:28:04,120 --> 00:28:09,460
比如说怎么能快速的查询 怎么能快速的删除插入等等

473
00:28:09,460 --> 00:28:13,020
那也许这种简单的线性的宿主结构可能不一定合适

474
00:28:13,020 --> 00:28:18,980
也會有一些哈希或者一些其他的一些結構來加速這個文件的訪問

475
00:28:18,980 --> 00:28:21,500
這只是一個性能優化問題

476
00:28:21,500 --> 00:28:25,140
總的來說我們需要了解的很重要的也就在於它重點包含的內容什麼

477
00:28:25,140 --> 00:28:28,260
是一個表 這個表裡面是有一系列的項組成本

478
00:28:28,260 --> 00:28:29,760
一項是代表一個文件

479
00:28:29,760 --> 00:28:33,840
這裡面有文件名和指向文件的一個文件空中畫的一個指針

480
00:28:33,840 --> 00:28:36,520
這是需要大家重點去理解的

481
00:28:44,520 --> 00:28:51,600
那这里面举个简单例子,比如说我们现在要去读这个

482
00:28:51,600 --> 00:28:59,240
给出一个目录名字,包含了目录和最后的文件,形成一个这么一个字符

483
00:28:59,240 --> 00:28:59,360
串

484
00:28:59,360 --> 00:29:04,200
要把这个里面的这个文件给读,要读出来的话怎么来做

485
00:29:04,900 --> 00:29:10,500
首先你这个文件是属于某一个目录的,那这个目录要从顶上往下去找

486
00:29:11,340 --> 00:29:13,240
所以它首先要读这个点

487
00:29:13,240 --> 00:29:15,160
这点代表也是一个当前目录的意思

488
00:29:15,160 --> 00:29:16,700
这个小点代表当前目录

489
00:29:16,700 --> 00:29:21,160
然后读到当前目录的它的目录内容

490
00:29:21,160 --> 00:29:22,680
这目录里面不会包含FS

491
00:29:22,680 --> 00:29:24,480
这个FS实际上是属于

492
00:29:24,480 --> 00:29:26,140
我们说这个

493
00:29:26,140 --> 00:29:27,320
好 还在这儿

494
00:29:27,320 --> 00:29:31,980
FS实际上是属于这个当前目录下的一个目录

495
00:29:32,660 --> 00:29:34,320
那么它自己又是一个目录文件了

496
00:29:34,320 --> 00:29:36,920
它里面的数据又包含很多了

497
00:29:36,920 --> 00:29:38,960
这里面至少就会包含我们说这个inode

498
00:29:38,960 --> 00:29:39,740
inode.rs

499
00:29:40,200 --> 00:29:44,240
通过它,这里面有个inode.rs,这个是放在这儿的。

500
00:29:44,240 --> 00:29:46,440
还有一点是它的所谓的文件控制块,

501
00:29:46,640 --> 00:29:50,820
文件控制块的inode结构会指向一个inode。

502
00:29:53,280 --> 00:29:55,880
inode再去指向所谓的data。

503
00:29:58,720 --> 00:30:00,980
从而可以把这个数据读出来,

504
00:30:01,340 --> 00:30:04,920
这是它大致的一个处理过程。

505
00:30:05,300 --> 00:30:08,480
这里面再讲一个比较有趣的内容,

506
00:30:08,480 --> 00:30:12,840
就在于别名 别名是在什么意思呢

507
00:30:12,840 --> 00:30:15,380
就是说我们可以多个文件名

508
00:30:15,380 --> 00:30:16,800
关联同一个文件

509
00:30:16,800 --> 00:30:18,460
这里面给了一个例子

510
00:30:18,460 --> 00:30:20,740
这是一个目录的内容

511
00:30:20,740 --> 00:30:22,020
这个目录内容里面

512
00:30:22,020 --> 00:30:23,100
你看包含了两个文件

513
00:30:23,100 --> 00:30:24,660
一个是f1 一个叫f2

514
00:30:24,660 --> 00:30:26,820
但是他们的这个inode

515
00:30:26,820 --> 00:30:28,840
就是文件控制框是同一个inode

516
00:30:28,840 --> 00:30:32,520
这就是一种所谓的两个文件名

517
00:30:32,520 --> 00:30:33,800
指向同一个文件

518
00:30:33,800 --> 00:30:35,860
需要注意我用的词是

519
00:30:35,860 --> 00:30:37,260
两个文件名指向同一个文件

520
00:30:37,260 --> 00:30:39,400
不是两个文件指向同一个文件

521
00:30:39,400 --> 00:30:41,260
这里面体现出来是两个文件名

522
00:30:42,200 --> 00:30:45,320
这两个文件名指向同一个文件控制块FCB

523
00:30:47,100 --> 00:30:50,560
它有点像我们说两个进程名指向同一个进程一样

524
00:30:50,560 --> 00:30:53,240
但其实我们现在目前没有这种情况

525
00:30:53,680 --> 00:30:55,260
这里面文件是有这种情况的

526
00:30:56,140 --> 00:31:00,520
这样子是为了方便一个管理

527
00:31:00,520 --> 00:31:01,980
这是一种方式

528
00:31:01,980 --> 00:31:03,540
我们称之为硬链接

529
00:31:04,120 --> 00:31:06,400
另外一种方式称之为软链接

530
00:31:06,400 --> 00:31:10,480
这叫softlink,或者叫symboliclink

531
00:31:10,480 --> 00:31:13,240
那这软链接什么意思呢,它比较有意思在哪呢

532
00:31:13,240 --> 00:31:15,280
它也是两个文件,f1,f2

533
00:31:15,280 --> 00:31:20,520
这个f1确实指向了这么一个inode文件控制块,但是f2呢

534
00:31:20,520 --> 00:31:25,680
它指向的一个文件控制块的内容里面,包含这个data,需要注意,包含的

535
00:31:25,680 --> 00:31:26,600
data

536
00:31:26,600 --> 00:31:27,980
实际上是一个路径名

537
00:31:27,980 --> 00:31:30,000
而这个路径名呢

538
00:31:30,000 --> 00:31:34,220
这个路径名,这个f1就指到这儿来了,它又指回到这儿来

539
00:31:34,860 --> 00:31:40,220
然后F1呢 它也是指向同一个文件 但它的形式不一样

540
00:31:40,800 --> 00:31:45,220
形式不一样 这里面是在这个层面上 在这个目录里面的

541
00:31:46,240 --> 00:31:52,400
两个文件名的所对应的这个iNode信息里面指向同一个iNode

542
00:31:52,400 --> 00:31:57,840
而这个不是 这个是F2里面是它的文件内容实际上是一个路径

543
00:31:57,840 --> 00:32:01,180
是一个文件路径 而这个路径呢 实际上指向这个地方

544
00:32:01,540 --> 00:32:09,720
这是所谓的一个软链接,这是两种不同的一种文件编辑的方式,在Lin

545
00:32:09,720 --> 00:32:12,180
ux或者Unix系统里面都是支持的。

546
00:32:12,940 --> 00:32:17,760
这里面我觉得最简单的情况,如果稍微复杂一点,你会发现也许有可能会实现

547
00:32:17,760 --> 00:32:22,680
所谓的一个文件编辑会带来一些问题,就是比如说循环的问题。

548
00:32:22,680 --> 00:32:30,440
这里面给了个例子,所谓情况就是,你会不会出现一种方式,就是T1指向

549
00:32:30,440 --> 00:32:37,640
了T2,T2指向了T3,T3又指回来了,这种情况,或者T1不停地

550
00:32:37,640 --> 00:32:47,900
指向自己,这都有可能,这里面给了一个例子,你看这里面是有点小,我们可以简单操

551
00:32:47,900 --> 00:32:50,980
作一下,你看这里面给的例子里面。

552
00:32:53,580 --> 00:32:57,680
这什么意思,就是穿越了一个目录,你看这里面

553
00:33:03,760 --> 00:33:06,540
这边有T1吧,T1可以看到T1在哪

554
00:33:09,040 --> 00:33:16,340
T1在这,这一个目录,这是一个它可以读写子音的权限的一个目录文件

555
00:33:16,340 --> 00:33:30,220
对这目录人员来说,我们可以建立一个链接,比如说cd t1,然后lnk

556
00:33:30,220 --> 00:33:31,840
-s就是软链接。

557
00:33:35,040 --> 00:33:48,780
那这什么意思,就是我们看到,你看一下T2是啥东西就知道了,这是T1,T2呢,在

558
00:33:48,780 --> 00:33:59,480
这,CDT,这是T2,T2是一个软链接,

559
00:33:59,480 --> 00:34:03,100
然后它里面的这个T2文件里面的内容

560
00:34:03,100 --> 00:34:04,320
实际上是点点反向T

561
00:34:04,320 --> 00:34:06,200
这样又指向了T1

562
00:34:06,200 --> 00:34:08,420
这实际上就形成了一种循环

563
00:34:08,420 --> 00:34:09,000
怎么循环呢

564
00:34:09,000 --> 00:34:11,840
你看看我如果到上一层目录里面

565
00:34:11,840 --> 00:34:14,320
ls t1 t2

566
00:34:14,320 --> 00:34:15,300
这感觉是正常的

567
00:34:15,300 --> 00:34:19,460
因为我们可以看到T1目录中有一个文件叫T2

568
00:34:20,000 --> 00:34:21,060
这是可以显示

569
00:34:21,060 --> 00:34:23,040
但是我再T1T2

570
00:34:23,040 --> 00:34:24,740
T2再T2

571
00:34:24,740 --> 00:34:25,400
还是可以

572
00:34:55,400 --> 00:34:57,780
存在循环,就循环形成算法

573
00:34:57,780 --> 00:34:59,400
当然这个算法会比较

574
00:35:00,260 --> 00:35:01,180
开销比较大

575
00:35:01,180 --> 00:35:03,720
确实,应该说是

576
00:35:03,720 --> 00:35:05,100
虽然你可以适应出来

577
00:35:05,100 --> 00:35:07,820
但是它的开销会比较大

578
00:35:07,820 --> 00:35:10,180
所以另外一种实际的做法是

579
00:35:10,180 --> 00:35:11,300
像超级红里面

580
00:35:11,300 --> 00:35:13,520
一般的做法是限制便利文件

581
00:35:13,520 --> 00:35:15,260
目录的路径数量

582
00:35:15,260 --> 00:35:18,120
这里面就给出了个例子,大家可以试,我实在敲把了这么多

583
00:35:18,120 --> 00:35:19,440
这是之前我试过的

584
00:35:19,840 --> 00:35:21,400
就是你在这里面情况下

585
00:35:22,600 --> 00:35:23,760
填到这么多的时候

586
00:35:23,760 --> 00:35:26,880
它会报一个错,服务连接的层次过多

587
00:35:26,880 --> 00:35:29,300
但如果你稍微少一点,比如到这儿

588
00:35:29,300 --> 00:35:30,580
你会发现这个层次还是OK的

589
00:35:30,580 --> 00:35:33,760
所以它确实是通过这么一个方式

590
00:35:33,760 --> 00:35:38,760
来简单的来规避所谓的目中行政循环这种情况

591
00:35:38,760 --> 00:35:43,640
这是关于这个硬连接和软连接的一个介绍

592
00:35:43,640 --> 00:35:45,440
那大家其实需要注意的就是

593
00:35:45,440 --> 00:35:47,420
你要知道它这种结构这么一个组织

594
00:35:47,420 --> 00:35:49,760
那如果我们给出一系列操作之后

595
00:35:49,760 --> 00:35:54,000
你能够知道对于这个里面的文件空中化或者iNode来说

596
00:35:54,000 --> 00:35:56,180
它的link数是多少

597
00:35:56,720 --> 00:36:01,160
这个是通常我们做练习的时候会给大家出的一些小题目

598
00:36:02,200 --> 00:36:05,460
好 那我们再看这个文件系统讲完这个文件变名之后

599
00:36:05,460 --> 00:36:07,640
我们再看这个所谓的文件挂载的问题

600
00:36:08,300 --> 00:36:14,300
那我们前面已经看到了就是在这里面有不同的文件系统

601
00:36:14,300 --> 00:36:17,980
但是我们希望给我们的应用呈现出一个一致的界面

602
00:36:17,980 --> 00:36:21,800
我们的应用不用care到底是XT3还是GFS2

603
00:36:21,800 --> 00:36:23,180
这种不同文件系统

604
00:36:23,180 --> 00:36:26,380
它展现的都是一个统一的这么一个目录结构

605
00:36:26,380 --> 00:36:28,220
既然要做到这一步的话

606
00:36:28,220 --> 00:36:29,080
那怎么来做呢

607
00:36:29,080 --> 00:36:30,540
其实就是靠我们说

608
00:36:30,540 --> 00:36:33,840
需要把某一些文件系统给挂接

609
00:36:33,840 --> 00:36:38,560
以目录的形式挂接在一个根文件系统之上

610
00:36:38,560 --> 00:36:41,080
或者是根文件系统下面的某个目录之上

611
00:36:41,080 --> 00:36:44,900
形成一个这么一个一致的一个基于目录的一个图

612
00:36:44,900 --> 00:36:49,920
这就是我们说的这个文件系统的挂载和卸载的一个操作

613
00:36:49,920 --> 00:36:54,860
这是这一块,大家能够有一个基本的了解就OK了

614
00:36:59,000 --> 00:36:59,680
过不去了

615
00:37:00,960 --> 00:37:01,360
OK

616
00:37:01,360 --> 00:37:04,540
那这一块好像就应该是讲完了我们的

617
00:37:05,660 --> 00:37:06,340
什么时候上课

618
00:37:06,340 --> 00:37:07,460
我现在突然发觉这个

619
00:37:09,840 --> 00:37:13,240
五十上课,十分,三十五分

620
00:37:13,240 --> 00:37:14,360
还有十分钟

621
00:37:16,880 --> 00:37:26,780
大家可以提醒一下我,有时候我上课就不知道没注意到时间,也确实没设定铃声,

622
00:37:27,360 --> 00:37:28,740
然后应该设一下。

623
00:37:29,640 --> 00:37:36,420
这属于第一部分,关于文件的基本概念的介绍就给大家讲完了。

624
00:37:36,640 --> 00:37:41,340
我们再讲第二部分,讲文件系统的设计实现。

625
00:37:41,340 --> 00:37:48,500
那这个稍微就是更测试在这个OS的内部

626
00:37:48,500 --> 00:37:51,440
来看看这个文件系统怎么来实现

627
00:37:51,440 --> 00:37:53,320
当然这里面和我们具体的实现

628
00:37:53,320 --> 00:37:55,440
我们后面还讲这个Lab的时候

629
00:37:55,440 --> 00:37:57,500
会讲的具体实现还是有点不同

630
00:37:57,500 --> 00:38:00,340
这个实现更多是站在一个

631
00:38:00,960 --> 00:38:02,460
还是概念性的一个角度

632
00:38:02,460 --> 00:38:04,940
来理解这个文件系统的设计实现

633
00:38:04,940 --> 00:38:06,740
但它还是具有很大的一个参考价值

634
00:38:07,220 --> 00:38:09,720
因为绝大部分的这个文件系统

635
00:38:09,720 --> 00:38:13,000
它都是基本上基于这么一个大的一个逻辑来进行设计和实现

636
00:38:14,100 --> 00:38:19,540
首先我们看一下这个文件系统的在整个超级系统的位置

637
00:38:20,200 --> 00:38:21,420
你看在这里面

638
00:38:23,120 --> 00:38:25,020
文件系统在这儿

639
00:38:25,020 --> 00:38:26,040
这是这一块

640
00:38:26,040 --> 00:38:27,360
那这一块呢

641
00:38:27,360 --> 00:38:30,000
那他有发现它其实和这一块放在一起

642
00:38:30,000 --> 00:38:30,480
为啥呢

643
00:38:30,480 --> 00:38:33,380
因为它最终是一种块设备

644
00:38:33,380 --> 00:38:39,700
通过块设备来进行这个数据的一个读写或者管理

645
00:38:39,720 --> 00:38:45,620
最终会落到一个驱动上面,就是磁盘驱动,来完成对磁盘的一个处理。

646
00:38:45,860 --> 00:38:48,740
所以这是它的一个大致的一个结构。

647
00:38:49,180 --> 00:38:51,260
但是还有一点不一样,就是对上层而言,

648
00:38:51,480 --> 00:38:53,540
你会发现它这个,上次是APP,

649
00:38:54,640 --> 00:38:59,520
APP我们说它需要一个一致的一个简洁,非常简洁的一个访问接口,

650
00:38:59,640 --> 00:39:01,300
而不用管具体的文件系统到底是啥,

651
00:39:01,340 --> 00:39:03,900
比如是FAT的,还是GXT2的,不用care。

652
00:39:04,500 --> 00:39:05,900
那这里面就有一个虚拟文件系统,

653
00:39:06,040 --> 00:39:08,500
其实在这里面,在这个之上,还有一个VFS。

654
00:39:09,720 --> 00:39:12,740
VFS能够把这一层给屏蔽掉

655
00:39:12,740 --> 00:39:15,300
向上提供一层Syscode系统调用

656
00:39:15,300 --> 00:39:18,700
我们说的那个基本的Read-Write

657
00:39:19,480 --> 00:39:23,200
Open-Close这些给我们的应用区去使用

658
00:39:23,200 --> 00:39:25,200
这是我们说的分层的一个架构

659
00:39:25,200 --> 00:39:26,660
这其实已经分了层了

660
00:39:26,660 --> 00:39:28,600
如果把这个分层在进一步卸化的话

661
00:39:28,600 --> 00:39:30,340
就看了这么一个结构

662
00:39:30,340 --> 00:39:32,080
这是一个分层结构

663
00:39:32,080 --> 00:39:33,740
在用户派我们写

664
00:39:33,740 --> 00:39:35,340
我们调的是一些函数

665
00:39:35,340 --> 00:39:38,060
就是比如说Open这些函数

666
00:39:38,060 --> 00:39:42,660
那么通过酷会变成SysOpen,这是一个系统雕用

667
00:39:43,920 --> 00:39:47,920
SysOpen再往下走会到VFS里面

668
00:39:47,920 --> 00:39:52,120
然后VFS会把它转到具体的一个文件系统里面去

669
00:39:52,120 --> 00:39:54,180
比如说这个FAT或者EXT2

670
00:39:54,180 --> 00:39:58,400
然后它会再进一步去通过一个缓冲

671
00:39:58,400 --> 00:39:59,460
一般会有一个缓冲

672
00:39:59,460 --> 00:40:01,320
缓冲的目的就是大家都知道

673
00:40:01,320 --> 00:40:03,780
Span的速度远小于内存的速度

674
00:40:03,780 --> 00:40:06,800
所以我把一些常常讀的数据呢

675
00:40:07,200 --> 00:40:08,120
会放到这里面

676
00:40:08,120 --> 00:40:09,280
放到Memory里面来管理起来

677
00:40:09,280 --> 00:40:10,880
这是所谓的缓冲驱动管理

678
00:40:10,880 --> 00:40:13,560
然后再往下就是一个驱动

679
00:40:13,560 --> 00:40:15,360
就是我们前面说到这一块

680
00:40:15,360 --> 00:40:16,700
十分驱动这一块

681
00:40:17,280 --> 00:40:21,200
来具体从物理的存储界限上面

682
00:40:21,200 --> 00:40:23,420
把数据读出来或者写入

683
00:40:23,420 --> 00:40:25,520
这是一个结构啊

684
00:40:25,520 --> 00:40:26,380
这是一个结构

685
00:40:26,380 --> 00:40:30,620
这里面的内核部分是这列这么大部分

686
00:40:30,620 --> 00:40:32,980
其实这一部分确实量比较大

687
00:40:32,980 --> 00:40:37,340
但它处理流程来说,不像我们前面的进程和内容管理一样,会不

688
00:40:37,340 --> 00:40:42,040
停的切换,它是一个单线,单线一路往下。

689
00:40:42,180 --> 00:40:59,260
所以虽然处理的过程比较多,但思考的方式是比较创新化的。

690
00:41:00,580 --> 00:41:09,060
这一幅图给出了一个就是站在用户空间和内核空间,还是应用和内

691
00:41:09,060 --> 00:41:15,020
核里面的角度来看整个文件的读写的过程。

692
00:41:15,400 --> 00:41:21,140
这里面可以看到用户空间发出一个Write,把这个简单再弄Write,最终进入

693
00:41:21,140 --> 00:41:22,560
内核变成SysWrite。

694
00:41:22,560 --> 00:41:26,000
然后由这个具体的文件系统来执行这个Write操作

695
00:41:26,000 --> 00:41:28,220
再通过Driver写回到磁盘里面去

696
00:41:28,220 --> 00:41:29,640
这是它大致处理过程

697
00:41:29,640 --> 00:41:33,140
在这里面 这是最简单的做法

698
00:41:33,140 --> 00:41:36,680
但这个Write实际上是一个我们先说的FD

699
00:41:36,680 --> 00:41:41,580
这FD它对应的那个所谓的那个项在哪呢

700
00:41:41,580 --> 00:41:46,660
所谓我们说那个文件控制框inode在什么地方呢

701
00:41:46,660 --> 00:41:49,180
它都要去查找 还要查找过程

702
00:41:49,180 --> 00:41:56,120
假设你是这个F2文件的话,它会找到相应的F2里面的内容,最终

703
00:41:56,120 --> 00:42:05,940
通过索引节点把它的数据给写入,这是一个处理过程,这个过程需要我们前

704
00:42:05,940 --> 00:42:13,780
面说的查找、定位、读写这一系列的一些操作,这是我们说站在一个比较

705
00:42:13,780 --> 00:42:18,400
无语的角度来看这个文件的一个处理过程。

706
00:42:23,440 --> 00:42:28,520
在这里面,强调的是VFS,虚拟文件系统。

707
00:42:29,080 --> 00:42:34,460
在VFS里面,我觉得韩式其实已经说到了,

708
00:42:34,800 --> 00:42:38,540
它重点是要支持一些统一的一些结构和标准的接口,

709
00:42:38,780 --> 00:42:42,960
会把这些函数接口会具体的绑到某一个文件系统里面去,

710
00:42:43,600 --> 00:42:49,160
从而可以实现对这个,我们前面说这个最终的

711
00:42:51,340 --> 00:42:56,540
因为你绑定好了,所以都可以比较直接的去连到具体文件系统,然后去访问

712
00:42:56,540 --> 00:43:01,960
相应的这个磁盘驱动来完成相应的处理。

713
00:43:02,340 --> 00:43:08,720
这是这一块,WFS就是一个很好的一个设计。

714
00:43:10,140 --> 00:43:17,280
我看看啊,他们怎么去跨这个文件系统,这里面给了一个例子,他们说其实提供同

715
00:43:17,280 --> 00:43:17,700
样的接口,

716
00:43:17,700 --> 00:43:21,800
但实际上你在实现的时候可能是由于有不同的文件系统

717
00:43:21,800 --> 00:43:25,900
比如说ext2或者是msdots的fat32

718
00:43:25,900 --> 00:43:30,500
这里面做了一个操作 cp操作 copy

719
00:43:30,500 --> 00:43:34,740
把这个文件把c这个文件copy到z里面去

720
00:43:34,740 --> 00:43:35,940
这是属于两个不同目录

721
00:43:35,940 --> 00:43:36,580
这两个不同目录

722
00:43:36,580 --> 00:43:38,840
这可能就是位于一个

723
00:43:39,640 --> 00:43:41,540
你看它这里面写的

724
00:43:41,540 --> 00:43:43,880
这里面是一个Windows里面的一个文件

725
00:43:43,880 --> 00:43:46,120
这个c可能是一个fat的文件

726
00:43:46,120 --> 00:43:47,040
是这么一个文件

727
00:43:47,040 --> 00:43:50,660
这个Z可能是Solars的一个文件

728
00:43:50,660 --> 00:43:51,960
Solars也是一个超级系统

729
00:43:51,960 --> 00:43:52,680
它里面的一个文件

730
00:43:52,680 --> 00:43:54,240
这两个是不同文件系统

731
00:43:54,240 --> 00:43:58,440
那怎么能够通过一个简单的CP命令

732
00:43:58,440 --> 00:43:59,820
就把这两个文件拷过来了

733
00:43:59,820 --> 00:44:04,360
那其实在于我们超级系统做了大量的工作

734
00:44:04,360 --> 00:44:08,300
通过这个VFS能够把你的相应的

735
00:44:08,300 --> 00:44:10,780
针对这个文件的操作

736
00:44:10,780 --> 00:44:11,960
读操作写操作

737
00:44:11,960 --> 00:44:14,740
映射到具体的文件系统的读写操作里面

738
00:44:14,740 --> 00:44:19,900
从而可以来完成一个跨文件系统的访问

739
00:44:19,900 --> 00:44:21,740
这就是VFS带来的好处

740
00:44:21,740 --> 00:44:24,680
也给我们应用程序提供了极大的便利

741
00:44:24,680 --> 00:44:28,540
这就是我们说VFS的一个简单的一个施力

742
00:44:31,160 --> 00:44:32,800
这是对于VFS的介绍

743
00:44:32,800 --> 00:44:35,480
我们再看看讲讲具体文件系统了

744
00:44:35,480 --> 00:44:36,460
V是虚

745
00:44:36,460 --> 00:44:38,800
我们还有一个具体文件系统

746
00:44:38,800 --> 00:44:40,180
GIM讲具体文件系统

747
00:44:40,180 --> 00:44:44,120
这是一个典型的一个

748
00:44:44,120 --> 00:44:48,820
比如说我们做实验的,或者是Unix的一个简化的文件系统的架构

749
00:44:48,820 --> 00:44:52,440
在这个架构里面,你会发现它有很重要的一些内容

750
00:44:52,440 --> 00:45:02,440
我们通常关注的,作为我们的用户或者是应用

751
00:45:02,440 --> 00:45:04,500
它所关注的在哪呢?

752
00:45:04,700 --> 00:45:10,200
在指在最底下这个file,以及对file的这个数据的读写

753
00:45:10,200 --> 00:45:11,600
这是它关注的

754
00:45:11,600 --> 00:45:17,740
但是你要落到这个file这一块,你前面这些东西也都需要去管理起来,

755
00:45:17,900 --> 00:45:22,140
我们是通过一步一步的才能够,一步一步的管理才最终管这个f

756
00:45:22,140 --> 00:45:27,540
ile的data的,所以你就看到这里面的所有的结构在这儿,在硬盘上,以硬盘

757
00:45:27,540 --> 00:45:32,100
为例,硬盘上都有相应的一个组织,这个组织就是我们会考虑到的很重要的

758
00:45:32,100 --> 00:45:39,080
一些内容,包括对文件的整体的了解是superblock,然后呢,对具体文件的一个

759
00:45:39,080 --> 00:45:41,580
管理,inode,对

760
00:45:41,580 --> 00:45:46,240
具体目录的管理就DI Entry 目录里面的一个项

761
00:45:46,240 --> 00:45:48,200
就是我们说目录里面有很多项

762
00:45:48,200 --> 00:45:52,140
这是一个项 一个项里面包含了文件名和对应的那个文件的I know的信

763
00:45:52,140 --> 00:45:52,310
息

764
00:45:53,060 --> 00:45:56,900
还有这个数据块 这是文件指向的一些数据块

765
00:45:56,900 --> 00:46:01,680
这些都是我们文件系统需要去管理的

766
00:46:01,680 --> 00:46:04,810
而这些所有的数据都会落到我们的硬盘上去

767
00:46:05,360 --> 00:46:06,880
所以说这个存储识图在哪呢

768
00:46:06,880 --> 00:46:09,700
就是这里面的信息最终会落到硬盘上去

769
00:46:09,700 --> 00:46:13,360
然后超级统在访问的时候会把这里面的关键信息还会调到内存中来,

770
00:46:13,360 --> 00:46:18,700
调到RAM中来,来进行更加高效的访问。

771
00:46:21,220 --> 00:46:28,160
把这个图,这个图和这个图是一样的,这个图,你可以看到这个图其实把它进一步细化

772
00:46:28,160 --> 00:46:32,040
就变成这个样子,这么一个样子。

773
00:46:32,040 --> 00:46:37,380
你看这里面SB Superblock在这儿,放在最前头,其实这也在这个地方,这写的比

774
00:46:37,380 --> 00:46:38,260
较小而已

775
00:46:38,260 --> 00:46:44,440
然后对这个inode哪些用了,哪些没有用呢,有一个标识叫bitmap,inode bitmap

776
00:46:44,440 --> 00:46:50,360
实际上它比如说这里面这两个地方没有用,这些地方都已经被用了

777
00:46:50,360 --> 00:46:56,340
这里面也是对应的一样,这是用一个bit代表了一个这里面到底是被使用的一个

778
00:46:56,340 --> 00:46:57,580
管理的一个仕途

779
00:46:57,580 --> 00:47:02,280
而这个Data bitmap 管的是这边,也是一样,这里面,你可以理解为这里面都用满了,

780
00:47:02,380 --> 00:47:06,260
其他都用满了,如果还有一些空格白的话,那可以认为它空了,也就用一个

781
00:47:06,260 --> 00:47:14,180
bit代表了一个block的一个结构,就是所谓的这个bitmap结构,inode结构,data

782
00:47:14,180 --> 00:47:19,620
结构,我们这里面没有看到什么,没有看到这一块,如果在这三个为例来说的话,这一

783
00:47:19,620 --> 00:47:26,600
块结构没有看到,然后呢,其他的像dir,entry,实际上这里面的进步的内容了,一个

784
00:47:26,600 --> 00:47:27,560
目录文件的内容了,

785
00:47:27,580 --> 00:47:31,780
这里面没有看到,但是这个DiAndroid在哪呢?

786
00:47:31,860 --> 00:47:37,260
在这,这是一个视图,实际上是这里面中的,比如这是一个目录文件的话,这里面会

787
00:47:37,260 --> 00:47:38,660
包含这里面的内容。

788
00:47:38,920 --> 00:47:45,180
那这个是呈现出来给用户的一个视角,就是可视化的,用户打开Windows或者

789
00:47:45,180 --> 00:47:51,180
LX看到的一个目录结构,最终是呈现在硬盘上这么一个复杂的一个结构。

790
00:47:56,560 --> 00:48:00,960
这是试一图,那我们再看下面这个图,这个图是什么,这个图实际上是把这里面的

791
00:48:00,960 --> 00:48:11,460
数据给它具体细化,用了一些具体的数来表示而已,这个我觉得倒也还好理

792
00:48:11,460 --> 00:48:15,720
解,你如果把这个看出来的话,那我可以简单的类比,这个东西实际上就指向

793
00:48:15,720 --> 00:48:21,080
什么,这样子,inode,这是代表一个inode,这个inode最终会指向它的data,

794
00:48:21,080 --> 00:48:24,280
这个是它的一个更具体的一个展现

795
00:48:25,860 --> 00:48:27,880
这是我们说关于这个文件的基本结构

796
00:48:27,880 --> 00:48:28,760
大家心中要有数

797
00:48:29,400 --> 00:48:31,020
就是你心中要有这么一个图

798
00:48:31,020 --> 00:48:33,840
你如果把这个图记在心里的话

799
00:48:33,840 --> 00:48:36,260
那么接下来就是对这个图进一步的处理的问题

800
00:48:36,260 --> 00:48:38,720
这里图的不同的结构进行处理的问题

801
00:48:42,280 --> 00:48:43,580
我们再稍微细化一点

802
00:48:43,580 --> 00:48:44,980
比如说对这个Cyberblock

803
00:48:45,780 --> 00:48:47,210
Cyberblock里面包含了什么呢

804
00:48:47,210 --> 00:48:51,530
包含了整个磁盘它有多少个块

805
00:48:51,530 --> 00:48:53,010
有多少个空余块

806
00:48:53,530 --> 00:48:55,270
block和inode的总量是多少

807
00:48:55,270 --> 00:48:57,070
哪些已经使用的没被使用

808
00:48:57,070 --> 00:49:01,030
它的数量级的一个多不必要的一个记录

809
00:49:01,030 --> 00:49:02,730
放在Cyberblock里面

810
00:49:02,730 --> 00:49:04,570
还包括一些原数据什么时候加载的

811
00:49:04,570 --> 00:49:05,650
什么时候写入等等

812
00:49:05,650 --> 00:49:08,610
这属于Cyberblock里面的记录的内容

813
00:49:09,010 --> 00:49:09,710
第二个呢

814
00:49:09,710 --> 00:49:12,530
就是我们说这个很重要的是在这个文件控制块

815
00:49:22,870 --> 00:49:26,230
因为它整个组织结构上用索引结构来进行处理的

816
00:49:26,230 --> 00:49:29,570
我们称之为简化称为inode

817
00:49:29,570 --> 00:49:32,410
有一些叫vnode是vcvirtual的意思

818
00:49:33,250 --> 00:49:35,090
就是它应对着vfx里面

819
00:49:35,090 --> 00:49:37,110
它把node称之为vnode

820
00:49:37,110 --> 00:49:38,230
但咱们这里面其实不用区分

821
00:49:38,230 --> 00:49:40,790
就简单理解为一个inode就OK了

822
00:49:40,790 --> 00:49:41,590
对于inode而言

823
00:49:41,590 --> 00:49:42,510
它其实我们说它是一个

824
00:49:42,510 --> 00:49:44,650
一个文件的管理控制结构

825
00:49:44,650 --> 00:49:47,290
它里面会有一些很重要的信息

826
00:49:47,290 --> 00:49:50,330
比如在这里面像这些信息是一些指针

827
00:49:50,330 --> 00:49:53,310
会指向具体的数据块的位置

828
00:49:53,310 --> 00:49:55,290
直接指向和间接指向

829
00:49:55,290 --> 00:49:56,850
这我们会进一步讲解

830
00:49:56,850 --> 00:49:58,410
反正大家理解为

831
00:49:58,410 --> 00:50:01,990
它记录的文件里面的内容所在的位置

832
00:50:01,990 --> 00:50:03,530
还有文件的大小等等

833
00:50:03,530 --> 00:50:07,670
这些都是这个iNote里面的一些重要的信息

834
00:50:07,670 --> 00:50:10,330
这个type比如说你可以是一般的文件

835
00:50:10,330 --> 00:50:11,990
regular的文件 常规文件

836
00:50:11,990 --> 00:50:13,190
还是一个目录文件

837
00:50:13,190 --> 00:50:14,870
这type里面的会有反应

838
00:50:14,870 --> 00:50:17,470
这就是我们说这个结构里面很重要的一些信息

839
00:50:18,810 --> 00:50:19,990
那数据块里面放什么

840
00:50:19,990 --> 00:50:23,350
数据块如果它是一个一般的文件的话

841
00:50:23,350 --> 00:50:24,970
它放的就是文件内容

842
00:50:24,970 --> 00:50:26,370
比如说ABCD这个字符串

843
00:50:26,370 --> 00:50:29,070
这些如果是字符文件就是ABCD的内容

844
00:50:29,070 --> 00:50:30,730
但如果是目录那就不一样了

845
00:50:30,730 --> 00:50:31,110
目录的话

846
00:50:31,110 --> 00:50:34,390
我们前面说的目录里面它是一个实际上是一个是一个表

847
00:50:34,390 --> 00:50:41,970
它里面有有文件名文件名和对应的I know的一个位置的记录

848
00:50:42,850 --> 00:50:46,470
这是目录里面的内容,不太一样。

849
00:50:47,990 --> 00:50:51,990
对于一个inode而言,它一般会放128个byte,

850
00:50:52,070 --> 00:50:55,950
但这是一个特殊的举例,并不代表一定是这样。

851
00:50:56,230 --> 00:50:59,250
Data block一般也是4k,当然这也不是绝对的,

852
00:50:59,350 --> 00:51:01,970
这只是一个大致的标识。

853
00:51:02,470 --> 00:51:04,390
这bitmap,前面已经看到了,

854
00:51:07,590 --> 00:51:09,730
这就是bitmap的内容。

855
00:51:09,730 --> 00:51:17,390
这个Bitmap呢,主要是表示这个inode区域和这个datanode区域的哪些用

856
00:51:17,390 --> 00:51:23,070
了,那些没用,用一个bit来代表一个框,这样我可以很快的查出来inode中哪

857
00:51:23,070 --> 00:51:27,670
些还是没有备用的,可以被进一步分配,包括这个data,data里面的区域哪

858
00:51:27,670 --> 00:51:33,810
些可以被进一步分配,就可以通过这个方式来快速查找,这是这个Bitmap的

859
00:51:33,810 --> 00:51:39,710
一个设计,数据框其实已经讲过了,就是数据框有

860
00:51:41,450 --> 00:51:50,770
这种结构大家应该能够看出来,如果我给了这幅图,其实你应该能看出来,

861
00:51:51,270 --> 00:52:04,630
这是一个目录,这是一个目录,这是一个目录,这个目录指向这个地方,这又是一个目录,

862
00:52:06,110 --> 00:52:08,250
这就是目录里面又嵌了一个目录。

863
00:52:09,290 --> 00:52:17,250
大致上看得出来,如果这块纸像只是一些Data的话,那么它可能代表了一个文件。

864
00:52:23,450 --> 00:52:29,690
目录表里面的每一项称之为一个叫做目录项,

865
00:52:29,690 --> 00:52:37,810
这个梦想,这里面给了一个简单的结构,比较小,我觉得这种上课方式,还有点,

866
00:52:38,470 --> 00:52:44,750
就是大家虽然盯着屏幕,可能看的会,虽然小,能看的清,也还大致能够

867
00:52:44,750 --> 00:52:50,670
理解,就是我们说的这个结构的一个展现,实际上是这个结构的一个展现。

868
00:52:51,730 --> 00:52:59,450
好,那關於這個,這裡面的數據塊,iNode的一些介紹,

869
00:52:59,630 --> 00:53:04,790
包括目錄像,目錄像是屬於目錄的數據,內容基本介紹了一下。

870
00:53:05,130 --> 00:53:09,470
那再往下看到什麼呢?再往下,其實它就是已經更基本的一些內容了,

871
00:53:09,470 --> 00:53:15,810
就是在於磁盤的緩存,對於磁盤緩存而言,它其實只是說,

872
00:53:16,250 --> 00:53:19,210
我看到的是一個一個的塊,一個磁盤塊的信息,

873
00:53:19,210 --> 00:53:24,410
这值班块的信息会放在缓存里面

874
00:53:24,410 --> 00:53:27,450
那么这里面其实就是把这里面的一个一个块给读进来

875
00:53:27,450 --> 00:53:30,010
或者写回去的一个中间的一个过程

876
00:53:30,010 --> 00:53:31,270
中间的一个阶段

877
00:53:31,270 --> 00:53:34,810
这个值班缓存 这个所谓的扇区缓存或者数据块缓存

878
00:53:36,390 --> 00:53:41,170
大家需要注意 现在我们的这个本身的这个 正式实际上是Device

879
00:53:42,570 --> 00:53:46,710
这Device 这一块OS在这跑

880
00:53:47,630 --> 00:53:52,630
这Device本身它也会有缓存,但是我们的OS也会有缓存,这也有个

881
00:53:52,630 --> 00:53:53,210
数据缓存。

882
00:53:53,670 --> 00:54:02,490
这个缓存和这个缓存都是为了能够加速磁盘数据的读或者写速度的

883
00:54:02,490 --> 00:54:03,430
一种优化手段。

884
00:54:04,070 --> 00:54:07,130
我们正面考虑的更多是这一块,更多数据块的缓存。

885
00:54:07,730 --> 00:54:11,850
你可以说这个数据块大小和3G大小是一样的,它们之间可能也有些

886
00:54:11,850 --> 00:54:12,910
功能上的重叠。

887
00:54:13,910 --> 00:54:23,050
但就目前而言,我们的硬件和我们的超系统都会对数据做相应的缓

888
00:54:23,050 --> 00:54:23,050
存。

889
00:54:24,570 --> 00:54:28,570
那缓存,我们通常像之前讲这个内存的时候也提到,

890
00:54:28,990 --> 00:54:34,250
哟,直接下课了,应该下课了。

891
00:54:34,330 --> 00:54:39,090
抱歉,大家先休息五分钟吧,我这边现在确实时间好像比较难以控制。

892
00:54:39,650 --> 00:54:42,210
我现在要定个时间,先休息五分钟。

893
00:54:42,910 --> 00:54:59,310
好 定了时间

894
00:55:42,910 --> 00:56:07,950
是

895
01:00:18,350 --> 01:00:24,130
我们10点50开始上课,还有一分钟,可以早点准备一下

896
01:01:16,130 --> 01:01:25,870
好,我们继续上课,我定了个35分钟,因为刚才多讲了10分钟,35分钟

897
01:01:25,870 --> 01:01:33,990
它这个定时期应该会响,所以我们应该在11点25会休息一下。

898
01:01:34,470 --> 01:01:43,210
好,咱们开始继续讲,讲这个缓存,这缓存在这,缓存这边其实就是一个把我们

899
01:01:43,210 --> 01:01:49,590
希望能够把我们常用到的,这用包和读和写常用到的这个数据块能

900
01:01:49,590 --> 01:01:56,090
放在内存中,保存起来,缓冲起来,这样使得我们这个不用频繁的去读写

901
01:01:56,090 --> 01:02:00,930
这个词盘,来提高整体这个系统的效率。

902
01:02:01,830 --> 01:02:05,790
这是这一道一个所谓的数据缓存的一个设计问题

903
01:02:05,790 --> 01:02:08,770
那我们这里面可以用非常简单的一些方法来提高效率

904
01:02:08,770 --> 01:02:10,090
比如说LRU算法

905
01:02:10,090 --> 01:02:13,570
这个在之前的这个我们说叫做

906
01:02:16,790 --> 01:02:18,850
页面置换甩法里面专门给大家讲过

907
01:02:18,850 --> 01:02:21,730
基于虚存管理中很重要的一个

908
01:02:21,730 --> 01:02:23,870
就是把常见的一些内存不够的情况

909
01:02:23,870 --> 01:02:25,930
要把常见的一些要放到内存中来

910
01:02:25,930 --> 01:02:28,090
不常见的一些给甩跑出去

911
01:02:28,090 --> 01:02:34,590
这里面其实已经向着我们以前对换这么一个idea是一样的

912
01:02:34,590 --> 01:02:41,290
这里面我们并没有专门去讲这些缓存的算法

913
01:02:41,290 --> 01:02:44,670
应该把哪些HOT的一些页给放进来 也应该换出去

914
01:02:45,310 --> 01:02:50,170
其实这个和我们的页面专案算法是有相似之处的

915
01:02:51,030 --> 01:02:52,530
但是也有不同的地方

916
01:02:54,410 --> 01:02:57,530
因为那个考虑的是内存的一个情况

917
01:02:57,530 --> 01:03:01,010
而這個呢 考慮到文件的情況 他們處理的對象是不一樣的

918
01:03:01,010 --> 01:03:04,750
所以在這種文件的緩存上面呢 我們可以使用一些

919
01:03:05,410 --> 01:03:09,850
在時間開發上相當於說更大一點的一些算法 來完成一些管理

920
01:03:09,850 --> 01:03:15,550
這個就可以實現一些比較有意思的一些緩存的置換算法

921
01:03:15,550 --> 01:03:18,330
不叫 頁面上叫緩存置換算法

922
01:03:19,170 --> 01:03:22,790
只是由於時間問題 我們並不會在這裡面展開講解

923
01:03:22,790 --> 01:03:27,590
怎么去有效的去设计各种缓存作业算法

924
01:03:27,590 --> 01:03:30,890
其实上一期我们有专门讲,有专门讲这方面的内容

925
01:03:31,750 --> 01:03:36,350
但今年我们这一块放后,如果后面有时间给大家介绍

926
01:03:36,350 --> 01:03:39,850
如果没有时间的话,那也就是大家课外可以去看一看

927
01:03:39,850 --> 01:03:42,350
我们会给出相应的一些参考的链接

928
01:03:42,350 --> 01:03:45,830
大家有兴趣的同学可以去了解一下

929
01:03:45,830 --> 01:03:52,510
这是关于缓存这一块,思路和页面作业算法很类似

930
01:03:52,510 --> 01:03:53,770
方法會有不同

931
01:03:54,570 --> 01:03:56,150
好 再講這個文件描述符

932
01:03:56,150 --> 01:03:57,090
這段時間已經講到了

933
01:03:57,090 --> 01:03:58,910
我們做文件描述符這一塊就是一個

934
01:04:00,730 --> 01:04:01,290
一個index

935
01:04:01,290 --> 01:04:04,290
這個index放在一個文件描述符表裏面

936
01:04:04,290 --> 01:04:06,170
這個表分了兩個層面

937
01:04:06,170 --> 01:04:08,690
一個層面是進程管理

938
01:04:09,130 --> 01:04:10,630
進程控制塊裏面會有一個

939
01:04:10,630 --> 01:04:12,110
第二個系統層面會有一個

940
01:04:12,110 --> 01:04:13,910
這是一般的做法

941
01:04:14,730 --> 01:04:17,050
就是每個進程有一個打開文件表

942
01:04:17,050 --> 01:04:18,430
一個系統有一個打開文件表

943
01:04:18,430 --> 01:04:20,350
這是這麽一個設計

944
01:04:20,350 --> 01:04:26,430
那么对于保证所谓的这种前面提到的这个安全或者说那种同步互斥

945
01:04:26,430 --> 01:04:32,630
的操作,我们会有一个文件锁这边的概念,这边很早引入了lock,前段

946
01:04:32,630 --> 01:04:37,290
时间这是一个文件,针对文件的锁,你要直白的理解,就是我锁了一个文件之

947
01:04:37,290 --> 01:04:42,270
后呢,别的进程先访问这个文件就访问不了了,因为我把它锁起来了,这种

948
01:04:42,270 --> 01:04:48,210
方式,只是这个锁也有两种强制式的劝告式,强制式的意思是说,我锁

949
01:04:48,210 --> 01:04:49,390
了之后你确实就不能访问了,

950
01:04:49,390 --> 01:04:54,490
勸告是说,我锁了之后,你可以知道我锁了,但是你可以决定你的行为

951
01:04:54,490 --> 01:04:58,110
一样你无视这个锁,你还可以做相应的操作,也是OK的

952
01:04:58,110 --> 01:05:00,610
所谓的劝告式的,就建议式的一个锁

953
01:05:00,610 --> 01:05:04,390
这是两组不同的处理方式,大家能够有一定的了解就OK

954
01:05:05,970 --> 01:05:11,450
好,那在这个文件的数据这一块,我们说这个Data这一块

955
01:05:11,770 --> 01:05:14,430
还有很重要的问题是这个文件的大小问题

956
01:05:14,430 --> 01:05:18,190
那对于大文件和小文件,其实你怎么去组织它

957
01:05:18,190 --> 01:05:20,210
有不同的做法

958
01:05:21,430 --> 01:05:23,290
一般來說我們有一個八十二手原則

959
01:05:23,290 --> 01:05:25,790
如果大數文件都是一個小文件的話

960
01:05:25,790 --> 01:05:28,470
那我們就對這種小文件有些重點的考慮

961
01:05:28,470 --> 01:05:30,610
讓它能夠訪問的非常快速

962
01:05:30,610 --> 01:05:31,870
不用開要特別大

963
01:05:31,870 --> 01:05:34,190
那如果你這個文件都是非常大的文件

964
01:05:34,190 --> 01:05:35,790
那我們也有一些手段

965
01:05:35,790 --> 01:05:39,370
能夠快速地支持大文件的創建

966
01:05:39,370 --> 01:05:41,150
大文件的讀寫等等

967
01:05:42,490 --> 01:05:44,250
所以這其實都是

968
01:05:44,250 --> 01:05:46,610
我們一些不同的文件系統需要重點考慮的問題

969
01:05:47,810 --> 01:05:51,970
这也是在后面有时间的情况下会给大家做展开讲解

970
01:05:51,970 --> 01:05:57,650
这里面并不会深入讲解怎么去支持大文件或者小文件

971
01:05:59,030 --> 01:06:03,090
好 那我们再看这个 这是文件大小的一个考虑

972
01:06:04,950 --> 01:06:11,550
还有一个是讲文件的这个数据块的一个分配方式

973
01:06:11,550 --> 01:06:14,250
就是这个测到的分配 这边是数据块分配

974
01:06:14,250 --> 01:06:19,130
大家可以类比,我觉得类比是一个很好的学习方法

975
01:06:19,130 --> 01:06:23,570
我们前面讲的是类存,就拿类存来做比较

976
01:06:23,570 --> 01:06:27,530
类存也有类存的分配,这是实际上文件数据块的分配

977
01:06:27,530 --> 01:06:33,650
类存分配我们前面说的best,first,worst类存块的分配

978
01:06:34,250 --> 01:06:37,850
其实对于这种数据块分配来说,我们有些是可以借鉴的

979
01:06:37,850 --> 01:06:43,390
有些还有些它独特的地方,使得采取一些不同的方式来做

980
01:06:43,390 --> 01:06:48,370
比如说我们这种连续类型分配、链式、索引,这是我们说的不同的分配方式

981
01:06:48,710 --> 01:06:51,250
而且屏下指标也是一样,考虑这个碎片问题

982
01:06:51,250 --> 01:06:53,570
我们前面说的这个memory类型分配也是一样,碎片问题

983
01:06:53,570 --> 01:06:58,390
第二个呢,速度问题,这都是我们需要去做点考虑的

984
01:06:58,390 --> 01:07:02,030
这里面我们只给大家简单介绍一下有哪一些分配的方法

985
01:07:02,030 --> 01:07:04,830
比如说第一个叫连续分配,什么叫连续分配

986
01:07:04,830 --> 01:07:08,750
就是一个,这是一个代表一个文件,文件的一个inode

987
01:07:08,750 --> 01:07:11,730
那么它会指向这个数据块的开始的位置

988
01:07:11,730 --> 01:07:17,710
然后呢,还有一个什么呢,还有一个长度,这是一个Line长度,有这两个星期之后呢,

989
01:07:17,710 --> 01:07:21,110
那这个就,这一块就是放置的就是整个文件的数据内容。

990
01:07:22,030 --> 01:07:25,650
下一个文件,可能从这开始,又是一个连续的一个款式,所谓的连续分配。

991
01:07:26,310 --> 01:07:30,810
那这个,你可以采取最先、最佳,我们前面用的那些方法是OK的。

992
01:07:30,970 --> 01:07:35,210
而且你这个,你这么分配之后,你发觉你这个读这块文件内容非常高效应,

993
01:07:35,250 --> 01:07:38,530
那顺序放在一起,然后你可以快速的进行读写。

994
01:07:38,530 --> 01:07:44,190
但是它缺点是一样的,就是频繁分配会带来碎片,特别是分配释放

995
01:07:44,190 --> 01:07:50,850
的话,因为这里面一旦把这一块给释放掉,这一块是空的,但是有可能下面一

996
01:07:50,850 --> 01:07:53,650
块比它更大,这种情况下这块就用不着了。

997
01:07:53,730 --> 01:08:01,310
这就所谓的碎片带来的一些问题,这其实和我们前面讲的内存的分配

998
01:08:01,310 --> 01:08:04,350
是类似的,这是连续的分配。

999
01:08:04,350 --> 01:08:05,550
当然也需要注意

1000
01:08:05,550 --> 01:08:10,350
我们列在这儿不是代表着它everything都是什么情况下都是差的

1001
01:08:10,350 --> 01:08:12,050
在某些情况下它是有效的

1002
01:08:12,050 --> 01:08:12,790
什么情况

1003
01:08:12,790 --> 01:08:14,970
本来在课堂可以直接问大家

1004
01:08:14,970 --> 01:08:16,770
但现在我也不太好问

1005
01:08:16,770 --> 01:08:17,970
所以还是自问自答

1006
01:08:17,970 --> 01:08:19,350
比如CD-ROM

1007
01:08:22,210 --> 01:08:24,530
它是一次性写入多次读

1008
01:08:24,930 --> 01:08:26,850
写进去之后它就不会再改

1009
01:08:26,850 --> 01:08:30,670
也就不会存在说频繁的分配这个问题就不存在

1010
01:08:30,670 --> 01:08:31,790
既然我一次写入的话

1011
01:08:31,790 --> 01:08:34,570
第一次做的时候我就把它一次性的写好了

1012
01:08:34,570 --> 01:08:35,970
后面只是一个读操作

1013
01:08:35,970 --> 01:08:37,310
那么在这种方式下

1014
01:08:37,310 --> 01:08:38,750
对CD-ROM这个方式呢

1015
01:08:38,750 --> 01:08:42,030
我们可能有一个比如ISO9660

1016
01:08:42,030 --> 01:08:43,150
这么一个文件系统呢

1017
01:08:43,150 --> 01:08:47,010
就很适合于基于这种联系分配来进行

1018
01:08:47,010 --> 01:08:48,750
它的文件系统的一个组织

1019
01:08:48,750 --> 01:08:51,190
这就是我们说这个分配还是有它存在的价值

1020
01:08:52,390 --> 01:08:53,390
我们看第二种

1021
01:08:53,390 --> 01:08:54,810
称之为链式分配

1022
01:08:54,810 --> 01:08:58,010
链式分配是数据化以链表其实来进行存储

1023
01:08:58,010 --> 01:08:59,510
你看这也很简单

1024
01:08:59,510 --> 01:09:00,930
比如这是一个inode

1025
01:09:00,930 --> 01:09:06,250
它指向了这个第一块,第一块会指向第二块,它有一个指针,这形成一个链,这

1026
01:09:06,250 --> 01:09:07,590
就是所谓的链表形式。

1027
01:09:07,790 --> 01:09:15,510
这种方式很明显就是它的灵活性很大,因为下面一块在这个地方,我可以直接把

1028
01:09:15,510 --> 01:09:20,570
这一块增加一块,链到这儿来,中间我都可以跳过,避免了前面所有

1029
01:09:20,570 --> 01:09:23,210
的碎片问题,几乎没有碎片。

1030
01:09:24,170 --> 01:09:30,290
但是另一个问题,你访问这个块,你要找到这个块,你必须一个一个的找,才能找到

1031
01:09:30,290 --> 01:09:33,350
这儿来,所以它这个随机访问效率就差了

1032
01:09:33,350 --> 01:09:38,150
而且呢,如果把中间这一块给砍掉,那你这些后面的块也都丢了,你

1033
01:09:38,150 --> 01:09:38,810
找不着了

1034
01:09:38,810 --> 01:09:43,710
说破坏一个,后面碎坏,你就丢了,它这种所谓的可靠性也比较弱

1035
01:09:44,450 --> 01:09:49,110
但是还是一样,它简单,所以你会看到,也有它存在的价值

1036
01:09:49,110 --> 01:09:53,650
这是两种 再把这个链丝分配再稍微扩展一下

1037
01:09:53,650 --> 01:09:56,390
有一个显示和隐视两种

1038
01:09:56,390 --> 01:10:00,670
我们前面说的这种 比如说把这个链表信息

1039
01:10:00,670 --> 01:10:03,790
放在数据块里面 把它称作为隐视的

1040
01:10:03,790 --> 01:10:06,690
如果这链表信息专门组成一个结构来放的话

1041
01:10:06,690 --> 01:10:10,030
称作为显示的 这种就是典型的比如FAT

1042
01:10:10,030 --> 01:10:15,030
Windows微软它那个FAT文件系统就是这么来做的

1043
01:10:15,030 --> 01:10:17,510
就是一种我们称之为显示的一种结构

1044
01:10:17,510 --> 01:10:22,550
它有个FAT表,这个FAT表就是这个东西

1045
01:10:24,910 --> 01:10:27,570
这是链式分配的情况

1046
01:10:27,570 --> 01:10:30,410
它比较适合于小文件的一些管理

1047
01:10:30,410 --> 01:10:34,370
早期的,比如说微软的DOS操作系统

1048
01:10:34,370 --> 01:10:36,350
它就大量的FAT文件系统

1049
01:10:36,350 --> 01:10:39,530
作为它的一个文件的管理的一个结构

1050
01:10:39,530 --> 01:10:43,530
第三个就是索引分配,这主要用在Unix里面

1051
01:10:45,230 --> 01:10:49,330
用这种架构的这种这种组织结构是比较多的,什么叫索引,就是我们

1052
01:10:49,330 --> 01:10:56,170
叫inode,这个inode就是一个,这个i就是index的意思,就体现了这一款,那它你看

1053
01:10:56,170 --> 01:11:03,670
到它这里面这个所谓的这个一个文件,它首先有一个叫做专门叫indexed block,

1054
01:11:04,010 --> 01:11:10,710
这个ib是indexed block,实际上就是放的是inode,这个inode里面呢,会有一个索

1055
01:11:10,710 --> 01:11:13,230
引表,来指向不同的data,

1056
01:11:13,970 --> 01:11:18,190
这就是你看指向,这指向Data,这指向Data,这就是所谓的这个,我们说这个索

1057
01:11:18,190 --> 01:11:25,210
引数据块的一个,它的一个大致的一个含义,它也一样就是灵活,跟那个链板

1058
01:11:25,210 --> 01:11:31,770
差不多灵活,几乎没有碎片,它也直接是直接访问,这个直接是怎么说呢,跟它,跟这个

1059
01:11:31,770 --> 01:11:36,090
比起来,跟这个比起来,这儿直接过去呢,还稍微多了一层,多了一层

1060
01:11:36,090 --> 01:11:42,270
这个IB,但IB过后,IB过后,那这样就是一个直接访问了,那你如果把这一块看

1061
01:11:42,270 --> 01:11:43,210
成是一个我们前面说的

1062
01:12:14,170 --> 01:12:15,890
这样的话 卡下就不大

1063
01:12:15,890 --> 01:12:18,810
相对来说 你访问的是内存的一次指针的访问

1064
01:12:18,810 --> 01:12:20,670
其实内存就不大

1065
01:12:20,670 --> 01:12:23,770
同学说 你把这个也防内存是不是也会快一些

1066
01:12:23,770 --> 01:12:25,130
是这样的

1067
01:12:25,130 --> 01:12:27,030
由于我们说这个是什么

1068
01:12:27,030 --> 01:12:28,530
文件系统不是特别大的情况下

1069
01:12:28,530 --> 01:12:30,390
那我可以整个把这个FAT表

1070
01:12:30,390 --> 01:12:32,810
整个这个表也可以放到内存中来

1071
01:12:32,810 --> 01:12:34,190
放内存中来之后

1072
01:12:34,190 --> 01:12:36,890
这些指针的访问还是比较快的

1073
01:12:36,890 --> 01:12:38,590
对于内存的访问来说

1074
01:12:40,010 --> 01:12:41,790
相对于磁盘要快很多

1075
01:12:42,190 --> 01:12:46,050
所以只要放到内存中就基本上不是一个特别大的事情

1076
01:12:46,810 --> 01:12:49,090
但另一个问题怎么处理大文件

1077
01:12:50,110 --> 01:12:53,070
你这个index是有限的 你怎么处理大文件

1078
01:12:53,070 --> 01:12:55,970
比如这里面只有13项 那只能指向13个block

1079
01:12:55,970 --> 01:12:59,510
一个block 4k 那就13乘以4k这么一个文件

1080
01:12:59,510 --> 01:13:01,970
那再大一兆怎么办

1081
01:13:02,570 --> 01:13:05,750
能想到一个办法就是index of index

1082
01:13:05,750 --> 01:13:09,130
这里面指向的index呢 指向的是另外一个index

1083
01:13:09,130 --> 01:13:12,850
那這個next可以再指向下一個next,有點像什麼?

1084
01:13:13,030 --> 01:13:19,830
有點像我們前面講的多級頁表,多級頁表的結構,

1085
01:13:20,430 --> 01:13:24,050
就是我這只是一個目錄,這也是一個目錄,

1086
01:13:24,290 --> 01:13:26,930
直到這兒最後一個才會指向具體的數據,

1087
01:13:27,170 --> 01:13:33,070
就是這種所謂的,這叫鏈式或者是多級索引的一個,

1088
01:13:34,370 --> 01:13:36,910
我前面說的多級索引,這個時候多級索引,

1089
01:13:36,910 --> 01:13:45,970
鏈式的意思是說,它一個index會指向其他的index,多個index來指向數

1090
01:13:45,970 --> 01:13:46,410
據

1091
01:13:46,410 --> 01:13:52,390
這種鏈式結構呢,不如這種多級結構更加靈活,因為它可以更靈活地支持

1092
01:13:52,390 --> 01:13:53,110
大文件

1093
01:13:54,370 --> 01:13:59,650
這實際上是一級,這裡面是更多級的,這是新IB

1094
01:14:00,130 --> 01:14:04,910
這個我們後面會看到一個相應的結構,可以更清楚地知道它的一個組織方式

1095
01:14:09,950 --> 01:14:18,870
我们看看这是它的一个结构,多级,在这里面多级索引,它这里面整个index分了

1096
01:14:18,870 --> 01:14:26,690
几类,这是直接索引,像这里面比如10个直接索引下,有10个,然后还有一个是2级

1097
01:14:26,690 --> 01:14:30,790
索引,还有一个是3级索引,这个是1级索引。

1098
01:14:34,490 --> 01:14:38,110
直接说在这 二级的一级间接就是二级了

1099
01:14:38,110 --> 01:14:39,810
就是它指向的一个还是一个index

1100
01:14:39,810 --> 01:14:42,270
这里面再会指向所有的数据块

1101
01:14:42,270 --> 01:14:44,990
这样可以看出来我这里面的项

1102
01:14:44,990 --> 01:14:45,750
有很多项的话

1103
01:14:45,750 --> 01:14:50,190
它可以用一项来表示很多数据块

1104
01:14:50,190 --> 01:14:53,310
那么二级呢 是这个index指向

1105
01:14:53,310 --> 01:14:54,950
它指向这一块还是一个index

1106
01:14:54,950 --> 01:14:57,650
到这才是指向了一具体数据

1107
01:14:57,650 --> 01:14:59,970
这是我的二级 那还有三级

1108
01:15:00,630 --> 01:15:06,530
你如果这么支撑下去的话,很明显它可以支持非常大的文件内容

1109
01:15:07,370 --> 01:15:09,410
这是所谓的多级索引的方式

1110
01:15:09,410 --> 01:15:16,470
这也是我们现在Unix里面通常用的基于索引的一种inode组织结构

1111
01:15:20,010 --> 01:15:28,610
这样虽然能够表示大的文件,但是你会发现我每次把玩的时候都要去查找

1112
01:15:28,610 --> 01:15:29,950
多个索引块

1113
01:15:29,970 --> 01:15:32,670
那这个多奢运块这样就有开销

1114
01:15:33,730 --> 01:15:36,250
那如果你有很有效的这种缓存机制

1115
01:15:36,250 --> 01:15:37,810
把这些都放到内容中来

1116
01:15:37,810 --> 01:15:39,130
那也许还OK

1117
01:15:39,590 --> 01:15:41,790
但是这个文件大文件本来

1118
01:15:41,790 --> 01:15:45,370
它这个数据块也会放到buff里面了

1119
01:15:45,370 --> 01:15:47,430
你这个index也会放到buff里面了

1120
01:15:47,430 --> 01:15:49,610
那大家就会对这个buff

1121
01:15:49,930 --> 01:15:51,630
我们说的缓冲区

1122
01:15:51,630 --> 01:15:53,370
你必须要有一个有效的管理

1123
01:15:53,370 --> 01:15:55,310
才能够实现高效的访问

1124
01:15:55,310 --> 01:15:56,850
所以它的这个管理本身来说

1125
01:15:56,850 --> 01:15:58,970
会比我们通常前面说的那个

1126
01:15:58,970 --> 01:16:04,970
基于内存的页面自然算法,要更加复杂一些,因为它的类型更多。

1127
01:16:07,370 --> 01:16:13,330
那就是把这一块给大家简单说了之后,这有一个比较,

1128
01:16:13,990 --> 01:16:19,570
这个大致的比较就是对顺序分配、列室分配和索引分配。

1129
01:16:19,970 --> 01:16:25,550
我们这边其实已经讲过了,大家再稍微看一下,会对它有一个整体的把握。

1130
01:16:27,110 --> 01:16:31,650
讲完这个文件分配之后,我们再讲这个空闲空间的管理,这空闲空间

1131
01:16:31,650 --> 01:16:44,710
更多是指的是inode和data,quad,block的管理,我们前面已经看到了bitmap,其实

1132
01:16:44,710 --> 01:16:51,470
就想用一个bit来代表一个inode或者代表一个data的是否被分配了,就

1133
01:16:51,470 --> 01:16:55,530
表明这个信息,这是一个典型的一个高效的一个分配方式。

1134
01:16:57,250 --> 01:17:02,950
比如说对160G的硬盘,数据块假设有40MB的话

1135
01:17:03,670 --> 01:17:06,770
那么把40MB我们用一个bit代表一个数据块的话

1136
01:17:06,770 --> 01:17:10,690
我们可以只要用5MB的位图就可以把整个数据块给管理起来了

1137
01:17:10,690 --> 01:17:15,970
那怎么去查找,我想这个算法大家应该比较容易想到

1138
01:17:15,970 --> 01:17:17,830
应该是比较快的能够做出来

1139
01:17:17,830 --> 01:17:20,550
比如说给出这个结构,迅速定位到它这个

1140
01:17:21,610 --> 01:17:26,830
空闲的inode通常分配等相应的一些小的一些计算题目应该能够

1141
01:17:26,830 --> 01:17:28,030
做到

1142
01:17:28,030 --> 01:17:29,930
当然也不仅仅是这种一种方式

1143
01:17:29,930 --> 01:17:35,710
我们还是一样可以通过链表的方式或者索引的方式

1144
01:17:35,710 --> 01:17:36,510
来管理空闲空间

1145
01:17:36,510 --> 01:17:40,550
就类似于我们刚才对文件的Datablock一样来管理

1146
01:17:41,490 --> 01:17:44,350
这种方式在某一些文件系统里面也存在

1147
01:17:44,350 --> 01:17:49,970
但目前来说我们觉得这种集位图的方式是用比较简洁的处理方式

1148
01:17:52,450 --> 01:17:56,030
希望大家能够对这些有一定的了解

1149
01:17:56,030 --> 01:17:58,270
最后我们会稍微总结一下

1150
01:17:58,270 --> 01:18:02,270
稍微总结一下文件系统的设计实现

1151
01:18:02,270 --> 01:18:03,050
讲得有点多

1152
01:18:03,610 --> 01:18:05,930
但是你重点把握几个视图

1153
01:18:05,930 --> 01:18:07,210
我觉得就OK

1154
01:18:07,210 --> 01:18:08,350
第一个视图是什么呢

1155
01:18:08,350 --> 01:18:09,330
用户的角度

1156
01:18:09,330 --> 01:18:10,490
你看到一个视图

1157
01:18:10,990 --> 01:18:13,690
这是大家最熟悉的

1158
01:18:13,690 --> 01:18:14,970
看到这么一个视图

1159
01:18:14,970 --> 01:18:16,150
第二个你要看到什么

1160
01:18:16,150 --> 01:18:19,550
看到的是一个目录里面的内容

1161
01:18:19,550 --> 01:18:23,710
包含了两部分,文件名和一个inode。

1162
01:18:23,930 --> 01:18:30,590
这是第二个试图了,就是你把这里面的这个目录里面的内容给挖掘出来,看

1163
01:18:30,590 --> 01:18:31,270
了这么一个图。

1164
01:18:32,330 --> 01:18:38,130
这都是站在一个进程的角度,或者应用的角度来看到的一个overview。

1165
01:18:38,870 --> 01:18:44,510
这个overview是站在系统的角度,站在OS的角度看到的一个内容。

1166
01:18:44,510 --> 01:18:51,550
Y角度里面它需要有file system,这个file system是在硬盘上这么一个总体的

1167
01:18:51,550 --> 01:18:52,170
结构,

1168
01:18:52,570 --> 01:18:59,130
包含了对整个这个的superblock,就是整个这个硬盘上的文件系统的一个结

1169
01:18:59,130 --> 01:19:01,290
构的一个总体的一个描述,

1170
01:19:02,250 --> 01:19:08,310
以及对重点的inode和data的一个管理,放哪儿呢?放这儿,inode bitmap

1171
01:19:08,310 --> 01:19:10,270
和data bitmap,哪些有的些没有。

1172
01:19:10,650 --> 01:19:14,470
怎么去分配,找空间块,CG bit来进行查找。

1173
01:19:14,910 --> 01:19:16,490
iNote里面又会记录到什么呢?

1174
01:19:16,510 --> 01:19:21,250
记录到我们说的它所管理的那些数据,

1175
01:19:21,410 --> 01:19:24,250
一个文件的数据具体在什么位置的一些信息。

1176
01:19:24,610 --> 01:19:29,650
这里面可能会放的是一个目录,也可能是指向是一个文件。

1177
01:19:29,890 --> 01:19:31,530
那目录就可能是它的内容是这个,

1178
01:19:31,770 --> 01:19:38,370
文件的内容可能就是纸白的这个文件的具体的一个字节流,这么一个数据。

1179
01:19:39,270 --> 01:19:45,590
这就是有这么一个全局的不同视角,看到这个OVO之后呢,

1180
01:19:45,670 --> 01:19:50,590
你再去理解怎么去读写文件就比较自然了。

1181
01:19:50,670 --> 01:19:55,550
比如说站在应用的角度来说,我会发出一个Open操作,

1182
01:19:55,670 --> 01:20:00,170
打开一个,然后再读一个文件,然后最后再做一个写操作,

1183
01:20:00,250 --> 01:20:02,510
但是这边没有写啊,就夹了这么一个操作,

1184
01:20:02,730 --> 01:20:06,730
那其实对应的这么一个图,你就很自然的会知道它做了什么事情。

1185
01:20:06,730 --> 01:20:12,450
比如说这个open,这open的一个tmp file这么一个文件,这个是竖着写的,大家看起来

1186
01:20:12,450 --> 01:20:18,790
肯定有点费劲,那么这里面它要去找这个的话,首先它就会找什么,找目录,找

1187
01:20:18,790 --> 01:20:29,150
这个,找这个应该叫,其实这个啊,这叫根目录,这叫什么tmp,然后再一个file,这个

1188
01:20:29,150 --> 01:20:35,070
是一个根目录,叫做root,它要去把这个根目录给读出来,这根目录里面

1189
01:20:35,070 --> 01:20:36,710
呢,就是这里面的内容,

1190
01:20:37,290 --> 01:20:42,090
我们再往下一点,你可以看这里,把这里面跟目录下的这个内容读出来

1191
01:20:42,090 --> 01:20:44,710
假如这里面还有一个tmp,还有一项叫tmp的话

1192
01:20:46,370 --> 01:20:48,190
那么tmp又是一个目录

1193
01:20:48,190 --> 01:20:53,490
它会进一步去找到tmp的inode,这个目录把这个内容给读出来

1194
01:20:53,830 --> 01:21:00,050
那tmp里面放的是一个file,这个file是一个常规文件,regular file

1195
01:21:00,050 --> 01:21:02,650
那么会把这个file这个inode会读出来

1196
01:21:02,650 --> 01:21:10,390
这是找到,读着 file 完之后才能知道它的数据内容在哪

1197
01:21:10,730 --> 01:21:13,990
它把这个读出来之后,找到它之后,它会返回一个 FD

1198
01:21:13,990 --> 01:21:18,550
这个里面没有画,进程里面有一个打开文件表

1199
01:21:18,550 --> 01:21:23,210
打开的文件里面有一个 index 是代表一个 idx

1200
01:21:23,890 --> 01:21:26,130
然后对这个 idx 进行一个 read 操作

1201
01:21:26,130 --> 01:21:32,210
我们说READ里面其实是READ一个是FD

1202
01:21:32,210 --> 01:21:34,170
然后还有一个buffer

1203
01:21:34,170 --> 01:21:36,390
那就是把这个FD所表示的文件

1204
01:21:36,390 --> 01:21:38,270
读到这个内存中的buffer中来

1205
01:21:38,910 --> 01:21:40,830
那么它还会做相应的读操作

1206
01:21:40,830 --> 01:21:42,810
那么读操作我要找到它数据在哪

1207
01:21:42,810 --> 01:21:45,150
你首先要找这个inode在哪

1208
01:21:45,150 --> 01:21:46,170
time的inode在哪

1209
01:21:46,170 --> 01:21:47,530
找这个inode之后

1210
01:21:47,530 --> 01:21:49,630
这不是time,应该是说file

1211
01:21:49,630 --> 01:21:51,350
file的一个inode在哪

1212
01:21:51,970 --> 01:21:54,290
这个file的inode会找到对应的数据

1213
01:21:54,290 --> 01:21:58,890
我们前面讲到它这个数据在这儿,把这个数据再读到内存中来

1214
01:21:59,550 --> 01:22:01,950
这读的内存是读到OS内存

1215
01:22:01,950 --> 01:22:04,910
先读到OS内存中来,通过我们的driver读到内存中来

1216
01:22:05,390 --> 01:22:10,170
然后OS内存中的数据再去拷贝到我们的用户台的buffer空间

1217
01:22:10,170 --> 01:22:12,430
才完成读写

1218
01:22:12,430 --> 01:22:14,510
这里面可以看到就是这里面的读

1219
01:22:15,130 --> 01:22:20,910
这里面的读操作就完了,这是相应性读操作

1220
01:22:21,870 --> 01:22:24,010
鞋也是类似的,这个我就不细讲了。

1221
01:22:24,030 --> 01:22:26,910
其实也是一样的一个查找过程,查找完之后再做一些鞋操作。

1222
01:22:31,290 --> 01:22:32,890
最后再简单讲一下分区。

1223
01:22:33,370 --> 01:22:39,110
这个分区实际上就是我们理解,我们现在也看到你这个硬盘特别大,

1224
01:22:39,710 --> 01:22:42,490
比如4个T或者多少个T,T笔。

1225
01:22:43,210 --> 01:22:48,450
那么我们没必要把所有这个硬盘空间都放在一个位置里面,

1226
01:22:48,450 --> 01:22:52,310
我可以有不同的分區,這裏面代表一個文件系統,這裏面代表一個文件系统

1227
01:23:18,210 --> 01:23:21,670
一致的展现在我们的应用程序和用户面前

1228
01:23:21,670 --> 01:23:24,810
这个就是我们文件系统能够干的事情

1229
01:23:25,590 --> 01:23:32,750
这一块我就大致把文件系统的设计实现给大家简单的过了一遍

1230
01:23:34,990 --> 01:23:38,150
上网课我觉得基本上就是比较稍微来说

1231
01:23:38,150 --> 01:23:42,890
由于缺少跟学生的当面的沟通基本上是自说自话

1232
01:23:42,890 --> 01:23:45,230
我也不知道同学看到啥

1233
01:23:45,230 --> 01:23:51,930
至少目前没看到有什么新的一些问题,那我就继续往下讲。

1234
01:23:53,750 --> 01:23:58,790
第三讲,第三讲讲的是支持崩溃一致性的文件系统。

1235
01:23:58,990 --> 01:24:04,810
实际上就是要设计一个可靠的文件系统,这我们强调的可靠性。

1236
01:24:05,650 --> 01:24:11,310
这可靠性主要是指断电或者是一些异常情况出现。

1237
01:24:12,090 --> 01:24:15,970
那文件系统会出现什么问题呢,就是它里面,我们说文件系统里面它有

1238
01:24:15,970 --> 01:24:19,810
大量的数据是放在一模一样的,那一模一样它里面有比如说,我们

1239
01:24:19,810 --> 01:24:28,990
说的,前面说的这个inode,这里面的data,这里面会指向它,那如果有一些异

1240
01:24:28,990 --> 01:24:37,830
常情况,这些指针信息没了,那这个data和这个里面的指向关系就不对

1241
01:24:37,830 --> 01:24:40,730
了,这就是一些所谓的不一致性问题。

1242
01:24:41,410 --> 01:24:46,830
我们需要把这个问题能够解决。如果不解决的话,会导致整个文件系统会混

1243
01:24:46,830 --> 01:24:54,830
乱,从而可以影响到我们操作系统和应用的一个对数据的存储访问

1244
01:24:54,830 --> 01:24:56,470
的一个情况。

1245
01:24:56,470 --> 01:25:04,170
所以我们需要,所谓的一定要将这个数据,整个放在磁盘上的文件中的数据

1246
01:25:04,170 --> 01:25:09,330
要保持一致性,这所谓的这个即使崩溃了,我们要尽量一次,要做,要,要,

1247
01:25:52,250 --> 01:25:56,190
它说一个应用以某种方式更新纸盘结构,加某个数据附带原文

1248
01:25:56,190 --> 01:26:02,030
件,某个数据写在原文件的末尾,它做法就是打开文件,通过Ls

1249
01:26:02,030 --> 01:26:03,250
ig,这是一个系统调用。

1250
01:26:06,290 --> 01:26:12,590
这个系统调用相当于是把文件的读写偏一量移到了文件的末尾,

1251
01:26:13,390 --> 01:26:16,410
然后这样的话,你写的话就写在从文件末尾开始写了。

1252
01:26:16,410 --> 01:26:21,190
然后在关闭文件前,向文件发出当个4K写入来完成追加

1253
01:26:21,190 --> 01:26:23,890
这就是添加了4K的数据

1254
01:26:23,890 --> 01:26:27,310
这是它大致的一个例子,那么这个例子呢

1255
01:26:27,310 --> 01:26:28,690
我们把文件系统给简化一下

1256
01:26:29,830 --> 01:26:32,910
设计一个简单的文件系统,能够看到它的一个结构

1257
01:26:32,910 --> 01:26:36,730
比如这个文件系统里面包含了inode,这是一个inode bitmap

1258
01:26:36,730 --> 01:26:37,910
inode和data

1259
01:26:40,190 --> 01:26:41,510
这是一个简化的文件系统

1260
01:26:42,970 --> 01:26:45,570
那這裡面的Inode的Bitmap有8位

1261
01:26:45,570 --> 01:26:49,410
那意味著它支持8個Inode的框

1262
01:26:50,910 --> 01:26:54,150
然後Data這個Bitmap也是8位

1263
01:26:54,150 --> 01:26:56,290
那意味著也只支持8個數據框

1264
01:26:56,290 --> 01:26:59,090
這是一個非常簡化的一個文件系統

1265
01:26:59,090 --> 01:27:00,490
但它能夠說明問題

1266
01:27:00,910 --> 01:27:04,510
我們希望通過對這個事情的一個闡述來看看

1267
01:27:04,510 --> 01:27:06,270
它到底會出現什麼樣的問題

1268
01:27:06,270 --> 01:27:09,870
以及怎麼去解決這種所謂的崩潰一致性的情況

1269
01:27:10,770 --> 01:27:16,430
好,那我们说要写一个4K,这里面一个DataBlock就是一个4K,要做这么一个操

1270
01:27:16,430 --> 01:27:17,870
作,那要干什么呢?

1271
01:27:18,690 --> 01:27:26,410
这里面做的,第一,你要修改什么呢?要修改,我看这里面说要修改好多东西,

1272
01:27:26,490 --> 01:27:31,150
不是第一,第二,反正就是分,总的要做这么多事情,第一个你要把这个信息要改了。

1273
01:27:31,150 --> 01:27:38,990
第二个版本,我们知道v2是在于,你这里面的信息,你有两个,以前只有一个链接

1274
01:27:38,990 --> 01:27:45,470
指向这,现在你增加了一个框,增加了一个sql,这一个,这一个,所以这里面的

1275
01:27:45,470 --> 01:27:49,490
整信息会发生变化,所以v2是第二个版本的意思,要不要进行一个重新

1276
01:27:49,490 --> 01:27:50,230
的更新。

1277
01:27:50,230 --> 01:27:56,350
第二个呢,你这个这一块本来是空白的,这是空闲的,但现在你增加了一个

1278
01:27:56,350 --> 01:28:04,010
块,所以在这地方,这和这是对应的,这两者之间是一个对应关系,你会

1279
01:28:04,010 --> 01:28:08,350
对位图做一个修改,所以这个位图也是第二个版本了。

1280
01:28:09,070 --> 01:28:13,590
第三个呢,你的DataBlock这一块呢,你要把这一块写进去,其实做了三个

1281
01:28:13,590 --> 01:28:18,630
写操作,所以你为了说通过这种方式,像一个文件发生4KB,你其实

1282
01:28:18,630 --> 01:28:19,790
做了三个写操作。

1283
01:28:20,590 --> 01:28:27,630
如果这三个写套作一定能正确完成,那一点事儿没有,但这种情况不一定,有很多

1284
01:28:27,630 --> 01:28:33,350
原因导致它不一定,比如说我们的缓存,你一开始写的时候它可能在内存中,最后

1285
01:28:33,350 --> 01:28:38,810
可能由于你这个系统绷乱,或者说你文件掉电了,在内存中的数据没有

1286
01:28:38,810 --> 01:28:45,950
放进去,那就会出现说这里面的某一个部分没有真正写在彩排上的一个情况,

1287
01:28:46,170 --> 01:28:49,390
这三种,每一个都有这种可能性。

1288
01:28:49,390 --> 01:28:55,690
最后出现所谓的不一致的状态,我们可以看到底有哪些不一致的状

1289
01:28:55,690 --> 01:28:56,390
态。

1290
01:28:58,410 --> 01:29:05,570
给了几个例子,第一个,我们前面说要写三个,就是inode,bitmap和数据块。

1291
01:29:06,870 --> 01:29:15,810
第一种情况,我只是想数据块写,那你这个inode和bitmap没有更新。

1292
01:29:45,810 --> 01:29:55,310
第二个情况,只更新了iNote,现在这一块是更新了,但这一块并没有写,你

1293
01:29:55,310 --> 01:30:00,370
更新了iNote,其实有这么一个指向,这么一个指针过来,这个数据其实是无效的,

1294
01:30:00,530 --> 01:30:09,250
这是什么数据,垃圾数据,你读进去之后,你像是垃圾数据,这有问题,而且

1295
01:30:09,250 --> 01:30:11,310
这个地方其实也没有。

1296
01:31:12,290 --> 01:31:19,130
所以这个数据就永远,文件系统永远不会使用这一块,这导致数据被

1297
01:31:19,130 --> 01:31:20,530
浪费了。

1298
01:31:21,630 --> 01:31:27,350
这是我们说只更新了这三个写操作中的一部出现的情况。

1299
01:31:27,830 --> 01:31:32,530
但还有啊,这情况反而是非常非常多,崩溃之后出现的各种情况非常多。

1300
01:31:32,530 --> 01:31:40,530
比如说,一根字写起来形容两个,位图和inode,但是没写data,那一样

1301
01:31:40,530 --> 01:31:46,710
就会出现什么呢?垃圾,垃圾数据,这个数据其实是没有写进去嘛,所以说你

1302
01:31:46,710 --> 01:31:52,910
这块访问过来的访问道是能访问到,但你的数据内容不对,这是写起

1303
01:31:52,910 --> 01:31:58,430
来的这两个,还有呢,是inode和数据框,inode数据框呢,意味着这块

1304
01:31:58,430 --> 01:32:02,450
没写,这块没写,这块没写,这块没写的话,一样,

1305
01:32:02,450 --> 01:32:07,850
有可能下一个创建新的文件的内容的时候呢,因为这是空的,它会把这块给

1306
01:32:07,850 --> 01:32:13,510
分配出去,使得它的内容会被覆盖,会被其他的文件内容给覆盖掉,出

1307
01:32:13,510 --> 01:32:17,070
现问题,这这这这就有问题了。

1308
01:32:18,450 --> 01:32:25,410
还有一种情况,这种情况什么呢,写入了未图和数据,但是inode没有改,写入了

1309
01:32:25,410 --> 01:32:31,750
未图和数据,这个图还是用这个图好点,这块是对的,它说这块是对的。

1310
01:32:32,450 --> 01:32:39,030
这个数据呢也是对的,但是这个不存在。这个不存在,那你就没法访问这个数据

1311
01:32:39,030 --> 01:32:39,450
了。

1312
01:32:40,410 --> 01:32:45,450
你这个DB写来白写,而且不会被释放掉。

1313
01:32:46,190 --> 01:32:50,810
因为你释放这个文件的时候,它只记录这个Data,它把这个释放掉了。

1314
01:32:50,810 --> 01:32:56,690
但这个没有人去释放,所以导致第一,写来白写,第二,这个数据会被永久地留

1315
01:32:56,690 --> 01:32:58,350
下来,浪费了。

1316
01:32:58,350 --> 01:33:02,670
所以浪费了,这就是我们说在这个情况6情况下的一个设计

1317
01:33:03,370 --> 01:33:06,050
你看我们比较详细的讨论了一下,就是由于

1318
01:33:06,630 --> 01:33:09,590
只写了一部分之后,产生了各种各样复杂的情况

1319
01:33:10,170 --> 01:33:12,890
而且这个情况最后导致的后果也是千差万别的

1320
01:33:13,950 --> 01:33:18,030
使得我们说这个一旦崩溃之后,会带来非常严重的影响

1321
01:33:18,030 --> 01:33:19,750
所以我们一定要解决它,怎么解决

1322
01:33:20,690 --> 01:33:21,510
有两种办法

1323
01:33:24,550 --> 01:33:30,650
就是我对文件系统本身不做任何的操作、不做任何改变,只是说反

1324
01:33:30,650 --> 01:33:39,750
正错了,没关系,下次重新启动的时候,我专门运行一个程序,File System Check,它

1325
01:33:39,750 --> 01:33:47,670
来负责检查是否在这里面是否有所谓的不一致性的存在,如果它

1326
01:33:47,670 --> 01:33:50,430
能够确保这里面内部数据是一致的,那就没问题。

1327
01:33:51,190 --> 01:33:52,570
这是他要干的事情

1328
01:33:54,630 --> 01:33:58,350
怎么干?它是更全面的一个检查

1329
01:33:58,350 --> 01:34:02,050
其实我们这里面讲这个结构的时候

1330
01:34:02,470 --> 01:34:05,330
并没有考虑到一个完整的OS的一个情况

1331
01:34:05,330 --> 01:34:06,430
比如说Cyberblock

1332
01:34:07,650 --> 01:34:09,270
这个结构并没有考虑

1333
01:34:09,270 --> 01:34:10,570
那你做FSCK的时候

1334
01:34:10,570 --> 01:34:15,090
它其实需要考虑一个完整的整个文件系统的一个check

1335
01:34:15,090 --> 01:34:17,670
既然对整个文件系统做check很明显

1336
01:34:17,670 --> 01:34:24,270
这文件系统很大的情况下,你check的时间和文件size成正比,开交很大,这

1337
01:34:24,270 --> 01:34:30,770
早期的文件正比就这样,就是如果掉电,我们念书的时候,时不时的,要不然系

1338
01:34:30,770 --> 01:34:35,390
统崩溃了,要不然掉电,掉电其实还比较少,主要是系统崩溃,那也

1339
01:34:35,390 --> 01:34:42,590
可能造成文件系统的不一致,那么你就要掉FSCK,你用一个1.2兆的,

1340
01:34:42,590 --> 01:34:47,650
兆B的软盘,叫它做check的话,那还OK,你这个文件系统也就,整个

1341
01:34:47,650 --> 01:34:53,190
这个磁盘的容量也就是1.2兆币,没问题,但是发现变成了500兆币的时候,它

1342
01:34:53,190 --> 01:35:01,010
要越来越大了,变成了4GB的时候,这个还靠它检查就难以容忍了,这

1343
01:35:01,010 --> 01:35:07,010
时间化得越来越长,而现在我们的硬盘是以TB为衡量标准的。

1344
01:35:07,010 --> 01:35:13,070
那你可以可見這個FSCK要去check這裡面的不同的部分

1345
01:35:13,070 --> 01:35:16,970
SybilBlock、iKnow、Bitmap、iKnow的data之間的不一致性

1346
01:35:17,810 --> 01:35:20,690
花的時間是非常長的

1347
01:35:20,690 --> 01:35:21,610
所以這種方式

1348
01:35:23,510 --> 01:35:24,380
怎麼說呢

1349
01:35:25,390 --> 01:35:28,450
就是現在對這種大的文件系統來說

1350
01:35:28,450 --> 01:35:30,310
大的存儲設備來說

1351
01:35:30,310 --> 01:35:33,970
這種方式還是需要

1352
01:35:33,970 --> 01:35:35,570
在極端情況下還是需要

1353
01:35:35,990 --> 01:35:41,150
但是用的次數越少越好,因為它實驗檢查實在是太開了太大了

1354
01:35:41,150 --> 01:35:46,070
它其實就要檢查我們說的那幾個部分是否有存在不一致的現象

1355
01:35:51,130 --> 01:35:58,410
另外還有一點是確實要靠它來幫忙這種前面沒有講到的一些問題

1356
01:35:58,410 --> 01:36:01,370
這裡面這一些都是它講的鏈接這種不一致性

1357
01:36:01,370 --> 01:36:09,090
还有一个什么问题是它需要去解决的,这个是比较特殊的,坏块。为什么有坏块?D

1358
01:36:09,090 --> 01:36:18,430
isk,不是一个可以用非常非常长时间的一个东西,跟我们去电脑比起来,你可能容易坏

1359
01:36:18,430 --> 01:36:27,050
的,其实我也有感觉,OK,大家先休息一下,11点20秒,休息5分钟。

1360
01:36:39,050 --> 01:36:44,050
我发觉有同学在上面问问题,等会我可以回答一下,聊天里面,如果大家有问题

1361
01:36:44,050 --> 01:36:54,690
的话,欢迎大家通过聊天来给老师提问,随时提问,我先处理一下。

1362
01:41:21,590 --> 01:41:28,570
好 我们开始上课

1363
01:41:31,670 --> 01:41:43,570
我看到有同学提问,第一个问题是,哈希表是只有目录iNode中才有吗?

1364
01:41:45,830 --> 01:41:53,550
我理解哈希表只是目录iNode中,目录iNode指向的data,它的数

1365
01:41:53,550 --> 01:41:55,650
据,它的内容是放了一个哈希表。

1366
01:41:55,650 --> 01:41:58,170
那哈希白只是其中一種形式

1367
01:41:58,170 --> 01:42:00,530
那你說這個是不是只有它才有

1368
01:42:01,830 --> 01:42:03,910
如果是一般文件的話

1369
01:42:03,910 --> 01:42:07,450
確實超級統不會認為裡面會有一個哈希表

1370
01:42:07,450 --> 01:42:08,990
所以它更多的是針對目錄

1371
01:42:10,050 --> 01:42:12,370
所以應該簡單理解是

1372
01:42:12,370 --> 01:42:17,450
目錄中的內容是有哈希白這種組織形式的

1373
01:42:18,270 --> 01:42:20,430
第二個問題是請問

1374
01:42:20,430 --> 01:42:24,470
丟掉的數據如何通過檢查恢復

1375
01:42:24,470 --> 01:42:27,870
这一部分的数据不是不可能获得吗?

1376
01:42:30,690 --> 01:42:36,490
是这样的,大家想一想,我们通常,我不知道你们碰到过没有?

1377
01:42:36,550 --> 01:42:42,630
我是碰到过,就是在我念书的时候,这个磁盘坏了。

1378
01:42:42,870 --> 01:42:46,850
所谓磁盘坏了,有各种原因造成的,我们确实想去恢复它,确实有些

1379
01:42:46,850 --> 01:42:48,490
程序说可以恢复它。

1380
01:42:48,490 --> 01:42:52,130
这种恢复其实是基于一种猜测

1381
01:42:52,130 --> 01:42:57,050
它不是说是一种百分之百的准确的恢复

1382
01:42:57,050 --> 01:43:01,790
包括我们的硬盘 其实通过FSCK说做了一些恢复

1383
01:43:02,450 --> 01:43:07,590
在某种程度上来说 我们认为也是一种概率性的恢复

1384
01:43:07,590 --> 01:43:09,490
并不是百分之百能够恢复

1385
01:43:10,450 --> 01:43:13,470
猜测间 猜测的话 我可以有很简单的一些办法来做

1386
01:43:13,470 --> 01:43:17,010
比如說我那個inode裡面

1387
01:43:18,290 --> 01:43:19,350
我的那個怎麼說呢

1388
01:43:19,350 --> 01:43:21,330
它不一定是inode 它可能是一種指針結構

1389
01:43:21,330 --> 01:43:23,850
結構就不一定是inode結構 它可能是指針結構

1390
01:43:23,850 --> 01:43:26,110
比如說我們前面說FAT文件系統

1391
01:43:26,590 --> 01:43:28,910
FAT的那個文件系統就是

1392
01:43:28,910 --> 01:43:30,450
它的那個索引信息呢

1393
01:43:30,450 --> 01:43:33,310
它其實在這個磁盤上備份了兩塊

1394
01:43:33,310 --> 01:43:37,130
它有一個主的FAT表和一個重的FAT表

1395
01:43:37,130 --> 01:43:42,730
對於FAT表 它說記錄是一種鏈式結構的一種

1396
01:44:42,730 --> 01:44:44,670
学员中问的一些问题

1397
01:44:46,010 --> 01:44:48,770
好 那对于这种FSCK呢

1398
01:44:48,770 --> 01:44:49,930
我们其实已经看到了

1399
01:44:49,930 --> 01:44:50,950
大家把这个稍微读一下

1400
01:44:50,950 --> 01:44:55,390
可以看出来这种各种奇怪的

1401
01:44:55,390 --> 01:44:56,250
不一致的情况

1402
01:44:56,250 --> 01:44:59,330
那么FSCK会采取一种方式

1403
01:44:59,330 --> 01:45:00,530
来确保它是一致的

1404
01:45:00,530 --> 01:45:02,190
这种方式可能会丢失数据

1405
01:45:02,190 --> 01:45:03,930
可能会丢失数据

1406
01:45:03,930 --> 01:45:05,730
而且它这个开销非常大

1407
01:45:06,370 --> 01:45:07,290
这是一种方式

1408
01:45:07,290 --> 01:45:09,850
第二种方式我们说日治方式

1409
01:45:09,850 --> 01:45:11,130
日治方式呢

1410
01:45:11,130 --> 01:45:12,030
更多的是对文件系统

1411
01:45:42,330 --> 01:45:49,050
先寫下來,其實就寫了兩次,就是我先做了一個日誌,基於日誌呢,我可以再

1412
01:45:49,050 --> 01:45:52,150
做實際的寫操作。

1413
01:45:53,630 --> 01:45:58,870
那這是所謂的一個基於日誌的方式,等於是我先寫了一個,預寫了一個日

1414
01:45:58,870 --> 01:46:00,610
誌,然後再完成實際的讀寫。

1415
01:46:00,890 --> 01:46:04,810
而這個日誌和實際讀寫呢,其實大致的幹事是一樣的。

1416
01:46:04,950 --> 01:46:09,190
那這樣就確保,假設我實際讀一個分鐘出了問題,我可以通過日誌來重新

1417
01:46:09,190 --> 01:46:10,590
恢復我要幹的事情。

1418
01:46:12,970 --> 01:46:18,110
那我们看看这个它怎么来做的

1419
01:46:18,110 --> 01:46:25,010
就是还是以这个简单的一个这么一个结构来做一个标识

1420
01:46:25,010 --> 01:46:30,230
比如说我们前面说的那个你要做一个增加一个数据内容

1421
01:46:30,230 --> 01:46:31,670
那其实要改三个地方

1422
01:46:32,450 --> 01:46:34,590
就是data我们说的data部分

1423
01:46:41,530 --> 01:46:46,670
那如果我们确保这整个三个部分中间不会被打断,所谓不被打断是要

1424
01:46:46,670 --> 01:46:51,010
不然成功,要不然全失败,等于啥也不做,要不然是把三个都做

1425
01:46:51,010 --> 01:46:56,130
成了,那其实就是做一个所谓的transaction的机制,这种机制呢来自于数据

1426
01:46:56,130 --> 01:47:04,030
库这个领域,这也是为什么就是我们的这个另外一个老师李国阳老师,他对数据库

1427
01:47:04,030 --> 01:47:04,570
特别精通

1428
01:47:04,570 --> 01:47:11,750
所以他讲这一块特别得心应手,就是怎么去做这个transaction呢?

1429
01:47:11,750 --> 01:47:16,930
其实我们简单理解就是这三步其实有一个结束,

1430
01:47:17,230 --> 01:47:23,410
只有把整个这个都搞定之后呢,才称之为一个日制的一个完成,一个日制记

1431
01:47:23,410 --> 01:47:24,010
录的完成。

1432
01:47:28,190 --> 01:47:36,850
那我们看一下要把这个都搞定的话,那还会不会有些其他的情况出现,比如说我们虽

1433
01:47:36,850 --> 01:47:44,390
然这简化每一个代表一个block,一个buffer的一个缓冲,其实我们要写五部分,但是

1434
01:47:44,390 --> 01:47:49,930
在写的过程中,写的过程中呢,你写了这几块,

1435
01:47:53,290 --> 01:48:02,510
但是这一块没有写进去,而是这一块的时候呢,这是第一步,这是第二步。这一块没

1436
01:48:02,510 --> 01:48:05,590
写进去的话,那么会变成这么一个情况。

1437
01:48:07,690 --> 01:48:14,570
那其實這就沒有達到所謂的這個,我們說要把這幾個整個變成一個Transaction

1438
01:48:14,570 --> 01:48:20,210
一次事物,完整的寫譯過程,沒有做到。那怎麽能做到呢?

1439
01:48:23,610 --> 01:48:31,730
它首先要确保的是把整个这个五个步骤的前面这四步先要写进去,

1440
01:48:31,970 --> 01:48:35,910
得到一个正确的确定的说我写完了这么一个标识,

1441
01:48:36,110 --> 01:48:38,510
一定确保得到这个写到这个值班上之后,

1442
01:48:38,750 --> 01:48:40,830
我才开始做这么一个操作。

1443
01:48:41,090 --> 01:48:42,590
前面说你前面不是这样的吗?

1444
01:48:42,630 --> 01:48:44,690
前面不就是把这五块全写进去吗?

1445
01:48:44,990 --> 01:48:45,730
这块全写进去吗?

1446
01:48:45,730 --> 01:48:53,130
是,但是当我们超级桶真正发出这个操作的时候,实际情况下,我们的硬盘,我们前

1447
01:48:53,130 --> 01:48:55,090
面讲的硬盘里面,其实它也有它的RAM。

1448
01:48:58,010 --> 01:49:02,250
所以你发了这五个操作说让它全部写完,它其实也不一定真正写完了。

1449
01:49:02,530 --> 01:49:08,430
所以我们只能采取一种更加保守的方式,我先写这四个部分,然后硬盘

1450
01:49:08,430 --> 01:49:14,210
告诉我说写完了,确实写了扯盘上之后,我还是写这个部分。

1451
01:49:15,510 --> 01:49:22,530
那有可能這一步沒寫進去,寫的時候過程中斷電了,那意味著你得到的

1452
01:49:22,530 --> 01:49:28,250
只是這麼一個信息,這個信息也不意味著是一個安全的狀態,所以意味著這個trans

1453
01:49:28,250 --> 01:49:29,270
action並沒有寫完。

1454
01:49:29,850 --> 01:49:39,810
所以我們要真正做完的話,那麼我們需要是這一步有一個反饋,這一步有一個反饋,都

1455
01:49:39,810 --> 01:49:42,330
寫完之後才叫這個日子寫完了。

1456
01:49:48,490 --> 01:49:54,830
这个就是我们说的这两步,日日写入,日日提交,分成两个阶段。

1457
01:49:57,170 --> 01:50:01,490
只有这两步完成之后,我们才开始真正的更新内容。

1458
01:50:01,770 --> 01:50:03,990
就是加减差点,把这个写到纸盘上去。

1459
01:50:04,290 --> 01:50:11,170
这是第三步,一共三步之后来完成整个文件的更新。

1460
01:50:11,170 --> 01:50:18,550
那么如果在这三步过程中发生了崩溃的话,

1461
01:50:19,170 --> 01:50:22,230
那么我们比如说在这一步写入过程中发生了崩溃,

1462
01:50:22,330 --> 01:50:25,270
那我认为后面两步就不用做了,等于是没有这个操作。

1463
01:50:26,290 --> 01:50:29,990
如果日字提交发生了崩溃,也不用做了。

1464
01:50:30,470 --> 01:50:35,810
但是你如果一二步完成了,第三步真正的理由没有写进去的话,

1465
01:50:36,250 --> 01:50:40,310
那么我可以根据一二来恢复第三步操作。

1466
01:50:40,990 --> 01:50:46,230
因为你这些信息都是存在的,我可以都写到一排上去了,我把它读出来,再进

1467
01:50:46,230 --> 01:50:49,450
行一次实际的写,那是OK的。

1468
01:50:49,470 --> 01:50:55,430
这我们说关于解决方案的一个考虑。

1469
01:50:55,670 --> 01:50:58,350
但这里面有一个问题在哪呢?就是性能还是性能。

1470
01:50:59,710 --> 01:51:05,170
因为这里面量最大的其实是DB,虽然我们这里面举的例子好像感觉它们是一个

1471
01:51:05,170 --> 01:51:05,510
量级的,

1472
01:51:05,510 --> 01:51:11,390
但其实实际情况下来说,可能是你修改这个只是一个很小的一个操作,但DB可能

1473
01:51:11,390 --> 01:51:13,390
是大量数据化去做写操作。

1474
01:51:13,750 --> 01:51:17,850
那这个大量数据化我都要放在一个产材体里面的话,那么其实有太多的

1475
01:51:17,850 --> 01:51:18,710
写,就会比较慢。

1476
01:51:20,410 --> 01:51:33,330
所以一个进一步的优化手段就是,我们把日字给它做一个简化,只去优化

1477
01:51:33,330 --> 01:51:34,910
什么,只去写Metadata。

1478
01:51:34,910 --> 01:51:36,530
而不是data

1479
01:51:36,530 --> 01:51:40,370
前面这种方式我们是把如果把这个看成metadata的话

1480
01:51:40,370 --> 01:51:45,430
这个看成data的话 我们这两块全都要去做一个日制的保存

1481
01:51:45,430 --> 01:51:50,950
但其实我们可以只保存什么呢 只保存我们的bitmap和index

1482
01:51:50,950 --> 01:51:56,210
从这种方式来 其实我们只对这个metadata做日制的工作

1483
01:51:57,150 --> 01:52:03,450
db这一块我们只写一次 我们并不把db做日制的保存

1484
01:52:03,450 --> 01:52:08,650
这种方式会快很多,因为我们少写了,我们这个没有写两次。

1485
01:52:10,370 --> 01:52:14,550
那如果要做这个的话,那你需要考虑这个顺序,这个顺序很重要。

1486
01:52:14,890 --> 01:52:19,150
如果顺序搞得不好的话,你还是会出现我们前面说的那种不一致的情况出

1487
01:52:19,150 --> 01:52:19,650
现。

1488
01:52:20,090 --> 01:52:23,650
那怎么来把这个顺序呢?更新的过程,你看到这个设计非常巧妙。

1489
01:52:25,990 --> 01:52:34,510
先写Data,再写这个字字,字字先写MetaData,再写Commit,就我们前面

1490
01:52:34,510 --> 01:52:41,730
说的这两步,先把MetaData叫inode和Bitmap写进去,再做一次and,

1491
01:52:41,850 --> 01:52:52,490
表明这个字字结束的一个提交,这是之前的第二步,现在是第三步,这是第一步,这是第二

1492
01:52:52,490 --> 01:52:53,530
步,这是第三步。

1493
01:52:55,230 --> 01:53:01,730
然后再check out metadata,然后这一步实际的把metadata写进去,然后再释放。

1494
01:53:02,130 --> 01:53:05,750
这是它整个的一个过程,这是五步的过程。

1495
01:53:06,010 --> 01:53:13,610
从这种方式可以确保通过首先强制写入数据,使得微信中指针不会

1496
01:53:13,610 --> 01:53:15,030
指向垃圾数据。

1497
01:53:15,310 --> 01:53:17,870
因为你先把这个写进去,这是很自然的过程。

1498
01:53:17,930 --> 01:53:20,470
那么如果不这样,会出现什么情况?

1499
01:53:50,470 --> 01:53:51,790
所谓的这种data。

1500
01:54:01,530 --> 01:54:04,130
稍等一下,我看到又有同学有反馈。

1501
01:54:11,830 --> 01:54:15,870
我刚才在课前问了一下,就是一页四章能不能看清楚,

1502
01:54:18,170 --> 01:54:25,970
然后,有同学说看得清楚,但现在也有同学说看起来还是影响体验,我其实

1503
01:54:25,970 --> 01:54:30,410
大家可以看出来我这样最大的好处在于我可以就是把前后给关联起来,否则

1504
01:54:30,410 --> 01:54:40,930
我要翻屏,那如果大家更喜欢一页一张还是四页一张的话,那我觉得大家可以有咱们

1505
01:54:40,930 --> 01:54:45,850
的这志愿者会发起一个投票,看大家更喜欢一页一张还是四页一张的话,

1506
01:54:46,970 --> 01:54:50,390
我其实是都OK 对我来说是没什么关系的

1507
01:54:50,390 --> 01:54:52,670
只是我到时候前后翻的问题

1508
01:54:52,670 --> 01:54:56,850
所以没关系 大家可以我先回一下

1509
01:54:57,830 --> 01:54:58,950
发起投票没问题

1510
01:54:59,550 --> 01:55:01,250
看看大家什么一个反馈

1511
01:55:01,250 --> 01:55:05,990
我也不知道大家是更喜欢哪种方式

1512
01:55:08,030 --> 01:55:10,590
好吧 那我就请志愿者投一个票

1513
01:55:10,590 --> 01:55:14,770
看看大家更喜欢这种方式呢

1514
01:55:18,730 --> 01:55:22,950
在没有得到结果之前,我还先继续这么讲吧。

1515
01:55:23,170 --> 01:55:26,130
好,那我前面说到的就是,在这一块就是,

1516
01:55:26,130 --> 01:55:28,410
它避免了一个指向垃圾数据的问题,

1517
01:55:28,570 --> 01:55:29,950
就是这种情况会出现这种问题。

1518
01:55:30,730 --> 01:55:34,650
好,那最后呢,我就再说一下这个Data,

1519
01:55:34,770 --> 01:55:36,870
就是我们前面这种方式和这种方式,

1520
01:55:37,030 --> 01:55:41,890
它们在处理过程中的一个大致的一个时间线的一个过程,

1521
01:55:42,010 --> 01:55:44,270
就是时间线就随于先发哪个,

1522
01:55:44,270 --> 01:55:46,310
大致的一个处理

1523
01:55:46,310 --> 01:55:48,290
那么我看看

1524
01:55:49,950 --> 01:55:52,250
这一块的一个

1525
01:55:52,250 --> 01:55:52,910
一个表述

1526
01:56:01,410 --> 01:56:02,530
看这是

1527
01:56:14,410 --> 01:56:22,450
嗯,先看这个,这个一开始是干什么的,一开始是先把

1528
01:56:25,610 --> 01:56:32,050
就是我们说的这种方式,先把这个transaction开始写进去

1529
01:56:32,050 --> 01:56:38,610
然后再把这个metadata和data写进去,最后再把txt写进去,我们说的

1530
01:56:39,790 --> 01:56:40,270
一

1531
01:56:43,790 --> 01:56:51,410
这两个步骤给写完,这种方式是把日字写进去了,最后还会做一次

1532
01:56:51,410 --> 01:56:58,910
所谓的Data本身的写操作过程,所以这里面可以看到Data写了两遍,这是

1533
01:56:58,910 --> 01:57:00,370
我们说它为什么开较大的原因。

1534
01:57:00,370 --> 01:57:11,250
而对于这种metadata这种日式方式的决动方式,我们看到它的写法是我首先

1535
01:57:11,250 --> 01:57:25,850
写的data,然后再把transaction里面会记录它的metadata给写进去,然后再把这个

1536
01:57:25,850 --> 01:57:26,810
写进去。

1537
01:57:26,810 --> 01:57:36,390
做完这个操作之后,再接下来我就会完成实际的metadata的处理。

1538
01:57:36,530 --> 01:57:44,750
由于这一块我只写了一次,所以它的效率会比Data Genome的方式要快

1539
01:57:44,750 --> 01:57:45,390
一些。

1540
01:57:47,430 --> 01:57:52,250
这是关于崩溃移植性的一个介绍。

1541
01:57:52,790 --> 01:57:57,590
OK,那这一块就简单给大家讲解完毕

1542
01:57:57,590 --> 01:57:58,930
那大家会知道什么呢

1543
01:57:58,930 --> 01:58:04,590
就知道说对一种可靠性的这个需求

1544
01:58:05,930 --> 01:58:10,310
会使得我们要去设计一种能够快速的恢复

1545
01:58:10,310 --> 01:58:12,650
这种由于掉电或者是系统崩溃

1546
01:58:12,650 --> 01:58:14,830
导致文件系统不一致的一种情况

1547
01:58:14,830 --> 01:58:16,570
我们有两种方式

1548
01:58:16,570 --> 01:58:18,410
一种是FSCK这种传统的方式

1549
01:58:18,410 --> 01:58:20,450
也有说我们对文件系统本身

1550
01:58:20,450 --> 01:58:27,950
做出一种日日的知识机制,除非使得在掉电或者崩溃之后,我们可以

1551
01:58:27,950 --> 01:58:30,070
快速的恢复文件系统的一致性。

1552
01:58:30,250 --> 01:58:34,950
这是我们这一节想重点给大家讲解的内容。

1553
01:58:36,690 --> 01:58:46,770
好,那接下来讲第四节,第四节是讲实验,这一块我们实验也给大家

1554
01:58:46,770 --> 01:58:47,370
布置了。

1555
01:58:49,210 --> 01:58:56,450
然后这个其实是需要单页的,因为这里面的内容更细,用一页的方式我觉得更加

1556
01:58:56,450 --> 01:58:57,370
容易展示出来。

1557
01:58:58,450 --> 01:59:04,070
这个给大家介绍一下,这个还没等到投票,本来我想是一二三是用四页方

1558
01:59:04,070 --> 01:59:08,070
式,然后这个第四节用一页方式,大家都可以感受一下。

1559
01:59:08,570 --> 01:59:15,630
这个一页是由于,原因是在于我们说的这个内容更细了,你用视野看不

1560
01:59:15,630 --> 01:59:19,290
看不清了,确实看不清了,我们看看这一页的方式怎么回事。

1561
01:59:20,230 --> 01:59:27,110
这讲的是实验,这是大致的一个过程,就是我们到底要做什么事情,然后它的一个历史背

1562
01:59:27,110 --> 01:59:30,930
景,时间步骤,软件架构和相应的程序设计,怎么去做这个事情。

1563
01:59:30,930 --> 01:59:35,930
跟前面的基于进程的OS比起来,它重点多了哪呢?

1564
01:59:35,950 --> 01:59:45,130
多了这一块,多了这一块,这一块内容,就是文件这一块内容。

1565
01:59:45,330 --> 01:59:49,010
当然你需要注意它和我们的进程控制块这一块有一个交集,就在这。

1566
01:59:50,050 --> 01:59:58,030
我们说这个文件描述符表,你看到这个index最终会变到这里面去,变成它的

1567
01:59:58,030 --> 01:59:58,750
一个fd。

1568
01:59:59,270 --> 02:00:05,050
然后我们的整个应用程序通过这些新的系统调用来完成对文件的

1569
02:00:05,050 --> 02:00:05,630
读写

1570
02:00:05,630 --> 02:00:08,090
当然这里面我们并没有强调什么

1571
02:00:08,090 --> 02:00:09,730
并没有强调BlockDriver

1572
02:00:09,730 --> 02:00:13,790
并没有把这个DeviceDriver作为一个重点来讲解

1573
02:00:14,510 --> 02:00:21,790
这一块你就假定我们提供了一个比较简单的Driver

1574
02:00:22,250 --> 02:00:27,290
然后它能够去把磁盘中的一个一个扇区

1575
02:00:27,750 --> 02:00:32,790
你给它一个散区的index,可以把这个散区做一个读或者写操作就行了

1576
02:00:32,790 --> 02:00:35,630
这是一个blockdriver的一个,我们去弱化了

1577
02:00:35,630 --> 02:00:36,970
但是我们重点是什么呢?

1578
02:00:37,930 --> 02:00:40,250
FD table跟进程管这一块相关的

1579
02:00:40,250 --> 02:00:44,630
以及这个EZFS跟这个文件系统相关的一部分的内容

1580
02:00:47,270 --> 02:00:51,870
然后这一块是系统级的,这一块进程级的,所以它们这有个交集

1581
02:00:51,870 --> 02:01:01,090
OK,这是一个总体的架构,可以看出来,我们的OS又多了一些内容。

1582
02:01:14,230 --> 02:01:19,070
那相对于以往目标来说,以往目标主要是提高性能,减化开发,

1583
02:01:19,150 --> 02:01:19,650
加强安全。

1584
02:01:19,650 --> 02:01:26,170
那这个文件OS,最主要的这个文件系统OS的支持,最主要的目标是什么,

1585
02:01:26,230 --> 02:01:29,470
支持数据的持续化保存,这是我们干的事情。

1586
02:01:30,830 --> 02:01:35,710
那它这个结构其实我们刚才已经看到过了,从总体的一个抽象的结构来说,

1587
02:01:36,010 --> 02:01:36,850
也包含这些内容。

1588
02:01:37,150 --> 02:01:44,290
我们也有相应的一些VFS,具体文件系统,就是EDFS,还有这个缓存,还有驱动

1589
02:01:44,290 --> 02:01:45,030
的内容。

1590
02:01:45,030 --> 02:01:54,070
但我们重点是在这一块这一块的一个姿势上面

1591
02:01:57,910 --> 02:02:01,350
那我们通过这个整个这个实验的实践

1592
02:02:01,350 --> 02:02:02,590
不是实验实践

1593
02:02:02,590 --> 02:02:06,270
你要能够理解文件文件的基本概念

1594
02:02:06,270 --> 02:02:08,790
特别是对应着实现这一块来说

1595
02:02:08,790 --> 02:02:10,570
你会发现他们很多相近的地方

1596
02:02:10,570 --> 02:02:15,010
前面那个图已经给出了一种非常overview的一个设计

1597
02:02:15,010 --> 02:02:18,250
但是你会发现在距离设计上面其实还有很多一些小的差异

1598
02:02:18,250 --> 02:02:20,510
这个差异体验在你的要达到的目标上

1599
02:02:20,510 --> 02:02:23,350
就是我们看到我可以实验一个是Easy就是File

1600
02:02:23,350 --> 02:02:25,290
非常简单的一个文件系统

1601
02:02:25,290 --> 02:02:26,870
也可以实现非常复杂的文件系统

1602
02:02:26,870 --> 02:02:28,390
我们这里面强调的是简单

1603
02:02:28,390 --> 02:02:30,510
你会看到我们在距离实验中

1604
02:02:30,510 --> 02:02:32,710
可能我们前面讲到的系统级的打开的

1605
02:02:32,710 --> 02:02:36,470
就是系统级OS Level的一个打开文件的一个表

1606
02:02:37,050 --> 02:02:39,330
在我们这个EasyFS里面就不存在

1607
02:02:39,330 --> 02:02:41,210
它简化了

1608
02:02:41,210 --> 02:02:42,950
那它把它这个所谓的文件的一个

1609
02:02:42,950 --> 02:02:47,050
当前读写的位置放到哪里呢?放到类似Inode的结构里面

1610
02:02:48,370 --> 02:02:49,710
这里面做了一个保存

1611
02:02:49,710 --> 02:02:52,350
这这里面有一个所谓的位置Offset

1612
02:02:53,830 --> 02:02:54,990
这是一种设计

1613
02:02:55,810 --> 02:03:01,370
但是不管那种设计,你要理解它和这个文件的系统和文件的概念的一个

1614
02:03:01,370 --> 02:03:02,330
对应关系

1615
02:03:02,330 --> 02:03:04,890
不管怎么说,你读写文件总要有一个Offset

1616
02:03:04,890 --> 02:03:06,630
这个东西是要有的

1617
02:03:06,630 --> 02:03:10,550
至于它放在这儿还是放在这儿,那取决于具体的设计实现

1618
02:03:11,570 --> 02:03:15,990
所以这是一个,第二个需要了解的,总体的了解,其实就像我们前面讲到的

1619
02:03:15,990 --> 02:03:20,270
从应用访问到库,库访问到内核的系统调用

1620
02:03:20,270 --> 02:03:24,810
再访问到进程,再访问到文件,系统,再访问到driver

1621
02:03:24,810 --> 02:03:27,970
整个处理过程要有一个全局的overview

1622
02:03:27,970 --> 02:03:31,410
这个了解清楚了,我想是我们需要达到的目标

1623
02:03:31,410 --> 02:03:33,970
而不是你只知道一个文件

1624
02:03:33,970 --> 02:03:37,010
这个文件在整个OS中怎么去处理的,你不知道

1625
02:03:37,010 --> 02:03:45,270
你通过实验是希望让你对整个应用发出一个所谓的 Read&Write

1626
02:03:45,270 --> 02:03:48,530
发出一个Open操作之后,我们的OS怎么处理的

1627
02:03:48,530 --> 02:03:49,650
整个过程一个了解

1628
02:03:49,650 --> 02:03:56,030
这一点我是觉得是我们实验中需要去重点去掌握的

1629
02:03:58,350 --> 02:03:59,890
当然更进一步更牛同学

1630
02:03:59,890 --> 02:04:02,770
那你会去写一个OS,写一个支持文件系统的OS

1631
02:04:02,770 --> 02:04:04,350
你可以设计自己的文件系统

1632
02:04:04,350 --> 02:04:06,330
那都是我们是觉得非常牛的一个事情

1633
02:04:08,470 --> 02:04:13,410
那我们看看总体思路 总体思路这一块

1634
02:04:13,410 --> 02:04:17,150
刚才讲的里面再稍微再稍微扩一下

1635
02:04:18,070 --> 02:04:19,330
就是这些

1636
02:04:27,230 --> 02:04:31,470
这一块啊 这一块都是在RAM中

1637
02:04:31,470 --> 02:04:34,830
我们OS是放在RAM中运行的 在RAM中的内容

1638
02:04:34,830 --> 02:04:39,590
但是这里面的很多信息,比如Cyberblock、iNode、Bitmap等等

1639
02:04:39,590 --> 02:04:43,910
iNode这些信息在哪呢?是在磁盘上,是EZFS

1640
02:04:43,910 --> 02:04:48,030
你看它有两份,一份是在硬盘上,然后一份是在RAM中

1641
02:04:48,030 --> 02:04:52,470
我们会把硬盘的一些关键的数据会读到内存中来

1642
02:04:52,470 --> 02:04:55,950
最终你对它的修改还要写回硬盘中去

1643
02:04:56,690 --> 02:05:01,130
这个大家需要了解,这是和之前我们讲的那些

1644
02:05:01,130 --> 02:05:03,390
比如说跑一个程序很大的不同

1645
02:05:03,830 --> 02:05:07,770
它有两个地方,一个在RAM中,一个在地图上。

1646
02:05:08,110 --> 02:05:10,110
当然我们这个地图在做实验中是虚拟的地图,

1647
02:05:10,210 --> 02:05:17,390
但你还是知道这两个不同位置都有这个文件系统的存在。

1648
02:05:20,090 --> 02:05:24,030
总理思路就是从这儿捅下来,

1649
02:05:24,370 --> 02:05:28,450
无论是读和写捅下来之后,整个过程你是比较清楚的。

1650
02:05:28,570 --> 02:05:29,950
这个图大家能理解,

1651
02:05:29,990 --> 02:05:32,670
但你需要理解的是这一步到这一步怎么做的,

1652
02:05:32,670 --> 02:05:37,210
这不知道这会怎么做,更细的一些内容需要大家去理解

1653
02:05:38,770 --> 02:05:43,410
好,那看看我们这里面,我们这个文件系统,我们设计了一个EZFS

1654
02:05:46,410 --> 02:05:54,890
那这个EZFS,它里面支持两类,一类是常规文件,一类是目录文件

1655
02:05:54,890 --> 02:06:00,830
所以这里面确实我们存在两类文件,但是我们并没有这个link链接

1656
02:06:00,830 --> 02:06:05,150
其实上次是作为一个实验布置出去的

1657
02:06:05,150 --> 02:06:10,110
但是我也希望大家通过讲解和对这个EDF的理解

1658
02:06:10,110 --> 02:06:13,850
你知道怎么在里面去实现一个链接文件

1659
02:06:13,850 --> 02:06:16,030
无论是硬链接还是软链接

1660
02:06:16,030 --> 02:06:20,570
然后这个设备这两块是在下一章讲IPC的时候

1661
02:06:21,330 --> 02:06:22,630
会看到一个扩展

1662
02:06:22,630 --> 02:06:27,090
就是我们的文件不仅仅是可以用来表示常规的定时上的东西

1663
02:06:27,090 --> 02:06:28,690
可以表示一些其他的东西

1664
02:06:28,690 --> 02:06:31,750
就是说想体现everything is file 这么一个结构

1665
02:06:31,750 --> 02:06:35,610
可以帮助我们的应用程序更好地去写出一种简洁的一种

1666
02:06:37,890 --> 02:06:40,210
编程来完成其他一些功能

1667
02:06:44,470 --> 02:06:44,790
那

1668
02:06:45,350 --> 02:06:48,130
如果我们要争取写这个文件系统的话

1669
02:06:48,130 --> 02:06:49,690
其实我们首先要理解

1670
02:06:50,770 --> 02:06:52,770
怎么在应用上组织一个文件

1671
02:06:52,770 --> 02:06:53,710
组织一个文件系统

1672
02:06:53,710 --> 02:06:54,510
不是组织一个文件

1673
02:06:54,510 --> 02:06:55,830
在应用上怎么去布局它

1674
02:06:56,410 --> 02:07:03,750
然后呢,在这里面细化出来,硬盘看到的是一个一个块,一个一个磁盘块,怎么去对块进

1675
02:07:03,750 --> 02:07:04,690
行管理。

1676
02:07:04,970 --> 02:07:09,710
但是磁盘块里面呢,它可能是一个文件,可能是一个目录,也可能是文件目录

1677
02:07:09,710 --> 02:07:11,490
的一个管理结构,我们说的inode。

1678
02:07:11,950 --> 02:07:20,250
那这个磁盘块怎么到这个inode里面这么去表示,对于inode来说,一个inode怎么

1679
02:07:20,250 --> 02:07:25,490
去对应到一个data,就是inode和data的一个对应关系。

1680
02:07:25,490 --> 02:07:31,650
怎么去表达它里面的内容,以及有了这些组织之后,我怎么能够去完成

1681
02:07:31,650 --> 02:07:33,570
对实际一个文件的读写。

1682
02:07:34,490 --> 02:07:38,830
这其实就是说你要去设计实现一个文件系统里面不得不考虑的问题。

1683
02:07:38,990 --> 02:07:45,310
前面我们讲了那么多,其实都是说最终落在上面,你能够去把这个事情给想清楚。

1684
02:07:52,070 --> 02:07:59,530
这里面其实和之前讲解,就是一个具体化的过程,我们有一个硬盘怎么来去组织

1685
02:07:59,530 --> 02:08:07,030
它,就包含这一部分,就包含什么超级块,总体的一个描述,对IDLE空间

1686
02:08:07,030 --> 02:08:12,030
的描述,Bitmap,Data空间的描述,Data,Bitmap,然后IDLE本身的一个

1687
02:08:12,030 --> 02:08:15,290
组织,和IDLE指向的这个Data,

1688
02:08:15,290 --> 02:08:19,490
还有两类,一个是file,一个是目录,这就是它的一个大字结构

1689
02:08:19,490 --> 02:08:22,170
这个最终是放在硬盘的不同的地方

1690
02:08:23,290 --> 02:08:28,090
最终我们会把不同的部分图到类型中来进行相应的进一步的处理

1691
02:08:28,090 --> 02:08:32,030
这就是一个总体的一个结构图

1692
02:08:32,030 --> 02:08:36,170
那从运行角度来说,我们超级系统在处置化

1693
02:08:36,170 --> 02:08:40,750
你首先这个文件系统放在硬盘上,所以我要把硬盘中的文件系统的基本

1694
02:08:40,750 --> 02:08:41,030
的信息

1695
02:08:41,030 --> 02:08:43,990
比如Cyberblock,给图进来

1696
02:08:45,130 --> 02:08:51,270
来完成它的处置化,然后找到它的根节点,找根节点干什么呢?根节点实际

1697
02:08:51,270 --> 02:09:00,110
上就是iNode里面的根,这个叫根,这里面的那些所有的目录项,你把这个

1698
02:09:00,110 --> 02:09:06,530
目录的目录内容给读出来,它是一个表,我们一直强调它是一个表,这是文件

1699
02:09:06,530 --> 02:09:10,890
名,然后这里面是它对应的其他的文件的iNode,然后把这个iNode读出来,

1700
02:09:11,130 --> 02:09:13,970
然后把这个进一步的就可以通过这一点,

1701
02:09:55,770 --> 02:10:02,670
这个图呢,稍微看起来有点detail啊,但还是有必要讲一讲,就是使得大家

1702
02:10:02,670 --> 02:10:09,070
能够看到我们刚才那个抽象的结构,其实也从上到下,这么一个抽象结构怎么

1703
02:10:09,070 --> 02:10:12,410
一步步的来完成了一个,比如说,

1704
02:10:12,410 --> 02:10:20,510
这个文件的一个Open,Read,Close的一个过程

1705
02:10:21,670 --> 02:10:24,410
那我们这边是以Read为例来讲解

1706
02:10:25,190 --> 02:10:27,710
那我们看到我们有Lib

1707
02:10:27,710 --> 02:10:30,790
我们应用程序其实访问的是一个函数

1708
02:10:30,790 --> 02:10:34,530
就是用户态的一个函数库,就是Read

1709
02:10:34,530 --> 02:10:37,590
这里面是这个Read这么一个操作

1710
02:10:37,590 --> 02:10:38,990
放在Libc里面

1711
02:10:38,990 --> 02:10:43,570
然后这个REID操作呢,最终Libc本来,实际上是对Syscall的封装,

1712
02:10:43,690 --> 02:10:50,830
会变成SysREID的一个请求,这个请求呢,最终会读到哪儿去呢,会

1713
02:10:50,830 --> 02:10:58,590
发给谁呢,发给当前的这个进程,当你这个应用是一个进程吧,这个进程,

1714
02:10:58,790 --> 02:11:03,650
它里面的这个所谓的一个进程控制块叫PCB,进程控制块里面呢,

1715
02:11:03,650 --> 02:11:08,970
它有一个FDTable,FDTable,FDTable里面,它不是,你这个REID的设

1716
02:11:08,970 --> 02:11:15,710
这时候带了一个fd,fd就是一个index,然后fd table里面根据这个fd做

1717
02:11:15,710 --> 02:11:21,910
index查到这里面的某一项,这一项记录的是什么,叫做os的inode,这个in

1718
02:11:21,910 --> 02:11:25,970
ode就是你可以理解为就是这个vfs提供了vfs的一些接口。

1719
02:11:28,470 --> 02:11:31,210
OS Dialogs 提供了 read 这么一个接口

1720
02:11:31,810 --> 02:11:40,550
所以 sysread 最终是调到当前进程对应的文件的 read

1721
02:11:42,370 --> 02:11:48,410
这个 read 实际上是对应到我们的 web-s

1722
02:11:48,410 --> 02:11:53,290
web-s 这个 read 实际上就是 readat

1723
02:11:53,290 --> 02:11:55,790
很小啊,这里面放大一页也比较小

1724
02:11:56,390 --> 02:11:58,670
幸好我个人觉得

1725
02:11:58,670 --> 02:12:00,310
如果同学觉得还是看不清的话

1726
02:12:00,890 --> 02:12:02,630
我可以下来再看一看

1727
02:12:03,930 --> 02:12:06,730
就是这就是VFS的ReadAt

1728
02:12:06,730 --> 02:12:09,110
但是VFS,不是具体的FS

1729
02:12:09,110 --> 02:12:19,050
它一定会把这个ReadAt这个函数指针指向一个具体的FS

1730
02:12:19,050 --> 02:12:22,470
这个ReadAt最终会落到

1731
02:12:22,470 --> 02:12:30,170
连到哪呢,连到这个具体EZFS,它的这个read里面,这个readat,这个readat和这个

1732
02:12:30,170 --> 02:12:35,890
reads是同一个,那根据它呢,我们就可以完成具体的读写,那在这个读写里面

1733
02:12:35,890 --> 02:12:41,470
呢,我读从哪开始读,它有一个offset,我们是一个offset,这个offset的信息发到

1734
02:12:41,470 --> 02:12:51,290
哪呢,就放在这个地方,就放在这个,我们说在哪,offset,

1735
02:13:00,170 --> 02:13:07,070
如果是某一个距离的正数的话,从一个正数开始,那个偏移开始进行读,那这是它

1736
02:13:07,070 --> 02:13:14,430
这个offset的这个信息,然后这个读的时候呢,你会发现我们说这里面到哪了,从V

1737
02:13:14,430 --> 02:13:21,270
FS到了EZFS,从我们的进程控制块已经到了,到了,到了我们说内线控制块,我们

1738
02:13:21,270 --> 02:13:25,730
和里面这个文件系统这一块的,这一块内容,这一块内容里面来了。

1739
02:13:26,270 --> 02:13:27,690
这个EDF是什么,REDAT呢?

1740
02:13:28,010 --> 02:13:30,950
我们说它读是,没说要从硬盘上读进来,

1741
02:13:31,010 --> 02:13:34,750
但是这个硬盘读,中间还有一个缓存,就是blockcatch,

1742
02:13:35,070 --> 02:13:37,250
或者是buffercatch,或者blockcatch。

1743
02:13:37,450 --> 02:13:42,350
那么它读是,读的是buffercatch里面的这个getblockcatch这么一个操作。

1744
02:13:43,130 --> 02:13:44,030
为什么用getblockcatch?

1745
02:13:44,150 --> 02:13:48,510
是在于你读这个,它已经把一个offset映射成了一个block,

1746
02:14:18,590 --> 02:14:24,710
它有它的一个index,把这个块通过这个driver读进来,读到这个cache里面,从而

1747
02:14:24,710 --> 02:14:31,870
可以把相应的数据一步一步在最终回到,最终回到了这个read的这个b

1748
02:14:31,870 --> 02:14:36,490
uffer里面,这里面会有一个buffer,用户它的buffer,给它写回去,从而完成

1749
02:14:36,490 --> 02:14:39,650
了整个这一次的一个读写的过程。

1750
02:14:40,450 --> 02:14:53,390
这就是我们说,这个有点detail了,就是和我们前面讲的对这个图的一个细化,这

1751
02:14:53,390 --> 02:14:54,830
其实也是这么一个图。

1752
02:14:55,370 --> 02:15:02,170
但是你如果落到一个,比如说我们现在已经写好这个EZFS的话,它整个处理过程

1753
02:15:02,170 --> 02:15:03,090
就是这么一个过程。

1754
02:15:03,090 --> 02:15:07,390
这过程里面你会看到它从应用层到了内核里面来

1755
02:15:07,390 --> 02:15:11,070
内核里面到了计程控制块这里面做一定处理

1756
02:15:11,070 --> 02:15:13,330
然后再到文件系统做一定的处理

1757
02:15:13,330 --> 02:15:18,370
最后是通过BlockDriver把这个数据从硬盘读进来

1758
02:15:18,370 --> 02:15:19,690
写过程是类似的

1759
02:15:19,690 --> 02:15:24,150
这是举了一个大致的一个整体思路的一个设计

1760
02:15:24,150 --> 02:15:26,450
这里面就会涉及到不同的数据结构

1761
02:15:26,450 --> 02:15:29,350
不同的函数的一个处理过程

1762
02:15:29,350 --> 02:15:35,190
这里面我们后面会逐一再给大家做一个简单的讲解,希望大家能够通过这个

1763
02:15:35,190 --> 02:15:41,150
讲解呢,即使你没有看代码,你也能够大致理解说一个真实的一个简

1764
02:15:41,150 --> 02:15:44,350
化的文件系统怎么去完成相应的文件的处理。

1765
02:15:47,930 --> 02:15:52,690
总理思路,把刚才过程在这个detail了,我们再把它稍微减化一下。

1766
02:15:53,050 --> 02:16:00,610
应用程序,它第一步就是我们说的一个Discord这么一个操作。

1767
02:16:01,110 --> 02:16:04,050
这个是第一步,通用网络接口就是Discord这个操作。

1768
02:16:05,970 --> 02:16:12,890
然后在内核里面,进程控制框里面,会得到相应的一个VFS的操作。

1769
02:16:12,890 --> 02:16:18,090
第二步就到VFS来了,VFS抽象出来了很多的接口,

1770
02:16:18,310 --> 02:16:21,710
接口包含了一些数语结构和一些函数。

1771
02:16:22,110 --> 02:16:27,910
这个VFS最终会对应到EasyFS,

1772
02:16:28,150 --> 02:16:30,190
就具体的某一个问题系统,我们认为是EasyFS,

1773
02:16:30,870 --> 02:16:33,210
来完成相应的处理。

1774
02:16:40,010 --> 02:16:50,970
在这里面会有一个比较重要的cache,来在FS和BlockDriver之间建立一个

1775
02:16:50,970 --> 02:16:58,910
缓冲,使得FS可以快速的进行读写,以磁盘块为单位进行读写的

1776
02:16:58,910 --> 02:17:01,410
操作过程,这就是靠BlockCache

1777
02:17:01,410 --> 02:17:07,910
我们在Blockhead就用了一个简化的LIU算法来实现的一个操作

1778
02:17:07,910 --> 02:17:09,030
大家可能就比较好奇

1779
02:17:09,030 --> 02:17:10,970
我们说讲页面质量算法的时候

1780
02:17:10,970 --> 02:17:12,550
LIU是一种不可行的方式

1781
02:17:12,550 --> 02:17:13,690
但这里面还是可行的

1782
02:17:13,690 --> 02:17:14,690
为什么可行

1783
02:17:14,690 --> 02:17:15,910
大家可以看一看

1784
02:17:15,910 --> 02:17:17,610
可以看看具体的实现

1785
02:17:17,610 --> 02:17:18,890
就可以理解

1786
02:17:18,890 --> 02:17:20,690
对于文件系统来说LIU是可行的

1787
02:17:20,690 --> 02:17:25,110
但对于我们的内存页面置换就不可行

1788
02:17:25,110 --> 02:17:25,470
为什么

1789
02:17:25,470 --> 02:17:27,490
大家可以去思考一下这个问题

1790
02:17:32,170 --> 02:17:35,550
这是我们说的总体的一个介绍。

1791
02:17:38,430 --> 02:17:42,270
在用的角度来说,其实还是一样,开发过程中也是包括了编译、构造。

1792
02:17:44,530 --> 02:17:51,830
编译、构造、运行这么一个过程,其实跟之前比起来还是有不同。

1793
02:17:52,070 --> 02:17:56,550
编译的过程中,你会形成一个文件系统,这是和之前不太一样的地方。

1794
02:17:56,550 --> 02:18:01,690
你在运行的时候呢,其实你加载应用的时候是用文件系统加载的,这之前也没有,

1795
02:18:01,750 --> 02:18:07,190
之前没有文件系统,那这里面也有一个比较,为什么之前没有文件系统也能够加

1796
02:18:07,190 --> 02:18:11,930
载应用,现在有了文件系统之后,也是能加载应用,那我们为什么还有文件系

1797
02:18:11,930 --> 02:18:19,670
统,这个问题我也希望大家能够思考一下,因为这种方式我不太好提问,就是我只能

1798
02:18:19,670 --> 02:18:26,530
统一的把问题提出来,希望大家能听到,并在课上或者课后去思考一下这些

1799
02:18:35,310 --> 02:18:42,410
歷史背景,歷史背景其實很早就有了,這也是一個古老的內容。

1800
02:18:43,550 --> 02:18:48,870
雖然古老,但我們可以看出前人的水平之高。

1801
02:18:49,270 --> 02:18:51,770
當時的馬里克斯的時候,65年就已經提出來了。

1802
02:18:51,770 --> 02:18:56,010
文件数据是一个无格式的字节流,引入层次文件系统的一个概念,

1803
02:18:56,150 --> 02:19:03,750
然后还启发UNIX,把什么都看成文件,这就是我们说一个很厉害的一个前瞻

1804
02:19:03,750 --> 02:19:09,750
性的一个设计思路,到现在为止我们觉得也不过时,也还是到现在为止你说OK

1805
02:19:09,750 --> 02:19:12,710
UNIX,你看那个Windows还是这样。

1806
02:19:12,710 --> 02:19:17,790
那现在我们说现在已经不是这个了,应该是什么安卓、iOS

1807
02:19:17,790 --> 02:19:20,010
那么它里面还有文件吗?

1808
02:19:20,210 --> 02:19:22,930
好像大家看到文件的概率比较小,也有

1809
02:19:22,930 --> 02:19:24,710
但是确实大家更多看到的是

1810
02:19:25,230 --> 02:19:26,790
我有一个视频,我有一个消息

1811
02:19:27,390 --> 02:19:29,750
比如微信的一条消息,它都不是文件

1812
02:19:30,230 --> 02:19:31,890
那这又意味着什么呢?

1813
02:19:31,930 --> 02:19:33,870
在文件系统之上,FS之上

1814
02:19:34,450 --> 02:19:36,870
还有更高层的,比如说微信

1815
02:19:36,870 --> 02:19:38,890
它有它自己一套组织方式

1816
02:19:38,890 --> 02:19:41,210
然后这种组织方式呢

1817
02:19:41,210 --> 02:19:42,470
是建立在文件上的

1818
02:19:42,470 --> 02:19:47,010
那我们的APP是建立在一个更高的

1819
02:19:47,010 --> 02:19:48,230
一个Framework上面的

1820
02:19:49,330 --> 02:19:51,050
这个Framework屏蔽了文件

1821
02:19:51,050 --> 02:19:52,210
屏蔽了进程

1822
02:19:53,670 --> 02:19:55,710
我们现在看到的是包括虚储

1823
02:19:56,410 --> 02:20:01,210
使得APP它可以开发起来更加简单

1824
02:20:01,210 --> 02:20:04,330
那是由于中间多了一个Framework

1825
02:20:04,870 --> 02:20:07,210
这个Framework有安卓的Framework

1826
02:20:07,210 --> 02:20:08,490
有IOS的Framework

1827
02:20:08,490 --> 02:20:14,110
所以我们的一般的手机的使用者可能他对这些东西都不太了解

1828
02:20:14,110 --> 02:20:17,230
他可能不需要知道有文件系统 不需要知道有进程

1829
02:20:17,870 --> 02:20:20,390
但对于我们来说 就是我们同学来说

1830
02:20:20,390 --> 02:20:25,150
你上这边课 你还是要知道需要有这些东西的

1831
02:20:25,150 --> 02:20:26,990
至于没有这些东西 为什么没有这些东西

1832
02:20:26,990 --> 02:20:29,090
你也能够给出一个合理的解释

1833
02:20:29,090 --> 02:20:31,670
或者别人看不到这些东西 为什么

1834
02:20:32,730 --> 02:20:35,110
好 那我们具体讲一下操作

1835
02:20:35,110 --> 02:20:37,050
这里面给了一个大致的一个操作过程

1836
02:20:37,050 --> 02:20:39,750
我觉得这个东西比较简单,大家去试一下就OK了

1837
02:20:39,750 --> 02:20:43,630
确实能够去读写文件

1838
02:20:43,630 --> 02:20:45,250
只是从界面上来说

1839
02:20:46,690 --> 02:20:50,430
看不出太多文件系统的影子,但是你能看到文件

1840
02:20:50,430 --> 02:20:51,670
虽然看不到文件系统

1841
02:20:51,670 --> 02:20:53,970
你能看到文件,因为我们的应用

1842
02:20:53,970 --> 02:20:56,670
更多的是跟文件打交道,并不是跟文件系统打交道

1843
02:20:59,070 --> 02:21:01,850
那里面有测试用力,你可以

1844
02:21:01,850 --> 02:21:03,410
可以把一个

1845
02:21:03,770 --> 02:21:06,630
字幕刷写到一个文件里面去,然后再把这个字幕刷给读出来

1846
02:21:06,630 --> 02:21:08,490
这是一个非常简单的一个例子

1847
02:21:08,490 --> 02:21:12,490
在这个例子里面能看到相应的一些操作

1848
02:21:13,010 --> 02:21:16,410
这是一个时间步骤了,我觉得大家空去看一下就OK了

1849
02:21:17,670 --> 02:21:19,570
再看一下软件架构

1850
02:21:19,570 --> 02:21:22,290
所谓软件架构就在于我们怎么去设计这个软件

1851
02:21:22,290 --> 02:21:27,650
设计软件其实主要就是VR这里应用怎么去用这个操作提供的服务

1852
02:21:27,650 --> 02:21:28,910
那也就是这几个东西

1853
02:21:31,690 --> 02:21:37,130
就是最经典的几个系统调用,怎么去实现这个问题

1854
02:21:37,130 --> 02:21:42,910
那理解这个的话,我们看到为了支持这几个经典的系统调用

1855
02:21:42,910 --> 02:21:49,750
我们还要做很多工作,我们单独设计了一个E-ZFS这个文件系统

1856
02:21:49,750 --> 02:21:52,910
这里面包含了我们说在值班上的布局、layout

1857
02:21:53,490 --> 02:22:01,610
包含了我们的VFS提供的一层抽象 能够有一个Read-Write的基本操

1858
02:22:01,610 --> 02:22:02,370
作

1859
02:22:02,370 --> 02:22:09,850
以及把对文件的基于字节流的读写转变成对Block的读写

1860
02:22:09,850 --> 02:22:12,330
这也是文件系统要重点搞定的问题

1861
02:22:12,330 --> 02:22:15,350
就是我对一个文件某一个位置开始读

1862
02:22:15,350 --> 02:22:20,190
那其实映射的是对某一个Block进行读写

1863
02:22:20,190 --> 02:22:21,390
它要有一个转换过程

1864
02:22:21,390 --> 02:22:24,590
这也是我们的EAFS要完成的问题

1865
02:22:25,910 --> 02:22:27,950
这一块都是EAFS的一个事情

1866
02:22:27,950 --> 02:22:32,270
这一块实际上是在我们的Linux里面

1867
02:22:32,270 --> 02:22:35,750
通过这么一个应用程序

1868
02:22:36,290 --> 02:22:38,290
来建立一个虚的文件系统

1869
02:22:38,290 --> 02:22:38,910
干这么一个事情

1870
02:22:38,910 --> 02:22:40,730
把一个文件当成一个设备

1871
02:22:40,730 --> 02:22:42,650
在这个文件上面去建立一个文件系统

1872
02:22:42,650 --> 02:22:43,390
这个文件是什么

1873
02:22:43,390 --> 02:22:44,530
是Linux的文件

1874
02:22:44,530 --> 02:22:46,350
这里面要理解

1875
02:22:46,350 --> 02:22:48,690
我们现在并没有针对实际的物理设备

1876
02:22:48,690 --> 02:22:49,610
来做一个文件系统

1877
02:22:49,610 --> 02:22:51,630
是基于的一个虚拟物理设备

1878
02:22:51,630 --> 02:22:53,510
而这虚拟物理设备是靠文件来实现的

1879
02:22:53,510 --> 02:22:55,050
这个文件又是Linux的文件

1880
02:22:55,050 --> 02:22:56,350
文件中的文件

1881
02:22:56,350 --> 02:22:59,210
那这其实你要理解它是什么含义

1882
02:23:01,790 --> 02:23:02,990
那这是文件组这一块

1883
02:23:02,990 --> 02:23:04,710
那么对于OS这一块来说

1884
02:23:05,350 --> 02:23:07,090
它需要一个具体的driver

1885
02:23:07,630 --> 02:23:09,170
来完成对这个虚拟文件

1886
02:23:09,170 --> 02:23:10,250
哎呦 这个错了

1887
02:23:11,510 --> 02:23:16,590
完成对虚拟的磁盆的一个操作

1888
02:23:16,590 --> 02:23:20,210
这里面有这么一个东西

1889
02:23:20,210 --> 02:23:21,970
但其实还有一个真的

1890
02:23:21,970 --> 02:23:24,230
这个SD card 这是真的一个开发板

1891
02:23:24,230 --> 02:23:28,190
它确实要把这个块设备能够驱动起来

1892
02:23:28,190 --> 02:23:31,490
这个是如果大家用到的KR10开发板的话

1893
02:23:31,490 --> 02:23:32,470
那是可以做到

1894
02:23:32,470 --> 02:23:34,130
我们现在当然我们现在全在QNAP上做

1895
02:23:34,130 --> 02:23:38,550
所以用不到这个专业板

1896
02:23:39,550 --> 02:23:41,070
那FS这一块

1897
02:23:41,070 --> 02:23:44,030
它就是比较多的

1898
02:23:44,750 --> 02:23:48,610
就是包含了就是我们说的这个iNode抽象的一个表示

1899
02:23:48,610 --> 02:23:52,870
实际上还是在在我们前面说的OSiNode

1900
02:23:55,910 --> 02:24:00,410
OSiNode里面能够体现出一个File的一个一个接口

1901
02:24:01,050 --> 02:24:01,930
好像有点问题

1902
02:24:08,170 --> 02:24:09,390
有点乱了

1903
02:24:14,070 --> 02:24:19,670
抱歉,现在这个屏幕出了位置出现了偏差,我来再写

1904
02:24:21,010 --> 02:24:24,670
好吧,我来继续说吧,就是在这里面能看到我用这个鼠标形

1905
02:24:26,410 --> 02:24:30,550
这里面就是FS,你可以以为是Wi-Fi四成接口

1906
02:24:30,550 --> 02:24:36,090
还是在提供Wi-Fi的支持,它来完成和具体的依赖FS的一个对接

1907
02:24:36,090 --> 02:24:37,570
这是OS层面的一个事情

1908
02:24:37,570 --> 02:24:41,490
第二层面的事情就是对进程的一个扩展,我们说文件是一个资源

1909
02:24:41,490 --> 02:24:44,010
所以我们需要对这个进程通知块进行扩展

1910
02:24:44,030 --> 02:24:50,670
这里面task,这个task进行扩展,然后能够完成对这个文件资源的一个封装。

1911
02:24:51,050 --> 02:24:56,570
这我们前面看到很重要一点就是这个FD,就是文件描述副表,这个就是进程的一

1912
02:24:56,570 --> 02:24:58,510
部分了,这是一个新的一个扩展内容。

1913
02:24:58,810 --> 02:25:05,750
这是在整个文件,整个超线种重新扩展上面做的一些工作。

1914
02:25:07,430 --> 02:25:13,230
那具体设计又会比较啰嗦一点,我们还有两分钟,肯定是讲不完了,但是没

1915
02:25:13,230 --> 02:25:17,750
关系,我还是继续往下讲,大家能够知道就行了。

1916
02:25:19,930 --> 02:25:24,910
那理解,这个其实大家都已经,前面的课都已经知道了,就是文件是对存储设备的

1917
02:25:24,910 --> 02:25:25,550
一个虚拟化的抽象。

1918
02:25:26,910 --> 02:25:33,910
那你如果去用一些工具去看这个文件内容的话,你能看到的其实是一个字节

1919
02:25:33,910 --> 02:25:44,210
流,它实际上是一些字符,但是我们去读代码,但对OS而言它看到的就是一个

1920
02:25:44,210 --> 02:25:48,550
没有意义的字节流,这是它看到的,就是线性的一个字节流。

1921
02:25:52,910 --> 02:25:54,950
那iNode怎么看iNode

1922
02:25:54,950 --> 02:25:59,610
其实我们直接在我们的Linux或者Windows上都能看到

1923
02:25:59,610 --> 02:26:01,630
比如用这个命令State这个命令

1924
02:26:01,630 --> 02:26:04,250
你打开这么一个这里面自己写的文件

1925
02:26:04,250 --> 02:26:07,610
自己写的文件可以看到它这个iNode里面的内容很多

1926
02:26:07,610 --> 02:26:09,970
我们这里面实践实验没有那么多内容

1927
02:26:09,970 --> 02:26:13,190
但是这里面可以看到有很多内容

1928
02:26:13,190 --> 02:26:15,310
OK 哎呀 下课了

1929
02:26:16,230 --> 02:26:18,190
好 那大家去吃饭吧

1930
02:26:18,190 --> 02:26:20,530
我们这段课就上到这,好,谢谢大家

