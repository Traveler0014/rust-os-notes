1
00:03:37,640 --> 00:03:40,980
好,我们开始上课了

2
00:04:00,320 --> 00:04:04,980
没有找到座位同学 尽快找一个地儿先坐下

3
00:04:23,020 --> 00:04:28,580
今天很高兴又碰到了同学再次来上课

4
00:04:29,120 --> 00:04:33,020
有很多同学上学期应该也上过我的编译的课

5
00:04:33,020 --> 00:04:36,340
那这个现在继续上超多一种课

6
00:04:38,240 --> 00:04:40,280
我叫陈瑜

7
00:04:40,880 --> 00:04:42,940
现在也是尽量不用黑板

8
00:04:44,020 --> 00:04:46,260
不对 还在学期中

9
00:04:49,760 --> 00:04:53,720
那这门课其实是三个老师一块准备的

10
00:04:54,360 --> 00:04:58,340
从上学期开始我们就有春季和秋季

11
00:04:58,340 --> 00:05:00,060
都开了超级统课

12
00:05:00,060 --> 00:05:03,260
那上一期是向老师在上这个课

13
00:05:03,840 --> 00:05:05,020
就是秋季学期

14
00:05:05,020 --> 00:05:09,540
然后春季学期是这次是我和李国梁老师

15
00:05:15,540 --> 00:05:16,880
就是我和李老师上

16
00:05:16,880 --> 00:05:18,540
他在上我在楼下

17
00:05:20,280 --> 00:05:22,620
其实今天来听课的

18
00:05:22,620 --> 00:05:26,200
除了各位同学之外

19
00:06:26,380 --> 00:06:30,260
然后其他的助教呢 你可以看到大部分可能还有些同学都认识

20
00:06:30,260 --> 00:06:32,600
就是你们的同学 这里面分两类

21
00:06:32,600 --> 00:06:36,040
一类是本科生同学 一类是研究生同学

22
00:06:40,740 --> 00:06:44,140
像 我看了一下 就这一位

23
00:06:45,000 --> 00:06:47,600
你们不认识的同学是研究生同学

24
00:06:47,600 --> 00:06:50,020
其他同学 还有前面这两位

25
00:06:50,020 --> 00:06:53,640
其他同学好像都是我们的本科生同学

26
00:06:53,640 --> 00:06:56,960
这说明了我们这门课需要我们的本个人同学

27
00:06:56,960 --> 00:06:59,600
自己来 作为助教来帮助大家

28
00:06:59,600 --> 00:07:00,760
一起来上好这门课

29
00:07:03,440 --> 00:07:08,540
而且在这一期我们的助教同学也会对我们的课程

30
00:07:08,540 --> 00:07:12,800
和我们的实验做出很多进一步的改进

31
00:07:12,800 --> 00:07:17,480
来推动我们的课能够让大家能够更好地学得比较顺畅一点

32
00:07:22,860 --> 00:07:24,940
然后上课时间这个大家都应该很清楚

33
00:07:24,940 --> 00:07:27,200
这我就不再细说了

34
00:07:27,200 --> 00:07:29,260
跟以前的课确实有个比较大的不同

35
00:07:29,260 --> 00:07:33,760
就是我们又经历了将近

36
00:07:33,760 --> 00:07:38,540
应该是将近十年的一个一周两次课

37
00:07:38,540 --> 00:07:40,680
现在又回到了一周一次课

38
00:07:40,680 --> 00:07:43,500
这也是考虑到收集到大家的一个反馈

39
00:07:43,500 --> 00:07:45,840
觉得一周两次课比较压力比较大

40
00:07:45,840 --> 00:07:47,460
所以我们就回到上课时间

41
00:08:18,580 --> 00:08:20,400
这里面可能有稍微有点错

42
00:08:21,460 --> 00:08:24,480
这个不是核,应该是货

43
00:08:25,780 --> 00:08:29,380
对,汇边是需要了解的,然后C-HORUS

44
00:08:31,200 --> 00:08:33,640
这是一个要求,就是你选择一个就行了

45
00:08:33,640 --> 00:08:36,860
后面我们最后一个统计,昨天也发了一个问卷

46
00:08:36,860 --> 00:08:39,800
也看看大家的一个选择

47
00:08:39,800 --> 00:08:42,660
对于数据结构而言,其实我们对数据结构有一定的要求

48
00:08:42,660 --> 00:08:45,380
但是数据结构的要求其实非常的简单

49
00:08:45,380 --> 00:08:48,080
基本上是非常基本的数据结构

50
00:08:48,080 --> 00:08:50,020
用不到很复杂的一些

51
00:08:50,020 --> 00:08:53,260
就你们在数据课上学的那些内容

52
00:08:53,260 --> 00:08:54,900
但这边有一点区别在哪呢

53
00:08:54,900 --> 00:08:56,340
就是你们之前开发程序

54
00:08:56,340 --> 00:08:59,540
更多的是开发应用程序

55
00:08:59,540 --> 00:09:01,040
那我们现在是要开发什么

56
00:09:01,040 --> 00:09:04,480
开发的是系统程序

57
00:09:04,480 --> 00:09:06,080
那我不知道同学

58
00:09:06,080 --> 00:09:08,380
对应用程序和系统程序的一同

59
00:09:08,380 --> 00:09:09,660
有什么理解没有

60
00:09:10,120 --> 00:09:11,700
什么叫系统程序

61
00:09:11,700 --> 00:09:14,060
什么叫应用程序

62
00:09:14,060 --> 00:09:16,060
有同学能够回答吗

63
00:09:17,060 --> 00:09:19,000
我上编译课的时候就说过

64
00:09:19,000 --> 00:09:21,360
就是我鼓励大家回答问题

65
00:09:21,360 --> 00:09:22,420
就是这种交流

66
00:09:22,420 --> 00:09:24,280
交流起来的话老是都有针对性

67
00:09:24,280 --> 00:09:26,120
但同学不回答的时候呢

68
00:09:26,120 --> 00:09:27,340
我就会自问自答

69
00:09:28,940 --> 00:09:31,760
应用程序就是你们现在写的那些

70
00:09:31,760 --> 00:09:33,940
比如上这个碎结构

71
00:09:33,940 --> 00:09:35,860
写了一段小的代码排序

72
00:09:35,860 --> 00:09:39,300
或者上软工写了一个网页

73
00:09:39,800 --> 00:09:41,380
我们看来这叫应用程序

74
00:09:41,380 --> 00:09:43,200
应用程序它完成一个特定的功能

75
00:09:45,140 --> 00:09:47,620
系统程序它和应用程序比起来

76
00:09:47,620 --> 00:09:49,860
它有一个比较大的区别在哪吗

77
00:09:49,860 --> 00:09:53,700
第一它的使用面会比应用程序要广很多

78
00:09:53,700 --> 00:09:55,040
比如说我们的超级桶

79
00:09:55,800 --> 00:09:58,200
它上面可以运行各种各样的应用程序

80
00:09:58,200 --> 00:10:01,740
它的用到它的其他的应用程序

81
00:10:01,740 --> 00:10:04,040
和其他的一些需求会非常广泛

82
00:10:04,040 --> 00:10:06,620
这是一个这是站在用的角度来说的

83
00:10:07,160 --> 00:10:08,280
站在开发角度来说

84
00:10:08,280 --> 00:10:11,700
这个系统程序它一般要强调极点化

85
00:10:11,700 --> 00:10:15,400
比如说它的高性能

86
00:10:16,040 --> 00:10:17,280
它的高可靠

87
00:10:18,380 --> 00:10:20,740
第三个如果是再往下一点

88
00:10:20,740 --> 00:10:21,820
像我们的超级系统

89
00:10:21,820 --> 00:10:24,740
它还有一点跟大家一边写应用程序不太一样

90
00:10:24,740 --> 00:10:26,100
它更靠底层

91
00:10:26,100 --> 00:10:29,960
这就和我们另外一门课组织原理可以接上

92
00:10:29,960 --> 00:10:31,240
跟编译其实也有关系

93
00:10:31,240 --> 00:10:34,840
就是你要接触到就是怎么去跟硬件打交道

94
00:10:34,840 --> 00:10:39,740
这个不是说所有的系统程序都有这个特点

95
00:10:39,740 --> 00:10:41,560
但是大部分的系统程序

96
00:10:42,120 --> 00:10:45,940
它基于性能或者基于可靠性等各方面的因素

97
00:10:45,940 --> 00:10:51,140
使它偏向于和底层的硬件在打交道多一些

98
00:10:51,140 --> 00:10:52,140
这就是所谓的系统程序

99
00:10:52,140 --> 00:10:55,540
这使得在它的编程难度上来说

100
00:10:55,540 --> 00:10:57,280
相对来说要稍微复杂一点

101
00:11:16,060 --> 00:11:20,840
那再说这个另外一门课 组成原理 组成原理上一期也都上了这门

102
00:11:20,840 --> 00:11:21,600
课

103
00:11:22,540 --> 00:11:25,660
那我们的组成原理呢 是其实也是三位老师

104
00:11:26,360 --> 00:11:29,540
还有路由游老师 我没忘了列进去

105
00:11:32,820 --> 00:11:34,700
没错吧 这个我记错了吗

106
00:11:34,700 --> 00:11:36,000
我印象没记错

107
00:11:36,600 --> 00:11:37,640
然后我印象

108
00:11:37,640 --> 00:11:40,260
因为我跟陈康老师是在隔壁

109
00:11:40,260 --> 00:11:41,980
所以经常跟他聊

110
00:11:41,980 --> 00:11:44,000
他一直很自豪地说

111
00:11:44,000 --> 00:11:44,920
上组织院理课

112
00:11:44,920 --> 00:11:46,840
把我们超级系统课的课程都讲完了

113
00:11:47,740 --> 00:11:49,680
他已经很深入地讲解了

114
00:11:49,680 --> 00:11:52,020
超级系统的很多的关键技术

115
00:11:52,020 --> 00:11:53,840
其实我们这门课就很轻松

116
00:11:53,840 --> 00:11:55,820
大家学起来自己已经学过了

117
00:11:56,900 --> 00:11:58,280
我表示怀疑

118
00:12:02,040 --> 00:12:03,320
因为陈康老师

119
00:12:03,320 --> 00:12:06,720
它的特点是说得多 做得不一定那么

120
00:12:09,480 --> 00:12:12,580
另外一门课 另外一门课是Person

121
00:12:12,580 --> 00:12:14,640
他经历了一本很著名的教材

122
00:12:14,640 --> 00:12:17,580
在这个教材上他其实也从早年的MIPS

123
00:12:17,580 --> 00:12:20,640
换成了RISC-V来作为这个机器组成原理的讲解

124
00:12:22,380 --> 00:12:24,260
大家都觉得他讲得挺不错的

125
00:12:24,260 --> 00:12:29,000
但其实我觉得其实和我们的刘老师和陈刚老师讲的差不多

126
00:12:29,000 --> 00:12:30,680
其实没有特别大的区别

127
00:12:30,680 --> 00:12:32,800
只是他用英文讲 用这种中文讲而已

128
00:12:34,260 --> 00:12:37,060
这门课我觉得是我们很重要的基础

129
00:12:37,060 --> 00:12:40,120
我们这里面会了解很重要的一个部分

130
00:12:40,640 --> 00:12:44,760
不是说怎么去实现一个算数计算

131
00:12:44,760 --> 00:12:47,620
比如说加减乘除这些指令的一些实现

132
00:12:47,620 --> 00:12:52,500
而更多要考虑我看过陈康老师的PPT

133
00:12:52,500 --> 00:12:56,400
他里面有一个PPT专门讲的是什么

134
00:12:56,400 --> 00:12:58,420
讲特权特权模式

135
00:12:58,420 --> 00:13:01,100
就是在Risk 5上面的特权模式

136
00:13:01,100 --> 00:13:02,120
到底能做哪些事情

137
00:13:02,120 --> 00:13:06,380
而那些事情其实是和我们超系统的联系是非常紧密的

138
00:13:07,400 --> 00:13:10,500
所以我们在后面也会给大家做一个这一半的讲解

139
00:13:10,500 --> 00:13:12,040
这是主持人你这一块

140
00:13:12,400 --> 00:13:14,840
我觉得是和我们OS有个紧密联系

141
00:13:14,840 --> 00:13:16,080
编译

142
00:13:17,160 --> 00:13:18,720
虽然我说没学过影响不大

143
00:13:18,720 --> 00:13:22,200
但其实我想大家都已经学过了

144
00:13:22,820 --> 00:13:23,840
所以这是一点

145
00:13:23,840 --> 00:13:26,720
第二点我觉得编译最大的一个

146
00:13:26,720 --> 00:13:28,360
对这门课的一个帮助是在哪呢

147
00:13:28,360 --> 00:13:30,060
是在于你对汇编的理解

148
00:13:30,060 --> 00:13:33,140
你要知道就是在汇编层面

149
00:13:33,140 --> 00:13:35,120
在汇编层面这个程序怎么去执行

150
00:13:35,120 --> 00:13:37,500
而不是在这种高级语言层面

151
00:13:37,500 --> 00:13:39,680
高级语言比如说C层面

152
00:13:39,680 --> 00:13:43,580
或者说是在加瓦更高层的Python这个层面

153
00:13:43,580 --> 00:13:44,380
而是在汇编级

154
00:13:44,380 --> 00:13:46,080
因为汇编级实际上就是

155
00:13:46,080 --> 00:13:48,840
我们说计算机它提供了一个interface

156
00:13:48,840 --> 00:13:50,140
你有了这个interface之后

157
00:13:50,140 --> 00:13:51,780
你就知道怎么去控制一台

158
00:13:51,780 --> 00:13:54,120
具体的控制一台计算机

159
00:13:54,120 --> 00:13:58,800
当然汇编这一块有一点不足

160
00:13:58,800 --> 00:14:00,340
也跟前面那个组成员里一样

161
00:14:00,340 --> 00:14:01,540
就是你们在完成

162
00:14:01,540 --> 00:14:04,320
就一般同学完成的基本实验里面

163
00:14:04,320 --> 00:14:06,420
不会涉及到特权模式

164
00:14:06,420 --> 00:14:07,680
对于汇编原理来说

165
00:14:07,680 --> 00:14:09,100
它编译原理做出来

166
00:14:09,100 --> 00:14:10,040
编译原理来说

167
00:14:10,460 --> 00:14:11,440
我们讲编译的时候

168
00:14:11,440 --> 00:14:13,300
更多人讲是高级原怎么转变成

169
00:14:13,300 --> 00:14:14,800
低级原转变成汇编原

170
00:14:15,240 --> 00:14:18,760
并没有去讲解特权指令

171
00:14:18,760 --> 00:14:19,340
这是一个

172
00:14:19,340 --> 00:14:20,720
第二个也没有去讲解

173
00:14:22,220 --> 00:14:25,140
这个汇编程序和组成员理之间

174
00:14:25,140 --> 00:14:26,180
它的一个关系

175
00:14:26,180 --> 00:14:29,280
执行条指令到底对我们组织员里的

176
00:14:29,280 --> 00:14:32,060
Risk-V CPU遭到什么样的影响

177
00:14:33,000 --> 00:14:34,100
这个了解的不多

178
00:14:34,100 --> 00:14:36,420
但是它有一点是对我们有很大的帮助

179
00:14:36,420 --> 00:14:37,880
就是滤金石那一块

180
00:14:37,880 --> 00:14:40,780
滤金石那一块讲完我们说这个函数

181
00:14:40,780 --> 00:14:43,400
函数它怎么去生成的

182
00:14:43,400 --> 00:14:44,700
函数怎么去调用的

183
00:14:44,700 --> 00:14:50,360
而这一块对我们的超级种来说是很重要的

184
00:14:50,920 --> 00:14:53,800
因为在编译阶段我们这个函数调用

185
00:14:53,800 --> 00:14:57,860
它里面的站的里面的数据的保存与恢复等等

186
00:14:57,860 --> 00:14:59,300
那都是编辑器

187
00:14:59,300 --> 00:15:01,320
把我们去自动生成了一堆代码

188
00:15:01,880 --> 00:15:03,540
到了超级统这一段不一样

189
00:15:03,540 --> 00:15:07,220
超级统需要去你去手动的去控制这个站

190
00:15:07,220 --> 00:15:10,100
手动的去对站进行一定的操作

191
00:15:10,100 --> 00:15:12,120
来完成一些更底层的功能

192
00:15:12,120 --> 00:15:13,000
底层有什么

193
00:15:13,000 --> 00:15:14,780
底层有更强大的功能

194
00:15:14,780 --> 00:15:17,760
它可以完成一些我们应用程序里面做不到的事情

195
00:15:17,760 --> 00:15:20,100
这就是我们说这个编辑原理

196
00:15:20,100 --> 00:15:22,980
其实还是有很大的一个帮助的

197
00:15:22,980 --> 00:15:26,580
至少对OS而言 它是有比较大的一个帮助和联系

198
00:15:31,360 --> 00:15:40,640
好 再看这个参考教材等等 相关的那一系列的书

199
00:15:41,840 --> 00:15:44,340
我们以前是比较多 这次我们就干脆用一本

200
00:15:47,460 --> 00:15:51,860
这本是威斯康星大学的一对夫妇

201
00:15:52,460 --> 00:15:53,860
他们那儿当教授

202
00:15:54,540 --> 00:15:56,700
RAMS,这个我就简称它了

203
00:15:56,700 --> 00:15:58,640
不读它那个字太复杂了

204
00:15:58,640 --> 00:16:02,840
然后它写了一个OPEN SYSTEM EASY PIECES

205
00:16:02,840 --> 00:16:05,140
这个教材,这个教材比较好在哪呢

206
00:16:05,140 --> 00:16:09,260
它有中文,也是完全免费开放

207
00:16:11,180 --> 00:16:13,880
这里面它是散的列出来的

208
00:16:13,880 --> 00:16:16,560
我们已经把它合成了一个文件

209
00:16:16,560 --> 00:16:18,880
让大家去看

210
00:16:18,880 --> 00:16:20,800
所以大家看起来会比较方便

211
00:16:20,800 --> 00:16:24,860
而且这里面它也比较强调这个easy

212
00:16:24,860 --> 00:16:27,720
就是three easy pieces

213
00:16:27,720 --> 00:16:30,780
这个easy是它的三个抽象

214
00:16:30,780 --> 00:16:34,440
这里面它里面其实在讲的虚拟化

215
00:16:35,160 --> 00:16:37,960
并发和持久性

216
00:16:39,440 --> 00:16:42,580
我们说我看这个能不能画一个图

217
00:16:42,580 --> 00:16:45,680
他们说虚拟化就是这一块

218
00:16:46,200 --> 00:16:48,860
这么一个小的山头

219
00:16:48,860 --> 00:16:52,560
然后并发是这么一个山头

220
00:16:52,560 --> 00:16:54,820
然后持久线是另外一个山头

221
00:16:54,820 --> 00:16:57,880
这个山头如果easy的话应该是要窝窝头

222
00:16:57,880 --> 00:16:59,600
就应该是很easy的把它啃掉

223
00:16:59,600 --> 00:17:05,020
但其实我们国内的一些学生把他认为是山多大山

224
00:17:05,020 --> 00:17:07,340
把大家压得喘不过气了

225
00:17:08,600 --> 00:17:10,320
所以就看你怎么去理解了

226
00:17:10,840 --> 00:17:15,360
就是他的easy和大家学习过程中希望达到的easy

227
00:17:15,360 --> 00:17:16,380
可能会有gap

228
00:17:16,380 --> 00:17:19,840
但是我觉得它抽象的这个程度还是挺不错的

229
00:17:19,840 --> 00:17:25,340
就是把整个OS分成了三个大的主题来分别来讲解

230
00:17:25,340 --> 00:17:26,800
这是它的一个特点

231
00:17:26,800 --> 00:17:29,120
而且它这本书里面我觉得还有一个特点是在哪呢

232
00:17:29,880 --> 00:17:31,860
就是它有大量的应用程序

233
00:17:31,860 --> 00:17:34,380
就是在用户台去让大家去体会

234
00:17:34,380 --> 00:17:36,400
站在用的角度

235
00:17:36,400 --> 00:17:38,400
站在使用者的角度来理解OS

236
00:17:38,920 --> 00:17:40,620
而我们之前上课

237
00:17:40,620 --> 00:17:41,800
我理解我们之前上课

238
00:17:41,800 --> 00:17:45,700
其实更多是直接就是从开发的角度

239
00:17:45,700 --> 00:17:49,400
OS的实现的角度来去理解OS

240
00:17:49,400 --> 00:17:52,280
那其实我觉得这两者之间需要结合

241
00:17:53,020 --> 00:17:54,800
就是像MIT

242
00:17:55,260 --> 00:17:57,060
像我看到MIT斯坦福

243
00:17:57,060 --> 00:17:58,700
还有包括我们学校

244
00:17:58,700 --> 00:18:00,440
一般讲OS课的时候

245
00:18:00,440 --> 00:18:02,260
都是从底下来

246
00:18:02,260 --> 00:18:04,140
直接就是实现

247
00:18:04,140 --> 00:18:05,200
怎么就实现一个OS

248
00:18:05,200 --> 00:18:07,780
但它这边更多的强调是应用

249
00:18:07,780 --> 00:18:10,000
甚至还用一些模拟的方式

250
00:18:10,000 --> 00:18:12,140
在应用台建一些模拟的一些抽象的环境

251
00:18:12,140 --> 00:18:13,560
非常简单用Python写

252
00:18:13,560 --> 00:18:16,940
来指出这个OS的一个基本的工作原理

253
00:18:16,940 --> 00:18:18,740
我觉得这点它是做得不错的

254
00:18:18,740 --> 00:18:20,580
这也是为什么我们把它推荐为

255
00:18:20,580 --> 00:18:23,180
我们的参考书的一个原因

256
00:18:27,160 --> 00:18:28,360
那第二个呢

257
00:18:28,360 --> 00:18:30,740
就是昨天就有同学说

258
00:18:30,740 --> 00:18:32,120
为什么不用PPT

259
00:18:32,120 --> 00:18:33,100
我确实觉得

260
00:18:33,100 --> 00:18:36,080
PPT其实还不如这个browser方便

261
00:18:37,520 --> 00:18:39,500
比如说这里面就直接就是

262
00:18:39,500 --> 00:18:41,780
我们就直接把它生成了一个

263
00:18:42,360 --> 00:18:44,420
然后生成了一个网页

264
00:18:44,420 --> 00:18:47,020
你们只要能连上这个网页就可以访问了

265
00:18:47,020 --> 00:18:48,400
所以我觉得这其实更方便

266
00:18:48,400 --> 00:18:49,840
改起来也方便

267
00:18:49,840 --> 00:18:50,660
里面不用存

268
00:18:50,660 --> 00:18:51,960
它一直存在那儿

269
00:18:51,960 --> 00:18:55,820
Github和Git就帮助我们保存在这儿了

270
00:18:55,820 --> 00:18:58,060
所以我觉得这个是挺方便的一点

271
00:18:58,760 --> 00:18:59,660
先把这个去掉

272
00:19:03,760 --> 00:19:07,920
Github是Git他们相互是Mirror的

273
00:19:07,920 --> 00:19:10,320
所以说你只要你访问Github不行

274
00:19:10,320 --> 00:19:11,300
就访问Git就行了

275
00:19:11,780 --> 00:19:13,020
这是在线的slides

276
00:19:13,020 --> 00:19:17,060
然后我们也有一个实践类的

277
00:19:17,060 --> 00:19:18,380
偏实践的参考书

278
00:19:18,380 --> 00:19:19,620
那这个后面会讲到

279
00:19:19,620 --> 00:19:21,820
就是我们讲这个参考书

280
00:19:21,820 --> 00:19:25,200
其实我们的整个上课的一个安排

281
00:19:26,340 --> 00:19:28,800
和参考教材和这个实践参考书

282
00:19:28,800 --> 00:19:30,760
是有很大的关系的

283
00:19:30,760 --> 00:19:33,060
那为什么我们并没有基于

284
00:19:33,060 --> 00:19:34,680
比如说就基于这个three pieces

285
00:19:34,680 --> 00:19:35,960
或者其他的一些

286
00:19:35,960 --> 00:19:37,960
我们看到的OS的课程来上

287
00:19:37,960 --> 00:19:38,940
是在于

288
00:19:51,040 --> 00:19:55,440
比如说这里面也给了大约10张的内容

289
00:19:55,440 --> 00:19:58,140
那么从第一章开始一直到第九章

290
00:19:58,140 --> 00:20:00,640
其实都是在讲一个一个的

291
00:20:00,640 --> 00:20:03,500
操作系统中的一些关键的知识点

292
00:20:03,500 --> 00:20:05,080
但是每一个知识点呢

293
00:20:05,080 --> 00:20:06,020
它都是一个相对来说

294
00:20:06,020 --> 00:20:08,780
就是有一个具体的一个OS来对应它

295
00:20:08,780 --> 00:20:08,920
这一个知识点

296
00:20:08,920 --> 00:20:14,640
这一点是和其他的超级统课的一些讲法不太一样

297
00:20:14,640 --> 00:20:17,640
其他课是说我是有一个时间内的OS

298
00:20:17,640 --> 00:20:19,340
比如MIT和XB6

299
00:20:20,020 --> 00:20:23,960
包括威斯康辛这个学校他们用的实验也是XB6

300
00:20:23,960 --> 00:20:25,560
内核级的也是XB6

301
00:20:25,560 --> 00:20:26,420
它就一个

302
00:20:26,420 --> 00:20:27,920
在这个里面去一开始

303
00:20:27,920 --> 00:20:29,760
你就是得到一个完整的框架

304
00:20:29,760 --> 00:20:31,300
然后上面去做事情

305
00:20:31,300 --> 00:20:32,460
而我们这个不一样

306
00:20:32,460 --> 00:20:34,720
我们第一章里面可能只有一两百行的一个代码

307
00:20:34,720 --> 00:20:36,060
就是一个OS

308
00:20:36,060 --> 00:20:38,100
第二章可能变成了一个三四百行

309
00:21:08,100 --> 00:21:10,280
MIT SV6大致对应的一个

310
00:21:10,280 --> 00:21:12,300
我们叫MU-Code R-Code这么一个OS

311
00:21:15,060 --> 00:21:19,200
所以这一块是指导大家去结合这个实践

312
00:21:19,200 --> 00:21:22,660
来比较OS的关键技术的一个参考书

313
00:21:22,660 --> 00:21:23,640
这里面可以看出来

314
00:21:23,640 --> 00:21:26,660
这是我们这方面的一些准备

315
00:21:27,660 --> 00:21:29,740
但是大家还要完成相应的实验

316
00:21:29,740 --> 00:21:31,480
这实验后面会讲

317
00:21:31,480 --> 00:21:32,460
但不管怎么说

318
00:21:34,060 --> 00:21:37,240
我们针对同学的选择提供两类

319
00:21:37,240 --> 00:21:42,540
一类是C的,就mule code tutorial guide,一类是RUST的,就是R code tutorial guide

320
00:21:42,540 --> 00:21:45,620
那么他们呢,一个是C写的,一个是RUST写的

321
00:21:45,620 --> 00:21:48,980
那我们现在的助教在努力的工作中

322
00:21:48,980 --> 00:21:54,620
以前最开始的时候,R code是模拟的仿照U code写的

323
00:21:54,620 --> 00:21:58,040
然后到今年我们希望是mule code仿照R code来写

324
00:21:58,040 --> 00:22:00,480
所以我们的助教还在辛苦的工作中

325
00:22:00,480 --> 00:22:03,100
怎么去让他们之间尽量的一致

326
00:22:03,100 --> 00:22:04,960
这也是便于大家去学习

327
00:22:04,960 --> 00:22:08,420
所以一致就是说他们的实现的虽然语言不同

328
00:22:08,420 --> 00:22:12,640
但他们实现的方式实现的目标是一样

329
00:22:12,640 --> 00:22:17,320
我们去年的春季和秋季达到了说实验目标一样

330
00:22:17,320 --> 00:22:18,300
就是什么叫实验目标一样

331
00:22:18,300 --> 00:22:20,580
就是你最后的那个测试用力是一样

332
00:22:20,580 --> 00:22:24,160
因为它Syscode和具体的语言是无关的

333
00:22:24,800 --> 00:22:27,860
但是我们今年希望它的实现上来说也是一样

334
00:22:27,860 --> 00:22:33,200
这样使得大家在掌握超级统计的时候能够更加一致

335
00:22:33,200 --> 00:22:34,540
希望大家能够一致的体会

336
00:22:35,600 --> 00:22:38,560
这是实验指导这一块的一个介绍

337
00:22:39,900 --> 00:22:41,480
也是一样大家可以随便看一看

338
00:22:41,480 --> 00:22:45,180
比如这是MuCode

339
00:22:45,180 --> 00:22:48,380
这就列了这么多

340
00:22:48,380 --> 00:22:52,800
但列这么多不代表说每一张都要去完成一个必做的实验

341
00:22:52,800 --> 00:22:54,320
必做实验只有5个

342
00:22:56,280 --> 00:22:59,840
所以不会有那么多的实验去做

343
00:23:00,820 --> 00:23:01,820
这是这一块

344
00:23:06,960 --> 00:23:09,320
好 那我们这边课到底讲啥

345
00:23:09,700 --> 00:23:11,780
现在大致给大家过一下

346
00:23:11,780 --> 00:23:13,780
那可以看到

347
00:23:15,840 --> 00:23:18,280
第一个我们要讲的内容

348
00:23:18,280 --> 00:23:19,820
应该是

349
00:23:19,820 --> 00:23:22,360
第一个要讲的内容

350
00:23:25,520 --> 00:23:26,700
是超系统结构

351
00:23:26,700 --> 00:23:29,480
就是我们说的左边 右边

352
00:23:29,480 --> 00:23:30,820
你们应该是 对 右边

353
00:23:30,820 --> 00:23:33,140
右边这一块的整个这一块区域

354
00:23:33,140 --> 00:23:34,680
这样就是我们说一个超系统结构

355
00:23:34,680 --> 00:23:36,400
当然这是其中一种结构

356
00:23:36,400 --> 00:23:37,660
我们还有其他的结构

357
00:23:37,660 --> 00:23:40,200
这是站在一个非常高的一个层面

358
00:23:40,200 --> 00:23:43,140
去知道一个比较大型的软件怎么去设计

359
00:23:43,520 --> 00:23:45,620
这也是同学可能经历的比较少一点

360
00:23:45,620 --> 00:23:47,860
我理解你们过去的过程中

361
00:23:47,860 --> 00:23:51,040
可能设计到比较大型的软件是在边缘里

362
00:23:51,040 --> 00:23:56,200
或者是在软工会做过稍微比较大的软件

363
00:23:57,080 --> 00:23:58,380
那软工我没有上过

364
00:23:58,380 --> 00:23:59,740
边缘里我上过

365
00:23:59,740 --> 00:24:01,110
如果说边缘里的编辑器

366
00:24:02,020 --> 00:24:04,040
那个软件和OS比起来的话

367
00:24:04,840 --> 00:24:08,740
在代码量上可能OS比较是它的1.5倍左右

368
00:24:10,160 --> 00:24:14,580
然后在复杂性上也可能是它的1.5到2倍左右

369
00:24:16,800 --> 00:24:19,940
所以在这么一个更加复杂的软件情况下

370
00:24:19,940 --> 00:24:22,440
怎么去设计一个OS

371
00:24:22,440 --> 00:24:24,300
这是需要去考虑一个问题

372
00:24:24,300 --> 00:24:25,740
就是架构设计问题

373
00:24:25,740 --> 00:24:27,960
将来你们如果将来有谁

374
00:24:27,960 --> 00:24:29,640
将来做一些大型的系统软件的话

375
00:24:29,640 --> 00:24:31,880
那么你会有一个职务家Architect

376
00:24:31,880 --> 00:24:34,880
实际上就是这个架构思,他就要干这种事情

377
00:24:36,020 --> 00:24:40,680
第二个我们要去理解的是终端和系统标用

378
00:24:41,280 --> 00:24:44,920
以及还有异常,其实还没有说完,就是终端和系统标用异常

379
00:24:44,920 --> 00:24:50,220
这个也是说和我们的应用程序开发非常不一样的一点

380
00:24:50,220 --> 00:24:53,720
我们应用程序开发里面,你说那种线性思维的逻辑

381
00:24:53,720 --> 00:24:56,140
就是所谓线性思维就是从上到下

382
00:24:56,660 --> 00:24:58,380
第一步怎么做,第二步怎么做

383
00:24:58,380 --> 00:25:00,720
第一步和第二步之间是一个连续的过程

384
00:25:00,720 --> 00:25:02,980
无论你有没有义务语句那其实无所谓

385
00:25:02,980 --> 00:25:06,200
总之它是一个连续往下执行的一个控制流的过程

386
00:25:06,960 --> 00:25:10,560
但是在超级通里面你需要去更深刻的理解

387
00:25:10,560 --> 00:25:12,640
这个指引过程是断断续续的

388
00:25:13,380 --> 00:25:16,160
它是一个随时会被打断的一个指引过程

389
00:25:16,160 --> 00:25:19,690
这个被打断就是由于中断系统调用异常产生的

390
00:25:20,200 --> 00:25:21,520
就叫异常控制流

391
00:25:21,520 --> 00:25:24,460
专门有一本书叫CSAPP

392
00:25:24,460 --> 00:25:29,170
CSAPP就是那个叫做深入理解计算机系统中文名字

393
00:25:34,310 --> 00:25:37,010
就是按照程序员的观点去理解教研机系统

394
00:25:38,130 --> 00:25:39,410
咱们这些同学没有上

395
00:25:39,410 --> 00:25:41,970
但是你们的下一届的同学

396
00:25:41,970 --> 00:25:43,230
我们系专门开了你们的课

397
00:25:43,230 --> 00:25:45,010
叫教研机系统导论

398
00:25:45,010 --> 00:25:49,990
是张安慧老师开的

399
00:25:50,670 --> 00:25:52,330
张老师你们也很熟悉吧

400
00:25:52,330 --> 00:25:55,470
应该他们上过你们的汇编课

401
00:25:56,530 --> 00:25:57,750
但是他们已经把汇编

402
00:25:57,750 --> 00:25:59,150
升级为了CSAPP

403
00:26:00,410 --> 00:26:01,990
所以有了那门课的基础之后

404
00:26:01,990 --> 00:26:03,170
你看第九章

405
00:26:03,170 --> 00:26:06,890
我觉得那门课里面跟YS相关性比较大的

406
00:26:06,890 --> 00:26:10,070
或者比较有特色的就是第九章

407
00:26:10,070 --> 00:26:14,150
就是关于异常控制流这一块咱们去做的

408
00:26:14,150 --> 00:26:15,630
这个是我们的一个重点

409
00:26:15,630 --> 00:26:17,250
第三个内存管理

410
00:26:17,250 --> 00:26:20,330
内存管理想了解的是什么呢

411
00:26:20,330 --> 00:26:22,570
了解的是说内存这一块

412
00:26:22,570 --> 00:26:23,830
我们写应用程序的时候

413
00:26:23,830 --> 00:26:26,990
我们确实如果写Python程序

414
00:26:27,370 --> 00:26:28,890
可能你都不需要申请内存

415
00:26:28,890 --> 00:26:31,810
你就直接定义好这些结构就用就完了

416
00:26:32,170 --> 00:26:33,550
各种变量就用就行了

417
00:26:33,550 --> 00:26:34,590
那你如果用低沉一点

418
00:26:34,590 --> 00:26:38,810
你们也学了像李国良老师专门教过大家CIA家

419
00:26:39,830 --> 00:26:43,630
这CIA家里面还是还有Maloc或者叫做New Free

420
00:26:43,630 --> 00:26:46,990
Maloc Free或者New还有Demaloc这种东西

421
00:26:47,910 --> 00:26:51,750
那么内存你可以去申请和释放

422
00:26:51,750 --> 00:26:54,070
然后申请释放是你发出一个请求

423
00:26:54,070 --> 00:26:56,110
那请求实际上是谁来帮你做的呢

424
00:26:56,110 --> 00:26:57,390
就是我们超线网来做的

425
00:26:57,390 --> 00:27:01,150
所以你要知道这个内存管理怎么能够去给我们应用情况下的支持

426
00:27:01,150 --> 00:27:03,730
而且这个支持非常的便捷

427
00:27:03,730 --> 00:27:05,350
这个便捷体验在很多方面

428
00:27:05,350 --> 00:27:07,230
比如说你其实不用太care

429
00:27:07,230 --> 00:27:08,350
你要申请多大的空间

430
00:27:08,350 --> 00:27:09,910
你申请好像申请了非常大的空间

431
00:27:09,910 --> 00:27:10,950
它也能够满足你

432
00:27:10,950 --> 00:27:12,010
反正为什么它能做到这一点

433
00:27:12,010 --> 00:27:14,310
实际上它有可能会超过你的物理内存的空间

434
00:27:14,310 --> 00:27:18,210
这都是我们OS里面重点去关注的一个内容

435
00:27:18,210 --> 00:27:19,850
就是内存管理这一块

436
00:27:19,850 --> 00:27:21,430
进程管理

437
00:27:21,430 --> 00:27:24,970
进程管理就是进程我们这边时不时都提到进程

438
00:27:24,970 --> 00:27:28,150
进程就是一个操作系统的一个重要的头像

439
00:27:28,150 --> 00:27:31,090
它就是简单的说就是我们这个直营的程序

440
00:27:31,090 --> 00:27:33,830
你这个OS里面可能要跑一堆程序

441
00:27:33,830 --> 00:27:37,130
这些一堆程序他们怎么把它有效的管理起来

442
00:27:37,130 --> 00:27:38,670
来共享这里面的资源

443
00:27:38,670 --> 00:27:41,830
这资源包括了Memory 包括CPU等等

444
00:27:41,830 --> 00:27:43,890
这是进程管理这一块

445
00:27:43,890 --> 00:27:46,930
这也是我们的一个重点

446
00:27:47,370 --> 00:27:48,570
然后处理器调度

447
00:27:49,090 --> 00:27:50,650
就是这是进程管理中的

448
00:27:50,650 --> 00:27:51,970
其实进程管理中的一部分

449
00:27:52,950 --> 00:27:53,990
一个关键点

450
00:27:53,990 --> 00:27:56,730
什么意思呢 就是说大家共享一个CPU

451
00:27:56,730 --> 00:27:58,250
在一个CPU的情况下共享一个CPU

452
00:27:58,250 --> 00:28:01,710
那么大家怎么去有效 合理 高效

453
00:28:01,710 --> 00:28:05,190
公平的去共享这个CPU 这是调度问题

454
00:28:06,710 --> 00:28:09,270
同模同似 对于共享制线而言

455
00:28:09,270 --> 00:28:11,470
只要你有共享 就会有冲突

456
00:28:11,470 --> 00:28:13,790
你怎么能够去解决这个冲突问题

457
00:28:13,790 --> 00:28:17,070
这是我们的一个 也是一个很困难的地方

458
00:28:19,890 --> 00:28:21,330
我觉得在这里面

459
00:28:21,330 --> 00:28:25,430
像中段内存管理进程管理都跟我们的硬件

460
00:28:25,430 --> 00:28:26,470
都会有或多或少的联系

461
00:28:26,470 --> 00:28:30,010
就是说对我们的主体原理会要求的多一点

462
00:28:30,010 --> 00:28:34,330
然后到了同步互斥或者是调度的时候稍微少一点

463
00:28:35,030 --> 00:28:37,090
但是他们的难度会更加

464
00:28:37,090 --> 00:28:40,290
就是所谓的这个思考的难度会更加大一点

465
00:28:40,790 --> 00:28:42,730
因为并发编程或者并行编程

466
00:28:42,730 --> 00:28:45,450
一直是一个比较困难的一个编程方式

467
00:28:45,450 --> 00:28:49,390
我们人一般习惯于是这种串型思维

468
00:28:49,390 --> 00:28:50,570
当然要去并行思维

469
00:28:50,570 --> 00:28:52,470
要考虑他们之间相互的关系的时候

470
00:28:52,470 --> 00:28:53,970
就会麻烦很多

471
00:28:53,970 --> 00:28:56,230
这也是为什么到现在为止

472
00:28:57,210 --> 00:28:59,890
我觉得我们的计算机器的课程里面

473
00:28:59,890 --> 00:29:02,750
还没有开设并行编程这门课

474
00:29:02,750 --> 00:29:05,410
好像没有 是吧 你们上过吗

475
00:29:05,410 --> 00:29:06,210
应该没上过

476
00:29:07,430 --> 00:29:09,910
但我记得那个

477
00:29:09,910 --> 00:29:11,110
就是国外的一个什么

478
00:29:11,110 --> 00:29:13,490
ASM的一个CS的一个教学大纲里面

479
00:29:13,490 --> 00:29:16,690
已经把并行编程列为一个非常重要的一个位置

480
00:29:16,690 --> 00:29:19,770
因为我们现在机器几乎都是多核的

481
00:29:19,770 --> 00:29:22,970
几乎都要考虑到并行的一个处理方式

482
00:29:25,650 --> 00:29:28,410
所以超级种是专门把这一块拎出来

483
00:29:28,410 --> 00:29:32,770
怎么去让你们去理解一个并行或者并发编程所要碰到的一些问题

484
00:29:32,770 --> 00:29:35,370
最后一个文件系统

485
00:29:38,270 --> 00:29:42,470
你可以看到前面讲的这些内存、进存、处理器、调度等等

486
00:29:42,470 --> 00:29:44,090
这实际上是我们先前说的维修

487
00:29:44,930 --> 00:29:47,650
同步估值属于concurrency就是并发处理

488
00:29:47,650 --> 00:29:48,550
这是虚拟化

489
00:29:48,550 --> 00:29:51,790
文件系统这块是讲什么 讲持久性

490
00:29:51,790 --> 00:29:54,050
你要把数据持久的保存在一个地方

491
00:29:54,050 --> 00:29:56,430
这个地方一般是我们的Disk

492
00:29:56,430 --> 00:29:59,330
就是我们的磁盘或者是我们的SSD

493
00:29:59,330 --> 00:30:00,990
U盘等等 无所谓

494
00:30:00,990 --> 00:30:03,190
只要是一种持久性的存储戒指

495
00:30:03,190 --> 00:30:05,270
那么它就和我们的memory是不一样

496
00:30:05,270 --> 00:30:06,950
我们需要把数据长久保存的时候

497
00:30:06,950 --> 00:30:13,370
就需要把数据从memory导到storage里面去

498
00:30:13,370 --> 00:30:14,910
这导的过程需要靠什么呢

499
00:30:14,910 --> 00:30:16,510
靠文件系统帮我们来管理

500
00:30:16,510 --> 00:30:19,310
使得我们的编程会更加简单

501
00:30:19,310 --> 00:30:25,210
所以你会看到整个超级统的原理和设计思想讲的是号

502
00:30:25,210 --> 00:30:26,770
这就讲到一堆号的一起

503
00:30:27,270 --> 00:30:30,270
那为什么要去讲这些号呢

504
00:30:30,270 --> 00:30:32,150
你要理解超级统

505
00:30:32,150 --> 00:30:36,130
它的一个很重要的一点就在于它要去支持应用

506
00:30:36,130 --> 00:30:39,070
让我们应用更加方便

507
00:30:39,070 --> 00:30:42,770
应用开发更方便 应用运行更有效

508
00:30:42,770 --> 00:30:45,150
那实际上应用easy了

509
00:30:45,150 --> 00:30:48,110
其实超级动物是变得麻烦了

510
00:30:48,110 --> 00:30:49,510
所以那个3 easy pieces

511
00:30:49,510 --> 00:30:52,630
我觉得应该是3 difficult pieces

512
00:30:52,630 --> 00:30:53,530
才比较合理

513
00:30:53,530 --> 00:30:55,810
它并不是容易是复杂

514
00:30:55,810 --> 00:30:58,090
我们是希望通过OS的复杂性

515
00:30:58,090 --> 00:31:00,110
来给我们的应用带来简单性

516
00:31:00,110 --> 00:31:02,630
这是我们要去讲这些的原因

517
00:31:02,630 --> 00:31:03,590
我们要支持应用

518
00:31:03,590 --> 00:31:04,910
这是我们背后的why

519
00:31:06,770 --> 00:31:08,010
最后一个IOS系统

520
00:31:08,010 --> 00:31:09,290
我还落于IOS系统

521
00:31:09,290 --> 00:31:11,810
IOS系统实际上是让我们的应用更加丰富多产

522
00:31:11,810 --> 00:31:13,430
就是除了我们

523
00:31:13,430 --> 00:31:15,570
我们现在的OS其实不够风波多彩

524
00:31:15,570 --> 00:31:17,810
就是字幕方式 连图形都没有

525
00:31:17,810 --> 00:31:19,610
但是如果我们做到第九章的时候

526
00:31:19,610 --> 00:31:20,970
其实如果同学感兴趣的话

527
00:31:20,970 --> 00:31:24,130
其实可以去在上面去显示图形

528
00:31:24,130 --> 00:31:28,030
去通过键盘鼠标来控制一个小游戏等等

529
00:31:28,030 --> 00:31:29,810
这就是IOS系统

530
00:31:29,810 --> 00:31:32,070
实际上是我们计算机的处理的范围

531
00:31:32,070 --> 00:31:35,070
跟外界打交道能力更加广泛

532
00:31:35,070 --> 00:31:37,750
它会涉及到各种各样的外售的一个支持

533
00:31:38,570 --> 00:31:41,190
这是我们放在最后去讲的一点

534
00:31:42,670 --> 00:31:48,590
这是我们整个OS课里面的主要的组成部分

535
00:31:52,550 --> 00:31:55,030
我不知道你们每天都在用超级统

536
00:31:55,030 --> 00:31:58,190
对这些内容是不是应该有所了解

537
00:32:00,530 --> 00:32:03,050
看起来有些东西比较茫然

538
00:32:05,270 --> 00:32:07,330
也很正常 不茫然也很正常

539
00:32:07,330 --> 00:32:09,470
我是觉得现在咱们同学差异比较大

540
00:32:09,470 --> 00:32:13,130
有同学觉得这门课很easy

541
00:32:13,130 --> 00:32:14,830
有同学觉得这门课很难

542
00:32:16,490 --> 00:32:18,230
对 这门课其实很easy

543
00:32:21,910 --> 00:32:25,350
作业 这个逐渐涉及到大家能去拿成绩了

544
00:32:25,350 --> 00:32:27,250
平时作业就是课后练习

545
00:32:27,250 --> 00:32:29,190
课后练习我们粗粒一些

546
00:32:29,190 --> 00:32:32,250
放在刚才那本书里面

547
00:32:32,250 --> 00:32:37,270
放在这个里面的每一张

548
00:32:37,270 --> 00:32:49,650
后面都有一个,有一个练习,你看这练习变了两类嘛,一个相对是编程练习

549
00:32:49,650 --> 00:32:56,960
和,诶,不对,这是第一张,应该是,随便找一个再显示的。

550
00:33:13,170 --> 00:33:24,610
这个有点 这是实验内容了 其实我们其实还应该有一个 我看看是放在哪儿

551
00:33:24,610 --> 00:33:25,890
稍等一下 我看看

552
00:33:55,890 --> 00:34:00,190
这些题目你上完课之后呢

553
00:34:00,190 --> 00:34:02,150
基本上就是可以去尝试做一下

554
00:34:02,150 --> 00:34:04,730
但是我们并不会给分

555
00:34:05,590 --> 00:34:08,170
所以大家有些东西觉得不给分就不做了

556
00:34:08,170 --> 00:34:09,250
这也可以理解

557
00:34:12,810 --> 00:34:16,650
但是考试的话会从这里面去出一些题

558
00:34:17,230 --> 00:34:19,330
所以做了的话总会有些好处

559
00:34:19,330 --> 00:34:21,490
不做的话那就靠你们的

560
00:34:22,650 --> 00:34:23,850
对可以考前做没问题

561
00:34:53,850 --> 00:34:55,910
你们觉得适合做的

562
00:34:55,910 --> 00:34:57,990
然后其他或者说你们还可以分个小组

563
00:34:57,990 --> 00:34:58,890
每人做不同的题目

564
00:34:58,890 --> 00:35:00,010
然后大家可以快交流交流

565
00:35:00,010 --> 00:35:01,450
这样的话可能收获会更大一点

566
00:35:02,710 --> 00:35:04,230
这是第二个是基础实验

567
00:35:04,230 --> 00:35:06,690
这个是我们会布置5个实验

568
00:35:06,690 --> 00:35:09,370
后面会有稍微的稍微讲解一下

569
00:35:09,370 --> 00:35:11,470
最后一个是属于课程设计大实验

570
00:35:11,470 --> 00:35:13,130
大实验主要是用来代替考试

571
00:35:13,890 --> 00:35:16,090
就是你如果能够提前完成基础实验

572
00:35:16,090 --> 00:35:18,550
然后就可以去做大实验

573
00:35:18,550 --> 00:35:20,970
尝试着去能不能代替考试

574
00:35:20,970 --> 00:35:24,030
那基础实验这样就是三个

575
00:35:24,030 --> 00:35:26,170
这里面列了三个 后面还有两个 一共五个

576
00:35:27,390 --> 00:35:29,450
相当于说跟去年差不多

577
00:35:29,450 --> 00:35:34,330
跟去年的秋季是差不多的

578
00:35:34,330 --> 00:35:41,230
比较大的区别是对实验五稍微做了一个区别

579
00:35:41,230 --> 00:35:43,590
实验五的话是同步不似

580
00:35:43,590 --> 00:35:45,090
这个在去年是没有的

581
00:35:45,090 --> 00:35:48,770
我们今年会增加同步不似相关的实验内容

582
00:35:48,770 --> 00:35:52,210
实验室更多是体验在文件系统这一块

583
00:35:52,210 --> 00:35:53,770
竞争间通信是去年有的

584
00:35:53,770 --> 00:35:55,160
但我们今年给它合在一起了

585
00:35:56,110 --> 00:35:59,210
其实基本上你可以把这个认为是比较简单的

586
00:35:59,210 --> 00:36:01,610
更多是文件系统本身的一些知识

587
00:36:01,610 --> 00:36:04,950
所以说我们降低了竞争间通信的工作量

588
00:36:04,950 --> 00:36:06,870
然后增加了一个同步式

589
00:36:06,870 --> 00:36:09,850
而前面的只是调整一下顺序

590
00:36:09,850 --> 00:36:10,930
没有大的变化

591
00:36:10,930 --> 00:36:14,590
比如说把之前的调度挪到了实验室上来

592
00:36:14,590 --> 00:36:15,950
放到这个位置来而已

593
00:36:15,950 --> 00:36:18,750
前面就没有调度的一些工作了

594
00:36:18,750 --> 00:36:21,790
这就是我们说的大约5个试验

595
00:36:23,490 --> 00:36:25,030
那大实验就千差万别

596
00:36:25,030 --> 00:36:26,350
大实验其实kiss by kiss

597
00:36:26,350 --> 00:36:28,650
有同学觉得自己能力很强

598
00:36:28,650 --> 00:36:30,410
或者有兴趣

599
00:36:30,410 --> 00:36:32,030
那你就可以选择大实验

600
00:36:32,030 --> 00:36:33,630
但是大实验就可以跟老师沟通

601
00:36:33,630 --> 00:36:36,510
来选择一个你更感兴趣的题目来做

602
00:36:37,490 --> 00:36:40,690
这是我就不细讲了

603
00:36:40,690 --> 00:36:42,070
那怎么考试

604
00:36:42,070 --> 00:36:43,770
怎么拿成绩

605
00:36:43,770 --> 00:36:45,190
不是考试应该怎么拿成绩

606
00:36:45,190 --> 00:36:47,550
然后第一通选择的也是大多数同学的选择

607
00:36:48,910 --> 00:36:51,950
也是结合我们几年的一个经验吧

608
00:36:52,550 --> 00:36:53,530
增加实验成绩

609
00:36:53,530 --> 00:36:55,090
所以实验上了40%

610
00:36:56,790 --> 00:36:59,470
比去年的应该是要高的

611
00:37:00,970 --> 00:37:02,470
其中考试降低了

612
00:37:02,470 --> 00:37:04,230
其中考试只占20%

613
00:37:04,230 --> 00:37:06,010
这目的是有朋友说

614
00:37:06,010 --> 00:37:07,670
其中考试有些反馈

615
00:37:07,670 --> 00:37:08,690
老师说

616
00:37:08,690 --> 00:37:09,770
其中考试我考差了

617
00:37:09,770 --> 00:37:11,230
我这门课就觉得学不下去了

618
00:37:11,750 --> 00:37:12,790
那其实你只扣了20分

619
00:37:12,790 --> 00:37:14,350
还有80分可以去

620
00:37:19,830 --> 00:37:23,170
以前大家觉得这个期末老师给分太多了之后

621
00:37:23,170 --> 00:37:24,510
影响大家后续的发挥

622
00:37:24,510 --> 00:37:25,670
我们就可以少一点

623
00:37:25,670 --> 00:37:30,190
这样使得大家有更多的精力去应对期末考试

624
00:37:32,090 --> 00:37:34,550
和平时的实验

625
00:37:34,550 --> 00:37:35,630
这就占了80分

626
00:37:37,210 --> 00:37:38,650
这是选择一

627
00:37:38,650 --> 00:37:40,430
这是我觉得是大部分同学的选择

628
00:37:44,250 --> 00:37:45,930
因为第八周要期中考试

629
00:37:45,930 --> 00:37:48,190
所以七周就完成实验一到实验五

630
00:37:48,190 --> 00:37:49,470
我们检查一下

631
00:37:49,470 --> 00:37:50,530
然后觉得你ok

632
00:37:51,010 --> 00:37:52,770
那你就可以开始大

633
00:37:54,010 --> 00:37:56,110
课程设计这个阶段的一个过程

634
00:37:56,110 --> 00:37:57,450
包括你做的更快的

635
00:37:57,450 --> 00:37:58,570
你可以提前去做

636
00:37:58,570 --> 00:38:00,870
跟老师沟通去做课程设计

637
00:38:01,250 --> 00:38:03,770
由于我们本学期的实验

638
00:38:03,770 --> 00:38:04,830
还在进一步完善中

639
00:38:04,830 --> 00:38:06,130
所以选择大试验的同学

640
00:38:06,130 --> 00:38:07,490
你可以直接

641
00:38:08,150 --> 00:38:09,790
选择去年秋季实验去完成

642
00:38:09,790 --> 00:38:10,410
去年秋季实验以后

643
00:38:40,410 --> 00:38:42,790
工作量并不是很大 参加考试

644
00:38:42,790 --> 00:38:47,270
这就是如果你选择大实验

645
00:38:47,270 --> 00:38:50,310
如果退出的话是这么一个考虑

646
00:38:50,310 --> 00:38:54,490
这就是选择一和选择二

647
00:38:54,490 --> 00:38:56,250
就两种选择

648
00:38:56,250 --> 00:39:00,030
科学科学就是有大实验

649
00:39:00,030 --> 00:39:03,590
就是一个人来主动

650
00:39:03,590 --> 00:39:04,570
看情况

651
00:39:05,570 --> 00:39:07,350
你可以一个人也可以主动

652
00:39:07,350 --> 00:39:13,610
但是基本实验是单个人,没有组队自己说,我觉得咱们同学足够了,一个人足够

653
00:39:13,610 --> 00:39:18,530
了,所有要组合的就是可能有一个同学要靠另一个同学,其实没必要,所以就干

654
00:39:18,530 --> 00:39:19,130
脆一个人算。

655
00:39:20,490 --> 00:39:25,430
调查问卷,调查问卷可以给大家看看,这样大家可以理解一下咱们同学整体的

656
00:39:25,430 --> 00:39:25,930
一个情况。

657
00:39:56,490 --> 00:39:58,370
这也基本上是采样也差不多

658
00:39:58,370 --> 00:40:00,090
我觉得应该是这个要求

659
00:40:00,090 --> 00:40:00,930
挺好

660
00:40:00,930 --> 00:40:02,550
大家就是由于学分要求

661
00:40:02,550 --> 00:40:03,750
使得大家必须要学

662
00:40:03,750 --> 00:40:06,010
我相信对大家将来工作还是有一定好处

663
00:40:07,770 --> 00:40:09,530
这是你们看到一个大致情况

664
00:40:09,530 --> 00:40:10,330
第二个

665
00:40:11,450 --> 00:40:13,030
怎么学如何学

666
00:40:13,030 --> 00:40:14,710
那这个我觉得

667
00:40:15,830 --> 00:40:16,810
这有点

668
00:40:17,370 --> 00:40:19,690
我觉得可能是有点说的有点过了

669
00:40:20,350 --> 00:40:21,690
平时认真上课

670
00:40:21,690 --> 00:40:25,150
我觉得一般取决于大家第一堂课是认真上课

671
00:40:28,890 --> 00:40:34,230
之后就跟编译课一样,就是逐渐下降,作业独立完成,作业根本就没

672
00:40:34,230 --> 00:40:38,350
故事,所以没有存在独立完成这一书,我们不会给作业打分的。

673
00:40:38,390 --> 00:40:45,070
对有兴趣内容主动进行深入学习,这个我们鼓励,就是上课讲的是比较,

674
00:40:45,070 --> 00:40:49,350
应该说比较浅一点的,如果大家需要了解更深入的内容的话,

675
00:40:50,310 --> 00:40:56,450
你可以找助教,找老师去沟通,这样我觉得也许对学问有帮助,也许对学问

676
00:40:56,450 --> 00:41:02,030
没有帮助,但是对你的能力和兴趣会有一个推动,这是这一块。

677
00:41:04,030 --> 00:41:12,970
我觉得如果你就想过的话,这个选择也是合理的,看视频就不来上课了,我觉得也OK,

678
00:41:13,090 --> 00:41:17,830
因为我们基本上都会录视频,做练习,做实验。

679
00:41:18,590 --> 00:41:21,770
这个也是一个非常好的一个我觉得是非常好的一个选择

680
00:41:21,770 --> 00:41:23,870
因为大家都时间有限

681
00:41:23,870 --> 00:41:26,030
你用双倍数来听老师上课

682
00:41:26,030 --> 00:41:27,170
这个效果是不一样的

683
00:41:27,170 --> 00:41:31,530
我觉得可以省一半的时间来得到一个掌握

684
00:41:31,530 --> 00:41:34,370
而且我看有一同学还可以同时开两个屏幕

685
00:41:36,090 --> 00:41:37,230
一个陈老师上课

686
00:41:37,230 --> 00:41:38,050
一个李老师上课

687
00:41:38,050 --> 00:41:39,010
可以对到地听

688
00:41:39,010 --> 00:41:41,390
我觉得这也是一种尝试

689
00:41:43,330 --> 00:41:44,370
但不管怎么说

690
00:41:44,370 --> 00:41:47,230
我觉得听课说都可以不用听

691
00:41:47,230 --> 00:41:53,430
你把书看懂了也行。但是一定要去做练习,做实验。干这两个事干啥呢?

692
00:41:53,450 --> 00:41:55,370
实际上就是在做考试的模拟。

693
00:41:55,650 --> 00:42:00,170
你把这个做得熟了之后,其实考试就没问题了。这是我的理解。

694
00:42:07,510 --> 00:42:12,350
我觉得这也是符合吧。我觉得有兴趣,我觉得应该是没兴趣。

695
00:42:13,070 --> 00:42:16,330
会尽力学好 精力有限 这都是正常现象

696
00:42:16,330 --> 00:42:19,230
尽力学好 我觉得挺好 这个也是占了大部分

697
00:42:20,570 --> 00:42:22,550
如果有这种情况 没兴趣

698
00:42:22,550 --> 00:42:24,350
对四五通过考试都不关心

699
00:42:28,810 --> 00:42:31,270
如果有这种同学的话 还是客户找一下老师

700
00:42:31,270 --> 00:42:33,350
老师给你沟一沟

701
00:42:37,650 --> 00:42:40,510
这个是一个要独立完成的

702
00:42:40,510 --> 00:42:42,730
因为其实你抄

703
00:42:44,190 --> 00:42:46,150
我的理解抄也是一种独立完成

704
00:42:46,750 --> 00:42:48,010
不是说抄不是独立完成

705
00:42:48,010 --> 00:42:49,110
但抄要抄懂

706
00:42:49,830 --> 00:42:51,910
你别抄了之后自己还没抄懂

707
00:42:51,910 --> 00:42:53,890
那其实就没有效果

708
00:42:53,890 --> 00:42:56,950
所谓懂的原因就是我不觉得大家都能够独立地完成

709
00:42:57,650 --> 00:43:00,510
这里面有三分之一的独立完成我觉得就挺不错了

710
00:43:01,270 --> 00:43:03,770
但是你参考别人的

711
00:43:03,770 --> 00:43:06,010
即使是把别人抄下来

712
00:43:06,010 --> 00:43:07,690
但是你真理解了

713
00:43:07,690 --> 00:43:11,370
然后在他基础上你还能够去再去尝试自己去做一遍的话

714
00:43:11,370 --> 00:43:12,830
我觉得就就已经学到

715
00:43:12,830 --> 00:43:16,230
不一定要学到完全是根据个人的情况

716
00:43:16,230 --> 00:43:18,730
我不觉得就是不允许看别人的

717
00:43:18,730 --> 00:43:19,390
我就可以看别人

718
00:43:19,390 --> 00:43:22,230
但是你要理解 这点我就是重要

719
00:43:22,230 --> 00:43:24,130
所以我对独立的理解是

720
00:43:24,130 --> 00:43:26,730
其实是你独立掌握了这个知识点

721
00:43:26,730 --> 00:43:29,090
而不是靠别人的内容来掌握知识点

722
00:43:29,090 --> 00:43:31,190
最终你考试的时候独立考试

723
00:43:31,190 --> 00:43:32,730
所以这一点你要理解

724
00:43:32,730 --> 00:43:36,210
这是独立完成实验任务

725
00:43:39,250 --> 00:44:03,830
咱们有这么多同学进入10%吗 咱们现在200人 前20人不就是前10%

726
00:46:04,010 --> 00:46:06,470
我们可以看一看

727
00:46:07,170 --> 00:46:10,830
Rcode这一块 我们也找了一位同学来负责

728
00:46:10,830 --> 00:46:16,470
是叫尤同学 尤同学正好在后面可以看一看

729
00:46:16,470 --> 00:46:18,970
好 大家认识一下 可能大家都不熟悉

730
00:46:20,270 --> 00:46:24,050
因为他不在计算机系 他是我们电子系的同学

731
00:46:24,050 --> 00:46:27,030
电子同学他对计算机这门课比较感兴趣

732
00:46:27,030 --> 00:46:30,990
就来这门课申请当助教 当然其实是被我要求的

733
00:46:30,990 --> 00:46:32,290
就是他要在这门课当助教

734
00:46:32,290 --> 00:46:36,350
然后上面那个李老师会把那个饶同学给抓的比较多一点

735
00:46:36,350 --> 00:46:39,450
去把这个溜扣给他改得更好一些

736
00:46:41,130 --> 00:46:47,370
然后这里面想选择课程设计的同学也建议早点和老师联系一下

737
00:46:47,370 --> 00:46:52,190
能够去合理安排你的前面的基本实验的完成

738
00:46:53,330 --> 00:46:55,670
你在说你想做课程设计之前

739
00:46:55,670 --> 00:46:57,710
你现在有一定的底子

740
00:46:57,710 --> 00:47:01,970
这个底子就是把之前的这个技术实验先完成了

741
00:47:36,570 --> 00:47:39,970
这个我就把这个第一部分算是讲完了吧

742
00:47:44,070 --> 00:47:47,030
好 我们开始第二部分

743
00:47:47,030 --> 00:47:48,810
第一部分算是给大家做一个开场白

744
00:47:48,810 --> 00:47:51,070
大家对这门课有一个初步的印象

745
00:47:51,070 --> 00:47:53,910
怎么知道去上这门课 怎么去过这门课

746
00:47:53,910 --> 00:47:56,330
然后呢 第二节开始

747
00:47:56,330 --> 00:47:58,750
第二节开始我们就讲是开始进入正体

748
00:47:59,090 --> 00:48:02,250
去理解OS 能够去把这门课学好

749
00:48:02,850 --> 00:48:05,350
第二个讲什么呢 讲什么是OS

750
00:48:05,750 --> 00:48:07,250
什么是操作系统

751
00:48:10,570 --> 00:48:17,950
第一个可能大家都会有点感觉和其他的

752
00:48:18,370 --> 00:48:21,010
这个怎么说呢 跟其他的一些课不太一样

753
00:48:21,010 --> 00:48:22,970
特别是跟数学类的课不太一样

754
00:48:29,850 --> 00:48:35,550
好 大家先休息一下

755
00:53:39,850 --> 00:53:43,190
我们继续上课

756
00:53:43,670 --> 00:53:46,910
刚才我们讲到就是

757
00:53:47,730 --> 00:53:49,490
操作系统的定义

758
00:53:50,010 --> 00:53:51,510
实际上我们前面也提到

759
00:53:51,990 --> 00:53:54,070
没有公认的精确定义

760
00:53:54,070 --> 00:53:55,250
这也是为什么你看到

761
00:53:55,250 --> 00:53:56,990
现在在我们世界上面

762
00:53:57,850 --> 00:53:58,730
很多的

763
00:53:58,730 --> 00:54:00,570
软件都号称自己是超级桶

764
00:54:05,670 --> 00:54:07,770
我们在讲别的那些软件之前

765
00:54:07,770 --> 00:54:09,810
我们先自己要清楚什么是超级桶

766
00:54:09,810 --> 00:54:12,090
超级桶这里面它的定义

767
00:54:12,090 --> 00:54:12,970
实际上你可以看着

768
00:54:12,970 --> 00:54:14,610
我们选择了什么计划机

769
00:54:15,610 --> 00:54:17,010
把客权书里面的一个

770
00:54:17,010 --> 00:54:19,530
就国内算是比较权威的

771
00:54:19,530 --> 00:54:21,450
这个计划机类的名词解释

772
00:54:21,450 --> 00:54:23,330
上面有个主角计划机把客权书

773
00:54:23,330 --> 00:54:25,130
它对超级桶的一个定义

774
00:54:25,990 --> 00:54:27,510
超级桶是什么

775
00:54:30,050 --> 00:54:32,510
去理解一下 它是一个软件

776
00:54:33,310 --> 00:54:34,770
你首先理解它是个软件

777
00:54:34,770 --> 00:54:36,510
第二个它是个系统软件

778
00:54:37,190 --> 00:54:38,130
先把这个搞明白

779
00:54:38,130 --> 00:54:40,830
我们先说软件系统软件

780
00:54:40,830 --> 00:54:43,630
就是它的是这么一类

781
00:54:43,630 --> 00:54:45,130
一个software

782
00:54:45,130 --> 00:54:47,910
那么这个软件干什么呢

783
00:54:47,910 --> 00:54:49,270
给应用提供支持

784
00:54:49,830 --> 00:54:51,830
给应用提供支持这个应用

785
00:54:51,830 --> 00:54:54,510
包括我们现在像我用这个

786
00:55:25,110 --> 00:55:30,610
这两个阶段都是能够很方便快捷的去完成

787
00:55:31,110 --> 00:55:33,330
那我们这里面可能体会了更多的

788
00:55:33,330 --> 00:55:34,830
就是你们在理解的时候

789
00:55:34,830 --> 00:55:38,770
运行的时候它会有更多的这种支持

790
00:55:38,770 --> 00:55:43,850
但其实我们的超级统也在我们的开发过程中

791
00:55:43,850 --> 00:55:44,750
比如说我们的编译

792
00:55:44,750 --> 00:55:47,730
编译器它和OS有一个协议

793
00:55:47,730 --> 00:55:51,350
能够让我们的编译器能够更便捷的去编译

794
00:55:51,350 --> 00:55:55,350
生成我们的高级员的执行码

795
00:55:55,350 --> 00:55:56,950
这实际上是开发

796
00:55:58,330 --> 00:56:01,850
那么另一方面它这是向上

797
00:56:01,850 --> 00:56:03,330
看着它是对应用有支持的

798
00:56:03,330 --> 00:56:05,430
向下是管理硬件

799
00:56:06,290 --> 00:56:08,570
管理业的目的其实也是为了说

800
00:56:08,570 --> 00:56:10,090
我们要更好地去支持应用

801
00:56:10,090 --> 00:56:11,730
因为只有把硬件管好之后

802
00:56:11,730 --> 00:56:13,290
你才能够去更好的支持应用

803
00:56:13,290 --> 00:56:15,990
这硬件包含了应用不愿意去管

804
00:56:15,990 --> 00:56:17,530
或者应用觉得很麻烦的一些东西

805
00:56:17,530 --> 00:56:19,310
比如说你的应用

806
00:56:19,310 --> 00:56:21,930
你本来是要显示一个图片

807
00:56:21,930 --> 00:56:23,350
你本来就调一个函数

808
00:56:23,350 --> 00:56:26,270
把那个图片的文件名给列出来

809
00:56:26,270 --> 00:56:27,090
调一个秀

810
00:56:27,090 --> 00:56:28,150
也就展示出来了

811
00:56:28,150 --> 00:56:29,430
Python就这么做

812
00:56:30,330 --> 00:56:31,930
但是这个显示图片

813
00:56:31,930 --> 00:56:34,230
其实涉及到了对显卡

814
00:56:34,230 --> 00:56:37,170
对文件的一系列的处理过程

815
00:56:37,170 --> 00:56:38,230
而这些过程

816
00:56:38,230 --> 00:56:39,610
底下的繁琐的工作

817
00:56:39,610 --> 00:56:41,450
都是OS帮我们做

818
00:56:42,270 --> 00:56:45,450
所以你必须要通过OS的硬件管理

819
00:56:45,450 --> 00:56:46,450
给上层提供

820
00:56:46,450 --> 00:56:48,270
才能给上面提供一个

821
00:56:48,270 --> 00:56:51,870
更加便捷的一个管理的一个界面

822
00:56:51,870 --> 00:56:54,270
这一块虽然我们说的Io这一块

823
00:56:54,270 --> 00:56:57,370
就是所谓的Io设备管理

824
00:56:57,370 --> 00:56:58,510
这个Io除了设备管理之外

825
00:56:58,510 --> 00:57:00,110
还包括一类不是Io的

826
00:57:00,110 --> 00:57:01,650
比如说我们的CPU我们的Memory

827
00:57:01,650 --> 00:57:03,710
这一块的硬件资源也需要去管理

828
00:57:04,910 --> 00:57:06,110
管好这些资源之后

829
00:57:06,110 --> 00:57:08,550
我们就能够去支持我们应用了

830
00:57:08,550 --> 00:57:09,510
但光支持还不够

831
00:57:09,510 --> 00:57:10,570
我们还要去协调

832
00:57:10,570 --> 00:57:11,890
什么叫协调呢

833
00:57:11,890 --> 00:57:13,810
你要控制程序的运行

834
00:57:13,810 --> 00:57:14,750
这里面是控制

835
00:57:15,670 --> 00:57:17,530
因为程序我们有个假设

836
00:57:17,530 --> 00:57:22,590
程序是不假定它是一个友善的一个软件

837
00:57:22,590 --> 00:57:25,050
它可能是一个恶意的软件

838
00:57:25,050 --> 00:57:26,650
或者是一个比较贪婪的软件

839
00:57:28,150 --> 00:57:30,750
如果几个程序都在这里面跑的话

840
00:57:30,750 --> 00:57:34,510
我们OS有这个义务去让其他的OS

841
00:57:34,510 --> 00:57:37,050
不受这种恶意或者贪婪软件的影响

842
00:57:37,050 --> 00:57:38,270
所以要去控制它

843
00:57:38,270 --> 00:57:41,070
使得大家能够比较公平的去使用

844
00:57:41,070 --> 00:57:42,630
那个资源或者高效能使用资源

845
00:57:42,630 --> 00:57:43,370
这是一块

846
00:57:44,630 --> 00:57:46,970
这个改善人机界面为什么强调这一点

847
00:57:46,970 --> 00:57:52,550
是在于我们的OS其实现在越来越和人形界面关系越来越大

848
00:57:52,550 --> 00:57:56,450
早期我们看到早期其实我们都不需要有界面

849
00:57:56,450 --> 00:57:58,190
连键盘鼠标都不需要

850
00:57:58,190 --> 00:58:00,390
就可以使用计算机了

851
00:58:00,390 --> 00:58:01,750
然后有了键盘

852
00:58:01,750 --> 00:58:03,470
然后再有了显示器

853
00:58:03,470 --> 00:58:04,950
有了鼠标

854
00:58:04,950 --> 00:58:06,490
有了图形界面

855
00:58:06,490 --> 00:58:11,710
再然后你会发现键盘鼠标也不一定那么好使了

856
00:58:11,710 --> 00:58:13,430
所以我们还可以用笔

857
00:58:13,910 --> 00:58:16,710
再然后你可以用声音等等

858
00:58:16,710 --> 00:58:18,750
你可以用手势来控制

859
00:58:18,750 --> 00:58:20,230
这都是人机界面

860
00:58:20,230 --> 00:58:23,770
这个界面使得我们的超级统

861
00:58:23,770 --> 00:58:25,970
能够去支持更广泛的应用

862
00:58:25,970 --> 00:58:28,770
这实际上就是超级统的一个

863
00:58:28,770 --> 00:58:32,670
我理解是站在一个使用管理的角度

864
00:58:32,670 --> 00:58:35,030
来考虑超级统的一个定义

865
00:58:35,030 --> 00:58:36,730
它不是一个很精确定义

866
00:58:36,730 --> 00:58:38,010
既然这么来定义的话

867
00:58:38,010 --> 00:58:40,090
所以我们这就可以理解了

868
00:58:40,090 --> 00:58:42,090
为什么 我们说

869
00:58:43,490 --> 00:58:44,230
怎么说呢

870
00:58:44,230 --> 00:58:47,090
就是说 你看这里面我们列超级统的这一块

871
00:58:47,710 --> 00:58:49,090
在这一块

872
00:58:49,970 --> 00:58:52,090
其实现在的很多的

873
00:58:52,790 --> 00:58:55,530
号称超级统的那些软件

874
00:58:55,530 --> 00:58:58,510
它是把上面这一块也叫超级统

875
00:58:58,510 --> 00:59:00,990
甚至把再往上掏

876
00:59:00,990 --> 00:59:03,350
这一块也叫超级统

877
00:59:03,790 --> 00:59:05,090
举个例子

878
00:59:05,950 --> 00:59:07,510
我们上课讲超级统

879
00:59:07,510 --> 00:59:09,830
我们正面在讲OS讲什么

880
00:59:09,830 --> 00:59:12,490
我们讲OS的不得不去把它限制

881
00:59:12,490 --> 00:59:14,810
它这个范围更加精确的OS kernel

882
00:59:14,810 --> 00:59:17,230
OS kernel主要是运行在特权级

883
00:59:17,230 --> 00:59:18,630
这个硬件特权级

884
00:59:18,630 --> 00:59:20,850
这个指令级下的一些软件

885
00:59:20,850 --> 00:59:22,170
这个OS kernel

886
00:59:22,170 --> 00:59:23,590
但其实我们也看到

887
00:59:23,590 --> 00:59:25,590
我们说Windows

888
00:59:25,590 --> 00:59:27,790
Windows也是Windows超级桶

889
00:59:27,790 --> 00:59:29,770
单用手机安卓超级桶

890
00:59:29,770 --> 00:59:33,110
那它这个Windows和安卓超级桶的定义里面

891
00:59:33,110 --> 00:59:34,090
其实有细分

892
00:59:34,090 --> 00:59:35,930
它有一层叫系统软件

893
00:59:35,930 --> 00:59:37,290
系统应用这一层

894
00:59:37,290 --> 00:59:42,030
这一层软件 比如说 我们会把Windows的Browser

895
00:59:42,030 --> 00:59:44,710
就这个Browser认为是超级系统的一部分

896
00:59:45,330 --> 00:59:54,270
对于安卓来说 我会把安卓的图形界面Framework认为是它的一部分

897
00:59:54,270 --> 00:59:57,250
而那一部分其实都不在我们说的传统

898
00:59:57,250 --> 00:59:59,890
我们现在讲的这个OS kernel里面的

899
00:59:59,890 --> 01:00:02,050
因为有很明确的一个界限是在哪呢

900
01:00:02,050 --> 01:00:05,050
就是那些都是运行在用户台的

901
01:00:05,050 --> 01:00:07,890
而我们现在讲的OS kernel更多运行在内核碳

902
01:00:08,910 --> 01:00:10,510
所以内核碳比较好界定什么呢

903
01:00:10,510 --> 01:00:11,710
就跑在这个特权级

904
01:00:11,710 --> 01:00:12,970
就大家都学RES5

905
01:00:12,970 --> 01:00:15,750
他们知道在特权级模式下运行的那个软件

906
01:00:15,750 --> 01:00:18,010
那就是以定义为一个超级统

907
01:00:18,010 --> 01:00:19,990
这是很直白的一个定义

908
01:00:19,990 --> 01:00:21,770
至上就不是超级统

909
01:00:21,770 --> 01:00:22,410
那是什么呢

910
01:00:22,410 --> 01:00:23,450
我们可以称之为系统软件

911
01:00:23,450 --> 01:00:24,750
前面讲的系统应用系统软件

912
01:00:24,750 --> 01:00:25,690
用这个来定义

913
01:00:25,690 --> 01:00:27,250
但是现在呢

914
01:00:28,010 --> 01:00:30,130
我们看到很多的软件

915
01:00:30,130 --> 01:00:31,570
它把它定义为所谓的超级统

916
01:00:31,570 --> 01:00:34,390
其实是把这个给它做了一个犯化

917
01:00:34,990 --> 01:00:39,230
就是它把超级统的界面也认为是超级统的一个重要组成部分

918
01:00:39,670 --> 01:00:41,170
这个界面就可以放得非常大

919
01:00:41,170 --> 01:00:43,230
所以我们看到现在安卓也有超级统

920
01:00:45,310 --> 01:00:47,950
还有什么比如说iOS都是超级统

921
01:00:49,510 --> 01:00:51,310
其实它你要再区分的话

922
01:00:51,310 --> 01:00:53,430
其实我们重点care的黄色那一部分

923
01:00:53,430 --> 01:00:55,170
就是说kernel这一部分

924
01:00:55,170 --> 01:00:58,490
这是我们这门课重点要去讲解的内容

925
01:01:19,650 --> 01:01:22,970
好 那我们再从不同的维度理解这个OS

926
01:01:23,290 --> 01:01:25,310
这个就相当于把这个OS进一步去细化

927
01:01:25,310 --> 01:01:27,730
我们现在说的OS是一个kernel

928
01:01:28,370 --> 01:01:29,790
再确认一下 我们说是kernel

929
01:01:29,790 --> 01:01:32,390
就运行在特运行模式下的一个软件

930
01:01:32,390 --> 01:01:34,210
这个软件它可以干什么呢

931
01:02:04,470 --> 01:02:09,250
怎么去解决通货物资问题,怎么去管理内存,怎么去分配CPU的时间。

932
01:02:09,950 --> 01:02:14,750
这些是站在资源管理角度来考虑问题的,这是我们进一步去细化。

933
01:02:15,010 --> 01:02:21,510
这里面要强调公平效率,甚至是针对特定应用的一些支持等等,

934
01:02:21,730 --> 01:02:25,290
这都是资源管理里面需要去应对不同问题,

935
01:02:25,670 --> 01:02:28,990
所以你就要去设计各种各样的一些策略和机制,

936
01:02:28,990 --> 01:02:31,290
来确保在这个计算机系统里面

937
01:02:31,290 --> 01:02:34,470
跑的各种各样的应用能够都能够得到一个很好的满足

938
01:02:36,250 --> 01:02:37,910
好 那我们再看看这个

939
01:02:40,530 --> 01:02:41,630
这个字写错了

940
01:02:42,570 --> 01:02:46,150
超市系统中的软件分类 少了一个软字

941
01:02:48,490 --> 01:02:50,410
那软件分类从上往下分

942
01:02:50,410 --> 01:02:52,570
软件分成两类 应用软件系统软件

943
01:02:52,570 --> 01:02:54,590
我们前面已经说了超市系统软件

944
01:02:54,590 --> 01:02:56,970
它是用来支持应用软件的

945
01:02:56,970 --> 01:02:58,550
那么系统软件里面又分系统应用和

946
01:02:59,250 --> 01:03:00,550
那什么叫系统应用呢

947
01:03:01,170 --> 01:03:03,590
我们可以简单的把我们上一期讲的那个编译

948
01:03:03,590 --> 01:03:05,150
编译就是一个典型的系统应用

949
01:03:05,150 --> 01:03:07,110
它要支持对各种程序的编译

950
01:03:07,110 --> 01:03:10,330
这是属于一个系统类的应用

951
01:03:11,650 --> 01:03:12,950
但还有什么是系统类的应用

952
01:03:12,950 --> 01:03:14,670
大家能想到吗

953
01:03:14,670 --> 01:03:19,010
系统应用也是要用得比较广泛的

954
01:03:19,010 --> 01:03:21,470
现在我觉得已经有一个软件

955
01:03:21,470 --> 01:03:22,670
已经可以升级为系统应用

956
01:03:22,670 --> 01:03:24,170
比如说我们的Browser

957
01:03:24,170 --> 01:03:26,550
Browser就是基本上是

958
01:03:30,890 --> 01:03:35,290
所以这种软件 大家都会用的软件 那就是一个系统应用

959
01:03:35,290 --> 01:03:40,170
我想再问一下手机安卓系统里面

960
01:03:40,170 --> 01:03:44,350
安卓超市系统里面 它的系统应用有哪个

961
01:03:46,870 --> 01:03:48,810
系统应用

962
01:03:48,810 --> 01:03:50,210
设置

963
01:03:50,210 --> 01:03:52,510
设置系统应用 没错

964
01:03:52,510 --> 01:03:54,190
这个Windows也是一样

965
01:03:54,190 --> 01:03:56,530
我想说的是一个Windows里面的系统应用

966
01:05:26,530 --> 01:05:30,290
微信已经逐渐从系统应用变成了超级系统

967
01:05:30,290 --> 01:05:31,130
大家不要笑

968
01:05:31,130 --> 01:05:33,510
也许过几年人会发现微信就是一个超级

969
01:05:34,050 --> 01:05:34,930
为什么这么说呢

970
01:05:34,930 --> 01:05:36,450
我们已经看了一个类似的例子

971
01:05:37,030 --> 01:05:38,070
什么例子

972
01:05:38,070 --> 01:05:38,830
谷歌

973
01:05:38,830 --> 01:05:41,070
谷歌为什么谷歌我说谁谷歌呢

974
01:05:41,070 --> 01:05:44,170
谷歌他在这公司内部他做了好几个OS

975
01:05:44,170 --> 01:05:46,530
安卓只差其中一个OS而已

976
01:05:46,530 --> 01:05:47,710
还有一个OS叫什么

977
01:05:47,710 --> 01:05:48,630
叫ChromeOS

978
01:05:48,630 --> 01:05:49,950
大家都听过ChromeOS

979
01:05:49,950 --> 01:05:53,710
ChromeOS里面它的界面就是Browser

980
01:05:53,710 --> 01:05:55,990
那个browser 你只要装这个ChromeOS

981
01:05:55,990 --> 01:05:57,970
你的browser是自带的 必须要有的

982
01:05:57,970 --> 01:05:59,150
如果没有这个browser

983
01:05:59,150 --> 01:06:00,790
你这个ChromeOS就不存在了

984
01:06:00,790 --> 01:06:03,850
因为它没有交互的界面了

985
01:06:03,850 --> 01:06:07,610
你想 如果再倒退十年

986
01:06:07,610 --> 01:06:09,410
你觉得browser是个必须的东西吗

987
01:06:10,170 --> 01:06:11,290
不是 是吧

988
01:06:11,290 --> 01:06:14,430
但现在 这说明什么 超级统计也在变化

989
01:06:14,430 --> 01:06:17,410
虽然你的定义好像看起来没变

990
01:06:17,410 --> 01:06:21,610
但其实它的这个形式状态内容一直在变化

991
01:06:22,410 --> 01:06:24,310
Chrome OS就是一个典型的例子

992
01:06:24,310 --> 01:06:27,750
我们早期比如说刚开始70年代讲OS的时候

993
01:06:27,750 --> 01:06:28,770
那有个线就OK了

994
01:06:28,770 --> 01:06:30,950
根本还不知道网络为何物的时候

995
01:06:30,950 --> 01:06:31,870
哪有Browser的事

996
01:06:31,870 --> 01:06:33,530
但现在Browser已经成为

997
01:06:33,530 --> 01:06:35,850
OS里面的一个不可或缺的一部分

998
01:06:36,310 --> 01:06:38,150
所以我们说

999
01:06:38,150 --> 01:06:39,910
这个超系统其实

1000
01:06:39,910 --> 01:06:41,770
我们那边给出来的所谓的命令行

1001
01:06:41,770 --> 01:06:43,390
GUI只是一方面

1002
01:06:43,390 --> 01:06:45,510
下次可能就NUI了

1003
01:06:45,510 --> 01:06:47,450
Network的一个user interface

1004
01:06:48,070 --> 01:06:50,110
这是我们看到的一个趋势

1005
01:06:54,770 --> 01:06:59,110
这里面我们只给了两类Share命令行方式

1006
01:06:59,110 --> 01:07:01,010
第二类GUI图形方式

1007
01:07:01,010 --> 01:07:06,710
这是OS暴露给应用的一个Share界面

1008
01:07:07,170 --> 01:07:09,550
还有其他的模式吗

1009
01:07:09,550 --> 01:07:11,070
前面我已经提到有一个Browser

1010
01:07:11,070 --> 01:07:14,490
Browser某种程度上是GUI的一个升级版本

1011
01:07:14,490 --> 01:07:16,910
它更把网络放在很重要的一位

1012
01:07:18,230 --> 01:07:20,050
再进一步发展还有什么

1013
01:08:20,050 --> 01:08:21,290
是一种新的一种界面

1014
01:08:23,030 --> 01:08:24,910
那么你看这些界面好像就跟人打交道

1015
01:08:24,910 --> 01:08:27,110
其实还有一些界面是跟人不打交道

1016
01:08:27,110 --> 01:08:28,710
就是它不是面向人的

1017
01:08:28,710 --> 01:08:29,290
那有OS

1018
01:08:29,290 --> 01:08:32,930
有很多OS它根本就不是需要一个跟人打交道的界面

1019
01:08:32,930 --> 01:08:36,190
比如说我们的物联网系统或者AIOT系统里面

1020
01:08:37,190 --> 01:08:39,250
那灯上面安了一个什么摄像头

1021
01:08:40,230 --> 01:08:41,270
那它的界面是啥

1022
01:08:41,270 --> 01:08:42,730
它比较跑了硬程序

1023
01:08:42,730 --> 01:08:48,890
那里面其实只要关注的只是一个数据的采集和传输

1024
01:08:48,890 --> 01:08:50,850
这就是他OS要提供的一个接口

1025
01:08:50,850 --> 01:08:51,950
只要提供这个接口

1026
01:08:51,950 --> 01:08:54,290
那个应用程序只干这一个事情就够了

1027
01:08:54,290 --> 01:08:55,950
他完全不需要去什么Coreline

1028
01:08:56,550 --> 01:08:58,390
什么GUI系统来支持

1029
01:08:58,390 --> 01:09:00,490
所以你会发现

1030
01:09:00,970 --> 01:09:04,150
这为什么有这么多种不同的接口

1031
01:09:04,150 --> 01:09:06,150
是在于我们的应用的需求

1032
01:09:06,150 --> 01:09:08,690
所以我们OS要抓住一点不变的什么

1033
01:09:09,090 --> 01:09:10,950
它的不变就是对应用的支持

1034
01:09:10,950 --> 01:09:12,550
这是不变的

1035
01:09:12,550 --> 01:09:15,230
如果一个软件说它不对应用有支持

1036
01:09:15,230 --> 01:09:17,170
那我很明确的知道它不是超级统

1037
01:09:19,230 --> 01:09:23,390
如果一个超一统说我要对支持一类应用

1038
01:09:23,390 --> 01:09:25,070
甚至是一小部分应用

1039
01:09:25,070 --> 01:09:26,470
那它都是一个OS

1040
01:09:27,550 --> 01:09:32,290
这需要大家去要对这个OS的这个要进一步去理解

1041
01:09:34,530 --> 01:09:38,490
好 那我们讲讲我们这个教学OS

1042
01:09:38,490 --> 01:09:41,950
教学OS其实是一个类Unix的OS

1043
01:09:42,510 --> 01:09:43,330
非常小

1044
01:09:43,330 --> 01:09:46,250
最早是参考了MIT的XV6

1045
01:09:46,250 --> 01:09:47,630
然后发展了几年之后

1046
01:09:47,630 --> 01:09:50,010
从mute call变成了r call

1047
01:09:50,010 --> 01:09:52,470
然后现在用z call、a call、e call

1048
01:09:53,010 --> 01:09:54,690
就是大家看到各种各样的call

1049
01:09:55,130 --> 01:09:56,210
但是本身上来说

1050
01:09:56,210 --> 01:10:00,110
我们教学用的是一个还是比较传统的

1051
01:10:00,110 --> 01:10:02,990
它是一个unix的单体内核的一个OS

1052
01:10:02,990 --> 01:10:05,250
在这里面会涉及到我们

1053
01:10:05,250 --> 01:10:09,450
当然讲到的所有的关键的知识点

1054
01:10:09,450 --> 01:10:10,630
但是有一些知识点

1055
01:10:10,630 --> 01:10:12,510
可能在我们的code中没有实现

1056
01:10:12,510 --> 01:10:14,730
等待着有些同学去把它实现

1057
01:10:18,510 --> 01:10:23,770
这里面需要关注两点,一个是你看这里面对应的前面说对应用的支持,这当然

1058
01:10:23,770 --> 01:10:27,650
体现了,如果在Coding这个level,不是在使用这个level,在Coding这个level体现的话,就看到

1059
01:10:27,650 --> 01:10:33,470
一个系统调用接口,这就是对应用的支持,它有提供各样的,你可以认为类

1060
01:10:33,470 --> 01:10:37,650
比于函数接口,它只是叫系统调用接口而已,有了这个支持之后,你上面可以

1061
01:10:37,650 --> 01:10:42,750
搭建share,搭建命令行程序,它会跑到用户台,它会通过这个系统

1062
01:10:42,750 --> 01:10:44,710
调用得到这个操纵的服务,包括

1063
01:10:45,170 --> 01:10:48,210
进程 内存 文件系统 等等

1064
01:10:48,210 --> 01:10:49,710
向下它还有一层

1065
01:10:50,490 --> 01:10:52,950
这是我们说向下管理硬件资源

1066
01:10:52,950 --> 01:10:54,050
它有一个硬件抽象层

1067
01:10:54,050 --> 01:10:55,590
这里面有各种各样的资源

1068
01:10:55,590 --> 01:10:58,070
我这里面只是列出来一小部分

1069
01:10:58,070 --> 01:11:00,110
我们会涉及到的

1070
01:11:00,110 --> 01:11:02,970
主要是时钟 创口

1071
01:11:03,410 --> 01:11:04,890
还有一个存储 一个block

1072
01:11:04,890 --> 01:11:06,450
这个block设备可能是一个磁盘

1073
01:11:07,570 --> 01:11:08,710
我们这里面

1074
01:11:09,410 --> 01:11:11,150
最简单的情况是涉及到三种

1075
01:11:11,150 --> 01:11:13,090
它分别应对三种不同的情况

1076
01:11:14,170 --> 01:11:15,510
你必须要通过这种商用情况

1077
01:11:15,510 --> 01:11:17,190
才能够更好的开发程序

1078
01:11:17,190 --> 01:11:18,690
调制程序和运营程序

1079
01:11:21,270 --> 01:11:22,130
我们再看一下

1080
01:11:22,870 --> 01:11:25,110
就是想在进一步去建立

1081
01:11:25,110 --> 01:11:27,190
超级系统和组成原理之间的关系

1082
01:11:27,190 --> 01:11:28,890
把这个关系给拉好一点

1083
01:11:28,890 --> 01:11:32,750
我们OS其实很和组成原理

1084
01:11:32,750 --> 01:11:34,010
是一个紧偶合的关系

1085
01:11:34,010 --> 01:11:35,790
其实某种程度来说是紧偶合

1086
01:11:35,790 --> 01:11:39,310
每次我们有一些系统内的一些

1087
01:11:39,310 --> 01:11:41,250
课程的老师在一块讨论的时候

1088
01:11:42,010 --> 01:11:45,090
吵架基本上是主持人原理和曹九蒙老师

1089
01:11:45,090 --> 01:11:47,850
他们之间会有一些观点不一样

1090
01:11:47,850 --> 01:11:50,850
导致康总特别愿意跟我们吵架

1091
01:11:52,830 --> 01:11:54,510
他跟其他老师都特别友善

1092
01:11:54,510 --> 01:11:59,970
对曹九蒙老师都比较感兴趣去申认一些问题

1093
01:11:59,970 --> 01:12:00,850
为什么呢

1094
01:12:01,490 --> 01:12:05,550
因为站在处理器的角度考虑问题和站在OS的角度

1095
01:12:05,550 --> 01:12:07,710
考虑问题是不一样的

1096
01:12:07,710 --> 01:12:09,250
比如你们学主持人原理之后

1097
01:12:39,930 --> 01:12:42,090
这是我们组成员里面要考虑的问题

1098
01:12:42,090 --> 01:12:46,830
它和我们的编译课讲的程序是比较对应的

1099
01:12:46,830 --> 01:12:47,830
我们要做一个计算

1100
01:12:47,830 --> 01:12:49,990
基本上也是过程取一个辨量做计算

1101
01:12:49,990 --> 01:12:52,690
然后把辨量再存在某个地方

1102
01:12:52,690 --> 01:12:53,870
这是一种思维

1103
01:12:53,870 --> 01:12:57,510
但是我们讲的是需要把CPU重新考虑

1104
01:12:57,510 --> 01:13:00,130
我们把CPU抽象成一个进程

1105
01:13:00,130 --> 01:13:01,350
什么叫进程呢

1106
01:13:01,350 --> 01:13:03,330
在这里面这个头像是想说

1107
01:13:03,330 --> 01:13:06,610
CPU其实我们需要把它划分成不同时间段

1108
01:13:06,610 --> 01:13:10,030
来共享使用这个CPU

1109
01:13:10,550 --> 01:13:13,010
是站在一个管理的角度来考虑问题的

1110
01:13:13,010 --> 01:13:15,070
不是站在一个它的执行的角度

1111
01:13:15,070 --> 01:13:15,710
管理什么意思呢

1112
01:13:15,710 --> 01:13:20,410
就是要管理不同的不同的程序

1113
01:13:20,410 --> 01:13:25,190
分时或者是基于一定的规则来使用这个处理器

1114
01:13:27,290 --> 01:13:29,510
所以管理角度我们才理解这个CPU的时候

1115
01:13:29,510 --> 01:13:31,630
我们把它操作出一个概念叫进程

1116
01:13:32,210 --> 01:13:40,450
第二个磁盘,磁盘在组成原理和超级勇克里面讲的都比较弱

1117
01:13:40,810 --> 01:13:43,730
但大致的你可以认为它是一种存储的设备

1118
01:13:43,730 --> 01:13:48,590
它就是我们说的可以把数据完整的存到这个长久的存在

1119
01:13:48,590 --> 01:13:50,410
保存在我们这个磁盘中

1120
01:13:50,410 --> 01:13:52,490
它这种特殊的介质和我们的memory不一样

1121
01:13:52,490 --> 01:13:55,650
这也是存,这个存,这个storage是memory,不一样

1122
01:13:55,650 --> 01:13:59,690
这就是类似于memory是什么,短期记忆

1123
01:13:59,690 --> 01:14:03,190
磁盘是长期记忆 只要磁盘不坏它一直存着

1124
01:14:03,190 --> 01:14:06,510
但内存一掉电 数据就丢了

1125
01:14:06,990 --> 01:14:09,430
所以你需要把这里面的数据 都是数据

1126
01:14:09,430 --> 01:14:11,970
要把这里面的数据能够有效地从磁盘

1127
01:14:11,970 --> 01:14:14,570
夺到内存里面 也要从内存存到磁盘里面去

1128
01:14:14,570 --> 01:14:15,550
要完成这个事情

1129
01:14:15,550 --> 01:14:18,290
我们不得不去建立一个新的图像叫文件

1130
01:14:20,190 --> 01:14:22,710
因为我们对磁盘的访问

1131
01:14:23,110 --> 01:14:24,990
不可能像这个就对内存访问一样

1132
01:14:24,990 --> 01:14:27,750
是按字节来访问的 当便捷的访问

1133
01:14:27,750 --> 01:14:30,750
它是一个一个的所谓的扇区来进行处理的

1134
01:14:30,750 --> 01:14:33,290
所以我不得不采用出所谓的文件的概念

1135
01:14:34,330 --> 01:14:35,690
来打开一个文件

1136
01:14:36,030 --> 01:14:37,550
你可以以为做对应器的话

1137
01:14:37,550 --> 01:14:39,130
这个文件类似于一些内存框

1138
01:14:39,130 --> 01:14:40,830
然后在内存框里面对它进行读写

1139
01:14:40,830 --> 01:14:42,690
实际上就是最终会通过我们的超级桶

1140
01:14:42,690 --> 01:14:44,830
把这个文件写回到我们的磁盘里面去

1141
01:14:44,830 --> 01:14:46,370
这个是要去考虑的问题

1142
01:14:46,370 --> 01:14:49,770
这个在组成员里面其实几乎不用考虑

1143
01:14:49,770 --> 01:14:51,610
因为重点在CPU这一块

1144
01:14:51,610 --> 01:14:53,830
但下一个内存里面是要考虑的

1145
01:14:53,830 --> 01:14:55,350
内存就涉及到我们的另外一个

1146
01:14:55,350 --> 01:14:56,270
说一下地址空间

1147
01:14:56,270 --> 01:14:57,210
为什么要地址空间呢

1148
01:14:57,210 --> 01:15:01,190
因为大家在学组成原理的时候

1149
01:15:01,190 --> 01:15:04,330
你考虑的是整个这个计算机是跑一个程序

1150
01:15:06,250 --> 01:15:09,570
所以所有的memory都是给这一个程序服务的

1151
01:15:09,570 --> 01:15:11,230
这个memory有多少

1152
01:15:11,230 --> 01:15:14,190
比如说有一个8兆

1153
01:15:14,190 --> 01:15:16,950
但是8兆的空间都是给你的程序用的

1154
01:15:16,950 --> 01:15:18,330
你的程序箱子没有怎么用

1155
01:15:18,790 --> 01:15:20,690
但是你只能用8兆

1156
01:15:20,690 --> 01:15:22,330
对于我们OS而言

1157
01:15:22,330 --> 01:15:26,590
我们需要把这个问题给它进一步的简化和增强

1158
01:15:26,590 --> 01:15:31,350
什么意思 八兆内存 我可以跑两个程序

1159
01:15:31,350 --> 01:15:36,610
这两个程序可以让他们的地址空间隔开 相互之间不打架

1160
01:15:37,190 --> 01:15:41,730
这个咱们在做组成员的时候不用考虑 这是管理的事情

1161
01:15:41,730 --> 01:15:48,170
第二个 我可以让每一个程序认为自己独占了一块空间

1162
01:15:48,170 --> 01:15:52,870
这空间可能还不止八兆 让它认为它是有一个4个G的空间

1163
01:15:52,870 --> 01:15:55,810
如果你们32位的处理器Risk5的话

1164
01:15:55,810 --> 01:15:58,070
那其实它地址群的空间是2的32

1165
01:15:58,070 --> 01:15:58,870
是4个G

1166
01:15:58,870 --> 01:16:00,330
它可以有4个G的空间

1167
01:16:01,410 --> 01:16:03,050
即使它物理上只有8兆

1168
01:16:03,050 --> 01:16:06,330
等于把你这个空间给虚拟的放大了

1169
01:16:06,330 --> 01:16:07,850
那这个就是我们说地址空间

1170
01:16:07,850 --> 01:16:09,910
超级统要建立一个地址空间这么一个概念

1171
01:16:10,430 --> 01:16:13,810
来帮助我们的应用软件更方便的去执行

1172
01:16:13,810 --> 01:16:15,710
它不用考虑内存不够用的情况

1173
01:16:16,150 --> 01:16:17,090
超级统八管

1174
01:16:17,090 --> 01:16:22,190
这就是我们说超级统的内核三个重要的抽象

1175
01:16:53,070 --> 01:16:54,710
你只有去实验出来之后

1176
01:16:54,710 --> 01:16:56,350
所谓的实验就是说你要去做实验

1177
01:16:56,350 --> 01:16:58,410
你要去能够理解实验看代码

1178
01:16:58,410 --> 01:17:00,590
把这个OS的实现搞明白

1179
01:17:00,590 --> 01:17:02,490
你知道这个OS实验搞明白之后

1180
01:17:02,490 --> 01:17:05,190
那么你就知道这个字面上的文件

1181
01:17:05,950 --> 01:17:07,790
在代码里面对应的哪一块

1182
01:17:07,790 --> 01:17:10,610
地址空间是代码里面什么样的数理结构

1183
01:17:10,610 --> 01:17:11,550
和什么样的控制逻辑

1184
01:17:11,550 --> 01:17:13,130
你来完成地址空间的管理

1185
01:17:13,130 --> 01:17:16,210
能够提供我刚才说到的一个非常大的空间

1186
01:17:16,830 --> 01:17:18,190
进程怎么能够

1187
01:17:19,730 --> 01:17:24,530
把这个CPU处理器和IOS设备都给管理起来

1188
01:17:24,530 --> 01:17:26,290
这个进程的概念实际上就是

1189
01:17:26,290 --> 01:17:30,210
我们希望让应用程序以进程的方式来运行

1190
01:17:30,210 --> 01:17:34,910
然后我们的超系统给这个整个应用程序提供了一个虚拟的一个环境

1191
01:17:34,910 --> 01:17:38,190
像这个应用程序使用了整个完整的一个CPU一样

1192
01:17:38,190 --> 01:17:40,770
这一层就是一层层的抽象 一层层的虚拟化

1193
01:17:40,770 --> 01:17:43,990
从而让我们应用程序非常方便的运行

1194
01:17:44,790 --> 01:17:48,370
当然这个方便是有代价的

1195
01:17:48,370 --> 01:17:49,970
这个代价是你有限制

1196
01:17:49,970 --> 01:17:52,630
就是比如说我们给这个超级统

1197
01:17:52,630 --> 01:17:55,410
给这个应用程序分配了一块空间

1198
01:17:56,110 --> 01:17:59,450
比如说分配了一个8兆的内存

1199
01:17:59,450 --> 01:18:02,990
我给它分配了一个1G的一个虚拟的空间

1200
01:18:02,990 --> 01:18:05,290
那它不能访问超过1G的内存

1201
01:18:05,290 --> 01:18:07,990
就它有限制的一个方便运行

1202
01:18:07,990 --> 01:18:08,890
这一点需要注意

1203
01:18:08,890 --> 01:18:10,390
包括处理器也是一样

1204
01:18:10,390 --> 01:18:13,810
我并不是给它百分之百的CPU的处理时间

1205
01:18:13,810 --> 01:18:17,550
可能在一分钟里面我给它分配了10秒 给它用

1206
01:18:17,550 --> 01:18:20,730
因为还剩下的50秒要给其他的应用程序去用

1207
01:18:20,730 --> 01:18:22,150
这就是一些限制

1208
01:18:22,670 --> 01:18:25,450
所以它是一种有限的方便

1209
01:18:26,750 --> 01:18:28,050
这个大家要去理解

1210
01:18:29,390 --> 01:18:31,650
不是无限的方便 是有限的方便

1211
01:18:33,670 --> 01:18:37,070
好 由于我们的OS要去正确支持我们的应用

1212
01:18:37,070 --> 01:18:40,590
使得我们OS整个在基础系统没运行的时候

1213
01:18:40,590 --> 01:18:41,890
和我们应用程序在运行的时候

1214
01:18:41,890 --> 01:18:44,170
就发现有一些特点

1215
01:18:44,170 --> 01:18:49,890
这些特点也是和我们的通常开发应用程序不太一样

1216
01:18:50,790 --> 01:18:55,070
这些特点现在看起来也是很直白的

1217
01:18:55,070 --> 01:18:56,950
但我希望大家能够

1218
01:18:56,950 --> 01:19:00,890
比如说我们在科后订了这个

1219
01:19:01,530 --> 01:19:02,950
应该是放在第0章

1220
01:20:02,950 --> 01:20:04,070
其实在Memory中

1221
01:20:06,030 --> 01:20:07,150
你能看到

1222
01:20:09,470 --> 01:20:12,550
你能看到这里面各种软件

1223
01:20:12,550 --> 01:20:13,750
这里面我这比较小

1224
01:20:13,750 --> 01:20:16,010
但你其实大家都可以任务管理器里面

1225
01:20:16,010 --> 01:20:18,130
这是Windows的Linux也类似的

1226
01:20:18,130 --> 01:20:19,470
就是看到各种软件

1227
01:20:19,470 --> 01:20:21,290
它占了很多的空间

1228
01:20:21,290 --> 01:20:22,170
像我这个机器

1229
01:20:22,170 --> 01:20:24,830
51%的Memory已经被物理内存被用掉

1230
01:20:24,830 --> 01:20:27,330
那它跑了上百个

1231
01:20:27,330 --> 01:20:28,810
这边是一部分上百个

1232
01:20:28,810 --> 01:20:31,470
接近1000个的各种样的service

1233
01:21:31,470 --> 01:21:33,790
CPU 我们的Io设备都是各种各样的资源

1234
01:21:34,550 --> 01:21:38,550
虚拟资源 比如说我们说文件是一种虚拟资源

1235
01:21:38,550 --> 01:21:41,710
其实它并不实实在在的 这个是一个物理设备

1236
01:21:42,310 --> 01:21:47,470
那我想问大家 程序 我把同时这个字去掉

1237
01:21:48,310 --> 01:21:49,710
不叫同时 应该叫互斥

1238
01:21:49,710 --> 01:21:52,770
互斥共享各种资源 这种互斥性的访问

1239
01:21:52,770 --> 01:21:56,630
某一个时刻只有一颗 访问这种资源有哪些

1240
01:21:56,630 --> 01:21:58,630
就拿我这台计算机来说

1241
01:22:00,470 --> 01:22:06,850
一个现场,现场是一种虚拟资源,咱们先说物理资源简单点,好理

1242
01:22:06,850 --> 01:22:08,790
解一点,现场还是很后面讲的东西。

1243
01:22:08,810 --> 01:22:14,150
物理资源,哪个是一个时刻只能允许一个程序跑,一个时间点。

1244
01:22:15,270 --> 01:22:27,530
大家想想,其实CPU就是一个,一个时刻只能有一个程序跑,那个在那儿执行。

1245
01:22:27,530 --> 01:22:28,410
你们学了组成原理

1246
01:22:29,770 --> 01:22:32,570
多核对于CPU的一个核而言

1247
01:22:32,570 --> 01:22:34,170
一个时刻是不是只有一个程序

1248
01:22:35,050 --> 01:22:35,850
这样好

1249
01:22:35,850 --> 01:22:36,250
是吧

1250
01:22:37,350 --> 01:22:37,970
没错

1251
01:22:39,190 --> 01:22:42,410
有没有说可以同时访问的

1252
01:22:43,030 --> 01:22:45,610
不用互次访问的共享资源

1253
01:22:48,210 --> 01:22:48,970
两个核

1254
01:22:50,890 --> 01:22:52,630
一个核只能是一个时刻

1255
01:22:52,630 --> 01:22:53,370
只能有一个程序

1256
01:22:53,370 --> 01:22:56,130
但两个核我可以两个程序去同时使用

1257
01:22:56,130 --> 01:22:59,530
那時候就是一個不需要互斥的共享使用 是吧

1258
01:23:00,750 --> 01:23:03,250
但是如果有三個程序要訪問兩個核怎麽辦

1259
01:23:03,770 --> 01:23:05,910
你發現問題又複雜了

1260
01:23:05,910 --> 01:23:08,650
所以你需要去了解這個互斥怎麽能夠保證

1261
01:23:09,610 --> 01:23:14,750
N個程序去訪問M資源且N大於M的情況下

1262
01:23:14,750 --> 01:23:17,110
怎麽去有效地去管理和調過這個問題

1263
01:23:17,110 --> 01:23:19,370
這個時候我們說同樣一次要去考慮這個問題

1264
01:23:20,290 --> 01:23:23,070
再看虛擬 虛擬什麽意思

1265
01:23:23,070 --> 01:23:24,590
我這又加了一個引號 獨佔

1266
01:23:25,190 --> 01:23:26,850
獨佔加引化是虛擬的意思

1267
01:23:27,490 --> 01:23:29,090
就是我寫個程序的時候

1268
01:23:29,090 --> 01:23:30,990
這個程序在運行的時候

1269
01:23:30,990 --> 01:23:32,890
你編寫其實不是在程序

1270
01:23:32,890 --> 01:23:34,090
應該在你編寫程序的時候

1271
01:23:34,090 --> 01:23:36,550
你就發覺你好像你在寫這個程序

1272
01:23:36,550 --> 01:23:39,710
應該是用了整個計算機的所有資源一樣

1273
01:23:39,710 --> 01:23:41,030
你寫個程序你可以說

1274
01:23:41,030 --> 01:23:44,700
我這個程序可以顯示可以發生可以存儲

1275
01:23:45,390 --> 01:23:47,130
那你做這一操作的時候

1276
01:23:47,130 --> 01:23:48,010
假定什麼

1277
01:23:48,010 --> 01:23:50,330
假定這個計算機都在跟你一個人在用

1278
01:23:50,330 --> 01:23:52,970
這個假定性其實是一個虛幻

1279
01:24:23,050 --> 01:24:26,290
但是它确实方便了我们在里面去运行

1280
01:24:26,950 --> 01:24:27,730
在里面运行

1281
01:24:28,730 --> 01:24:29,490
异步性

1282
01:24:30,270 --> 01:24:31,350
这个异步什么意思呢

1283
01:24:31,350 --> 01:24:35,550
异步都是由于这个并发带来的

1284
01:24:35,550 --> 01:24:38,010
其实我讲这个并发共享虚拟异步

1285
01:24:38,010 --> 01:24:42,430
都和在一个超级统里面跑多个应用相关

1286
01:24:42,430 --> 01:24:43,650
由于一个超级统跑多个应用

1287
01:24:43,650 --> 01:24:48,970
使得大家要去随时的可能会被打断执行

1288
01:24:48,970 --> 01:24:51,550
这就使得一个程序的执行时间是不确定的

1289
01:25:22,790 --> 01:25:26,510
只是这个异步,所以这个异步和大力的异步可能有所不同。

1290
01:25:28,250 --> 01:25:32,990
要不然你可以,如果再想明确点的话,就干脆把这个异步改成不确定,也行。

1291
01:25:34,010 --> 01:25:40,010
就是它这个程序什么时候执行完,不确定。这样可能会更好地理解这个事情。

1292
01:25:40,190 --> 01:25:42,490
那你能不能写一个程序来验证它?

1293
01:25:44,430 --> 01:25:50,110
你能写一个程序来验证它这个执行时间不确定的情况吗?

1294
01:25:50,110 --> 01:25:51,890
大家能不能想出写一个小程序。

1295
01:26:03,570 --> 01:26:09,090
你写一个程序,运行一下,它就能显示出它时间的这种不确定。

1296
01:26:09,390 --> 01:26:11,110
怎么写?我想用这个问题。

1297
01:26:12,170 --> 01:26:13,810
不用两个线程,再简单点。

1298
01:26:16,410 --> 01:26:18,830
不用随机数,确定点,写个print,行吗?

1299
01:26:20,830 --> 01:26:26,190
你就写一个print hello world,然后就前面加一个time,统计它的时间,你每次执行它发现

1300
01:26:26,190 --> 01:26:27,270
时间都不一样。

1301
01:26:28,730 --> 01:26:33,750
这个不是应用程序决定了它的不确定,是超级统决定了它的不确定。你

1302
01:26:33,750 --> 01:26:36,510
随便写任何一个程序,它都是不确定的。

1303
01:26:36,710 --> 01:26:38,850
OK,大家把问题不要想那么复杂。

1304
01:26:40,970 --> 01:26:45,530
我只想说你们会用一个工具 比如说一个Time

1305
01:26:45,530 --> 01:26:48,970
一个Time时间 在列宁视频叫Time 空格

1306
01:26:48,970 --> 01:26:54,190
那个应用程序的名字 一执行 超级组会帮你统计这个程序的时间

1307
01:26:54,190 --> 01:26:57,670
当结束的时候 它会统计说这个程序在应用它要花多少时间

1308
01:26:58,270 --> 01:27:04,070
在列核它要花多少时间 你会发现你如果程序时间稍微长点

1309
01:27:04,430 --> 01:27:06,910
你就会发现它每次时间是不一样

1310
01:27:06,910 --> 01:27:09,450
因为它中间职业货中央大量被打断

1311
01:27:09,450 --> 01:27:12,510
而打烂的具有一定的随机性 使它这个不确定

1312
01:27:17,770 --> 01:27:18,410
OK 好

1313
01:27:18,410 --> 01:27:20,550
怎么到这了 你对超级通道理解

1314
01:27:25,250 --> 01:27:27,990
现在来看一看

1315
01:27:28,930 --> 01:27:34,230
你如果站在应用开发者的角度

1316
01:27:34,230 --> 01:27:35,210
你的YS是什么标准

1317
01:27:39,450 --> 01:27:41,690
这里面要去写的三个

1318
01:27:41,690 --> 01:27:43,610
一个叫高效和应用

1319
01:27:43,610 --> 01:27:44,890
高效的意思是什么

1320
01:27:44,890 --> 01:27:46,310
运行的非常快

1321
01:27:46,310 --> 01:27:49,810
易用的就是非常方便使用

1322
01:27:49,810 --> 01:27:52,910
请问你们日常生活中碰到这种情况吗

1323
01:27:52,910 --> 01:27:55,870
跑得又快又特别方便的东西

1324
01:27:56,450 --> 01:27:57,910
有这样的东西存在吗

1325
01:28:03,570 --> 01:28:04,910
这个例子

1326
01:28:05,430 --> 01:28:06,310
飞机不方便

1327
01:28:06,310 --> 01:28:08,970
我们去机场那么长时间是吧

1328
01:28:08,970 --> 01:28:10,670
要走那么长时间才能去机场

1329
01:28:10,670 --> 01:28:12,070
最方便什么单车

1330
01:28:12,730 --> 01:28:13,850
你看你骑个单车

1331
01:28:13,850 --> 01:28:16,050
我就从那儿就回实验室

1332
01:28:16,050 --> 01:28:18,270
你们骑个单车就来回车到处串

1333
01:28:19,010 --> 01:28:20,270
但是方便了

1334
01:28:20,270 --> 01:28:21,150
高效吗

1335
01:28:21,150 --> 01:28:22,670
所谓高效的功能强大

1336
01:28:22,670 --> 01:28:23,330
性能强大吗

1337
01:28:23,330 --> 01:28:24,090
不强大

1338
01:28:24,090 --> 01:28:25,830
单车靠两个两个腿在蹬

1339
01:28:26,570 --> 01:28:27,910
汽车高效

1340
01:28:27,910 --> 01:28:29,310
搭别人的单车

1341
01:28:31,890 --> 01:28:33,090
搭别人的单车

1342
01:28:33,090 --> 01:28:33,910
那也慢了

1343
01:28:34,950 --> 01:28:39,010
我说的是快 车快 车为什么快

1344
01:28:39,010 --> 01:28:42,410
四个轮子 比两个轮子要快 然后用电或者用油

1345
01:28:43,030 --> 01:28:45,030
但是你能随着外面这儿开吗

1346
01:28:45,030 --> 01:28:48,550
你发现不易用 你会受各种各样的道路交通的限制

1347
01:28:48,550 --> 01:28:51,110
其他车我想串就串 但还要出于交通规则

1348
01:28:51,110 --> 01:28:53,330
就是说你串的地方可以更加easy

1349
01:28:53,330 --> 01:28:55,810
所以这就是一种生活中你自己碰到的情况

1350
01:28:56,170 --> 01:28:58,910
高效和易用是矛盾的

1351
01:28:59,470 --> 01:29:02,850
你说坐飞机 你说刚才这个同学说坐飞机快

1352
01:30:02,850 --> 01:30:04,670
你为了支持这个所谓的一行代码

1353
01:30:04,670 --> 01:30:05,790
你要做大量的事情

1354
01:30:06,570 --> 01:30:09,050
这是强大的超级种服务和简单的接口

1355
01:30:09,050 --> 01:30:09,750
这是一个问题

1356
01:30:09,750 --> 01:30:12,190
你接口简单了之后 你发生一行代码

1357
01:30:12,190 --> 01:30:14,570
你可能也只能是干一个非常简单的事情

1358
01:30:14,570 --> 01:30:18,970
你被固化 你被固定在一个函数的

1359
01:30:18,970 --> 01:30:22,230
这函数里面说你只能去支持

1360
01:30:23,250 --> 01:30:25,690
比如说某一个摄像头的一个显示

1361
01:30:25,690 --> 01:30:26,950
你换了一个摄像头 不是摄像头

1362
01:30:26,950 --> 01:30:28,850
这段视频可能就不支持了

1363
01:30:30,030 --> 01:30:32,390
你要想实现这种强大的功能

1364
01:30:32,390 --> 01:30:36,670
不得不去把几个函数用几个函数来实现

1365
01:30:36,670 --> 01:30:37,950
当你足够强大之后

1366
01:30:37,950 --> 01:30:39,370
你发现你也是一堆函数了

1367
01:30:39,370 --> 01:30:42,090
那这样你的编程接口就不简单了

1368
01:30:42,090 --> 01:30:45,670
所以你会发现和OS也是一样

1369
01:30:45,670 --> 01:30:47,690
OS可以提供非常多的接口

1370
01:30:47,690 --> 01:30:50,010
让你达到一定的灵活性和强大的功能

1371
01:30:50,010 --> 01:30:54,330
你可以把所有的底层物理硬件都控制起来

1372
01:30:54,330 --> 01:30:55,950
但是我们应用程序并不喜欢用

1373
01:30:55,950 --> 01:30:58,130
因为它太麻烦了

1374
01:30:58,130 --> 01:31:01,910
但如果你的应用程序像我刚才说的那样

1375
01:31:01,910 --> 01:31:03,550
非常简单的去完成某些事情之后

1376
01:31:03,550 --> 01:31:05,690
你就发现这个接口又不灵活了

1377
01:31:05,690 --> 01:31:07,750
所以这个简单的接口和强大的服务之间

1378
01:31:07,750 --> 01:31:09,030
是有一个平衡

1379
01:31:09,470 --> 01:31:10,310
都是一个平衡

1380
01:31:10,310 --> 01:31:11,610
高效和应用也是一个平衡

1381
01:31:11,610 --> 01:31:14,090
你要找到一个中间状态

1382
01:31:14,090 --> 01:31:16,530
既能够保证一定的强大功能

1383
01:31:16,530 --> 01:31:17,110
灵活功能

1384
01:31:17,110 --> 01:31:19,370
也要保证一个简洁的接口

1385
01:31:19,370 --> 01:31:21,310
这个其实挺不容易

1386
01:31:21,310 --> 01:31:24,570
这个是为什么我们看到所有设计OS的

1387
01:31:25,470 --> 01:31:32,270
这个OS设置OS这个人来说一般来说强调一点就是我要我要提供一个合理简

1388
01:31:32,270 --> 01:31:32,890
单的接口

1389
01:31:34,610 --> 01:31:36,330
这里面我举几个例子

1390
01:31:37,470 --> 01:31:41,490
你们或多或少都在各种场合开发过应用程序

1391
01:31:41,490 --> 01:31:47,250
你觉得哪个程序的接口是简单的

1392
01:31:47,250 --> 01:31:49,570
接口就是你可以认为函数接口

1393
01:32:00,710 --> 01:32:06,530
就是硬件 操作系统 运行时 然后是各种库

1394
01:32:06,530 --> 01:32:09,670
库上面又是一个其他的一些更高层的库

1395
01:32:09,670 --> 01:32:11,630
一层层的库在最上面还是应用

1396
01:32:11,630 --> 01:32:16,270
所以你发现对于某些应用而言

1397
01:32:16,270 --> 01:32:18,590
它比如说只支持一行代码

1398
01:32:18,590 --> 01:32:19,550
一个函数调用就可以使用

1399
01:32:49,550 --> 01:32:52,550
OS提供功能,这所谓Interface设计。

1400
01:32:55,170 --> 01:32:59,430
后面有时间给大家讲讲,比如说Windows的Interface和Linux的Interface有

1401
01:32:59,430 --> 01:33:02,490
什么样的一些相似和不一样的地方。

1402
01:33:03,970 --> 01:33:09,650
最后一个,灵活性和安全性。灵活就意味着不安全,安全意味着不灵活。

1403
01:33:10,690 --> 01:33:17,910
这是一个典型的例子,就是国内有一些,比如说我要做一个安全操作系统,手打的是

1404
01:33:17,910 --> 01:33:18,550
安全这个牌。

1405
01:33:18,550 --> 01:33:22,550
你会发现它有大量的限制使得你在开发

1406
01:33:22,550 --> 01:33:26,110
你在使用上面受到非常多的一些约束

1407
01:33:26,110 --> 01:33:30,810
但这个约束能保证你的应用词已经是安全可靠

1408
01:33:30,810 --> 01:33:32,410
不会被泄漏 信息不会泄漏

1409
01:33:32,410 --> 01:33:34,310
然后不会被别人控制

1410
01:33:35,150 --> 01:33:37,910
所以安全性是OS里面非常重要一点

1411
01:33:37,910 --> 01:33:40,070
但是我们在这里面讲的稍微少一点

1412
01:33:40,070 --> 01:33:42,210
我们更多的讲的是灵活性多一点

1413
01:33:42,210 --> 01:33:44,590
就是你要能完成各种各样的功能

1414
01:33:44,590 --> 01:33:47,730
你甚至会弱化安全性来提供所谓的灵活性

1415
01:33:48,730 --> 01:33:51,390
这都是这段时间有个平衡

1416
01:33:52,130 --> 01:33:56,530
由于我们的OS其实希望把这些条件都要满足了

1417
01:33:56,530 --> 01:34:00,450
这是OS的一个impossible mission 就是根本达不到的

1418
01:34:00,450 --> 01:34:02,090
但是它就不得不去这么去做

1419
01:34:02,090 --> 01:34:04,230
为什么呢 要贴近那个所谓的天花板

1420
01:34:04,230 --> 01:34:08,710
我们尽量能够满足高效易用 强大 简单 灵活 安全

1421
01:34:09,730 --> 01:34:12,570
这些在我们的实验中

1422
01:34:12,570 --> 01:34:18,690
你们体现的是简单 易用 灵活

1423
01:34:18,690 --> 01:34:20,310
高效 强大 安全

1424
01:34:20,850 --> 01:34:24,890
是在你们的目前的基本实验里面是不设计的

1425
01:34:24,890 --> 01:34:26,430
这也是为什么我们只有几千行代码

1426
01:34:26,430 --> 01:34:27,790
还可以号称之后写出一个OS

1427
01:34:27,790 --> 01:34:30,570
但其实Linux只有上千万行代码

1428
01:34:30,570 --> 01:34:31,430
这不是一个量级

1429
01:34:31,430 --> 01:34:36,570
这里面有一部分内容是跟这里面的一些是相关的

1430
01:34:38,110 --> 01:34:42,570
好 为什么要学专门课 为了拿学分

1431
01:34:43,170 --> 01:34:44,770
这是我觉得大部分同学的想法

1432
01:34:44,770 --> 01:34:46,570
但我还要给大家介绍一下他的好处

1433
01:34:47,750 --> 01:34:52,290
学专门课 其实也是为了你们以后的生计

1434
01:34:52,290 --> 01:34:55,230
我觉得大家身为计算机专业的同学

1435
01:34:55,230 --> 01:34:56,990
大家也有一些可能不是计算机专业

1436
01:34:56,990 --> 01:34:58,930
至少你学专门课的目的就是

1437
01:34:58,930 --> 01:35:01,710
要知道计算机专业里面的一些

1438
01:35:01,710 --> 01:35:03,290
其他专业不知道的东西

1439
01:35:03,290 --> 01:35:06,130
物以稀为贵 你知道的东西

1440
01:35:06,130 --> 01:35:08,010
别人知道的少那自然你就有优势

1441
01:35:08,010 --> 01:35:08,790
这些什么呢

1442
01:35:08,790 --> 01:35:12,930
第一个是了解计算机里面的软硬件的运行机理

1443
01:35:12,930 --> 01:35:16,390
这个机理会帮助你后面开发其他的那些应用

1444
01:35:16,390 --> 01:35:17,190
也是有帮助的

1445
01:35:17,190 --> 01:35:18,310
你知道怎么去优化

1446
01:35:18,310 --> 01:35:21,730
你怎么知道去规避一些潜在的风险安全风险

1447
01:35:21,730 --> 01:35:25,130
你怎么知道去充分的利用所谓的计算机系统

1448
01:35:25,130 --> 01:35:27,390
你只有知道它后面的运行原理之后

1449
01:35:27,390 --> 01:35:33,210
你才能够开发出更加高效安全的软件

1450
01:35:33,210 --> 01:35:36,710
这是一点,就是提升你的能力

1451
01:35:36,710 --> 01:35:39,250
第二点可以学习软件的基础架构

1452
01:35:39,250 --> 01:35:41,210
这个架构的意思是说

1453
01:35:42,650 --> 01:35:44,490
将来我们很多同学可能

1454
01:35:44,490 --> 01:35:46,570
你如果想往更深层次发展

1455
01:35:46,570 --> 01:35:49,550
可能应对的不是一个小的几百行的代码

1456
01:35:49,550 --> 01:35:51,210
你可能应对的是一个

1457
01:35:51,970 --> 01:35:53,470
几千行、上万行

1458
01:35:53,470 --> 01:35:55,830
甚至更多规模的一个代码

1459
01:35:55,830 --> 01:35:57,650
需要你一个人去应对

1460
01:35:57,650 --> 01:35:58,910
那你怎么去应对它

1461
01:35:58,910 --> 01:36:02,690
你要去知道一个复杂软件的开发方法

1462
01:36:02,690 --> 01:36:06,910
那么至少这门课会给你们打下一定的基础

1463
01:36:06,910 --> 01:36:08,350
不是说你们将来都要去做OS

1464
01:36:08,770 --> 01:36:10,550
不是 只要你开发一个复杂软件

1465
01:36:10,550 --> 01:36:12,370
那么这里面碰到的问题

1466
01:36:12,370 --> 01:36:14,330
将来你们或多或少都会碰到

1467
01:36:14,330 --> 01:36:16,090
你怎么能够提供合理的接口

1468
01:36:16,090 --> 01:36:17,770
你怎么去避免bug

1469
01:36:17,770 --> 01:36:20,570
你怎么去调试一个看起来

1470
01:36:20,570 --> 01:36:22,810
这个错误不是从哪来的一个软件

1471
01:36:22,810 --> 01:36:24,650
这些都是你们要学习的

1472
01:36:24,650 --> 01:36:27,090
就是这里面说可以发现和修复难对付的bug

1473
01:36:28,090 --> 01:36:30,530
这一点OS有天然的优势

1474
01:36:30,530 --> 01:36:31,850
因为它的bug特别多

1475
01:37:03,050 --> 01:37:04,330
他专门就是来找bug

1476
01:37:04,330 --> 01:37:06,450
因为他知道这里面bug找不完

1477
01:37:06,450 --> 01:37:08,130
他有很多事情可以做

1478
01:37:11,630 --> 01:37:13,010
所以学这门课

1479
01:37:13,010 --> 01:37:15,270
你要知道怎么去调bug

1480
01:37:15,270 --> 01:37:16,470
怎么去分析程序

1481
01:37:16,470 --> 01:37:18,210
然后把这个bug给fix掉

1482
01:37:18,210 --> 01:37:20,490
我觉得这门课挺有意思的

1483
01:37:20,490 --> 01:37:21,730
就实践类的

1484
01:37:21,730 --> 01:37:24,330
对你们将来的动手能力增强的是这个地方

1485
01:37:24,330 --> 01:37:26,270
这个地方是比较实践

1486
01:37:26,270 --> 01:37:28,210
那需要你去独立去解决

1487
01:37:28,210 --> 01:37:30,730
但如果超的话可能就太easy了

1488
01:37:30,730 --> 01:37:32,970
超其实你的能力得不到提升

1489
01:37:32,970 --> 01:37:35,730
你只是超的能力稍微强一点而已

1490
01:37:35,730 --> 01:37:37,750
其他能力都是退化弱化

1491
01:37:39,090 --> 01:37:41,050
所以你看到我讲这个学生们课的目的

1492
01:37:41,050 --> 01:37:44,370
不是让大家去说加工作去做OS

1493
01:37:44,930 --> 01:37:45,330
不是

1494
01:37:45,330 --> 01:37:49,530
做OS的人是你们的百分之一就不错了

1495
01:37:49,530 --> 01:37:52,470
我觉得但是你通过学生们课

1496
01:37:52,470 --> 01:37:55,790
你可以对你的计算机的专业能力

1497
01:37:55,790 --> 01:37:57,370
做一个比较大的提升

1498
01:37:57,370 --> 01:37:59,290
我觉得这一点是它的好处

1499
01:37:59,290 --> 01:38:00,850
无论你将来做啥

1500
01:38:00,850 --> 01:38:02,290
只要你是要coding

1501
01:38:02,290 --> 01:38:04,670
当然你说你将来不coding了

1502
01:38:04,670 --> 01:38:08,330
这个不coding的概率也是有的

1503
01:38:08,330 --> 01:38:10,290
你要转行的话也是有可能的

1504
01:38:10,290 --> 01:38:13,250
但是我想说这里面的管理的水平

1505
01:38:13,250 --> 01:38:15,330
超级总统的管理水平其实也和

1506
01:38:15,330 --> 01:38:17,110
你将来管人也是一样的

1507
01:38:17,110 --> 01:38:19,130
到政府部门 你到一些行政部门

1508
01:38:19,130 --> 01:38:19,870
你也需要管人

1509
01:38:19,870 --> 01:38:21,990
你也需要怎么去协调调度

1510
01:38:21,990 --> 01:38:23,410
这些策略

1511
01:38:31,450 --> 01:38:32,690
啊大家休息五分钟

1512
01:43:38,530 --> 01:43:46,910
好 刚才讲了第二部分最后一页

1513
01:43:46,910 --> 01:43:48,210
就是为什么要学这门课

1514
01:43:48,210 --> 01:43:50,970
然后再如果再那个一点的话

1515
01:43:50,970 --> 01:43:53,490
其实我们看到所有大公司

1516
01:43:53,490 --> 01:43:56,350
所谓大公司就是排在IT类的

1517
01:43:56,350 --> 01:43:57,770
排在前五的公司

1518
01:44:27,850 --> 01:44:30,950
要去动手设计实现一个OS

1519
01:44:30,950 --> 01:44:32,490
当然是一部分的OS

1520
01:44:32,490 --> 01:44:38,210
这都是看出来这个课还是很重要的

1521
01:44:38,210 --> 01:44:42,990
将来你去走教研系列 走政府系列

1522
01:44:43,350 --> 01:44:44,970
走公司系列

1523
01:44:44,970 --> 01:44:48,230
都和OS或多或少的应该有一定的关系

1524
01:44:48,230 --> 01:44:51,770
所以希望大家能够通过这门课有更多的收获

1525
01:44:53,230 --> 01:44:56,090
好 那我们开始讲第三部分

1526
01:44:56,090 --> 01:44:58,690
第二份是操作系统历史的演变

1527
01:45:00,870 --> 01:45:02,950
这个一般的教材里面

1528
01:45:02,950 --> 01:45:07,130
会把它作为一章中的一节来讲

1529
01:45:07,130 --> 01:45:09,070
我们也是讲课是这样的

1530
01:45:09,070 --> 01:45:10,750
但其实我们后面的内容

1531
01:45:10,750 --> 01:45:12,670
和它这个历史演变有很大的一些关系

1532
01:45:12,670 --> 01:45:14,090
我们后面可以看着

1533
01:45:15,050 --> 01:45:16,370
首先是单用户时代

1534
01:45:17,030 --> 01:45:17,830
单用户时代的话

1535
01:45:17,830 --> 01:45:20,070
那么最早的计算机

1536
01:45:20,070 --> 01:45:24,070
它其实不需要有那么复杂的交互界面

1537
01:45:24,070 --> 01:45:27,650
它需要的只是把程序给灌到类传中去执行就完了

1538
01:45:27,650 --> 01:45:29,450
那时候的超级桶更多是一个monitor

1539
01:45:29,450 --> 01:45:31,270
一个监控器的角色

1540
01:45:31,270 --> 01:45:32,490
监控器有什么呢

1541
01:45:32,490 --> 01:45:34,750
我能够完成一个程序的加载

1542
01:45:34,750 --> 01:45:37,850
这个程序可能不是我们现在看到的什么网络加载

1543
01:45:37,850 --> 01:45:40,210
或者说从硬盘上加载

1544
01:45:40,210 --> 01:45:42,210
它可能通过纸带机来进行加载

1545
01:45:42,210 --> 01:45:44,910
纸带机大家估计都没见过 我也没见过

1546
01:45:44,910 --> 01:45:48,070
但是在博物馆里面是有的

1547
01:45:48,070 --> 01:45:51,150
第二个呢 那个程序就跑一个程序

1548
01:45:51,150 --> 01:45:53,470
所以你的超级桶更多的是起了一个酷的作用

1549
01:45:53,470 --> 01:45:55,910
它把底层的硬件细节给屏蔽了

1550
01:45:55,910 --> 01:45:58,490
提供一个比较好的程序库

1551
01:45:59,850 --> 01:46:02,530
这是我们最早期的时候

1552
01:46:02,530 --> 01:46:06,370
单用户单程序的一个时代看到的一个情况

1553
01:46:07,490 --> 01:46:10,950
但随着计算机的硬件能力增强

1554
01:46:10,950 --> 01:46:12,510
计算速度越来越快

1555
01:46:12,510 --> 01:46:15,430
我们希望计算机能够更高效地使用它的CPU

1556
01:46:15,430 --> 01:46:17,190
非常昂贵又贵又快

1557
01:46:17,850 --> 01:46:21,490
所以这时候我们就尽量让CPU想让它忙起来

1558
01:46:21,490 --> 01:46:24,270
后面的一个比较长的阶段就在想

1559
01:46:24,270 --> 01:46:26,450
怎么让CPU尽量干更多的活

1560
01:46:26,450 --> 01:46:28,870
这里面从早期一开始的批处理

1561
01:46:28,870 --> 01:46:32,630
批处理就是能够降低一些中间的所谓的瓶颈

1562
01:46:32,630 --> 01:46:34,310
因为发现它要解决的问题

1563
01:46:34,310 --> 01:46:37,310
就是应用的不高效的问题

1564
01:46:37,310 --> 01:46:41,710
比如说我怎么能够提升它整个CPU利用率

1565
01:46:41,710 --> 01:46:43,470
而当时的瓶颈并不在CPU本身

1566
01:46:43,470 --> 01:46:44,530
CPU很快

1567
01:46:44,530 --> 01:46:46,110
虽然相当于现在CPU很慢

1568
01:46:46,110 --> 01:46:47,510
但在当时那个场景下

1569
01:46:47,510 --> 01:46:49,830
CPU属于非常快的一个部件

1570
01:46:49,830 --> 01:46:50,570
那慢在哪里

1571
01:47:22,710 --> 01:47:29,390
在这个过程中,所有的部件都在运行,只是最快的部件还是等的时间比较

1572
01:47:29,390 --> 01:47:29,850
长。

1573
01:47:30,690 --> 01:47:36,370
那也没办法,因为那时候内存也很小,在内存中没法同时装入多个

1574
01:47:36,370 --> 01:47:36,670
程序。

1575
01:47:37,050 --> 01:47:43,710
但是后面的硬件的发展,内存大了之后,我们就可以在内存里面放多个

1576
01:47:43,710 --> 01:47:44,270
程序。

1577
01:47:44,270 --> 01:47:48,490
这样就可以避免Io传计从Io设备

1578
01:47:48,490 --> 01:47:50,770
比如纸带机传到内存中的开销

1579
01:47:50,770 --> 01:47:52,830
我一开始就把它放入多个程序去跑

1580
01:47:53,670 --> 01:47:55,730
这样的话多个程序做了内存

1581
01:47:55,730 --> 01:47:57,170
既然多个程序做了内存的话

1582
01:47:57,170 --> 01:48:00,350
自然能想到一点就是大家去轮流使用CPU了

1583
01:48:01,070 --> 01:48:01,930
让CPU忙起来

1584
01:48:02,650 --> 01:48:06,550
这时候的超级桶已经从前面讲的装载器

1585
01:48:07,230 --> 01:48:09,250
又多了程序调度

1586
01:48:09,250 --> 01:48:13,610
由于你这里面存在多个程序共享内存的问题

1587
01:48:13,610 --> 01:48:18,070
有個內存管理問題 當然還有很重要的輸出

1588
01:48:18,070 --> 01:48:20,810
你接過輸出出來的那個輸出的管理

1589
01:48:20,810 --> 01:48:24,910
但是輸出管理呢 那時候主要是打印

1590
01:48:24,910 --> 01:48:28,930
那時候不需要顯示器 輸入是子彈

1591
01:48:28,930 --> 01:48:33,070
輸出也是子彈 子彈輸入子彈輸出

1592
01:48:33,070 --> 01:48:35,030
就把它打印出來 這就是所謂的這個

1593
01:48:35,030 --> 01:48:37,850
早期的多道程序系統的一個過程

1594
01:48:37,850 --> 01:48:40,530
這個過程呢 大家程序之間還是比較友好的

1595
01:48:40,530 --> 01:48:42,370
去在輪流使用

1596
01:48:42,370 --> 01:48:46,890
但在後面就發現這個程序它的友好性不是那麼強

1597
01:48:47,350 --> 01:48:48,730
我們開發成績的時候

1598
01:48:49,090 --> 01:48:51,850
我希望當然希望獨佔這個處理器了

1599
01:48:51,850 --> 01:48:52,570
那這樣的話

1600
01:48:53,270 --> 01:48:56,270
我們就讓那種有獨佔想法的應有程序

1601
01:48:56,270 --> 01:48:57,570
第一 我還支持它運行

1602
01:48:57,570 --> 01:48:58,790
第二呢

1603
01:48:58,790 --> 01:48:59,770
它想獨佔

1604
01:48:59,770 --> 01:49:01,490
給它一個虛的一個假象它在獨佔

1605
01:49:01,490 --> 01:49:02,390
其實它並沒有獨佔

1606
01:49:02,390 --> 01:49:03,830
這是所謂的分時

1607
01:49:03,830 --> 01:49:05,550
中國分時給它一種假象

1608
01:49:05,550 --> 01:49:07,210
讓它感覺它在獨佔地下棲息

1609
01:49:07,210 --> 01:49:10,510
但其实是多个程序在分时使用CPU

1610
01:49:10,510 --> 01:49:12,430
这样可以进一步的提高效率

1611
01:49:12,430 --> 01:49:14,830
有些处理器正在执行Io操作的时候

1612
01:49:14,830 --> 01:49:15,510
它没必要堵在

1613
01:49:15,510 --> 01:49:16,750
它可以把CPU让出来

1614
01:49:16,750 --> 01:49:19,630
有些时候它运行时间比较长了

1615
01:49:19,630 --> 01:49:21,490
我们超系统可以打断它

1616
01:49:21,490 --> 01:49:25,430
让它能够把CPU的时间给其他程序运行

1617
01:49:25,430 --> 01:49:26,950
这个所谓的分时

1618
01:49:26,950 --> 01:49:28,130
你看到这个时候

1619
01:49:28,130 --> 01:49:29,970
从50年代到现在70年代

1620
01:49:29,970 --> 01:49:33,270
分时系统就已经出现了

1621
01:49:33,270 --> 01:49:34,110
其实到这个阶段

1622
01:49:34,110 --> 01:49:37,310
我们基本上我们课程上学到很多内容

1623
01:49:37,310 --> 01:49:39,530
在70年代就已经奠定了我们的基础

1624
01:49:40,250 --> 01:49:45,250
那时候的机器是从大型机转向了小型机

1625
01:49:47,630 --> 01:49:49,430
这是一个变化的过程

1626
01:49:49,430 --> 01:49:50,790
在这个变化的过程中

1627
01:49:50,790 --> 01:49:56,090
它的一个重要解决的问题是应用的效率问题

1628
01:49:56,090 --> 01:49:59,870
然后到了分时阶段还要解决一个应用的交互问题

1629
01:49:59,870 --> 01:50:00,570
什么叫交互呢

1630
01:50:00,570 --> 01:50:02,910
我希望那时候已经有键盘鼠标了

1631
01:50:02,910 --> 01:50:07,970
我希望我们在开发程序的时候可以一边开发一边调试一边运行

1632
01:50:07,970 --> 01:50:13,050
而前面的这种多套程序阶段还有批处理论由于它不支持分时

1633
01:50:13,050 --> 01:50:17,410
所以它没法去及时的响应用户的键盘鼠标操作

1634
01:50:17,410 --> 01:50:20,830
这就是一个分时带来的一个好处

1635
01:50:20,830 --> 01:50:24,110
既提高了效率又提高了交互性

1636
01:50:26,330 --> 01:50:31,830
那么这些idea其实我找了一个非常看起来非常古老的一个OS叫matics

1637
01:50:32,610 --> 01:50:35,170
这个是Unix的前身

1638
01:50:35,610 --> 01:50:37,890
这个操作系统是MIT

1639
01:50:37,890 --> 01:50:45,590
联合了AT&T和通用电器这三个单位

1640
01:50:45,590 --> 01:50:47,930
一起承担的一个非常大型的课题

1641
01:50:48,430 --> 01:50:51,150
MIT出idea了

1642
01:50:51,150 --> 01:50:55,070
那些主要的教授是出idea了

1643
01:50:55,070 --> 01:50:55,890
然后基益呢

1644
01:50:55,890 --> 01:50:57,470
那个简称的基益就是通用电器

1645
01:50:57,470 --> 01:50:59,230
它主要是出机器

1646
01:50:59,230 --> 01:51:00,610
那Coding谁干的

1647
01:51:01,750 --> 01:51:08,350
AT&T是他有一个软件团队来开发OS

1648
01:51:08,350 --> 01:51:14,370
那这个Martix由于他的想法来自于早期MIT这样成功的一个OS

1649
01:51:14,370 --> 01:51:16,810
叫CTSS,这个OS

1650
01:51:18,390 --> 01:51:22,310
那么通用电力,这个OS他做好之后

1651
01:51:22,310 --> 01:51:26,990
他既不想扩大他的这个计算机的处理能力

1652
01:51:26,990 --> 01:51:29,610
他希望能够在一台大型主义上支持

1653
01:51:29,610 --> 01:51:32,170
多达上千步终端

1654
01:51:32,170 --> 01:51:34,210
就上千步终端可以连到计划机里面去

1655
01:51:34,210 --> 01:51:35,990
有上百个用户可以上线

1656
01:51:38,470 --> 01:51:39,330
我想问一下

1657
01:51:39,330 --> 01:51:41,110
在咱们计划机系有这样的系统吗

1658
01:51:42,410 --> 01:51:44,690
这是MIT的计划机系要做的事情

1659
01:51:45,410 --> 01:51:48,490
我们计划机系给同学用过吗

1660
01:51:48,490 --> 01:51:49,350
有这样的系统吗

1661
01:51:50,090 --> 01:51:51,370
可能计划机系里面没有

1662
01:51:51,370 --> 01:51:53,850
但是我们的学校有

1663
01:51:53,850 --> 01:51:55,410
学校有这样的一个环境

1664
01:51:55,410 --> 01:52:00,190
比如说大家可以登录现在的电子邮件

1665
01:52:00,190 --> 01:52:02,010
那就是其实可以理解为

1666
01:52:02,010 --> 01:52:03,830
就是如果把你的计算机看成一个终端的话

1667
01:52:03,830 --> 01:52:06,250
你通过登录到那个电子邮件去查询邮件

1668
01:52:06,250 --> 01:52:08,350
编写邮件通过网页的方式

1669
01:52:08,350 --> 01:52:12,110
就可以支持多达上百位上千位的用户去再现

1670
01:52:12,110 --> 01:52:13,210
其实是一个idea

1671
01:52:13,210 --> 01:52:16,930
但这个idea是在64年提出来

1672
01:52:18,230 --> 01:52:21,390
你想这是非常早的时候就提出这个idea

1673
01:52:21,390 --> 01:52:24,210
要支持多人多任务的一个超级统

1674
01:52:24,210 --> 01:52:26,150
所以思想非常超前

1675
01:52:26,150 --> 01:52:30,150
那时候的硬件还跟不上这个想法

1676
01:52:31,750 --> 01:52:35,730
而且还有一点是软件工程的能力也不够

1677
01:52:35,730 --> 01:52:37,710
开发复杂软件的能力也不够

1678
01:52:37,710 --> 01:52:39,190
编辑器也不够

1679
01:52:39,190 --> 01:52:42,590
但是他们就想开发超系统了

1680
01:52:42,590 --> 01:52:44,090
他能不能开发出来呢

1681
01:52:44,090 --> 01:52:46,770
其实这一开始就是一个想法很好

1682
01:52:46,770 --> 01:52:48,370
但是搞不定的一个事情

1683
01:52:51,090 --> 01:52:53,150
所以当开发了几年之后

1684
01:52:53,150 --> 01:52:54,430
AT&T就退出了

1685
01:52:54,430 --> 01:52:55,910
因为他看不到希望

1686
01:52:57,810 --> 01:52:59,170
这两位是骨干

1687
01:53:00,650 --> 01:53:01,370
这是谁

1688
01:53:03,350 --> 01:53:04,210
这是Thompson

1689
01:53:04,210 --> 01:53:05,070
这是Richard

1690
01:53:05,830 --> 01:53:07,710
Richard是C元的发明者

1691
01:53:07,710 --> 01:53:09,130
Thompson是Unix的发明者

1692
01:53:09,750 --> 01:53:12,910
这两位是作为骨干工程师

1693
01:53:12,910 --> 01:53:14,350
参与了这个项目Matic这个项目

1694
01:53:15,390 --> 01:53:17,910
但是由于AT&T不再坚持

1695
01:53:17,910 --> 01:53:23,410
所以他们就退传 退传之后 工程师的特点是闲不住

1696
01:53:23,890 --> 01:53:28,610
他其实想去放松一下 就自己开发了个游戏

1697
01:53:28,610 --> 01:53:32,990
又开发了一个磁盘分析程序

1698
01:53:32,990 --> 01:53:35,270
然后在这个基础上就开发了一个超系统

1699
01:53:35,270 --> 01:53:37,610
这次Thompson在号称

1700
01:53:37,610 --> 01:53:40,470
如果大家看他那个历史的一个书叫

1701
01:53:40,470 --> 01:53:42,070
Unix Memory那个书

1702
01:53:42,070 --> 01:53:45,870
我可以讲到 他是在他夫人带着小孩

1703
01:53:46,250 --> 01:53:48,010
去回梁家之后的三周之内

1704
01:53:48,010 --> 01:53:49,610
把这个unix给开发出来

1705
01:53:50,510 --> 01:53:52,210
一个人用汇边语言写的

1706
01:53:53,470 --> 01:53:56,190
然后他自己对汇边语言写的代码也不太满意

1707
01:53:57,050 --> 01:54:00,470
于是他就搞了一个语言叫B语言

1708
01:54:01,230 --> 01:54:03,090
他用B语言来写

1709
01:54:03,090 --> 01:54:06,090
B语言写完之后也写出来了

1710
01:54:06,090 --> 01:54:09,190
写出来之后被他鄙视了一下

1711
01:54:09,190 --> 01:54:10,750
他觉得这个B语言太low了

1712
01:54:11,530 --> 01:54:12,890
他于是搞了一个C语言

1713
01:54:14,790 --> 01:54:17,810
搞了C语言 搞完C语言之后

1714
01:54:17,810 --> 01:54:21,470
确实大家现在都很熟悉C语言

1715
01:54:21,470 --> 01:54:23,770
C语言搞完之后他们俩合在一起

1716
01:54:23,770 --> 01:54:25,330
又把这个unix又重写了一把

1717
01:54:26,110 --> 01:54:29,290
所以你看到编程语言和超级总是紧密合的

1718
01:54:29,290 --> 01:54:32,050
大家比较好奇之前matrix用什么语言

1719
01:54:33,470 --> 01:54:34,970
你朋友了解过吗

1720
01:54:37,410 --> 01:54:39,530
他们用的语言不是会编语言

1721
01:54:39,530 --> 01:54:42,610
matrix所有ID我说他当时在60年代提出的ID

1722
01:54:43,130 --> 01:54:44,670
放在现在也不过时

1723
01:54:44,670 --> 01:54:46,750
他那时候已经提出他要用高级语言编程了

1724
01:54:46,750 --> 01:54:47,510
他不应该用汇编

1725
01:54:47,510 --> 01:54:49,210
他认为不应该用汇编

1726
01:54:49,210 --> 01:54:50,350
PL1

1727
01:54:51,450 --> 01:54:53,230
这是他的一个语言

1728
01:54:53,230 --> 01:54:54,910
这个1是罗马数字的1

1729
01:54:54,910 --> 01:54:56,630
用这个语言来编程

1730
01:54:57,030 --> 01:54:58,650
他定好这个计划之后

1731
01:54:58,650 --> 01:55:00,450
这个编辑还没出现

1732
01:55:00,930 --> 01:55:04,130
所以他们是先设计超级统

1733
01:55:04,130 --> 01:55:06,530
同时在开发编辑器

1734
01:55:06,530 --> 01:55:08,630
所以你可以看到这个软件工程

1735
01:55:08,630 --> 01:55:09,910
如果大家学我软件工程

1736
01:55:09,910 --> 01:55:11,230
这种合理的设计

1737
01:55:12,890 --> 01:55:14,170
不合理确实不合理

1738
01:55:14,170 --> 01:55:15,170
就是编辑的不存在

1739
01:55:16,070 --> 01:55:18,610
所以机器这个机器是存在的

1740
01:55:18,610 --> 01:55:21,230
这个机翼645这个机器存在的

1741
01:55:21,230 --> 01:55:22,410
很强大一台机器

1742
01:55:23,610 --> 01:55:25,390
但是这个编辑没有

1743
01:55:25,390 --> 01:55:26,770
然后超级统也没有

1744
01:55:26,770 --> 01:55:29,850
他就要去开发编辑和超级统

1745
01:55:31,110 --> 01:55:33,330
所以这个事情一开始就特别困难

1746
01:55:33,330 --> 01:55:33,990
因为困难在哪

1747
01:55:33,990 --> 01:55:35,390
困难在软件上面

1748
01:55:35,390 --> 01:55:36,510
这个软件上面

1749
01:55:37,290 --> 01:55:37,650
然后

1750
01:55:45,050 --> 01:55:47,490
由于这种软件工程设计不合理

1751
01:55:47,490 --> 01:55:49,410
这也是我们其实我理解了

1752
01:55:49,990 --> 01:55:52,230
这一点其实在我们的学校是通病

1753
01:55:52,230 --> 01:55:53,390
不光是MIT

1754
01:55:53,390 --> 01:56:01,910
其实我觉得主要是大学都缺少开发复杂软件的经验

1755
01:56:01,910 --> 01:56:03,310
虽然MIT也号称很强

1756
01:56:03,310 --> 01:56:05,930
但其实它这种设计思路就很糟糕

1757
01:56:07,870 --> 01:56:09,250
我不知道大家学了软件工程之后

1758
01:56:09,250 --> 01:56:11,110
是不是对开发超级通路有帮助

1759
01:56:11,110 --> 01:56:12,510
我希望有帮助

1760
01:56:12,510 --> 01:56:14,990
我听说感觉工程师和组成员里合作是吧

1761
01:56:17,190 --> 01:56:18,350
取消了

1762
01:56:20,910 --> 01:56:23,190
我觉得更好的时候应该跟超级组合作一下

1763
01:56:24,070 --> 01:56:26,350
但以前是时间不对等

1764
01:56:26,350 --> 01:56:27,410
它那是秋季的课

1765
01:56:27,410 --> 01:56:28,430
我们是春季的课

1766
01:56:28,990 --> 01:56:30,670
但现在超级组秋季也开了

1767
01:56:30,670 --> 01:56:32,430
所以估计大家秋季也去上一上

1768
01:56:35,730 --> 01:56:36,510
上一次就行了

1769
01:56:36,510 --> 01:56:37,150
不用上两次

1770
01:56:38,790 --> 01:56:40,370
好 这个我再说回了

1771
01:56:40,370 --> 01:56:44,070
他们俩其实就工程师出身

1772
01:56:44,070 --> 01:56:47,170
但是他们都是博士的学历

1773
01:56:47,170 --> 01:56:50,010
都是博士级别的学历

1774
01:56:50,010 --> 01:56:53,950
所以他们俩开发的编程影响超系统

1775
01:56:53,950 --> 01:56:58,070
一下子就在AT&T内部去流行起来了

1776
01:56:58,070 --> 01:56:59,990
而流行他们开发这个OS

1777
01:56:59,990 --> 01:57:01,410
并不是有一个什么宏大的目标

1778
01:57:01,410 --> 01:57:03,790
就是要支持游戏 开发小游戏

1779
01:57:03,790 --> 01:57:05,050
支持文本编辑

1780
01:57:05,050 --> 01:57:07,570
支持一些非常简单的一些打印工作

1781
01:57:07,570 --> 01:57:08,690
就是一小工作

1782
01:57:09,810 --> 01:57:13,130
然后一开始也就几千万代嘛,也就写出来了

1783
01:57:13,130 --> 01:57:17,210
然后呢就定义好自己的所谓的Sitting Call

1784
01:57:17,210 --> 01:57:19,610
然后上面开发各种新的软件

1785
01:57:19,610 --> 01:57:25,310
它在小目标逐步迭代,越来越强大

1786
01:57:25,310 --> 01:57:26,470
这么一个开发过程

1787
01:57:26,470 --> 01:57:31,890
这其实是一个一般来说开发一个长期持久的大型软件的一个

1788
01:57:31,890 --> 01:57:33,590
好像目前是一个比较可行的道路

1789
01:57:33,590 --> 01:57:35,970
一般来说你一开始想把一个目标定得特别大

1790
01:57:35,970 --> 01:57:37,890
一开始设计得非常规范

1791
01:57:37,890 --> 01:57:41,350
好像比较困难 因为我们的思路经常受限

1792
01:57:41,350 --> 01:57:44,190
而你这个软件随着时间的增长之后

1793
01:57:44,190 --> 01:57:48,270
它的各种情况会发生变化 使得你之前的一些假设

1794
01:57:48,270 --> 01:57:53,270
你之前的一些约定都会出现一些差异性

1795
01:57:53,270 --> 01:57:56,490
这使得我们只能不停的开发 不停的迭代

1796
01:57:56,490 --> 01:57:58,890
才能保证这个软件能够正常的满足

1797
01:58:00,210 --> 01:58:02,830
现在和可能未来的一个发展趋势

1798
01:58:02,830 --> 01:58:06,150
所以你看到 当于TNT把这个软件开发出来之后

1799
01:58:06,150 --> 01:58:08,650
他们首先内部使用 第二步就是AT&T

1800
01:58:08,650 --> 01:58:13,270
他把这个说我Open 我给大学科研机构

1801
01:58:13,270 --> 01:58:16,890
免费发放原代码和Binary Code都发放

1802
01:58:16,890 --> 01:58:20,470
使得Berkeley就是UC Berkeley的

1803
01:58:20,470 --> 01:58:22,450
他们那个group里面有一个超级轮的group

1804
01:58:22,450 --> 01:58:24,750
就把这个代码做了进一步的改进

1805
01:58:24,750 --> 01:58:25,930
增加了网络协议站

1806
01:58:25,930 --> 01:58:28,490
你们现在学的网络园里面Socket那套东西

1807
01:58:28,490 --> 01:58:31,790
就是他们开发的 开发在units之上

1808
01:58:31,790 --> 01:58:34,270
然后形成了自己的一个发行板叫BSD

1809
01:59:04,270 --> 01:59:09,270
还有惠普,他有自己的OS,还有IBM有自己的AX,还有苹果,IOS

1810
01:59:09,930 --> 01:59:14,770
他们的核心就是Kono部分,Kono部分基本上继承的是Unix

1811
01:59:15,270 --> 01:59:17,170
所以可以看到Unix影响非常大

1812
01:59:17,170 --> 01:59:21,630
但是大家不要忘了一点,大家只看到了成功的Unix

1813
01:59:21,630 --> 01:59:25,470
它失败了这个Maniacs OS,也值得大家记住

1814
01:59:25,470 --> 01:59:29,710
因为idea是从哪儿来的,基本上它的idea是从哪儿来的

1815
01:59:36,530 --> 01:59:38,450
在60年代末的时候是很简单

1816
01:59:38,450 --> 01:59:41,010
但到现在为止这个Unix就是Maniacs所有的目标

1817
01:59:41,010 --> 01:59:42,470
它都实现了

1818
01:59:42,470 --> 01:59:44,190
所以它这个目标是逐步实现的而已

1819
01:59:44,190 --> 01:59:46,710
不是一步实现 一步登天

1820
01:59:46,710 --> 01:59:47,730
另外一个典型例子

1821
01:59:48,970 --> 01:59:53,810
现在统治着我们整个世界的超级统是Linux

1822
01:59:53,810 --> 01:59:58,370
Linux就是这位Linux

1823
02:00:01,190 --> 02:00:06,990
这个学生开发出来的,一个人,这也说明了一点就是超级组并不是大家想象中

1824
02:00:06,990 --> 02:00:13,310
需要多个人合作,一个人就搞定,当然这个人比较厉害一点,我相信大家很厉害,

1825
02:00:14,450 --> 02:00:21,530
这一个人搞定了,在当学生的时候搞定了这个OS,他怎么搞定的,不是从零开始,

1826
02:00:21,890 --> 02:00:27,110
这也是说其实可以copy,他一开始copy了minix,另外一个大学教授开发了一个

1827
02:00:27,110 --> 02:00:27,450
超级组,

1828
02:00:28,590 --> 02:00:34,770
叫MINIX超级统 仿照他把大学教授的教科书好好读了一遍

1829
02:00:34,770 --> 02:00:36,790
把代码下载好好看了一遍

1830
02:00:36,790 --> 02:00:42,710
然后就自己独立的在一台PC 80386

1831
02:00:42,710 --> 02:00:45,490
在机器上开发了Linux超级统

1832
02:00:46,450 --> 02:00:49,850
开发完之后 他就放到网上

1833
02:00:50,290 --> 02:00:55,090
用GPU协议 放到网上大家可以共享 一起来开发

1834
02:00:55,650 --> 02:00:57,790
在芬兰那时候它Internet还比较方便

1835
02:00:58,650 --> 02:01:02,110
所以吸引了国际上的很多人来参与Lynx开发

1836
02:01:02,110 --> 02:01:07,850
大家都希望有一个类Unix潮系统来用于它日常的研发工作

1837
02:01:07,850 --> 02:01:10,050
而当时为什么这个BSD没有成呢

1838
02:01:10,050 --> 02:01:15,490
是在于BSD Berkeley发展很快

1839
02:01:15,950 --> 02:01:18,490
但是AT&T那个公司它是公司行为

1840
02:01:18,490 --> 02:01:22,030
公司盈利是它的一个很重要的一个目标

1841
02:01:22,030 --> 02:01:23,750
所以它发现Unix可以赚很多钱的时候

1842
02:01:23,750 --> 02:01:26,250
就开始提起专利诉讼

1843
02:01:26,250 --> 02:01:28,230
就跟Bokeh打官司

1844
02:01:28,230 --> 02:01:32,150
打官司期间这个BSD就没法发展了

1845
02:01:32,150 --> 02:01:33,750
正好Linux又刚出现

1846
02:01:33,750 --> 02:01:35,650
大家找不到一个可以玩的OS

1847
02:01:35,650 --> 02:01:36,910
就找到了Linux

1848
02:01:36,910 --> 02:01:39,830
所以Linux占了先机

1849
02:01:39,830 --> 02:01:41,670
然后就发展了非常迅速的

1850
02:01:42,530 --> 02:01:43,290
就是广泛的使用

1851
02:01:43,290 --> 02:01:44,630
就犯了现在的情况

1852
02:01:44,630 --> 02:01:47,870
你们现在看到的叫Linux超级统

1853
02:01:47,870 --> 02:01:49,030
那也叫安卓超级统

1854
02:01:49,030 --> 02:01:52,570
安卓超级统底下那一块就是Linux

1855
02:01:53,130 --> 02:01:53,970
都叫超级种

1856
02:01:53,970 --> 02:01:56,710
但其实他们的定义的边界是不一样的

1857
02:01:56,710 --> 02:01:58,330
前面我已经讲过了

1858
02:01:58,330 --> 02:02:02,130
Wealth Linux又出现了很多所谓的超支系统的Distribution

1859
02:02:02,130 --> 02:02:03,330
就是OSDistribution

1860
02:02:03,330 --> 02:02:06,230
你看到我们现在也推荐大家用的什么Yubuntu

1861
02:02:06,230 --> 02:02:06,830
Red Hat

1862
02:02:06,830 --> 02:02:07,410
Federo

1863
02:02:07,410 --> 02:02:11,170
这些都是一些名字代表公司推出的一个

1864
02:02:11,170 --> 02:02:15,390
基于Linux kernel的OS的Distribution

1865
02:02:15,390 --> 02:02:16,550
它也叫OS

1866
02:02:16,550 --> 02:02:18,130
这个OS也是一个放大的意思

1867
02:02:20,250 --> 02:02:21,090
国内也有

1868
02:02:21,090 --> 02:02:28,870
国内有麒麟,红麒也有,它经过了倒闭又重新又活回来了

1869
02:02:28,870 --> 02:02:31,410
然后现在还有一个叫统性

1870
02:02:31,870 --> 02:02:34,450
就是国内现在目前最大的两个临时体系

1871
02:02:34,450 --> 02:02:37,270
比如说一个叫麒麟软件,一个叫统性软件

1872
02:02:37,270 --> 02:02:41,690
他们都是这两年迅速的发展非常壮大

1873
02:02:42,410 --> 02:02:43,930
这是国内的代表作

1874
02:02:43,930 --> 02:02:50,170
当然国内还有几个大的公司也有自己的操作系统

1875
02:02:50,170 --> 02:02:52,970
比如说华为它有叫做OpenOLA

1876
02:02:54,210 --> 02:02:57,570
它取的名字OpenOLA其实也是一个Ninth-Stage表型

1877
02:02:59,690 --> 02:03:02,590
大家知道跟华为打得比较厉害的是谁

1878
02:03:03,090 --> 02:03:05,830
国内的是阿里巴巴

1879
02:03:05,830 --> 02:03:07,590
阿里巴巴有一个什么超级系统呢

1880
02:03:08,130 --> 02:03:10,210
阿里巴巴有一个叫做龙稀超级系统

1881
02:03:11,290 --> 02:03:13,970
龙就是中国的龙 稀那稀的稀

1882
02:03:14,570 --> 02:03:16,970
龙稀超级系统 这是阿里巴巴在推的

1883
02:03:17,830 --> 02:03:19,230
你说阿里巴欧除了超级系统

1884
02:04:49,690 --> 02:04:52,450
还有谁 我应该说了一个

1885
02:04:52,450 --> 02:04:55,630
对 字节我要去说头条 是吧

1886
02:04:55,630 --> 02:04:56,710
或者抖音

1887
02:04:57,290 --> 02:04:59,710
做应用放到一定阶段之后

1888
02:04:59,710 --> 02:05:02,950
它发现这些应用越来越复杂 越来越广泛

1889
02:05:02,950 --> 02:05:03,810
不是单个应用

1890
02:05:03,810 --> 02:05:09,530
它就需要一个更适合它应用的一套操作系统来管理它

1891
02:05:09,530 --> 02:05:12,630
所以他们也确实是有原因的

1892
02:05:12,630 --> 02:05:17,150
但是像麒麟和统性这两个当然不太一样

1893
02:05:17,530 --> 02:05:19,110
他创立公司的时候

1894
02:05:19,110 --> 02:05:20,470
他就说我要做超级股

1895
02:05:21,410 --> 02:05:23,390
做超级股的目的是给别人用

1896
02:05:23,390 --> 02:05:24,350
不是做自己用

1897
02:05:25,170 --> 02:05:26,730
这一点是不太一样

1898
02:05:26,730 --> 02:05:30,270
所以你会发现他们虽然都号称是有自己的OS

1899
02:05:30,270 --> 02:05:34,630
但是OS的出发点和用处是不一样的

1900
02:05:34,630 --> 02:05:35,990
这是稍微有点商业了

1901
02:05:35,990 --> 02:05:37,370
但大家可以稍微了解一下

1902
02:05:37,370 --> 02:05:39,750
更于大家将来找公司的时候知道怎么去找

1903
02:05:40,390 --> 02:05:44,590
我个人看好是有应用需求的公司去做OS

1904
02:05:44,590 --> 02:05:46,410
这样它的针对性会更强一些

1905
02:05:47,770 --> 02:05:51,030
好 那我说的这一块是Linux的家族简单介绍一下

1906
02:05:51,030 --> 02:05:53,350
再介绍一下个人电脑

1907
02:05:53,350 --> 02:05:56,230
到了70年代末 80年代初的时候

1908
02:05:57,030 --> 02:06:01,510
计算机的硬件发展非常迅速 成本下降很快

1909
02:06:01,510 --> 02:06:03,590
所以贝尔盖茨就说了一句话

1910
02:06:03,590 --> 02:06:07,330
他希望每一个人的家里面都有一台电脑

1911
02:06:08,630 --> 02:06:12,690
这个梦想在80年代其实就逐步成为现实

1912
02:06:12,690 --> 02:06:14,110
因为个人电脑出现了

1913
02:06:44,750 --> 02:06:48,070
那些买的是要开发软件,要去做一些应用

1914
02:06:48,070 --> 02:06:51,310
这里面是直接去做应用,它不可能开发软件

1915
02:06:51,310 --> 02:06:55,010
你能看到干啥?那时候就是显示一些漂亮的图片

1916
02:06:55,010 --> 02:06:57,550
然后开发一个电子表格,可以用来算账

1917
02:06:57,550 --> 02:06:59,870
算我的个人所得税等等

1918
02:06:59,870 --> 02:07:01,270
这是当时典型的应用

1919
02:07:01,270 --> 02:07:05,770
从面向一般家庭中可能存在的应用

1920
02:07:05,770 --> 02:07:10,330
文字处理,一些基本的数字计算

1921
02:07:10,330 --> 02:07:12,970
用来完成一些计算就OK了

1922
02:07:12,970 --> 02:07:17,850
所以它的应用是相对于我们的前面讲的应用来说要简单很多

1923
02:07:17,850 --> 02:07:18,690
这是一个特点

1924
02:07:18,690 --> 02:07:22,910
第二个特点 硬件的能力很便宜

1925
02:07:22,910 --> 02:07:26,110
能力其实不如那些小型机和大型机

1926
02:07:26,110 --> 02:07:27,710
硬件也很简单

1927
02:07:27,710 --> 02:07:30,050
硬件简单 应用也很简单

1928
02:07:30,050 --> 02:07:32,570
这就使得一个什么特点

1929
02:07:32,570 --> 02:07:36,370
OS其实不需要像unix那么强大的超级统化

1930
02:07:37,090 --> 02:07:39,370
它需要的是一种非常简单的超级统化

1931
02:08:09,370 --> 02:08:12,770
超级统的能力在弱化 它的功能在弱化

1932
02:08:13,530 --> 02:08:17,490
它其实在早期的单用户超级统里面

1933
02:08:17,490 --> 02:08:19,290
单个人计算机的超级统里面

1934
02:08:19,290 --> 02:08:22,430
它是对以往超级统的一个退化

1935
02:08:23,530 --> 02:08:25,250
所以我在你们念书那时候

1936
02:08:25,690 --> 02:08:28,250
其实刚上大学的时候就是用DOS比较多

1937
02:08:28,250 --> 02:08:30,390
那时候我们非常高兴的是

1938
02:08:30,390 --> 02:08:33,170
经常可以把这个机器给搞崩了

1939
02:08:33,890 --> 02:08:36,230
你现在好像搞崩还不太容易 是吧

1940
02:08:36,230 --> 02:08:39,250
你要写个程序 电量不足了

1941
02:08:39,570 --> 02:08:42,130
我对呀 我这个应该可以撑的时间比较长

1942
02:08:43,650 --> 02:08:44,930
稍等一下 我要通大电

1943
02:09:16,990 --> 02:09:24,770
嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,

1944
02:09:25,270 --> 02:09:34,450
嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,

1945
02:09:34,450 --> 02:09:39,210
嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯,嗯

1946
02:09:44,490 --> 02:09:50,730
那时候一个典型的特点是病毒特别猖狂

1947
02:09:51,950 --> 02:09:54,750
就是我们的兴趣点就是怎么去写一个病毒程序

1948
02:09:54,750 --> 02:09:56,170
可以把机器给控制起来

1949
02:09:56,170 --> 02:09:57,810
或者能够实现这种传播

1950
02:09:57,810 --> 02:10:00,410
那时候我们计算机系的同学对这个感兴趣

1951
02:10:00,410 --> 02:10:01,850
跟现在同学感兴趣的不太一样

1952
02:10:01,850 --> 02:10:05,270
现在同学没有谁对写病毒感兴趣

1953
02:10:07,130 --> 02:10:08,030
然后这一个

1954
02:10:08,030 --> 02:10:09,190
第二个就是我们在计算机系的计算机系

1955
02:10:39,190 --> 02:10:41,170
要实现更复杂的GUI管理

1956
02:10:41,170 --> 02:10:43,490
这时候我就发现传统的DOS已经不够用

1957
02:10:43,490 --> 02:10:47,650
它不得不开发类似于Unix的Windows NT超级图

1958
02:10:48,550 --> 02:10:51,030
那么Windows NT从哪来的

1959
02:10:51,030 --> 02:10:54,730
至少它的GUI界面是超的Mac

1960
02:10:55,950 --> 02:10:57,790
超的Mac的这个界面

1961
02:10:57,790 --> 02:11:00,870
当时就是Jobs和比尔·盖茨

1962
02:11:00,870 --> 02:11:02,830
他们之间是一个

1963
02:11:02,830 --> 02:11:04,110
应该是

1964
02:11:04,110 --> 02:11:10,090
伯利也是一个非常相互之间很认可的竞争对手

1965
02:11:10,090 --> 02:11:11,770
就是都很佩服对方

1966
02:11:11,770 --> 02:11:15,510
当然更多的是喬布斯会看不起比尔盖茨

1967
02:11:15,510 --> 02:11:18,710
但其实他们是我觉得是非常好的一对朋友

1968
02:11:18,710 --> 02:11:20,590
竞争上的竞争关系的朋友

1969
02:11:20,990 --> 02:11:24,450
那么MACWISE的GUI界面其实也是抄的

1970
02:11:24,450 --> 02:11:28,930
抄的是斯勒公司打印机公司

1971
02:11:28,930 --> 02:11:31,310
他们开了一个研究中心

1972
02:11:31,310 --> 02:11:33,430
那个中心里面设计出了鼠标

1973
02:11:33,430 --> 02:11:34,910
设计出了GI系统

1974
02:11:34,910 --> 02:11:36,650
然后他们去参观了一次

1975
02:11:36,650 --> 02:11:38,270
然后把你们的核心人员挖过来

1976
02:11:38,270 --> 02:11:39,650
自己开发自己的MacOS

1977
02:11:41,050 --> 02:11:45,390
然后Jobs就是当看到比尔盖茨的时候

1978
02:11:45,390 --> 02:11:46,690
比尔盖茨一开始的时候

1979
02:11:46,690 --> 02:11:47,630
我要跟你合作

1980
02:11:47,630 --> 02:11:49,030
我要把我们的Office

1981
02:11:49,030 --> 02:11:50,590
要把我们的软件

1982
02:11:50,590 --> 02:11:52,570
要放到这个Mac上面去

1983
02:11:52,570 --> 02:11:53,670
那Jobs说 好啊

1984
02:11:53,670 --> 02:11:54,970
你给我开发应用挺好的

1985
02:11:54,970 --> 02:11:55,770
我负责超级组

1986
02:11:55,770 --> 02:11:57,350
超级组具有管理权

1987
02:11:57,350 --> 02:11:58,550
但比尔盖茨

1988
02:11:58,550 --> 02:12:00,530
当看到他这个MacOS的界面之后

1989
02:12:00,530 --> 02:12:02,630
然后他回去就去做了一个Windows

1990
02:12:04,810 --> 02:12:08,670
然后Jobs就骂比尔盖茨说你是一个小偷

1991
02:12:09,350 --> 02:12:11,810
比尔盖茨说咱们俩彼此彼此

1992
02:12:11,810 --> 02:12:14,790
相互尊重都是小偷 所以没什么好说的

1993
02:12:14,790 --> 02:12:18,990
然后最后其实这个idea我觉得应该是

1994
02:12:18,990 --> 02:12:21,890
确实是来自于我们说的那个斯勒红斯

1995
02:12:21,890 --> 02:12:26,010
他们的研究中心应该在硅谷那边

1996
02:12:26,010 --> 02:12:28,210
那个研究中心他们的科学家做的成果

1997
02:12:28,210 --> 02:12:32,130
很快的被转变成了PC机的必备的GI系统

1998
02:12:32,130 --> 02:12:34,570
有了这个系统之后就实验了一个快速发展

1999
02:12:34,570 --> 02:12:37,250
MacOS发展到现代追求高大上

2000
02:12:37,250 --> 02:12:40,810
到现在为止也没有能够占据主流的PC市场

2001
02:12:40,810 --> 02:12:44,130
虽然大家现在用的笔记本有Mac的

2002
02:12:44,130 --> 02:12:46,770
但是其实还是小众 我理解是小众

2003
02:12:46,770 --> 02:12:49,430
像我还没用过Mac 我觉得Mac是挺好

2004
02:12:49,430 --> 02:12:53,190
但是确实我觉得它属于太高大上了一点

2005
02:12:53,190 --> 02:13:00,150
Windows 虽然界面超的 Mac

2006
02:13:00,150 --> 02:13:03,510
但它的 kernel 它并没有想超 Mac

2007
02:13:03,510 --> 02:13:05,950
Mac 的 kernel 是走着 BSD 路线

2008
02:13:05,950 --> 02:13:08,190
Windows 觉得这个 BSD 路线

2009
02:13:08,190 --> 02:13:10,570
如果都超了的话 可能有点过意不去

2010
02:13:10,570 --> 02:13:13,850
所以它从当时一个很牛的公司叫 DEC

2011
02:13:13,850 --> 02:13:19,350
DEC 公司是一个叫做数字设备公司

2012
02:13:19,350 --> 02:13:24,170
数字设备公司它当时是生产小型机特别厉害

2013
02:13:24,170 --> 02:13:26,810
所以小型机里面跑来跑去UNIX

2014
02:13:26,810 --> 02:13:30,650
它把当时的那个首席架构师叫Carter给挖过来了

2015
02:13:30,650 --> 02:13:33,290
作为Windows NT的主设计师

2016
02:13:33,290 --> 02:13:35,190
然后开发了这个所谓的Windows NT

2017
02:13:35,190 --> 02:13:38,350
Windows NT其实你可以认为来源还是UNIX

2018
02:13:38,350 --> 02:13:41,050
只是它请了一个名物人过来做主设计师

2019
02:13:41,050 --> 02:13:45,570
开发了几年之后把DOS换成了Windows NT

2020
02:13:45,570 --> 02:13:49,410
这就是我们说Windows操纯的Kernel叫Windows NT

2021
02:13:49,410 --> 02:13:51,890
Kernel那么他还专门一本书

2022
02:13:51,890 --> 02:13:53,350
大家有兴趣可以看一看

2023
02:13:53,350 --> 02:13:58,110
叫《官子》就微软怎么去创建NT的

2024
02:13:58,110 --> 02:14:00,790
他里面讲到这个Cutler

2025
02:14:00,790 --> 02:14:02,590
怎么一个疯狂的一个角色

2026
02:14:02,590 --> 02:14:04,930
把一般人管得特别难受

2027
02:14:04,930 --> 02:14:06,210
最后不管怎么难受

2028
02:14:06,210 --> 02:14:08,090
还是开发出来这个Windows NT

2029
02:14:08,090 --> 02:14:10,590
一直到现在 现在叫Wind 11了是吧

2030
02:14:10,590 --> 02:14:11,890
我这跑的也是Wind 11

2031
02:14:11,890 --> 02:14:15,550
其实和第一代的Windows NT的Kernel是一样的

2032
02:14:15,990 --> 02:14:18,570
只是有些小的改变 核心没有变化

2033
02:14:19,730 --> 02:14:22,530
所以我们站在OS的角度来看Windows

2034
02:14:23,610 --> 02:14:27,410
可能没变化 变化的只是界面

2035
02:14:27,410 --> 02:14:29,310
界面其实变化也不大

2036
02:14:29,310 --> 02:14:35,050
我们看到的是在桌面占统治地位的超级统

2037
02:14:35,050 --> 02:14:36,570
Windows超级统

2038
02:14:38,430 --> 02:14:42,090
这是80年代到90年代的发展情况

2039
02:14:42,090 --> 02:14:43,650
到了90年代之后

2040
02:14:43,650 --> 02:14:46,390
有一个重要的一个计算机的一个领域

2041
02:14:46,390 --> 02:14:48,210
办得非常迅速 就是网络

2042
02:14:48,210 --> 02:14:53,430
Internet逐渐成为一个非常广泛的一个基础设施

2043
02:14:53,430 --> 02:14:54,730
在这个情况下呢

2044
02:14:54,730 --> 02:14:57,610
我们就自然想到我能不能把一些

2045
02:14:57,610 --> 02:14:59,830
我们前面讲的计算机

2046
02:14:59,830 --> 02:15:01,830
都是超级系统是管单机的

2047
02:15:01,830 --> 02:15:03,950
这个时候想要是超级系统能不能管多个机

2048
02:15:03,950 --> 02:15:07,130
就所谓的我把多个机器有一个超级系统管起来

2049
02:15:07,130 --> 02:15:08,570
使得应用程序开发出来之后

2050
02:15:08,570 --> 02:15:09,570
我这应用程序跑到哪个机器上

2051
02:15:09,570 --> 02:15:10,650
其实我不care

2052
02:15:11,290 --> 02:15:13,070
这样应用程序更加方便

2053
02:15:13,070 --> 02:15:14,070
这个想法很好

2054
02:15:15,210 --> 02:15:19,510
请问大家已经体会到这种分布式操作系统的一些好处了没有

2055
02:15:19,510 --> 02:15:21,070
有谁用过分布式操作系统

2056
02:15:23,230 --> 02:15:26,070
分布式操作系统 有谁用过吗

2057
02:15:30,370 --> 02:15:36,250
如果你的目标是说让应用程序完全不用感知到

2058
02:15:36,250 --> 02:15:40,290
它这个程序跑在一堆机器中的哪一台机器上面

2059
02:15:40,290 --> 02:15:45,430
这个目标如果做到了的话 它就是一种典型的分布式超级统

2060
02:15:45,430 --> 02:15:50,390
因为超级统建立一种透明性和抽象 使得我们的应用程序不用care这个

2061
02:15:50,390 --> 02:15:51,030
事情

2062
02:15:53,090 --> 02:15:57,310
但是超级统发觉要这么去做的话比较困难

2063
02:15:57,310 --> 02:16:02,050
这个困难就是虽然应用程序很easy了 但是我们的OS很困难

2064
02:16:02,050 --> 02:16:04,590
所以我们发现到目前为止

2065
02:16:04,590 --> 02:16:10,730
我们说这种让应用程序无感的去使用一堆机器

2066
02:16:10,730 --> 02:16:14,510
这么一个超音笼其实还不够成熟

2067
02:16:14,510 --> 02:16:19,210
并没有一个公司做出这么一个产品给大家广泛使用

2068
02:16:19,210 --> 02:16:20,750
巡述业有过尝试

2069
02:16:20,750 --> 02:16:23,490
但是并没有这个怎么说呢

2070
02:16:23,490 --> 02:16:25,950
并没有这个普遍使用

2071
02:16:25,950 --> 02:16:26,930
既然做到这一步

2072
02:16:26,930 --> 02:16:27,570
那怎么办

2073
02:16:27,930 --> 02:16:32,930
我们还是希望让很多机器为一个应用来做服务

2074
02:16:33,330 --> 02:16:35,570
那能想到一点就是让应用复杂一点

2075
02:16:36,290 --> 02:16:39,570
所以你会发现我们要开发分布式应用

2076
02:16:40,290 --> 02:16:42,470
成为越来越多的一种尝试

2077
02:16:42,470 --> 02:16:45,070
早期的分布式应用用在科学计算里面

2078
02:16:45,070 --> 02:16:46,510
比如说我们的那个科学计算里面

2079
02:16:46,510 --> 02:16:49,310
要用一个集群系统来算一道题

2080
02:16:49,310 --> 02:16:50,410
你会发现那个应用程序

2081
02:16:50,410 --> 02:16:53,030
它要意识到有多个机器的存在

2082
02:16:53,030 --> 02:16:56,510
然后现在你们在开发安卓应用的时候

2083
02:16:56,510 --> 02:16:59,570
其实你也知道你写的一些数据

2084
02:16:59,570 --> 02:17:00,730
其实不是在本地处理

2085
02:17:00,730 --> 02:17:02,470
是在Data Center里面处理

2086
02:17:02,470 --> 02:17:03,590
这也是分布式应用

2087
02:17:03,590 --> 02:17:05,710
只是让这个应用稍微更加简单点

2088
02:17:05,710 --> 02:17:07,930
通过一些编译的手段

2089
02:17:07,930 --> 02:17:12,130
通过一些所谓的一些酷的手段

2090
02:17:12,130 --> 02:17:13,030
让它更加简单点

2091
02:17:13,030 --> 02:17:14,290
但总的来说

2092
02:17:14,290 --> 02:17:15,850
超级系统直接支持

2093
02:17:15,850 --> 02:17:17,970
透明的支持分布式的环境

2094
02:17:17,970 --> 02:17:19,310
这一点还挺难做到

2095
02:17:20,990 --> 02:17:22,970
那有没有人就这种尝试

2096
02:17:23,450 --> 02:17:23,770
还有

2097
02:17:24,390 --> 02:17:25,810
这个就说到

2098
02:17:25,810 --> 02:17:29,450
其实我们教研机系就有老师在做他们的尝试

2099
02:17:31,530 --> 02:17:33,010
大家可能不了解

2100
02:17:33,010 --> 02:17:34,790
我们系里面有没有几个院士

2101
02:17:34,790 --> 02:17:37,290
其中有一个院士叫张浩学院士

2102
02:17:37,810 --> 02:17:41,470
张浩学院士他提过一个idea叫透明计算

2103
02:17:41,470 --> 02:17:43,110
这个透明计算他有一个idea

2104
02:17:43,110 --> 02:17:46,850
我觉得是说的和分布式超日系统是很相近的

2105
02:17:47,910 --> 02:17:50,710
他说应用程序在运行的时候

2106
02:17:50,710 --> 02:17:52,070
它可以流动

2107
02:17:52,070 --> 02:17:53,610
可以从服务器流到终端

2108
02:17:53,610 --> 02:17:55,030
可以从终端流到服务器

2109
02:17:55,030 --> 02:17:59,730
至于流动呢,是由底下那一层超级桶来管理的

2110
02:17:59,730 --> 02:18:01,330
OK,这是一个基本的idea

2111
02:18:01,730 --> 02:18:04,970
就是根据当前的使用情况,让程序自由地流动

2112
02:18:04,970 --> 02:18:07,390
但是我程序本身我不需要care我在哪里运行

2113
02:18:08,070 --> 02:18:09,670
这挺好的一个idea

2114
02:18:09,670 --> 02:18:11,310
但这个idea太难实现

2115
02:18:11,310 --> 02:18:14,610
到目前为止,我也觉得它只是在学术界

2116
02:18:14,610 --> 02:18:17,210
还没有真正去实现

2117
02:18:17,210 --> 02:18:18,770
将来能不能实现,也许能实现

2118
02:18:18,770 --> 02:18:21,090
因为当你的进一步的技术设施

2119
02:18:21,090 --> 02:18:24,930
比如说你的网络,你的助理器能力进一步增强

2120
02:18:25,030 --> 02:18:26,070
也许可以做到

2121
02:18:26,070 --> 02:18:30,210
但到目前为止我觉得这个很好 idea 这一块分布系统这一块还没有做到

2122
02:18:30,210 --> 02:18:33,750
所以我们看到我们现在我提的名字都不叫分布式操作系统

2123
02:18:33,750 --> 02:18:35,290
叫分布式系统

2124
02:18:35,290 --> 02:18:37,630
大家将来有兴趣的话

2125
02:18:37,630 --> 02:18:39,570
可以看看分布系统里面讲的课程

2126
02:18:39,570 --> 02:18:41,150
这是一门研究生的课程

2127
02:18:41,150 --> 02:18:44,910
是由我们的陈康老师来主讲的

2128
02:18:45,470 --> 02:18:50,130
他直接follow了MIT的一个课叫Morris

2129
02:18:50,130 --> 02:18:51,630
Robert Morris

2130
02:18:53,710 --> 02:18:55,350
那个老师也非常厉害

2131
02:18:55,870 --> 02:18:58,150
他在写乳虫病毒的一个老师

2132
02:18:58,150 --> 02:18:59,050
他上了两门课

2133
02:18:59,050 --> 02:19:00,750
超级等课和分布式系统课

2134
02:19:01,970 --> 02:19:04,150
然后这边就是落到我上超级等课

2135
02:19:04,150 --> 02:19:05,670
陈康老师上分布系统课

2136
02:19:05,670 --> 02:19:07,250
就是人家一个老师上两门课

2137
02:19:07,250 --> 02:19:10,030
我们说两个老师上课上一门课

2138
02:19:12,850 --> 02:19:14,670
好 我们再看一个

2139
02:19:14,670 --> 02:19:18,030
就是现在也号称是有一定分布式的

2140
02:19:18,030 --> 02:19:19,930
一个特征的一个超级等课叫安卓超级等课

2141
02:19:20,670 --> 02:19:22,770
你光看这个超级统本身就有点小

2142
02:19:22,770 --> 02:19:23,910
大家都可以看出来

2143
02:19:23,910 --> 02:19:25,710
底下就是一个Linux kernel

2144
02:19:25,710 --> 02:19:27,910
这是谷歌做的一个设计

2145
02:19:27,910 --> 02:19:29,850
然后它的interface是什么

2146
02:19:29,850 --> 02:19:32,610
这是它的interface 这是绿色的一堆库

2147
02:19:32,610 --> 02:19:37,030
如果kernel本身的interface就是一套标准的Syscore

2148
02:19:37,490 --> 02:19:40,810
但是这一套标准的Syscore并没有暴露给应用程序

2149
02:19:40,810 --> 02:19:44,270
应用程序为了能够去访问这个Linux kernel的interface

2150
02:19:44,270 --> 02:19:46,290
中间还隔了两大层

2151
02:19:46,290 --> 02:19:48,090
一层是那个Java的运营池

2152
02:20:18,150 --> 02:20:21,970
比如说开发出来一个刚才说的一个电话应用

2153
02:20:21,970 --> 02:20:25,630
开发出一个什么视频浏览器的应用

2154
02:20:25,630 --> 02:20:27,750
都很简单 因为它把webview

2155
02:20:27,750 --> 02:20:31,230
就是等于是browser的核心也封装成了一个组件

2156
02:20:31,230 --> 02:20:33,930
那只要调它就可以实现所谓的这个browser的功能

2157
02:20:33,930 --> 02:20:36,470
就所谓一行代码就开发了一个浏览器

2158
02:20:36,470 --> 02:20:39,830
因为它封装的足够高 可以走到这一步

2159
02:20:41,030 --> 02:20:42,870
那使得我们就开发所谓的application

2160
02:20:42,870 --> 02:20:48,250
那么我们把整个这个application之下的这一堆东西

2161
02:20:48,250 --> 02:20:51,890
蓝色的、绿色的、红色的把它称之为安卓超级统

2162
02:20:51,890 --> 02:20:55,990
那这个超级统不是我们这门课重点讲的

2163
02:20:55,990 --> 02:21:00,110
我们重点讲的跟它相关的是最底下这个所谓的Ninth kernel

2164
02:21:00,110 --> 02:21:03,790
它用了一些共性的一些超级统的一些核心技术

2165
02:21:03,790 --> 02:21:05,290
这是我们要去关注的

2166
02:21:05,290 --> 02:21:08,270
讲上面的其他课程将来有其他一些课程会去讲

2167
02:21:10,850 --> 02:21:14,590
另外一类就是现在发展的比较快的叫AIoT超级

2168
02:21:14,590 --> 02:21:17,290
所谓快的就是说它还没有成为主流

2169
02:21:18,450 --> 02:21:20,750
大家或多或少能感觉到一些应用的存在

2170
02:21:20,750 --> 02:21:23,770
但并没有一个很好的YSM去支持它

2171
02:21:23,770 --> 02:21:24,930
这什么意思呢

2172
02:21:24,930 --> 02:21:28,470
它需要去管理现在能够联网的多个设备

2173
02:21:28,470 --> 02:21:30,610
这个设备目前还不是给人用的

2174
02:21:30,610 --> 02:21:34,330
是给一些设备和设备之间进行一些互操作

2175
02:21:34,970 --> 02:21:36,730
这个情况是越来越普遍的

2176
02:21:36,730 --> 02:21:48,050
比如说我能看到的 现在国内有三个公司在上面做了很多探索

2177
02:21:48,050 --> 02:21:54,010
一个是华为 华为它做了另外一个我还是号称叫Open鸿蒙

2178
02:21:54,010 --> 02:21:57,390
Open鸿蒙超级的鸿蒙的一个最大的特点

2179
02:21:57,390 --> 02:22:00,550
叫实现设备级的跨网络的一个访问

2180
02:22:00,550 --> 02:22:02,990
就是我写个应用程序 我访问一个浏览器

2181
02:22:02,990 --> 02:22:05,310
这个浏览器可以位于另一个设备上的一个浏览器

2182
02:22:05,310 --> 02:22:07,310
它能够跨 至于我写应用程序的时候

2183
02:22:07,310 --> 02:22:09,550
我根本不用care这个浏览器

2184
02:22:10,270 --> 02:22:12,630
这个摄像头在哪个地方 不用关注

2185
02:22:12,630 --> 02:22:14,670
这个是由底层的超线帮我管

2186
02:22:14,670 --> 02:22:17,190
是Open红红 其实了解这个分布式

2187
02:22:17,190 --> 02:22:18,930
还有一个词叫分布式软组线

2188
02:22:18,930 --> 02:22:20,350
通过分布式软组线能够把

2189
02:22:21,950 --> 02:22:24,570
分布式系统中的各个设备合在一起

2190
02:22:24,570 --> 02:22:25,810
给应用程序来访问

2191
02:22:25,810 --> 02:22:28,510
应用程序不用关注底层的分布的特征

2192
02:22:28,510 --> 02:22:30,810
这就是一种我们说的分布式系统

2193
02:22:30,810 --> 02:22:32,670
想要达到的一个目标吧

2194
02:22:33,870 --> 02:22:37,570
第二个 这是停留在现在的一个前期的阶段

2195
02:22:37,570 --> 02:22:40,450
第二个 其实大家可能看了更多的

2196
02:22:40,450 --> 02:22:42,270
至少我们家里面用的比较多的

2197
02:22:42,270 --> 02:22:43,870
我夫人比较喜欢小米的东西

2198
02:22:43,870 --> 02:22:45,130
发现她买了一堆

2199
02:22:45,130 --> 02:22:50,070
一开始买了一个小米的电视

2200
02:22:50,070 --> 02:22:53,950
玩完电视之后又发现扫地机器人比较不错

2201
02:22:53,950 --> 02:22:55,990
然后又看了手机也不错

2202
02:22:55,990 --> 02:22:59,150
通过手机可以控制电视和机器人

2203
02:22:59,150 --> 02:23:01,610
最后又买了摄像头 也可以控制摄像头

2204
02:23:01,610 --> 02:23:05,930
就发现这些分布式的设备在小米的手机上全可以完成管理和控

2205
02:23:05,930 --> 02:23:06,370
制

2206
02:23:06,370 --> 02:23:09,250
当然那个手机还是一个安卓手机

2207
02:23:09,250 --> 02:23:11,330
那超级勇是不是已经具有AoT的特征呢

2208
02:23:11,330 --> 02:23:13,070
其实已经具有了一定的AoT特征

2209
02:23:13,070 --> 02:23:14,790
因为它能跑的程序

2210
02:23:14,790 --> 02:23:19,290
我也不用关注这个程序管理的设备是不是在这几台机上

2211
02:23:19,290 --> 02:23:20,990
其实已经分布在不同的地方

2212
02:23:20,990 --> 02:23:27,150
通过现在的5G或者通过现在史类的Wi-Fi

2213
02:23:27,150 --> 02:23:29,510
就可以对这些设备进行有效的管理

2214
02:23:29,510 --> 02:23:32,330
这也是一种 虽然还没有上升到AIoT超系统

2215
02:23:32,330 --> 02:23:34,070
但其他的往这条路上的发展

2216
02:23:34,070 --> 02:23:36,390
在那个设备端 它需要去能够实现

2217
02:23:36,390 --> 02:23:37,950
所有设备之间的互联互通的步骤

2218
02:23:37,950 --> 02:23:41,810
这就是我们说AIoT里面存在的一个特点

2219
02:23:41,810 --> 02:23:44,490
第三个特点 我觉得这不是横步式的特点

2220
02:23:44,490 --> 02:23:46,070
是A的特点 AI

2221
02:23:46,070 --> 02:23:50,010
AI是人工智能 目前来说

2222
02:23:50,010 --> 02:23:52,090
这一块我们现在还没有涉及到

2223
02:23:52,950 --> 02:23:56,090
就是在超支系统的眼里

2224
02:23:56,090 --> 02:23:57,650
大家认为人工智能是什么

2225
02:24:28,270 --> 02:24:30,810
现在目前有一些研究领域是怎么能够去

2226
02:24:31,190 --> 02:24:35,730
通过AI的一些技术能够用在OS里面

2227
02:24:35,730 --> 02:24:37,850
来提升OS的使用效率

2228
02:24:37,850 --> 02:24:38,830
举个例子

2229
02:24:38,830 --> 02:24:41,870
前几天就有一个单位一个公司找到

2230
02:24:41,870 --> 02:24:44,010
通过系里找到我说

2231
02:24:44,010 --> 02:24:46,450
你能不能开发一个超级桶

2232
02:24:46,450 --> 02:24:50,150
它能够去分析这个应用的行为

2233
02:24:50,150 --> 02:24:52,690
从而可以预测这个应用是一个恶意的应用

2234
02:24:52,690 --> 02:24:54,650
还是一个好的应用

2235
02:24:56,050 --> 02:24:59,710
这就是分析程序行为 就和分析人的行为是一样的

2236
02:24:59,710 --> 02:25:01,950
你可以通过AI的技术来分析这个行为

2237
02:25:01,950 --> 02:25:05,290
但是这个分析的过程 你可以在OS里面来做

2238
02:25:05,290 --> 02:25:06,910
因为OS可以管这个应用

2239
02:25:06,910 --> 02:25:12,050
它自然可以得到更多应用本身的行为的数据

2240
02:25:12,050 --> 02:25:16,450
从而可以通过某种方式来完成对它的一个预测

2241
02:25:16,450 --> 02:25:19,730
这也是一种 比如说把AI技术用在操作里面的一种方式

2242
02:25:19,730 --> 02:25:22,850
这是AILT 我们认为是下一代的一个趋势

2243
02:25:23,390 --> 02:25:27,630
在国外和我刚才提的两个公司做了一个类似的事情

2244
02:25:27,630 --> 02:25:28,890
就是谷歌做了一个

2245
02:25:30,570 --> 02:25:31,870
这是它第三个超级统合

2246
02:25:31,870 --> 02:25:33,930
它现在做了一个Chrome OS

2247
02:25:33,930 --> 02:25:35,050
做了一个安卓

2248
02:25:35,050 --> 02:25:37,250
又做了一个Fusion

2249
02:25:37,250 --> 02:25:38,390
这是第三个OS

2250
02:25:38,390 --> 02:25:40,930
这个OS变相就是IoT领域的一个OS

2251
02:25:40,930 --> 02:25:43,510
就想实现我们前面达到了说Open鸿蒙

2252
02:25:43,510 --> 02:25:44,850
想做的目标

2253
02:25:45,410 --> 02:25:47,030
分布式的设备能合在一起

2254
02:25:47,030 --> 02:25:49,570
这个已经开发了四年了

2255
02:25:49,570 --> 02:25:50,870
到现在为止还没有公布

2256
02:25:50,870 --> 02:25:53,350
可以发现它原码 但它并没有广泛使用

2257
02:25:53,350 --> 02:25:54,910
中间碰到什么困难 我们还不知道

2258
02:25:54,910 --> 02:25:58,930
只是说它们内部有几百号人 上千号人在做

2259
02:25:58,930 --> 02:26:01,170
但是目前为止还没有完全公开

2260
02:26:01,170 --> 02:26:05,090
所以大家不知道它将来做出来是一个什么样的特征

2261
02:26:05,090 --> 02:26:06,670
这是我们看到的情况

2262
02:26:07,970 --> 02:26:10,770
OK 我就把历史简单的给大家过了一下

2263
02:26:10,770 --> 02:26:12,910
可以看到就是OS

2264
02:26:12,910 --> 02:26:14,810
有些人可能觉得OS是一成不变的

2265
02:26:14,810 --> 02:26:15,670
其实OS一直在变

2266
02:26:16,730 --> 02:26:19,530
它只要你的应用在变 你的应验在变

2267
02:26:19,530 --> 02:26:21,530
你的Y是要跟着变。

2268
02:26:27,770 --> 02:26:28,890
还有两分钟。

2269
02:26:30,890 --> 02:26:34,250
我好像比较能吹牛,所以还有两节没讲。

2270
02:26:40,250 --> 02:26:43,930
第四节,第五节。

2271
02:26:45,230 --> 02:26:50,570
第五节其实大家,我觉得主要是动手啊,大家动动手,我动动嘴,大家动动手就

2272
02:26:50,570 --> 02:26:51,290
OK

2273
02:26:51,710 --> 02:26:55,930
咱们先把这个,四姐稍微看两分钟就讲到哪儿

2274
02:26:57,670 --> 02:27:03,090
超级组结构,第一种结构讲最差的结构,一般从简单到复杂

2275
02:27:03,090 --> 02:27:08,250
前面会出的那个在PC时代,统治PC计算机的超级组MS-DOS

2276
02:27:08,250 --> 02:27:12,290
就是应用和YS混在一起,他们之间没有任何的隔离

2277
02:27:12,290 --> 02:27:15,590
所以很容易破坏整个系统

2278
02:27:15,590 --> 02:27:18,310
这是我们当时常用的一种架构

2279
02:27:19,350 --> 02:27:21,030
DOS是用汇边写的

2280
02:27:21,030 --> 02:27:22,750
所以也非常底层

2281
02:27:22,750 --> 02:27:24,090
也不具有可疑之性

2282
02:27:24,090 --> 02:27:26,750
所以我们认为它是一个OS的倒退

2283
02:27:26,750 --> 02:27:31,170
但是它满足那个时候的PC机的一个配置

2284
02:27:31,170 --> 02:27:33,890
和那时候的个人用户的一个需求

2285
02:27:33,890 --> 02:27:35,510
所以它有存在的价值

2286
02:27:35,510 --> 02:27:37,190
到目前为止

2287
02:27:37,190 --> 02:27:39,990
我们还是可以在Windows里面看到DOS的影子

2288
02:27:39,990 --> 02:27:42,630
你运行在Command 那就是DOS的一个环境

2289
02:27:44,630 --> 02:27:47,670
这个单体分层结构就是我们典型的Unix结构

2290
02:27:47,670 --> 02:27:49,350
Unix第一 它比较复杂

2291
02:27:49,350 --> 02:27:54,370
它有上从几万瓦代码 甚至到几千万瓦代码

2292
02:27:54,370 --> 02:27:55,630
你在这么多行代码里面

2293
02:27:55,630 --> 02:27:58,810
占用这种所谓的单体的简单结构是很难做到的

2294
02:27:58,810 --> 02:28:01,490
它第一要把应用和OS分开

2295
02:28:01,490 --> 02:28:03,430
再要靠一些硬件的手段

2296
02:28:03,430 --> 02:28:04,430
比如说我们后面讲的

2297
02:28:04,430 --> 02:28:06,730
大家学过分页技术来把它隔开

2298
02:28:06,730 --> 02:28:10,650
第二个 它内部也要分层

2299
02:28:10,650 --> 02:28:11,950
但这个分层是逻辑分层

2300
02:28:11,950 --> 02:28:14,230
它不具有安全的一个隔离机制

2301
02:28:14,230 --> 02:28:16,450
但你逻辑上分层 这是软工的技术

2302
02:28:16,450 --> 02:28:18,130
这样大家学了软工就应该知道

2303
02:28:18,130 --> 02:28:21,130
这一个大型软件一定要化成不同的模块

2304
02:28:21,130 --> 02:28:23,230
这个模块最好是层次结构

2305
02:28:23,230 --> 02:28:24,730
上层调为下层

2306
02:28:30,290 --> 02:28:32,930
好 没讲完没关系 大家下去看一看

2307
02:28:32,930 --> 02:28:34,430
我下段会再继续补充

2308
02:28:34,430 --> 02:28:35,270
好 下课

2309
02:28:36,730 --> 02:28:37,490
謝謝

