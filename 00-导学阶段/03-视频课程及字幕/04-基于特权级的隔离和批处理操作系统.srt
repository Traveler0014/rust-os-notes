1
00:00:05,480 --> 00:00:12,760
我们开始上课 今天我们上上次继续讲上次没有上完的

2
00:00:12,760 --> 00:00:17,380
关于科学研究的隔离与批数与超级种族

3
00:00:18,400 --> 00:00:20,460
那还是稍微简单回顾一下

4
00:00:20,460 --> 00:00:24,480
我们上次课讲到的是第二节

5
00:00:25,460 --> 00:00:27,000
从官方角度看Respect

6
00:00:27,000 --> 00:00:28,980
那为什么要讲这一节是在于

7
00:00:28,980 --> 00:00:33,960
我们后续要去基于Risk 5来设计我们的P2D超级统

8
00:00:33,960 --> 00:00:37,260
那我们需要对这个硬件有所进一步的深入了解

9
00:00:37,260 --> 00:00:39,800
而不是光知道说他们这样有隔离

10
00:00:39,800 --> 00:00:40,840
有特权级

11
00:00:40,840 --> 00:00:42,980
那具体这些特权级怎么用

12
00:00:42,980 --> 00:00:46,100
这个是需要大家去了解和掌握的

13
00:00:46,100 --> 00:00:50,360
所以我们讲就是这一小节

14
00:00:50,360 --> 00:00:53,620
重点是要去了解Risk 5的几个模式

15
00:00:53,620 --> 00:00:57,160
关于它的U Mode S Mode M Mode等等

16
00:00:57,160 --> 00:01:01,000
以及我觉得更困难的一点是什么呢

17
00:01:01,000 --> 00:01:02,780
是这个,是他们这种转换

18
00:01:02,780 --> 00:01:05,720
这个转换这一块其实是

19
00:01:07,200 --> 00:01:09,540
我们的一个比较困难的地方

20
00:01:09,540 --> 00:01:11,240
大家在实验中

21
00:01:11,840 --> 00:01:13,900
软硬件协同怎么能把事情搞定

22
00:01:13,900 --> 00:01:16,760
这一块其实是我们要去重点考虑的

23
00:01:18,920 --> 00:01:20,920
好,我们看看就是

24
00:01:21,440 --> 00:01:22,340
为了能够讲这个

25
00:01:22,340 --> 00:01:25,200
我们就是在这里面介绍了

26
00:01:25,200 --> 00:01:29,760
关于Risk5里面的这个相关的系统编程的一块细节

27
00:01:29,760 --> 00:01:31,260
我们上堂课讲到的

28
00:01:31,260 --> 00:01:32,880
我看我这个相中小点

29
00:01:33,760 --> 00:01:35,540
讲到的就是

30
00:01:36,800 --> 00:01:38,700
这些相关的一些术语

31
00:01:38,700 --> 00:01:39,620
术语挺多的

32
00:01:39,620 --> 00:01:42,200
你会发现OS英特点的它术语比较多

33
00:01:42,200 --> 00:01:46,500
那么其实也没必要去去去实际啊

34
00:01:46,500 --> 00:01:49,080
就是还是结合到你讲的那个地方

35
00:01:49,080 --> 00:01:50,020
就老实讲那个地方

36
00:01:50,020 --> 00:01:51,320
你看那个地方呢

37
00:01:51,320 --> 00:01:52,540
你看得不清楚的

38
00:01:52,540 --> 00:01:53,480
再回去查就行了

39
00:01:53,480 --> 00:02:03,220
我觉得这个就稍微省事一点,这是这一块,我这个先过一下,这是我们上堂课都讲过

40
00:02:03,220 --> 00:02:03,480
的。

41
00:02:12,660 --> 00:02:20,820
好,那上堂课我觉得我开了头,关于这个我们说我们想设计特效级很重要的

42
00:02:20,820 --> 00:02:21,720
目的是什么呢?隔离。

43
00:02:21,720 --> 00:02:27,480
那隔离呢,有三个方面,三个层次的隔离,或者三个维度的隔离

44
00:02:27,480 --> 00:02:32,200
一个是所谓的控制权,就是你执行指令,指令代表一定的权力

45
00:02:32,200 --> 00:02:40,440
指令需要防止应护态的应用,能够去执行一些可能会破坏系统的指

46
00:02:40,440 --> 00:02:40,540
令

47
00:02:40,540 --> 00:02:43,800
这一块涉及到所谓的权力这一块

48
00:02:43,800 --> 00:02:49,980
第二个呢,时间,因为我们GID的资源是有限的,你需要在特别是CPU资源

49
00:02:49,980 --> 00:02:53,100
我们不希望说如果只有一个CPU的情况下

50
00:02:53,100 --> 00:02:56,520
你不希望应用程序一直站着那个CPU不放

51
00:02:56,520 --> 00:02:58,180
所以一定要有种机制

52
00:02:58,180 --> 00:02:59,780
能够说我这个时间上来说

53
00:02:59,780 --> 00:03:05,780
我要能够限制或者是管理我们的应用

54
00:03:05,780 --> 00:03:09,300
能够不让它随时长期的占用处理器

55
00:03:09,300 --> 00:03:10,940
第三个是数据

56
00:03:10,940 --> 00:03:14,580
数据就是说内核有些数据很重要

57
00:03:14,580 --> 00:03:16,300
如果应用程序知道这些数据的话

58
00:03:16,300 --> 00:03:17,980
它会可能做一些非法事情

59
00:03:17,980 --> 00:03:21,380
所以我们需要能够在数据上也要防止

60
00:03:21,380 --> 00:03:26,300
应用程序看到内核或者其他应用的一些数据

61
00:03:26,300 --> 00:03:27,360
这就是三个层面

62
00:03:27,360 --> 00:03:28,600
为了这三个层面

63
00:03:28,600 --> 00:03:31,260
我们会进一步讲解它这个硬件上做了什么事情

64
00:03:31,260 --> 00:03:32,320
当然这是overview

65
00:03:32,320 --> 00:03:33,460
这还是overview

66
00:03:33,460 --> 00:03:37,760
那么后面几个实验都会和这个有或多或少的关系

67
00:03:37,760 --> 00:03:40,980
我们大致是先把这个战争应用

68
00:03:40,980 --> 00:03:45,980
来了解一下Mesh5的一些相关的软硬件的一些细节

69
00:03:46,740 --> 00:03:52,780
好,那这是我们上一堂课讲到的,就是我们写应用程序的时候,其实不需要去了解受

70
00:03:52,780 --> 00:03:56,960
限级,大家想想你写应用程序的时候,你不需要去了解怎么去管进程,怎么去管

71
00:03:56,960 --> 00:03:58,920
这个终端异常处理。

72
00:03:59,340 --> 00:04:05,040
我们写的更多就是大家在组成员理科上上到控制指令,能够跳出来,能

73
00:04:05,040 --> 00:04:11,100
够调用,能够去做逻辑运算和算数运算,OK,基本上到这里打住了。

74
00:04:12,080 --> 00:04:17,200
但是国王有那些操作不足以去管理竞争机系统

75
00:04:17,200 --> 00:04:18,600
而我们既然写OIS的话

76
00:04:18,600 --> 00:04:22,100
你就需要去了解怎么去构造超级统

77
00:04:22,100 --> 00:04:25,400
那也意味着你要会对这里面说的S-MOD

78
00:04:25,400 --> 00:04:27,660
这一块S-MOD有一个比较清楚的了解

79
00:04:27,660 --> 00:04:31,580
甚至会涉及到M-MOD的一部分的知识

80
00:04:31,580 --> 00:04:33,980
这个知识虽然不是我们的重点

81
00:04:33,980 --> 00:04:36,140
但是大家需要去了解

82
00:04:41,080 --> 00:04:43,760
好 那我们讲一个例子

83
00:04:44,580 --> 00:04:46,200
就是一般来说你要讲一个流程

84
00:04:46,200 --> 00:04:47,040
可能更好理解

85
00:04:47,040 --> 00:04:49,580
就是为什么这个Mode存在

86
00:04:49,580 --> 00:04:51,600
Mode这些怎么能够去进行交互

87
00:04:51,600 --> 00:04:52,420
就是我们的软件

88
00:04:52,420 --> 00:04:53,440
怎么能够在不同的Mode中

89
00:04:53,440 --> 00:04:54,900
来做相应的一些操作

90
00:04:54,900 --> 00:04:56,020
那举一个很简单的例子

91
00:04:56,020 --> 00:04:57,180
就是还是Hello World

92
00:04:58,180 --> 00:04:59,900
这个大家一开始学编程的时候

93
00:04:59,900 --> 00:05:01,740
都会知道有个Hello World的程序

94
00:05:01,740 --> 00:05:02,740
你用哪种语

95
00:05:02,740 --> 00:05:05,080
你用牌子 用C 用Java

96
00:05:05,080 --> 00:05:06,120
你可以用非常短的一个程序

97
00:05:36,640 --> 00:05:38,880
其实对于很多应用程序开发员来说

98
00:05:38,880 --> 00:05:40,080
他已经不需要care了

99
00:05:40,600 --> 00:05:42,600
他知道有这个函数会帮你干这个事情

100
00:05:42,600 --> 00:05:46,200
但你作为我们说系统程序员

101
00:05:46,860 --> 00:05:48,700
那我们需要一个从上到下

102
00:05:48,700 --> 00:05:51,280
从里到外的一个更全面的了解

103
00:05:51,280 --> 00:05:52,980
你这样才能够知道

104
00:05:52,980 --> 00:05:55,140
才能更深刻的理解救人机系统

105
00:05:55,140 --> 00:05:58,720
其实我记得我之前有一次课就说过

106
00:05:58,720 --> 00:06:00,200
我们上OS课不是说

107
00:06:00,200 --> 00:06:03,140
只是简单的说希望大家能够就是会写ROS

108
00:06:03,140 --> 00:06:04,500
这个不是一个根本的目的

109
00:06:04,500 --> 00:06:05,540
根本目的是说

110
00:06:05,540 --> 00:06:07,800
你们能够更深刻地理解救援机系统

111
00:06:07,800 --> 00:06:10,380
这个救援机系统是由软件硬件合在一起的

112
00:06:10,380 --> 00:06:11,400
还帮你构成

113
00:06:11,400 --> 00:06:13,540
我们看这个站在

114
00:06:14,240 --> 00:06:16,260
我们非常简单的OS角度

115
00:06:16,860 --> 00:06:19,160
比如说我们这堂课会讲到的

116
00:06:19,160 --> 00:06:19,920
皮书理操系统

117
00:06:19,920 --> 00:06:22,360
这里面如果有一个程序

118
00:06:22,360 --> 00:06:23,720
要打印一个print一个hello world

119
00:06:23,720 --> 00:06:25,180
它大致是走个过程

120
00:06:25,180 --> 00:06:27,540
确实你看我们前面这一块

121
00:06:29,780 --> 00:06:31,380
这是我们通常说的

122
00:06:31,380 --> 00:06:33,440
一般的各种语言写的print

123
00:06:34,840 --> 00:06:38,060
它在内部会调一个酷的函数

124
00:06:38,060 --> 00:06:39,520
这个是一个酷的函数

125
00:06:39,520 --> 00:06:40,920
这函数举个例子

126
00:06:40,920 --> 00:06:43,380
具体怎么实现的 我们不介意

127
00:06:43,380 --> 00:06:44,360
我们不用去关注

128
00:06:44,360 --> 00:06:45,960
我们只要能够知道有个uprint

129
00:06:45,960 --> 00:06:49,260
或者printf或者println等等

130
00:06:49,260 --> 00:06:50,740
这些就够了

131
00:06:50,740 --> 00:06:52,240
但这个酷里面

132
00:06:53,020 --> 00:06:54,280
它会发现

133
00:06:54,280 --> 00:06:55,240
你们会进去发现

134
00:06:55,240 --> 00:07:00,300
它实际上它会去有一个操作

135
00:07:00,300 --> 00:07:04,620
能够实现从用户态到内核态的切换

136
00:07:04,620 --> 00:07:06,500
这一点靠什么

137
00:07:06,500 --> 00:07:09,100
不同的体结构有不同的一些做法

138
00:07:09,100 --> 00:07:14,960
对于我们的Risk5而言

139
00:07:14,960 --> 00:07:17,300
它有一条特殊的指令叫ECO

140
00:07:18,980 --> 00:07:21,140
这条指令能够帮助我们完成

141
00:07:21,140 --> 00:07:22,940
从用户态到内核态的切换

142
00:07:23,480 --> 00:07:24,380
那么切换工具之后

143
00:07:24,380 --> 00:07:25,440
它会把相应的参数

144
00:07:25,440 --> 00:07:27,220
传递给我们内核的一个

145
00:07:29,440 --> 00:07:33,160
他会进一步去整理相应的一些参数

146
00:07:33,820 --> 00:07:35,140
然后要不然是他自己

147
00:07:35,140 --> 00:07:37,040
要不然是他在求追下一层

148
00:07:37,040 --> 00:07:38,580
我们说的下一层还有M mode

149
00:07:38,580 --> 00:07:41,560
M mode下面有一个SPI软件

150
00:07:41,560 --> 00:07:46,020
通过他能够完成对driver的一个

151
00:07:46,020 --> 00:07:48,120
对我们的外设的一个操作

152
00:07:48,120 --> 00:07:49,500
从软件之后给打出来

153
00:07:49,500 --> 00:07:52,820
那么他也是一样走了一个eco

154
00:07:52,820 --> 00:07:54,900
所以有一个阻值的eco

155
00:07:54,900 --> 00:07:56,820
这个指令来帮助我们完成了一个

156
00:07:56,820 --> 00:07:58,380
用它来给它切换

157
00:07:58,380 --> 00:08:02,580
那我想问的是,我们这个为什么不直接调查呢?

158
00:08:02,660 --> 00:08:04,320
其实按道理来说,它可以直接调查

159
00:08:12,820 --> 00:08:16,320
我还是认为大家都是很了解的同学

160
00:08:17,100 --> 00:08:19,860
对上午的组成员有课

161
00:08:19,860 --> 00:08:24,500
我想问一下,在我们现在这个简单的小例子里面

162
00:08:24,500 --> 00:08:30,460
我那个Uprint能直接照过WriteSTR夹线Q,所以WriteSTR直接不走这个E

163
00:08:30,460 --> 00:08:32,440
Q,直接就是一个方形Q,很喜欢。

164
00:08:33,560 --> 00:08:34,360
为什么不行?

165
00:08:40,920 --> 00:08:48,960
对,这个同学说的是照了数码Q,如果是照了代码Q,我把那个EQ换成

166
00:08:48,960 --> 00:08:52,640
一个正常的方形Q,不行吗?为啥不行?

167
00:08:57,140 --> 00:09:02,680
你现在在U-Mode,U-Mode里面执行的指令是一般的指令,就是

168
00:09:02,680 --> 00:09:03,860
非特权指令。

169
00:09:04,480 --> 00:09:12,360
那么这个Rant是讲的SYS、SYS Rant,这个里面有特权指令吗?有

170
00:09:12,360 --> 00:09:17,300
没有特权指令?如果是有特权指令的一个函数,我可以教你为什么不教。

171
00:09:57,740 --> 00:10:08,320
你会了解到这个函数和sret是在另外一个回去的地方

172
00:10:08,320 --> 00:10:12,220
我们看如果把这个在按下面的话

173
00:10:12,220 --> 00:10:13,020
你会发现

174
00:10:15,900 --> 00:10:17,300
对在这

175
00:10:17,820 --> 00:10:18,720
在这里面

176
00:10:19,360 --> 00:10:21,620
swrite其实只是那个

177
00:10:22,180 --> 00:10:23,460
我们内核动作一小部分

178
00:10:23,460 --> 00:10:25,920
其实只是这是一个框架

179
00:10:26,460 --> 00:10:28,080
在swrite里看那个函数里面

180
00:10:28,080 --> 00:10:29,200
其实没有srit

181
00:10:29,960 --> 00:10:32,440
swrite只是一个正常的函数

182
00:10:32,440 --> 00:10:33,820
如果你去看代码的话

183
00:10:34,340 --> 00:10:35,920
它那个srit

184
00:10:35,920 --> 00:10:37,660
这种人很清楚的知道有个srit

185
00:10:37,660 --> 00:10:39,420
就这里面就个srit这个指令

186
00:11:09,420 --> 00:11:14,020
这只是它中间的一个故事,没画完。所以你直接只是看那个SysWrite的话,它没有

187
00:11:14,020 --> 00:11:14,820
任何特征之类的。

188
00:11:17,880 --> 00:11:21,700
所以大家不要机械地理解这里面的东西。

189
00:11:21,860 --> 00:11:28,020
那第二问题,按道理来说,我确实这一块SysWrite是OS的一个函数,虽

190
00:11:28,020 --> 00:11:28,680
然它没有特征之类,

191
00:11:28,680 --> 00:11:36,120
为什么它不能够保护到让我们的用户太直接电用这个函数?它为什么保护不了?

192
00:11:41,080 --> 00:11:50,000
这说明了一点,光靠特权指令不足以阻止我们的用户派程序去访

193
00:11:50,000 --> 00:11:56,100
问本来属于OS的那段代码或者数据,其实代码也是数据。

194
00:11:56,280 --> 00:12:00,780
它缺少了一个什么?缺少了一个我们后面讲的,大家都学过只是没想到用了这

195
00:12:00,780 --> 00:12:04,320
儿,页表,靠G存把它管起来。

196
00:12:04,320 --> 00:12:09,060
除非我这儿搞个页表说这个地方是一个页表管的一块区域

197
00:12:09,060 --> 00:12:11,180
这个地方是页表管的一个区域

198
00:12:11,180 --> 00:12:12,840
那么你如果想直接调查

199
00:12:12,840 --> 00:12:14,460
因为在访问这个地址里面的内容

200
00:12:14,460 --> 00:12:16,780
在月件那会产生异常

201
00:12:16,780 --> 00:12:21,580
但现在我们讲的这堂课里面还没设计到页表

202
00:12:21,580 --> 00:12:23,620
所以说你这儿碰不到

203
00:12:23,620 --> 00:12:26,220
OK 大家有没有问题 有问题要尽快提

204
00:12:27,020 --> 00:12:33,200
所以我觉得大家需要灵活地理解这个特权指令

205
00:12:33,200 --> 00:12:37,760
特权及以及相应的一些保护机制

206
00:12:37,760 --> 00:12:39,200
它们的关系和区别

207
00:12:49,200 --> 00:12:54,060
我们前面说 如果你内核里面的函数没有特权指令

208
00:12:54,060 --> 00:12:57,140
其实我的用户态的程序可以直接调内函数

209
00:12:57,140 --> 00:13:01,940
但是如果用户态的程序里面我有特性指令

210
00:13:01,940 --> 00:13:04,280
或者内核它的那个函数里面的特性指令的话

211
00:13:04,280 --> 00:13:06,640
你再去调 它会出现什么情况呢

212
00:13:06,640 --> 00:13:07,860
就会出现异常

213
00:13:07,860 --> 00:13:09,600
所以我们还给了一个小例子

214
00:13:09,600 --> 00:13:12,120
就在用户带执行特性指令

215
00:13:12,120 --> 00:13:14,180
你会发现当用户带执行特性指令的时候

216
00:13:14,180 --> 00:13:16,660
它当前属于U mode的

217
00:13:16,660 --> 00:13:19,880
那么我们在check的时候

218
00:13:19,880 --> 00:13:21,880
会发现在U mode下

219
00:13:21,880 --> 00:13:24,160
你执行的一条特性指令 它就会报错

220
00:13:24,160 --> 00:13:26,340
OK 那我就想问一下同学

221
00:13:26,340 --> 00:13:28,660
你们在设计DPU的时候

222
00:13:29,700 --> 00:13:30,800
有这个考虑吗

223
00:13:30,800 --> 00:13:34,240
你们的CPU在执行的时候,有考虑当天处于哪个mode吗?

224
00:13:35,940 --> 00:13:43,100
是有一条判断,是吧?如果当天是Umode,还是Mode,还是Smode,然后说哪些

225
00:13:43,100 --> 00:13:44,640
指令会有个check,OK。

226
00:13:44,700 --> 00:13:46,960
那大家在进入这个问题就OK了,但是其实一点问题没有。

227
00:13:47,660 --> 00:13:51,860
那这是在做处理器的时候,我们知道有一个当天处于哪个mode。

228
00:13:52,280 --> 00:13:56,940
到现在我的问题是,你们现在是写过S了,你不是写处理器了。

229
00:13:57,940 --> 00:14:06,740
如果是写方式,或者写应用,我知道我当天处于哪些模式吗?

230
00:14:06,960 --> 00:14:08,200
能吗? 不能。

231
00:14:10,940 --> 00:14:12,940
没有一个直接的方法知道什么。

232
00:14:13,200 --> 00:14:15,080
那我问题是,为什么没有直接的方法知道?

233
00:14:18,220 --> 00:14:21,280
我觉得身为OS,应该知道我当天处于什么状态。

234
00:16:21,280 --> 00:16:23,840
这两个可能大家没看到WFI是等待中断的

235
00:16:23,840 --> 00:16:26,620
就当前我现在它是一种省电的方式

236
00:16:26,620 --> 00:16:29,600
我当前如果没有任何的一些事情要做的时候

237
00:16:29,600 --> 00:16:31,600
OS可以执行WSI

238
00:16:31,600 --> 00:16:33,900
使这一团一个省电状态

239
00:16:33,900 --> 00:16:35,460
直到中断来它可以继续做

240
00:16:35,460 --> 00:16:38,300
这是一个特殊的指令

241
00:16:38,300 --> 00:16:39,440
下面两条指令呢

242
00:16:39,440 --> 00:16:45,860
像SFANS-BMA和SFANS-INUS都是和Cache-TOB相关的

243
00:16:45,860 --> 00:16:47,520
这个对我们应用程序来说也是不care

244
00:16:47,520 --> 00:16:48,660
但是对我们OS来说

245
00:16:48,660 --> 00:16:49,660
你需要知道的是说

246
00:16:50,040 --> 00:16:56,700
当TOB的内容或者Cache的内容和内存中的页表或者是Memory

247
00:16:56,700 --> 00:16:58,680
你们的数据不一致的情况下

248
00:16:58,680 --> 00:17:01,960
那么我们需要通过这种方式来把它刷掉

249
00:17:01,960 --> 00:17:05,220
就是把TOB给刷掉或者把Cache刷掉 就干这个事情

250
00:17:05,220 --> 00:17:09,580
这样可以保证说你接下来CPU读的数据一定要从Memory中写

251
00:17:09,940 --> 00:17:14,040
这是保证数据的正确性 需要这两条指令

252
00:17:14,040 --> 00:17:18,940
这是特殊的指令 没了 接下来的指令就是一些通用的指令

253
00:17:19,680 --> 00:17:23,540
接下来这些还有很多管理指令是不是通过指令本身

254
00:17:23,540 --> 00:17:32,660
而是通过FENCE 写错了

255
00:17:33,220 --> 00:17:33,840
有bug

256
00:17:35,420 --> 00:17:36,900
OK 这个肯定很好

257
00:17:36,900 --> 00:17:38,960
就是帮我们敲bug

258
00:17:38,960 --> 00:17:45,340
我们确实老师在做这个时候会有一些失误

259
00:17:45,340 --> 00:17:46,880
后面会改掉

260
00:17:48,320 --> 00:17:54,160
那第二个就是说,我们说还有很多其他的一些系统级的控制,它不是靠特殊指令,

261
00:17:54,300 --> 00:17:56,300
而是靠一些计程器来帮我们搞定。

262
00:17:56,420 --> 00:18:01,100
这叫SETAR,就是我们前面讲到的控制状态计程器,通过这个控制状

263
00:18:01,100 --> 00:18:05,040
态计程器的夺写来完成对整个系统的一个管理。

264
00:18:07,100 --> 00:18:13,080
接下来我们讲了这个特权指令法,这要讲什么呢?讲M目的编程和S

265
00:18:13,080 --> 00:18:13,620
目的编程。

266
00:18:13,620 --> 00:18:17,260
所谓是M1编程,M1编程大家大致了解,

267
00:18:17,460 --> 00:18:21,900
你可以看到说在M1最底层到底没干哪些事情,

268
00:18:22,060 --> 00:18:24,780
这个是大家需要去看的,先看M1的,

269
00:18:24,780 --> 00:18:29,280
M1其实是最底层的一个特权级,

270
00:18:29,420 --> 00:18:32,560
在这里面它会涉及到什么,主要是一些中章异常的处理,

271
00:18:33,080 --> 00:18:35,820
那中章异常处理,我们需要了解硬件做了啥,

272
00:18:36,000 --> 00:18:40,620
软件能做啥,把这个搞清楚就行,这一块我会过得稍微快一点。

273
00:18:42,380 --> 00:18:46,900
那首先简单介绍iMode,iMode是Machine Mode的一个简称

274
00:18:46,900 --> 00:18:52,100
那么它是Risk5中CPU HDRT Hardware Thread KDEV

275
00:18:52,100 --> 00:18:54,400
它就是我们说的那个CPU或者CPU Core

276
00:18:54,400 --> 00:18:55,500
就这边有东西

277
00:18:55,880 --> 00:18:59,740
它的处理器的最高全线模式

278
00:18:59,740 --> 00:19:02,660
那么它可以对整个浏览器系统的底层功能有完全的使用权

279
00:19:03,640 --> 00:19:07,280
它主要干的事情就是处理异常和中断

280
00:19:08,940 --> 00:19:10,780
这个简单介绍

281
00:19:10,780 --> 00:19:12,680
你看到跟它相关的一堆计程器

282
00:19:12,680 --> 00:19:14,260
你要去记吧 我觉得没必要记

283
00:19:14,260 --> 00:19:16,220
大致看一看 还是说观点

284
00:19:16,220 --> 00:19:18,480
你看 然后后面发现有这个复语

285
00:19:18,480 --> 00:19:19,920
或者用到这个复语 不知道是啥

286
00:19:19,920 --> 00:19:21,480
反正再查一查

287
00:19:21,480 --> 00:19:24,000
通过来归的几遍 你就大致知道了

288
00:19:24,000 --> 00:19:24,920
大致你也看出来

289
00:19:24,920 --> 00:19:26,600
我大致说一下 所有这些计程器

290
00:19:26,600 --> 00:19:33,460
你看到大部分都是和终端异常的产生处理相关

291
00:19:33,460 --> 00:19:35,120
跟这些处理相关

292
00:19:35,120 --> 00:19:36,580
这里面会有一个简单介绍

293
00:19:36,580 --> 00:19:41,080
像mstatus,表明是当前我在mmode下的一些状态

294
00:19:41,080 --> 00:19:44,220
比如说这个状态下,它之前产生中断的时候

295
00:19:44,220 --> 00:19:46,960
比如说在fmod或者在umod产生中断的时候

296
00:19:48,380 --> 00:19:53,160
什么一个情况,这个是我当前允允许产生中断等等

297
00:19:53,160 --> 00:19:55,300
这都是在mstatus里面会有记录

298
00:19:55,300 --> 00:19:58,660
它所谓保存了一些当前的全局的一些状态

299
00:19:58,660 --> 00:20:02,100
细节我不讲,我觉得大家可以记着可以看

300
00:20:02,100 --> 00:20:03,600
那为什么要写这么详细呢?

301
00:20:03,600 --> 00:20:08,300
在于这也是主缘的老师给我们一个经验

302
00:20:08,300 --> 00:20:11,740
他说很多同学他觉得老师讲得也挺啰嗦的

303
00:20:11,740 --> 00:20:12,520
他自己看就行了

304
00:20:12,520 --> 00:20:14,220
他自己看需要比较详细的内容

305
00:20:14,220 --> 00:20:15,220
所有的列字

306
00:20:15,220 --> 00:20:16,720
他可以仔细的去看一看

307
00:20:16,720 --> 00:20:18,620
这样第一不用听老师讲

308
00:20:18,620 --> 00:20:20,000
第二还看得比较清楚

309
00:20:21,120 --> 00:20:23,260
第二个就是叫M-CORSE计算器

310
00:20:23,260 --> 00:20:24,840
M-CORSE计算器CORSE原因

311
00:20:25,160 --> 00:20:26,940
很棒的也就是说

312
00:20:26,940 --> 00:20:28,620
产生异常或者产生终端的时候

313
00:20:28,620 --> 00:20:30,060
那么它这个M-CORSE计算器里面

314
00:20:30,060 --> 00:20:32,060
记录了异常终端的一个编号

315
00:20:32,060 --> 00:20:37,480
那么到底是异常还是中断,取决于这个bit,最高位的一个bit,这个bit是1代表

316
00:20:37,480 --> 00:20:43,460
中断,不是0代表异常,这不是硬件在响应异常中断的时候,它去硬件做

317
00:20:43,460 --> 00:20:43,780
的事情。

318
00:20:43,960 --> 00:20:49,660
我们软件干什么,软件把它读出来,只要它读出来就知道什么原因了。第三位就是中断

319
00:20:49,660 --> 00:20:50,720
阶值,hammer。

320
00:20:51,480 --> 00:21:00,160
hammer我们说是我们后面要接触的很重要的一个机制。这个机制有hammer之后,我们

321
00:21:00,160 --> 00:21:01,980
可以干什么呢?就可以解决我们第二个阶值。

322
00:21:02,060 --> 00:21:05,060
应用程序它实战的处理器不换

323
00:21:05,060 --> 00:21:07,500
一旦有Timer之后 它会产生中断

324
00:21:07,500 --> 00:21:08,660
中断就会重新用过它

325
00:21:08,660 --> 00:21:11,020
你无论在哪个程序上 它会回到OS里面去

326
00:21:11,020 --> 00:21:12,020
回到S Mode

327
00:21:12,020 --> 00:21:16,900
回到S Mode之后 因为它可以抢占当前进行在U Mode的软件

328
00:21:16,900 --> 00:21:21,800
就可以让我们的应用程序不能够长期的占用处理器了

329
00:21:21,800 --> 00:21:24,920
所以这个Timer 我们的OS要想得到控制权

330
00:21:24,920 --> 00:21:26,160
你就要把Timer设好

331
00:21:26,160 --> 00:21:30,640
这样可以保证一到中断产生 我就可以得到响应

332
00:21:33,060 --> 00:21:39,760
除了这些东西之外,我们前面说的都是在哪里,都是在这一块,这一块

333
00:21:39,760 --> 00:21:49,720
是处理器,那么其实还有一块,这一大块,这一块是外设,外设的内容其实

334
00:21:49,720 --> 00:21:51,260
远大于处理器内容。

335
00:21:52,060 --> 00:21:57,620
这里面举的例子是一个当前目前能拿到的最高端的Risk 5处理器,

336
00:21:58,360 --> 00:22:00,700
就是一个适合的PC级别的处理器。

337
00:22:00,700 --> 00:22:05,940
那么我们后面会发现你除了对于中断而言

338
00:22:05,940 --> 00:22:07,280
它是更多是外设中断

339
00:22:07,280 --> 00:22:10,740
那外中断的会有一个P-derive-C

340
00:22:10,740 --> 00:22:13,080
这么一个接口在这儿

341
00:22:13,080 --> 00:22:18,060
负责来在外设和处理器之间建立元器

342
00:22:18,060 --> 00:22:21,700
能够去帮助我们处理器去及时地

343
00:22:22,940 --> 00:22:26,940
感知外设产生的各种中断

344
00:22:26,940 --> 00:22:28,260
这是这么一个结构

345
00:22:28,260 --> 00:22:29,340
大家可以说下去了

346
00:22:29,340 --> 00:22:39,160
后面很后面才会碰到 大家只要知道这么一个结构就行

347
00:22:41,320 --> 00:22:47,240
这是多了这一块 那么我们处理器要想

348
00:22:47,240 --> 00:22:50,540
能够对它有一个全球的管理 其实我有时候不想处理这么多

349
00:22:50,540 --> 00:22:55,180
那我可以Decay或者这个也是可以的 但是能不能Decay都异常

350
00:22:56,660 --> 00:22:57,440
大家想一想

351
00:22:59,100 --> 00:23:05,080
目前我们的硬件设计里面是不能够disable异常

352
00:23:05,080 --> 00:23:07,300
你可以disable中断但是不能够disable异常

353
00:23:07,300 --> 00:23:08,820
这个大家需要了解

354
00:23:08,820 --> 00:23:10,400
第二个需要了解就是说

355
00:23:10,400 --> 00:23:11,440
比如当前我在U mode

356
00:23:12,380 --> 00:23:13,820
或者当前在S mode

357
00:23:13,820 --> 00:23:15,520
我这时候产生了中断

358
00:23:15,520 --> 00:23:20,160
这时候它之前那些信息会保存在mstatus这个技能器里面

359
00:23:20,160 --> 00:23:22,740
前面已经说到这是一个记录当前状态的技能器

360
00:23:22,740 --> 00:23:26,840
而产生的那个具体的中断异常的信息放在mcost里面

361
00:23:26,840 --> 00:23:28,980
这个大家再简单了解一下

362
00:23:28,980 --> 00:23:31,120
这是硬件 那我们软件干一下

363
00:23:31,120 --> 00:23:33,180
我们先讲硬件它会当产生作用的时候

364
00:23:33,180 --> 00:23:35,420
它会把一些信息记录在一些机成器里面

365
00:23:35,420 --> 00:23:42,040
软件干了之后一直在把这些信息读出来

366
00:23:42,040 --> 00:23:44,760
像这是取得我们那个里面的代码

367
00:23:44,760 --> 00:23:49,800
这一块就读S-COS和S7VL的两个机成器里面的内容

368
00:23:49,800 --> 00:23:52,120
这两个COS机成器干什么呢

369
00:23:52,120 --> 00:23:54,540
S-COS怎么说 知道源头在哪

370
00:23:55,840 --> 00:24:05,280
第二个呢,STBAL实际上是进一步的信息,比如异常的原因,或者是中断

371
00:24:05,280 --> 00:24:07,620
的进一步的信息,就是放在STBAL里面。

372
00:24:07,680 --> 00:24:12,580
有这两个信息之后,我们就知道这个原因是啥了。知道原因之后,我们会去做相

373
00:24:12,580 --> 00:24:13,360
应的进一步的处理。

374
00:24:13,360 --> 00:24:20,360
比如说如果发觉它是一个user mode发过来的一个e-code指令

375
00:24:21,180 --> 00:24:22,220
产生了一个异常

376
00:24:22,220 --> 00:24:25,860
那么我会做对应的syscode就可以把这事情搞定

377
00:24:25,860 --> 00:24:28,880
如果没有相应的一个去做处理的话

378
00:24:28,880 --> 00:24:30,120
就会爆个panic

379
00:24:32,060 --> 00:24:33,260
这是大致的写法

380
00:24:33,260 --> 00:24:34,220
我再次强调

381
00:24:34,220 --> 00:24:36,500
我这里面其实都是讲的是示意

382
00:24:36,500 --> 00:24:39,140
并不是说给大家去详细的解释这个语法

383
00:24:39,140 --> 00:24:40,440
或者说它一定是这么做的

384
00:24:40,760 --> 00:24:46,120
因为咱们有两种这种选择,一种是用Rap,一种是用C。

385
00:24:46,400 --> 00:24:55,180
它们的C上面还是有些细微的差别,但大致思路是一样的。

386
00:24:55,180 --> 00:24:58,340
这是软件做的事情,软件就是要能够感知它。

387
00:24:58,780 --> 00:25:02,940
然后呢,软件其实后面还有一点,这后面会讲细节的,我讲到。

388
00:25:03,140 --> 00:25:06,420
刚才那个同学也提到过了,你最终感知完处理完之后,你还要回去。

389
00:25:36,480 --> 00:25:41,400
这个处理器是不知道的,这是异步的一个定义,就是未知的。

390
00:25:42,700 --> 00:25:49,100
这是软件、时钟、外部。软件你可以认为是一个call,给另一个call,要发一个终端,核

391
00:25:49,100 --> 00:25:50,660
间终端,这是软件终端。

392
00:25:50,900 --> 00:25:54,100
时钟终端这我们前面已经提到了,就是一个时钟,它会定时地产生一个终端。

393
00:25:54,180 --> 00:25:59,220
外部终端则是外设终端。那么它把所有的外设匯结为一个标题的外

394
00:25:59,220 --> 00:25:59,840
部终端。

395
00:26:00,140 --> 00:26:03,860
那具体是哪个外部终端,那我们一定还有一个机制来帮助我们找到确定

396
00:26:03,860 --> 00:26:04,380
哪个外部终端。

397
00:26:04,380 --> 00:26:11,340
我们前面说了 在处理器和外设之间

398
00:26:11,340 --> 00:26:13,960
它有一个连接的部分的PLIC

399
00:26:13,960 --> 00:26:17,960
这个就是Platform Leveled Interrupt Controller

400
00:26:18,680 --> 00:26:21,260
就是平台级的中段控制器

401
00:26:22,600 --> 00:26:25,720
这是我们说是RESPEC的一个定义而已

402
00:26:25,720 --> 00:26:26,560
但其实大家都理解

403
00:26:26,560 --> 00:26:29,800
反正对于我们的W来说也是有类似的

404
00:26:29,800 --> 00:26:30,720
对于ARM WMIPS

405
00:26:30,720 --> 00:26:36,940
各自的一个连接外饰和处理器的一个中间结构

406
00:26:36,940 --> 00:26:38,780
通常说法叫中段控制器

407
00:26:38,780 --> 00:26:40,720
只是它们后面会取写各自的名字

408
00:26:45,900 --> 00:26:49,660
这里面我们能看到的就是M course里面能列出来的

409
00:26:49,660 --> 00:26:50,720
比如中段就这么几种

410
00:26:51,820 --> 00:26:52,180
不多

411
00:26:52,820 --> 00:26:55,000
那么这个信息就是M course里面的信息

412
00:26:55,000 --> 00:26:56,380
这是中段的编号

413
00:26:56,380 --> 00:26:57,300
这是中段的含义

414
00:26:57,300 --> 00:27:02,300
这对应的是一个最高位,1代表着中段,如果是0的话,那是异常了。

415
00:27:03,560 --> 00:27:08,800
中段其实简单给大家介绍,你可以知道,中段产生之后会影响技能器,软件

416
00:27:08,800 --> 00:27:11,480
会读入技能器,然后会相应速度。

417
00:27:11,560 --> 00:27:16,260
这是一个大致的处理过程。对于异常来说,异常的种类会更多一点。

418
00:27:16,680 --> 00:27:22,420
你会发现,如果产生了异常,也会放在mcos里面,只是这里面最高的那个

419
00:27:22,420 --> 00:27:23,120
bit是0。

420
00:27:23,120 --> 00:27:25,240
证明列出了很多的异常

421
00:27:25,240 --> 00:27:28,640
那么有一个有一个异常

422
00:27:28,640 --> 00:27:30,580
我觉得应该是大家需要注意知道的

423
00:27:31,740 --> 00:27:34,760
就是我们说的这个environment code

424
00:27:35,440 --> 00:27:37,240
your code from you mode

425
00:27:37,980 --> 00:27:40,040
这个异常就是我们说

426
00:27:40,040 --> 00:27:42,280
就是我们要去软件去产生syscode

427
00:27:42,280 --> 00:27:44,260
所以你这个是要知道的

428
00:27:44,260 --> 00:27:45,680
后面还有一些需要知道的

429
00:27:45,680 --> 00:27:47,580
但这个到的时候该讲的那个时候

430
00:27:47,580 --> 00:27:48,980
我们再去理解一下

431
00:28:05,220 --> 00:28:11,220
一旦产生了异常中断之后 当前产生异常的一条指令 或者当前

432
00:28:11,220 --> 00:28:18,940
被中断打断的指令 会保存在一个特殊的解诊器MEPC里面

433
00:28:18,940 --> 00:28:23,100
那么这是一个 MEPC就是保存了当前被打断的指令 因为加了一个MEPC

434
00:28:23,100 --> 00:28:23,100
之后 当前被打断的指令会保存在一个特殊的解诊器MEPC里

435
00:28:23,100 --> 00:28:23,100
面

436
00:28:25,760 --> 00:28:31,640
第二个呢,我还跳到一个异常处理的一个地方,就是这几个MT VEC里面

437
00:28:31,640 --> 00:28:39,280
会记录那个位置,那个位置是跳到那儿去让那个函数做相应的处理。

438
00:28:40,380 --> 00:28:47,120
这是我们的硬件要去做的事情。同时呢,就是M-CORUS,MTVL,这个会把

439
00:28:47,120 --> 00:28:48,380
相应的原因给设清楚。

440
00:28:48,920 --> 00:28:54,680
所以做完之后,那么我们的CPU会跳到这儿去执行,这是它的硬件的一个选

441
00:28:54,680 --> 00:28:55,380
择过程。

442
00:29:00,760 --> 00:29:08,160
同时还有一点细节,这个细节也是比较重要的,就是如果是产生了一个中断和

443
00:29:08,160 --> 00:29:08,800
异常之后,

444
00:29:38,980 --> 00:29:41,480
它会一开始就把这个中断给禁掉

445
00:29:41,480 --> 00:29:44,120
那么什么时候enable到呢 可以软件来改它

446
00:29:45,480 --> 00:29:47,540
软件改它的原因是在于

447
00:29:47,540 --> 00:29:48,880
一旦我把这个中断退完之后

448
00:29:48,880 --> 00:29:51,680
我就应该及时地要去让我们的处理器响应程度

449
00:29:51,680 --> 00:29:54,480
所以这时候软件就可以把这个部位再给它自载

450
00:29:54,480 --> 00:29:55,760
使它可以响应程度

451
00:29:55,760 --> 00:30:00,800
这是关于这一块禁的一个理解

452
00:30:05,480 --> 00:30:07,840
好 这是硬件响应

453
00:30:07,840 --> 00:30:11,220
最后还要讲一个就是M-Mode里面比较特殊的一个处理

454
00:30:11,720 --> 00:30:14,420
就是异常中断的控制权移交

455
00:30:14,420 --> 00:30:15,980
这下说明什么意思呢

456
00:30:15,980 --> 00:30:17,780
这个就是大致的意思就是说

457
00:30:18,300 --> 00:30:19,280
在正常情况下

458
00:30:19,280 --> 00:30:20,760
就一般情况下默认情况下

459
00:30:20,760 --> 00:30:25,040
所有的异常中断都是要把控制权交给了M-Mode的

460
00:30:25,040 --> 00:30:29,980
那个MTVC那个技能器指向地址去执行的

461
00:30:29,980 --> 00:30:31,400
但是为了提高效率

462
00:30:31,400 --> 00:30:33,240
我们可以设置一下

463
00:30:33,240 --> 00:30:34,660
就在M-Mode下都要设置

464
00:30:34,660 --> 00:30:36,960
说有些中断或者异常

465
00:31:36,960 --> 00:31:40,460
就标示出来了 它把哪一些中断或者异常

466
00:31:40,460 --> 00:31:41,880
交给了XMode去处理

467
00:31:48,080 --> 00:31:49,780
另外还是需要注意一点

468
00:31:49,780 --> 00:31:52,140
发生异常和中断时 处理器控制权

469
00:31:52,140 --> 00:31:54,480
不会交给权限更低的模式

470
00:31:55,140 --> 00:31:56,180
这个怎么来理解

471
00:31:57,100 --> 00:32:01,220
就是说我们的软件可以在Mode下运行

472
00:32:01,220 --> 00:32:04,400
也可以在XMode下运行 也可以在UOE下运行

473
00:32:04,400 --> 00:32:11,000
这时候,我们前面说我已经把时钟终端委托给了Xmod去处理。

474
00:32:12,040 --> 00:32:17,840
其实那个时钟终端更多是说,如果是运行在Umod或者是Xmod下的处理

475
00:32:17,840 --> 00:32:18,420
器,

476
00:32:18,460 --> 00:32:23,260
在运行的时候产生这个终端,那个终端是在Xmod上去处理。

477
00:32:23,620 --> 00:32:28,540
但如果我现在正在Mod上运行这个软件,产生了一个时钟终端,

478
00:32:28,700 --> 00:32:31,880
那么它一定是在Mod上去处理的。

479
00:32:31,880 --> 00:32:35,480
不会说回到一个低温级的软件去处理

480
00:32:35,480 --> 00:32:38,020
这是要保证这个全线的一个平衡

481
00:32:38,020 --> 00:32:40,200
你不能说高温级下来执行

482
00:32:40,200 --> 00:32:42,340
结果让低温级去处理了

483
00:32:42,340 --> 00:32:45,580
我们相信的是底层的软件

484
00:32:45,580 --> 00:32:47,580
这个性能都是一层一层

485
00:32:47,580 --> 00:32:49,160
全线有高违约性能

486
00:32:49,160 --> 00:32:50,740
所以这一点大家需要注意

487
00:32:50,740 --> 00:32:51,960
就是所谓的这个土地线的控制权

488
00:32:51,960 --> 00:32:53,700
不会交给全线更低的模式

489
00:32:53,700 --> 00:32:56,200
这是一个基本的一个设计原则

490
00:32:58,460 --> 00:33:11,240
好,我讲完之后简单出两个小题,如果我出一个小的练习题,就是这两

491
00:33:11,240 --> 00:33:15,700
个题,如何通过断点异常来实现调试器的断点调试功能。

492
00:33:46,000 --> 00:33:53,340
其实我们这里面,你们有实现过EBREAK吗,CPU做CPU的时候,那你们应该知道

493
00:33:53,340 --> 00:33:58,860
了,那就是EBREAK,没错,我如果要收断点的话,我会把断点的位置插

494
00:33:58,860 --> 00:33:59,920
一个EBREAK,

495
00:34:00,740 --> 00:34:04,540
修完这个地方要保存的某个地方,这样一旦处理器执行到EBREAK之

496
00:34:04,540 --> 00:34:05,840
后,就会先到OS,

497
00:34:06,220 --> 00:34:10,340
它也是一个异常,跟E4一样,从用台到那个它的线路。

498
00:34:10,960 --> 00:34:17,700
然后操作一种就可以让我们的Debug完成对我们的被调制成绩的一个控制。

499
00:34:17,820 --> 00:34:19,960
就这么一个处理过程。

500
00:34:20,560 --> 00:34:22,400
包括单不跟踪也是一样的。

501
00:34:22,680 --> 00:34:26,220
就是实际上用到了我们的一个特殊的指令叫Ebrick。

502
00:34:28,480 --> 00:34:31,640
好,那这块就简单的给大家说了。

503
00:34:31,660 --> 00:34:33,300
然后再说下sMode编程。

504
00:34:33,300 --> 00:34:37,200
S-MODE变成这个其实和M-MODE很类似

505
00:34:37,200 --> 00:34:38,660
但是还是有点区别

506
00:34:38,660 --> 00:34:39,500
我们可以看看

507
00:34:40,300 --> 00:34:43,880
S-MODE它主要是要实现避免

508
00:34:43,880 --> 00:34:45,580
U-MODE的APP执行越权指令

509
00:34:45,580 --> 00:34:48,440
非法地址或长期佔用处理器

510
00:34:48,440 --> 00:34:50,320
让U-MODE的APG能够得

511
00:34:50,320 --> 00:34:51,820
还要能够让U-MODE的APG

512
00:34:51,820 --> 00:34:54,960
要得到S-MODE的服务

513
00:34:54,960 --> 00:34:56,380
就是说你除了隔离之外

514
00:34:56,380 --> 00:34:58,720
还是要有一定程度的交互

515
00:34:58,720 --> 00:34:59,560
还是要交互

516
00:34:59,560 --> 00:35:00,940
不是彻底的隔离

517
00:35:00,940 --> 00:35:02,300
所以这需要软件协同

518
00:36:05,760 --> 00:36:08,360
是在SIE技能器里面设置的

519
00:36:08,360 --> 00:36:10,780
SIP是当前产生的终端

520
00:36:10,780 --> 00:36:11,600
它会有个记录

521
00:36:11,600 --> 00:36:12,980
就是SIP heading

522
00:36:12,980 --> 00:36:14,040
当前还没有

523
00:36:14,040 --> 00:36:15,020
遗产还没有处理的

524
00:36:15,020 --> 00:36:16,700
技能器放在这个SIP里

525
00:36:17,380 --> 00:36:19,520
这话我也会稍微过一下

526
00:36:20,040 --> 00:36:22,280
S-CORS跟前面那个M-CORS

527
00:36:22,280 --> 00:36:23,820
是类似的

528
00:36:23,820 --> 00:36:25,660
它的反应是一样的

529
00:36:25,660 --> 00:36:26,980
只是它的量会少一点

530
00:36:26,980 --> 00:36:31,160
它没有MO的那么多

531
00:36:31,160 --> 00:36:32,240
那么这里面

532
00:36:32,240 --> 00:36:35,440
就把STVC稍微有详细的介绍了一下

533
00:36:36,040 --> 00:36:38,560
因为我们需要去设置这个技能器

534
00:36:38,560 --> 00:36:40,780
使它指向相应的中段

535
00:36:40,780 --> 00:36:44,160
我们叫Handler的地址

536
00:36:44,160 --> 00:36:45,420
这有两种设置方式

537
00:36:45,420 --> 00:36:47,600
我们其实选择了Mode0这种方式

538
00:36:47,600 --> 00:36:49,100
也意味着所有的异常和中断

539
00:36:49,100 --> 00:36:50,460
它会到同一个路口

540
00:36:50,460 --> 00:36:51,720
这是这一块

541
00:36:54,680 --> 00:36:57,120
硬件这一块就非常简单的

542
00:36:57,120 --> 00:36:59,420
硬件的描述简单介绍完毕

543
00:36:59,420 --> 00:37:01,060
然后第二看看还是一样

544
00:37:01,580 --> 00:37:06,260
我们硬件的动作是啥,就是当它产生了异常之后,我们硬件要做哪些

545
00:37:06,260 --> 00:37:06,840
事情。

546
00:37:08,740 --> 00:37:11,680
还是一样,它其实和MODE也是比较类似的。

547
00:37:11,740 --> 00:37:17,520
但前提是在于,我们MODE的SBI已经委托了我们的SMODE去响

548
00:37:17,520 --> 00:37:21,020
应终端和异常,它要委托它。

549
00:37:21,280 --> 00:37:28,700
这样,一旦委托之后,那么硬件会在产生终端的异常之下,会做以下

550
00:37:28,700 --> 00:37:29,740
三步重要的事情。

551
00:37:30,860 --> 00:37:37,120
把异常中断的指令存在SEPC,设置PC为STVEC,这是第一步。

552
00:37:37,360 --> 00:37:44,380
就是保存异常的那个地址,设置要翘转的地址,然后设置原因S-COR

553
00:37:44,380 --> 00:37:45,140
PS STVEO,

554
00:37:45,820 --> 00:37:53,180
然后呢,Disable中断,保存之前的那个SIE位,是否允许中断的位会保存

555
00:37:53,180 --> 00:37:54,180
在SPIE里。

556
00:37:54,180 --> 00:37:58,960
这是一个wake,也是在之类的上面,相当于看它通过设置一系列集成器,

557
00:37:59,260 --> 00:38:06,580
完成一个当前被打断的状态的保存,以及要到场的地址的一个设置。

558
00:38:07,480 --> 00:38:13,460
但需要注意这个状态,它只是保存非常早的信息,而光频的信息不足以能

559
00:38:13,460 --> 00:38:15,000
够恢复回去继续执行。

560
00:38:15,380 --> 00:38:20,400
所以我们需要软件去配合,软件还要把进一步的能够确保能够正确

561
00:38:20,400 --> 00:38:22,640
恢复的那些状态信息要保留起来。

562
00:38:22,740 --> 00:38:26,520
那些通用集团器也需要通过我们的软件来保证,但这个不属于硬件

563
00:38:26,520 --> 00:38:27,000
干的事情。

564
00:38:27,360 --> 00:38:34,100
因为发现硬件干的事情非常少,这是MIPS和RISC-V他们的设计理念,硬

565
00:38:34,100 --> 00:38:38,240
件尽量简单,让给软件更大的灵活性。

566
00:38:38,720 --> 00:38:41,640
你如果看X86就不一样,X86会帮我们干更多的事情。

567
00:38:41,640 --> 00:38:48,120
它们的设计是硬件干尽量多的火,让我们的软件少干两个,这是两

568
00:38:48,120 --> 00:38:49,960
者都在设计处理机上的一个不同。

569
00:38:51,960 --> 00:38:55,740
设置完之后,就会跳到stbc刚才你示好的地址去继续执行。

570
00:38:56,060 --> 00:39:02,520
那么这个时候呢,它当前的执行状态就是Smod,它因为它有把设成当成S

571
00:39:02,520 --> 00:39:06,480
mod,然后呢,所有的执行就是在Smod上执行。

572
00:39:08,620 --> 00:39:12,480
如果我们要能够正常的去在OS里面去处理这个事情

573
00:39:12,880 --> 00:39:14,780
我们一定会有一个过程 第一个处理化

574
00:39:14,780 --> 00:39:20,220
所以你会编写一个类似于TruePanel这么一个函数

575
00:39:20,220 --> 00:39:22,020
来完成这个处理化过程

576
00:39:22,020 --> 00:39:24,120
第二要把这个STV是一个设置好

577
00:39:24,120 --> 00:39:25,960
这种处理化要干的事情

578
00:39:25,960 --> 00:39:27,780
然后设置好之后

579
00:39:27,780 --> 00:39:32,280
也意味着当我们的真产生硬件产生一个异常中断之后

580
00:39:32,280 --> 00:39:39,640
那我们就可以根据前面的这个,这个地方来跳到川普汉顿里面去,然后去相应

581
00:39:39,640 --> 00:39:46,060
的处理,这是一个大致的说法,细节我们在后面会进一步展开讲,OK,最

582
00:39:46,060 --> 00:39:52,020
后一个讲的是虚拙机制,就是前面我一讲到的就是它虽然我们限制了我们

583
00:39:52,020 --> 00:39:56,260
的应用程序去执行特权指令,但是它没有限制它对地址空间的任

584
00:39:56,260 --> 00:40:02,260
意访问,所以我们要有一套机制,这个机制我想大家都应该比较

585
00:40:03,520 --> 00:40:06,200
主程原理课也是讲的比较多的

586
00:40:06,200 --> 00:40:09,680
大致就类似于一个页表的一个结构

587
00:40:09,680 --> 00:40:12,300
来完成一个虚实地址的转换

588
00:40:12,300 --> 00:40:14,320
从而指责你应用程序访问的虚地址

589
00:40:14,320 --> 00:40:17,120
如果我们的超级统不给它设置好相应的物理地址的话

590
00:40:17,120 --> 00:40:18,940
它没法访问到相应的物理地址

591
00:40:18,940 --> 00:40:21,480
这是它的一个大致的设计思路

592
00:40:21,480 --> 00:40:25,260
这个细节我就也是简单的过一下

593
00:40:25,260 --> 00:40:26,370
它大致处理过程就是

594
00:40:30,450 --> 00:40:39,410
我们的OS,就是OS,它会去通过STAP,就是页机子技能器来建立这个页表

595
00:40:39,410 --> 00:40:42,970
的机子,在这儿,这就是页表的机子。

596
00:40:44,890 --> 00:40:50,570
这些业表的内容 这是业表的内容 这个三级业表的内容也是OS先建

597
00:40:50,570 --> 00:40:51,050
立好

598
00:40:51,050 --> 00:40:56,790
建立好之后 等于是一旦把它设置完这个SATP之后

599
00:40:56,790 --> 00:40:59,510
我们最后一步要去nable一个业机制

600
00:40:59,510 --> 00:41:02,690
你nable业机制之后 接下来处理器在访问的时候

601
00:41:02,690 --> 00:41:05,490
就是要走这么一个查询过程

602
00:41:05,490 --> 00:41:08,530
当然大家也都学过 如果这个查询过程比较

603
00:41:08,530 --> 00:41:09,950
都是在内存里面访问比较慢

604
00:41:09,950 --> 00:41:12,770
它一定会有一个加速的处理过程

605
00:41:12,770 --> 00:41:16,850
MMU 负责地址转换

606
00:41:16,850 --> 00:41:18,310
但是还有一个TLB

607
00:41:18,310 --> 00:41:21,810
TLB 是这些页两项的一个catch

608
00:41:21,810 --> 00:41:23,130
它都在TPU里面

609
00:41:23,130 --> 00:41:24,170
然后这个加速之后

610
00:41:24,170 --> 00:41:26,910
我们就可以实现一个快速的驱动方法

611
00:41:26,910 --> 00:41:28,810
那至于这个映射关系

612
00:41:28,810 --> 00:41:30,570
谁来建立是OS来建立

613
00:41:30,570 --> 00:41:32,570
所以OS可以通过这种方式来

614
00:41:32,570 --> 00:41:35,470
让我们的应用程序没法完成OS的地址空间

615
00:41:35,470 --> 00:41:37,650
然后可以完成这种地址空间的隔离

616
00:41:47,870 --> 00:41:53,970
怎么去找的,有个流程,这个我们就不太细讲,好,大家休息一下。

617
00:42:12,870 --> 00:42:15,890
就是因为gdb调试的时候想加个断点

618
00:42:15,890 --> 00:42:18,130
然后派来一个智能专案想等

619
00:42:18,130 --> 00:42:19,850
然后用这种方式的话

620
00:42:19,850 --> 00:42:22,530
你包有这样的方式什么车

621
00:42:22,530 --> 00:42:23,510
就这个车

622
00:42:24,590 --> 00:42:26,950
但是这个形态是可不可用的

623
00:42:26,950 --> 00:42:29,170
我刚确实能用的太不确实了

624
00:42:35,010 --> 00:42:38,130
我没觉得需要这个没什么能做

625
00:47:03,190 --> 00:47:04,750
好 那我们继续上课

626
00:47:04,750 --> 00:47:06,810
刚才讲到这个虚存机制

627
00:47:06,810 --> 00:47:07,530
它有一个页表

628
00:47:07,530 --> 00:47:08,110
页表呢 它会有一个

629
00:47:38,110 --> 00:47:45,670
它首先处理器会把虚粒子拆成三块,这是一个offset,业内便宜,然后业会

630
00:47:45,670 --> 00:47:48,030
分成两块,这是二阶业表。

631
00:47:48,410 --> 00:47:55,170
二阶业表的话,那会根据SATP找到业目录表的其实地址,然后其实地

632
00:47:55,170 --> 00:47:57,270
址里面会有很多的业目录像,

633
00:47:57,270 --> 00:48:04,910
而页目向,到底哪一项是由VPN1作为index来查找,找到对应的PD

634
00:48:04,910 --> 00:48:05,430
E

635
00:48:05,430 --> 00:48:11,890
然后这个PDE里面会记录二级页表的其实地址,物理的其实地址,它们

636
00:48:11,890 --> 00:48:13,430
会到这儿来,所以它会指向这个地方

637
00:48:13,850 --> 00:48:20,250
到这个地方之后,再把VPN0里面的作为index去查找这儿

638
00:48:20,250 --> 00:48:23,330
会找到第二个PTE,这个PTE里面存的是什么呢?

639
00:48:23,330 --> 00:48:29,090
存的是这个PPN,物理业Lumber,PageLumber

640
00:48:29,090 --> 00:48:31,330
这个PageLumber虽然就包含了这么多位

641
00:48:31,330 --> 00:48:33,450
这是一个32位的处理器

642
00:48:33,450 --> 00:48:37,270
咱们那个是39位,不太一样

643
00:48:37,270 --> 00:48:39,010
大致结构是一样的,过程是一样的

644
00:48:39,010 --> 00:48:40,550
那么有这个PPN之后,在线上

645
00:48:41,470 --> 00:48:43,310
就形成了所谓的物理粒子

646
00:48:43,310 --> 00:48:45,650
就是VA到PA的一个转换过程

647
00:48:45,650 --> 00:48:54,170
那整个转换过程,整个查导过程都是由我们的硬件自己去完成的,不需要

648
00:48:54,170 --> 00:48:55,110
我们的软件介入。

649
00:48:55,450 --> 00:49:00,250
但是这里面的内容,两个table里面的内容是我们的OS来建立的,这是它的区

650
00:49:00,250 --> 00:49:00,550
别。

651
00:49:00,750 --> 00:49:06,350
因为有这么一个机制,使得我可以通过OS会给自己设一块区域,一块物理

652
00:49:06,350 --> 00:49:06,730
内存,

653
00:49:07,110 --> 00:49:12,890
然后给APP设一块物理内存,这是APP的,这是OS的,它们在空间上是隔离

654
00:49:12,890 --> 00:49:13,190
的。

655
00:49:13,190 --> 00:49:19,050
所以当APP通过这个页表去访问的时候,它只能得到它自己的这一块区域,

656
00:49:19,170 --> 00:49:21,650
不可能跨越这个地址空间。

657
00:49:21,750 --> 00:49:28,070
如果跨越的话,那会产生异常。这就是我们说的这个虚存,有这个虚存之后,会

658
00:49:28,070 --> 00:49:29,210
带来一定的保护机制。

659
00:49:31,250 --> 00:49:41,870
好,那最后简单小节一下,就是我们这一节,这一小节,重点让大家了解R

660
00:49:41,870 --> 00:49:45,590
isk5的一个特权级和应用隔离的一种方式。

661
00:49:46,090 --> 00:49:52,330
中断异常特权级虚存,就是页表,这就是他们的基本特征。

662
00:49:52,330 --> 00:49:58,090
MODE干了什么事情,MODE能干什么事情,他们在产生异常和中断的时候,或者

663
00:49:58,090 --> 00:50:02,890
在执行特别指令的时候,或者跟特别相关的指令的时候,

664
00:50:03,090 --> 00:50:08,470
他到底应景上要做了什么事情,软件上应该怎么去做,在切换这一块,这是

665
00:50:08,470 --> 00:50:09,530
我们需要去了解的重点。

666
00:50:10,470 --> 00:50:17,290
这一节就简单给大家介绍完毕,我们在第三节就是具体做一个OS。

667
00:50:18,110 --> 00:50:25,610
我理解这就是我们现在上课的一个比较大的不同,讲原理的话其实还是比较简单,

668
00:50:25,910 --> 00:50:29,590
就是大家都知道能不能从一个特征机挑另一个特征机,这好像没什么太多说的,

669
00:50:29,590 --> 00:50:34,450
但是如果说你要去争取把这个OS给做出来的话,你会发现有些细节需要加一些

670
00:50:34,450 --> 00:50:34,830
掌握,

671
00:50:35,090 --> 00:50:40,910
这个OS的特点它的细节也比较多,原理也比较多。

672
00:50:42,130 --> 00:50:45,070
但一旦你把这个细节和原理建立好联系之后,

673
00:50:45,410 --> 00:50:47,630
那你也理解起来,掌握起来就比较容易一些。

674
00:50:50,330 --> 00:50:51,710
这其实讲怎么去做OS,

675
00:50:51,850 --> 00:50:53,770
更多是一种软件设计的思路,

676
00:50:53,950 --> 00:50:56,250
只是这个软件它需要了解很多硬件细节。

677
00:50:56,510 --> 00:50:58,790
这里面会讲你要达到什么样的目标,

678
00:50:58,910 --> 00:51:01,710
既然我们是做一个软件,叫系统软件,

679
00:51:01,850 --> 00:51:05,030
它的目标是啥,然后它的总体思路是啥。

680
00:51:05,710 --> 00:51:07,630
这种软件别人以前做过没有,

681
00:51:08,190 --> 00:51:09,810
然后具体我们怎么去尝试一下,

682
00:51:09,810 --> 00:51:14,390
以及你需要了解相应的一些应验细节,最后来完成这个软件的设计。

683
00:51:15,290 --> 00:51:20,310
这是我们说,我们后续写OS,基本上会设计到这么一个整体的流程。

684
00:51:21,130 --> 00:51:25,850
首先看这个目标,大家回顾一下,我们在前面讲,

685
00:51:26,250 --> 00:51:29,110
第一个OS,叫LibOS的时候,三月成OS的时候,

686
00:51:29,570 --> 00:51:33,490
我们也做了一个事情,让应用与硬件隔离。

687
00:51:33,810 --> 00:51:37,850
但这个隔离不是为了安全,做了什么?

688
00:51:37,850 --> 00:51:40,310
为了我们的软件开发更加简单

689
00:51:40,310 --> 00:51:43,550
所以它简化了应用程序保护硬件的难度和可达性

690
00:51:43,550 --> 00:51:45,610
这个隔离是为了简化

691
00:51:45,610 --> 00:51:47,350
但是我们现在这个OS

692
00:51:47,350 --> 00:51:49,070
Batch的P2.0 OS

693
00:51:49,070 --> 00:51:49,970
目的是安全

694
00:51:49,970 --> 00:51:50,970
它也这样做隔离

695
00:51:50,970 --> 00:51:53,190
让ADP和OS隔离

696
00:51:53,190 --> 00:51:54,210
层次不一样

697
00:51:54,210 --> 00:51:55,590
APO是这样隔离

698
00:51:55,590 --> 00:52:00,410
那么这种隔离能够保证ADP不会影响到我们的OS

699
00:52:00,410 --> 00:52:02,410
但是也看出来了

700
00:52:02,410 --> 00:52:05,330
从LibOS到BatchOS P2.0 OS

701
00:52:05,330 --> 00:52:06,270
它们有很大的区别

702
00:52:06,270 --> 00:52:13,950
对于LibreOS而言,我们的OS是信这个应用的,它是把应用和OS是

703
00:52:13,950 --> 00:52:19,290
通过库子方式紧合起来的,但是一旦到了现在这个再进一步去讨论应

704
00:52:19,290 --> 00:52:25,970
用,你要都是很多HP的时候,我们已经不信OS了,我们已经不信应用了,所以你需要一种

705
00:52:25,970 --> 00:52:26,690
隔离机制。

706
00:52:26,690 --> 00:52:28,850
然后同时为了提高效率

707
00:52:28,850 --> 00:52:30,890
我们也会自动加载比例去多个程序

708
00:52:31,610 --> 00:52:33,250
但不管多多少

709
00:52:33,250 --> 00:52:35,090
你在这里面看到

710
00:52:35,090 --> 00:52:36,690
在这儿

711
00:52:37,490 --> 00:52:39,230
这儿是多个程序

712
00:52:39,230 --> 00:52:41,370
但每次我只加载一个程序

713
00:52:41,370 --> 00:52:42,690
在HPP里面

714
00:52:42,690 --> 00:52:44,690
内存中始终只有一个程序

715
00:52:45,450 --> 00:52:47,090
这个是它的一个非常

716
00:52:47,090 --> 00:52:49,250
简单的P处理设计思路

717
00:52:49,250 --> 00:52:51,290
这样可以降低我们的开发难度

718
00:52:51,290 --> 00:52:52,850
所以你看到

719
00:52:52,850 --> 00:52:55,810
它的代码量和前面的

720
00:52:55,810 --> 00:52:57,230
Legos比起来是要多一些

721
00:52:57,230 --> 00:53:00,450
但是还是在一个几百行的一个代码可控的范围之类

722
00:53:06,830 --> 00:53:07,690
我们软件这么设计

723
00:53:08,050 --> 00:53:09,150
那你同学做完这个之后

724
00:53:09,150 --> 00:53:10,130
你应该掌握什么内容

725
00:53:10,130 --> 00:53:12,630
你应该知道我要写一个软件

726
00:53:12,630 --> 00:53:14,210
它要运行其他软件

727
00:53:14,210 --> 00:53:15,590
这个大家以前写应用的时候

728
00:53:15,590 --> 00:53:17,910
可能比较早要去做这种事情

729
00:53:17,910 --> 00:53:19,050
第二个

730
00:53:19,050 --> 00:53:21,170
你要知道特别一些的存在

731
00:53:21,170 --> 00:53:22,490
还知道我们去切特别一些

732
00:53:24,090 --> 00:53:30,830
这个是OS需要的。第三个,你知道怎么写应用,应用要调系统调应,所以你要知道怎么写

733
00:53:30,830 --> 00:53:31,530
应用程序。

734
00:53:31,970 --> 00:53:39,570
然后把它合在一起,你就完成了一个所谓的P数理上去。这是我们说的这个OS的一个

735
00:53:39,570 --> 00:53:43,130
同学需要掌握的一个要求。

736
00:53:44,190 --> 00:53:48,850
好 第二个 看看总体思路

737
00:53:49,230 --> 00:53:52,650
总体思路其实还是软件开发的一个过程

738
00:53:52,650 --> 00:53:56,770
首先我们还是尽量重用以前还能够重用的东西

739
00:53:56,770 --> 00:53:57,630
比如说力波网上面

740
00:53:57,970 --> 00:54:00,070
我们可以把应用和内核单独编译

741
00:54:00,070 --> 00:54:01,090
但是合成一个迹象

742
00:54:01,090 --> 00:54:02,530
这块跟以前一样

743
00:54:02,530 --> 00:54:03,830
我们直接重用

744
00:54:03,830 --> 00:54:05,090
第二个不一样了

745
00:54:05,090 --> 00:54:06,570
第二个 我们前面是bounding code

746
00:54:06,570 --> 00:54:09,210
我们要把它变成所谓的sesting code

747
00:54:10,350 --> 00:54:12,610
你要把以前的编辑帮你干的事

748
00:54:12,610 --> 00:54:17,010
要自己做,要变成一个所谓的依靠这种指令,这又涉及到系统家用

749
00:54:17,010 --> 00:54:23,770
服务的一个接口,这一块是构造利本,我们支持用户带程序的一个用户

750
00:54:23,770 --> 00:54:26,710
利本,要干这个事情,也是一个系统程序。

751
00:54:26,850 --> 00:54:32,610
第三个呢,下面就是我们还要去写OS,所以这个OS会完成应用的管理和处置化,

752
00:54:33,050 --> 00:54:37,270
这是构造OS。一旦把这个做完之后,那我们就可以去运行了。

753
00:54:37,270 --> 00:54:40,370
你们会发现 OOS 是一个一个的执行应用

754
00:54:40,370 --> 00:54:41,690
就是我每次加载一个程序

755
00:54:41,690 --> 00:54:43,650
这个程序是一完毕之后再下一个

756
00:54:43,650 --> 00:54:45,570
这是一个流水线的执行过程

757
00:54:45,950 --> 00:54:47,350
而应用程序在执行过程中

758
00:54:47,350 --> 00:54:48,490
它会发出去冷掉用

759
00:54:48,490 --> 00:54:50,670
让我们的 OOS 提供相应的服务

760
00:54:50,670 --> 00:54:53,810
它不是通过方形口而是 SysTick口来做这个事情

761
00:54:53,810 --> 00:54:54,910
一旦要做这个事情的话

762
00:54:54,910 --> 00:54:58,770
我们 OOS 要很重要的点是要完成这个科研机的切换

763
00:54:58,770 --> 00:55:01,470
谁要涉及到什么状态的保存与恢复

764
00:55:02,190 --> 00:55:03,850
这个是我们重点要去解决

765
00:55:03,850 --> 00:55:06,010
它也是会编辑的一些处理

766
00:55:06,010 --> 00:55:08,610
这个需要大家去比较深入去了解

767
00:55:10,890 --> 00:55:14,510
那这个其实在历史上也是非常经典的一个OS

768
00:55:14,510 --> 00:55:19,650
就这个叫做GMNAA这么一个IoSystem

769
00:55:19,650 --> 00:55:22,230
在1956年的时候就出现了一个这么一个OS

770
00:55:22,230 --> 00:55:23,510
它叫P处理OS

771
00:55:23,990 --> 00:55:25,270
后续的matrix

772
00:55:25,270 --> 00:55:26,550
我们前面讲的matrixOS

773
00:55:26,550 --> 00:55:29,430
1969年MIT为首做了这个OS

774
00:55:29,430 --> 00:55:31,930
也一样有这种所谓

775
00:55:31,930 --> 00:55:33,190
这是有P处理这种特点

776
00:55:33,190 --> 00:55:37,030
而它这个劈腿设计完全是受到汽车纽线

777
00:55:37,030 --> 00:55:38,330
当时汽车纽线的一个启发

778
00:55:38,330 --> 00:55:40,350
就是流水的处理方式

779
00:55:40,710 --> 00:55:44,490
而matrix OS它在用这个机翼生产了645

780
00:55:45,090 --> 00:55:46,670
这个大型机的处理器的时候

781
00:55:47,110 --> 00:55:50,370
它用到它的一个8级的硬件保存

782
00:55:50,710 --> 00:55:52,110
叫做保护环

783
00:55:52,110 --> 00:55:53,190
Protecting Ring

784
00:55:53,190 --> 00:55:54,070
这个东西

785
00:55:54,890 --> 00:55:56,270
这个Ring这个概念

786
00:55:56,270 --> 00:55:58,210
在现在的X86里面它也是一样的

787
00:55:58,210 --> 00:56:00,190
X86里面那个特先机它叫Ring

788
00:56:00,190 --> 00:56:02,630
X86有零到三四级Ring

789
00:56:02,630 --> 00:56:08,250
但在Risk 5里面,我们不叫Ring了,我们叫Mode,只是一种称呼而已。

790
00:56:09,330 --> 00:56:13,910
这次例子上其实已经存在了类似的做法,但它们主要集中在大型

791
00:56:13,910 --> 00:56:14,410
机里面。

792
00:56:16,770 --> 00:56:18,930
简单介绍一下,我们来看看大致的一个实现步骤。

793
00:56:20,030 --> 00:56:25,010
其实实现步骤前面已经大致介绍过,就是要构造一个镜像,然后联络去执

794
00:56:25,010 --> 00:56:25,290
行它。

795
00:57:25,630 --> 00:57:27,300
这个大家尝试一下就行

796
00:57:31,170 --> 00:57:32,750
这个都很快就过了

797
00:57:32,750 --> 00:57:35,070
我们看看这个软件架构这一款

798
00:57:35,770 --> 00:57:39,030
其实这边这个图就是一个软件架构

799
00:57:39,030 --> 00:57:41,310
就是我们要做这个OS的一个架构

800
00:57:41,310 --> 00:57:42,930
我可以先把这个简单介绍一下

801
00:57:42,930 --> 00:57:44,170
后面再讲稍微详细一点

802
00:57:44,170 --> 00:57:47,050
你可以看到它有两大部分的层

803
00:57:47,050 --> 00:57:49,310
第一部分第一部分是应用层

804
00:57:49,310 --> 00:57:50,290
就这一块

805
00:57:50,950 --> 00:57:52,290
在用户台这一层

806
00:57:52,290 --> 00:57:55,250
这一层你可以写非常简单的小程序

807
00:57:55,250 --> 00:57:56,290
就是我们说的print

808
00:57:56,770 --> 00:57:57,950
或者其他一些小程序

809
00:57:57,950 --> 00:57:59,510
比如说做一个磊加等等

810
00:57:59,510 --> 00:58:02,610
这个APP如果它需要

811
00:58:02,610 --> 00:58:04,610
比如print把这个字符上面打出来的话

812
00:58:04,610 --> 00:58:06,350
那么它需要发syscall

813
00:58:06,350 --> 00:58:09,450
而这个syscall实际上是在一个lib里面实现

814
00:58:09,450 --> 00:58:11,590
所以我们会做到用过它一个lib库

815
00:58:11,590 --> 00:58:14,830
这个lib库会完成对e-code指令的封装

816
00:58:14,830 --> 00:58:16,190
向上给APP来说

817
00:58:16,190 --> 00:58:18,190
它只要调用一个类似于uprint

818
00:58:18,190 --> 00:58:21,490
这么一个函数就OK了

819
00:58:21,490 --> 00:58:22,930
我们用户他要去做的事情

820
00:58:24,650 --> 00:58:27,650
其实这个程序只是这么两块

821
00:58:28,570 --> 00:58:31,030
那么底下这一块是我们的OS

822
00:58:31,030 --> 00:58:32,250
底下这一块是我们的OS

823
00:58:32,250 --> 00:58:35,850
这个OS你会发现它分了两大部分

824
00:58:36,490 --> 00:58:38,870
一部分是跟应用相关

825
00:58:38,870 --> 00:58:39,890
就是App Manager

826
00:58:39,890 --> 00:58:42,370
App Manager这样是它是能够去查找

827
00:58:42,370 --> 00:58:43,670
App在什么地方

828
00:58:43,670 --> 00:58:47,350
然后把这个App从某一个地方调到那些地方去执行

829
00:58:47,350 --> 00:58:48,990
这是App Manager要干的事情

830
00:58:48,990 --> 00:58:54,950
另一块叫做Trap Handler或者Sitting Service这一块相关的,就是我们的右侧

831
00:58:54,950 --> 00:58:59,390
右侧一块主要是能够去响应Syscall,就要支持这个系统标用

832
00:59:00,530 --> 00:59:04,110
为了能够响应系统标用,它能够完成特先级的保存与恢复

833
00:59:04,110 --> 00:59:10,090
那在这里面叫Trap Handler,其实还有更底层的汇编程序来支持

834
00:59:10,890 --> 00:59:16,130
那么为了能够简化我们这个OS,我们这边并没有设计到具体跟OS打交道

835
00:59:16,130 --> 00:59:20,750
我们把这一块也堵不去了,为什么堵不去了,我们有SBI的一个口,这样的SBI的

836
00:59:20,750 --> 00:59:26,370
一个口,让我们的RUS SBI帮我们去完成了制度刷的显示,所以我们这边并

837
00:59:26,370 --> 00:59:32,610
没有对,实际上是通过一个串口外设,串口外设的驱动的设计,我们现在

838
00:59:32,610 --> 00:59:40,310
不用考虑,我们这样可以简化我们OS的设计,只有它整体的一个架构,这一块就

839
00:59:40,310 --> 00:59:41,310
简单说了一下。

840
00:59:47,230 --> 00:59:51,730
能够把多个应用合成一个 image 的code 放在这儿

841
00:59:51,730 --> 00:59:57,310
这主要看到一个叫做 link-apg.s 这么一个汇编程序

842
00:59:57,310 --> 00:59:59,830
这汇编程序不是隐编写的

843
00:59:59,830 --> 01:00:04,310
是 build.rs 或者用一个 Python 脚本 自动可以生成出来

844
01:00:05,150 --> 01:00:09,910
汇编程序里面包含了所有的应用程序的 binary 迹象

845
01:00:09,910 --> 01:00:11,670
然后把这些 binary 迹象合在一起

846
01:00:11,670 --> 01:00:15,350
再和 OS 和本身的迹象合在一起 形成整个单一的 image

847
01:00:15,790 --> 01:00:18,450
这是所谓构建应用这一块要干的事情

848
01:00:18,450 --> 01:00:22,710
这是一个新的 因为我们之前也构建

849
01:00:22,710 --> 01:00:24,310
但是只有一个应用和一个OS

850
01:00:24,310 --> 01:00:26,530
这里面是有多个应用和一个OS

851
01:00:26,530 --> 01:00:28,690
这是一个差别

852
01:00:28,690 --> 01:00:33,510
第二个 你还要去对早期的立国OS做一定的扩展

853
01:00:33,510 --> 01:00:35,410
这扩展就是我们分了两块

854
01:00:35,410 --> 01:00:37,110
前面讲的一个是ADP Manager

855
01:00:37,110 --> 01:00:41,030
一个是对系统家用的一个处理

856
01:00:41,670 --> 01:00:42,610
就是分了两大块

857
01:00:42,610 --> 01:00:44,430
这是这里面的两块的一个内容

858
01:00:47,670 --> 01:00:52,630
比较tricky的就是最底下的Trap.S这个程序

859
01:00:52,630 --> 01:00:58,750
它这个汇编程序它有对特循级切换的一个处理

860
01:00:58,750 --> 01:01:01,970
包括特循级的状态的保存与恢复等等

861
01:01:03,770 --> 01:01:06,250
具体的系统调其实比较简单

862
01:01:06,250 --> 01:01:16,190
他就是进一步的得到那个用户台的那个字符串的信息

863
01:01:16,190 --> 01:01:20,530
然后把这个信息一个字符一个字符的发给底下的 SDI RAS

864
01:01:20,530 --> 01:01:23,650
然后他就帮我们处理 就干这么一个事情

865
01:01:25,510 --> 01:01:27,650
好 那这个应用程序本身来说呢

866
01:01:28,130 --> 01:01:29,990
就有各种应用 说有五个应用程序

867
01:01:29,990 --> 01:01:32,890
非常简单 Hello World 这是一个正常的

868
01:01:32,890 --> 01:01:36,230
其他几个 第二个叫02power.is

869
01:01:36,730 --> 01:01:43,570
是一个让机上的Io来回切换的一个应用

870
01:01:43,570 --> 01:01:45,790
还有几个就是01、03、04

871
01:01:45,790 --> 01:01:48,670
实际上都是一些专门验证这个测验机

872
01:01:48,670 --> 01:01:52,870
是否管用的一个 是否生效的一些小程序

873
01:01:52,870 --> 01:01:57,210
它还带了一些对特循 带了一些特循指令的一些操作

874
01:01:57,210 --> 01:01:59,070
如果是这个程序 应该很容易查

875
01:01:59,070 --> 01:02:00,590
从这种方式能够check

876
01:02:00,590 --> 01:02:03,590
你这个OS能否正确的应对

877
01:02:03,590 --> 01:02:08,390
相应的一些用户在发出的一些特权操作

878
01:02:08,390 --> 01:02:09,670
这是这一部分

879
01:02:09,670 --> 01:02:13,310
那么0.001是为了我们OS好去找

880
01:02:13,310 --> 01:02:17,070
跟这个编号来去放置和查导这个应用

881
01:02:20,970 --> 01:02:24,430
这是我们说的这个应用的酷的知识

882
01:02:25,310 --> 01:02:27,010
就是我们前面讲到的就是

883
01:02:27,010 --> 01:02:29,270
它需要把用户程序发出的那种printf

884
01:02:29,690 --> 01:02:32,690
或者一些系统级的函数都封端起来

885
01:02:32,690 --> 01:02:35,130
来形成一个更简单的一个给应用的一个支持

886
01:02:35,130 --> 01:02:39,230
那底下它就在这个Sysquad的IS里面

887
01:02:39,230 --> 01:02:41,770
完成具体的一块那条汇编指令的一个调用

888
01:02:43,870 --> 01:02:48,690
OK 这是大致的一个硬件架构的一个介绍

889
01:02:50,750 --> 01:02:51,910
我讲这个有点细

890
01:02:51,910 --> 01:02:53,650
我不知道大家有问题吗觉得

891
01:02:58,670 --> 01:03:07,590
我们前面已经看到了,在应验的角度,我们需要去理解几个特定的一些指令。

892
01:03:08,090 --> 01:03:13,270
在这里面,主要是一个e-code,e-code是说从用户碳,humor的跳到用

893
01:03:13,270 --> 01:03:13,810
户碳去。

894
01:03:15,630 --> 01:03:19,130
从用户碳回到用户碳去,就是刚才同学提到的SRIT。

895
01:03:19,770 --> 01:03:23,630
那么它会在我们的OS完成相应的这个指令。

896
01:03:23,630 --> 01:03:29,070
处理之后能够回到从这回到用户台去

897
01:03:29,490 --> 01:03:35,030
其实我们说OS里面发出显示字幕串的SBI code

898
01:03:35,030 --> 01:03:36,190
也是走一一口

899
01:03:36,690 --> 01:03:40,030
只是走到这个时候是从S mode回到了M mode

900
01:03:40,030 --> 01:03:44,590
由RUS SBI帮我们去完成跟外设串口打交道之后再回来

901
01:03:44,590 --> 01:03:49,030
这是大致的一个刻意切换的一个示意图

902
01:03:51,370 --> 01:03:55,590
那么我们这里面的要去响应的

903
01:03:55,590 --> 01:03:57,470
就是OS要响应异常

904
01:03:58,650 --> 01:04:00,530
有能够碰到的有ebrick

905
01:04:00,530 --> 01:04:01,430
这可以看到

906
01:04:01,430 --> 01:04:03,410
还有一个就是叫echo

907
01:04:03,410 --> 01:04:04,950
echo-brown-u-mode

908
01:04:04,950 --> 01:04:07,570
你看这里面专门标准的是echo-brown-u-mode

909
01:04:07,570 --> 01:04:11,970
这意味着这个echo是在用物上发出来的

910
01:04:11,970 --> 01:04:14,090
这两个异常是由我们的OS

911
01:04:14,090 --> 01:04:19,010
要去结获并进一步去处理的

912
01:04:19,010 --> 01:04:23,530
这些是给了这个硬件,其实硬件给的信息就这么多,

913
01:04:23,790 --> 01:04:26,910
硬件的它的简单处理由成为在上一堂课讲过,

914
01:04:27,290 --> 01:04:29,910
那我们的软件,需要注意的是我们的软件,

915
01:04:29,990 --> 01:04:32,030
基于现在硬件提供机制,我们软件怎么做,

916
01:04:33,210 --> 01:04:36,670
这是应该是我们后续要讲的一个比较重要的地方。

917
01:04:39,370 --> 01:04:42,250
OK,首先我们这个软件,写这个软件的时候,

918
01:04:42,350 --> 01:04:45,670
你会发现你其实写两划,它不是说你只是写个OS,

919
01:04:45,670 --> 01:04:50,570
另外调个应用谱,所以你先要去写更简单的一个应用态的一道代码

920
01:04:50,570 --> 01:04:53,710
应用态代码除了应用本身之外,就是那个底层支撑库

921
01:04:53,710 --> 01:04:55,490
你要把它的底层支撑库写出来

922
01:04:55,490 --> 01:04:59,950
底层支撑库里面就是要去把E-code给它好好地管起来

923
01:04:59,950 --> 01:05:01,430
这是要干的事情

924
01:05:01,430 --> 01:05:04,490
我们看看这跟前面的不同在什么地方

925
01:05:04,490 --> 01:05:07,430
首先我们把应用程序和库给分开了

926
01:05:07,430 --> 01:05:08,650
库是库,应用程序是应用程序

927
01:05:08,650 --> 01:05:11,230
应用程序可以有自己独特的一些写法

928
01:05:11,230 --> 01:05:12,550
但库是一个共性的东西

929
01:05:12,550 --> 01:05:16,030
它是给我们应用程序员提供一些共性的一些函数

930
01:05:16,030 --> 01:05:20,750
这是我们酷的大致的一个位置

931
01:05:20,750 --> 01:05:22,870
user src下面就列出来了

932
01:05:22,870 --> 01:05:24,570
所有的应用程序是闭幕录像

933
01:05:25,110 --> 01:05:27,490
这是它的一个大致的一个组织的方式

934
01:05:27,490 --> 01:05:29,170
那应用程序用酷的话

935
01:05:29,170 --> 01:05:30,630
你会link

936
01:05:30,630 --> 01:05:33,870
比如说你用c语言是include的一个

937
01:05:33,870 --> 01:05:34,870
它的一个图文件

938
01:05:34,870 --> 01:05:35,930
酷的图文件

939
01:05:35,930 --> 01:05:37,990
对于WAS语言来说

940
01:05:37,990 --> 01:05:40,510
你就直接指明它酷的那个create

941
01:05:40,510 --> 01:05:41,770
user live就OK了

942
01:05:41,770 --> 01:05:44,390
总之你要声明一下,你要带这个库在什么地方

943
01:05:44,730 --> 01:05:47,630
那我们应用程序知道,一旦知道之后呢

944
01:05:47,630 --> 01:05:49,810
我们应用程序可以调相应操作

945
01:05:49,810 --> 01:05:52,250
但是应用程序在这些所谓的卖函数之前

946
01:05:52,250 --> 01:05:53,670
无论是C还是R

947
01:05:53,670 --> 01:05:55,350
听卖函数之前呢

948
01:05:55,350 --> 01:05:57,330
其实我们的库还要完成一定的处理化工作

949
01:05:57,770 --> 01:05:59,410
就是你看这就有个start

950
01:05:59,410 --> 01:06:00,570
C也是一样的

951
01:06:00,570 --> 01:06:02,990
有一个类似的start一个操作

952
01:06:02,990 --> 01:06:07,290
它是来对我们的应用程序的执行环境做进一步的处理

953
01:06:07,290 --> 01:06:09,490
比如说我们上次讲过的

954
01:06:09,490 --> 01:06:11,370
会对应用程序的一个叫PSS管

955
01:07:41,410 --> 01:07:44,770
不光是要了解 也还能够定制它内存布局

956
01:07:45,210 --> 01:07:47,470
所以你要知道它内存布局是怎么来的

957
01:07:47,470 --> 01:07:50,250
但其实是我们的编译器中的

958
01:07:50,250 --> 01:07:51,950
我们说编译器是 我再说一下

959
01:07:51,950 --> 01:07:53,530
我好像多次说过编译器

960
01:07:53,530 --> 01:07:55,190
我们说编译器是一个大的编译器

961
01:07:55,190 --> 01:07:56,090
它包含三部分

962
01:07:56,090 --> 01:07:57,950
一个叫做Compiler 一个叫Assembler

963
01:07:57,950 --> 01:07:59,370
第三个叫Linker

964
01:07:59,370 --> 01:08:02,450
它这三部分合在一起 成为一个编译器

965
01:08:02,450 --> 01:08:06,930
那么我们Linker会把我们的那些编写好的那些

966
01:08:06,930 --> 01:08:09,750
Object文件合成一个最后的一个指令程序

967
01:08:09,750 --> 01:08:16,050
那么linker里面会查找所谓的一个叫link.ld这么一个描述性文件

968
01:08:16,050 --> 01:08:18,850
这个文件指出了我们这个执行程序

969
01:08:18,850 --> 01:08:21,230
最后生成的执行程序 它的代码应该在哪个地方

970
01:08:21,990 --> 01:08:25,350
比如在这里面 看这个 这里面没有

971
01:08:25,350 --> 01:08:27,190
大家可以看出来 它里面它其实例子

972
01:08:27,190 --> 01:08:29,510
它有一个base address 会指向这个地方

973
01:08:29,510 --> 01:08:31,070
这是我们人为特质的

974
01:08:31,650 --> 01:08:34,270
我也可以改 我会改另外一个合理的地方

975
01:08:34,650 --> 01:08:38,530
但是你改了之后 你要让我们的os也知道

976
01:08:38,530 --> 01:08:41,050
因为这是编辑 我们说编辑的OS达成共识

977
01:08:41,050 --> 01:08:43,670
他们要知道这个应用程序其实地址在哪

978
01:08:43,670 --> 01:08:45,850
这样我们编辑生成

979
01:08:45,850 --> 01:08:47,230
在这个地址的指令的时候

980
01:08:47,230 --> 01:08:50,610
我们的OS也能够知道跳到那个地方去执行

981
01:08:50,610 --> 01:08:53,610
甚至说我们把我们的应用程序加到这个地方去执行

982
01:08:56,930 --> 01:09:00,190
好 内存部级这一块 简单做完

983
01:09:00,190 --> 01:09:03,530
再看看我们的应用程序怎么来执行系统调用

984
01:09:05,070 --> 01:09:07,910
主要是那个 我们说也是在库里面它有一个ECO

985
01:09:37,910 --> 01:09:42,350
A0应该保存返回值,A0到A6保存性能量的参数,当然你其实

986
01:09:42,350 --> 01:09:48,350
用不了这么多,我们现在其实选三个A0、A1、A2,这三个来传,这个约定实

987
01:09:48,350 --> 01:09:53,330
际上是我们目前,你写零零十也好,写其他套用也好,大致上一个约定,

988
01:09:53,390 --> 01:10:01,910
但是你要注意,这些技能器的,如果不这么传,我们的硬件会报错吗?

989
01:10:31,910 --> 01:10:33,490
不需要硬件做什么干预

990
01:10:33,490 --> 01:10:34,990
硬件不会去干预这个事情

991
01:10:34,990 --> 01:10:36,990
所以发现写的时候

992
01:10:38,610 --> 01:10:40,430
这是用户他写的那个SysWrite

993
01:10:40,430 --> 01:10:42,590
这库里面实现SysWrite这个操作

994
01:10:42,590 --> 01:10:44,010
那么它会有几个参数

995
01:10:44,010 --> 01:10:45,810
SysWrite会传

996
01:10:45,810 --> 01:10:49,330
比如说它的FB或者是Bubble的

997
01:10:49,330 --> 01:10:51,230
其实例子以及Bubble size

998
01:10:51,230 --> 01:10:53,030
这是我们正常说

999
01:10:53,530 --> 01:10:57,270
当然我们还没有实现完整的SysWrite

1000
01:10:57,270 --> 01:10:59,470
大致的你要print一个字幕刷

1001
01:10:59,470 --> 01:11:00,290
还可以这么来写

1002
01:11:01,150 --> 01:11:03,690
然后除了C1之外 显示C1之外

1003
01:11:03,690 --> 01:11:07,290
我们还有一个系统调用需要去做 就是退出

1004
01:11:08,590 --> 01:11:10,810
C3Exit就退出这个

1005
01:11:10,810 --> 01:11:12,290
退出有个退出码

1006
01:11:13,030 --> 01:11:16,290
那这两个系统调用是

1007
01:11:16,990 --> 01:11:18,950
我们在这个SpecOS里面

1008
01:11:18,950 --> 01:11:22,630
需要去支持的最基本两个系统调用

1009
01:11:23,290 --> 01:11:25,400
这个加了一个感叹号的意思是说

1010
01:11:25,910 --> 01:11:27,850
一旦执行了这个系统调用之后

1011
01:11:27,850 --> 01:11:29,250
这个应用程序并不要求返回

1012
01:11:29,730 --> 01:11:34,550
因为它已经把它Key了,它会把它回收掉,所以它是不返回的

1013
01:11:34,550 --> 01:11:37,490
但这个是要返回的,这个iSense代表的是说

1014
01:11:37,490 --> 01:11:40,730
当我写这个字幕串之后,我们OS到底输出了多少个字幕串

1015
01:11:40,730 --> 01:11:43,610
它会有一个返回值,有可能和你这个LAN是一样

1016
01:11:43,610 --> 01:11:48,630
有可能和你LAN不一样,这是一个约定

1017
01:11:48,630 --> 01:11:52,350
那你这个SysWrite或者SysAccess

1018
01:11:52,350 --> 01:11:58,050
它其实都会调这么一个SysCode的一个切入式内联汇边

1019
01:11:58,050 --> 01:11:59,110
来完成相应的处理

1020
01:11:59,110 --> 01:12:00,650
这个我简单解释一下

1021
01:12:02,090 --> 01:12:03,110
C里面也一样

1022
01:12:03,110 --> 01:12:04,850
C也会有类型汇编

1023
01:12:04,850 --> 01:12:07,790
这个汇编里面就是在Rust或者C这种高级元元

1024
01:12:07,790 --> 01:12:08,690
直接嵌汇编

1025
01:12:08,690 --> 01:12:11,010
这样实验起来更加高效一点

1026
01:12:11,010 --> 01:12:12,650
就写起来更加高效一点

1027
01:12:12,650 --> 01:12:13,790
因为发现它这里面Cisco

1028
01:12:13,790 --> 01:12:15,510
实际上传了一个Cisco的ID

1029
01:12:15,510 --> 01:12:17,270
以及对应的三个参数

1030
01:12:17,270 --> 01:12:18,790
这个Cisco需要三个参数

1031
01:12:18,790 --> 01:12:20,510
然后你底下可以看出来

1032
01:12:20,510 --> 01:12:22,290
第一它会生成一个依靠指令

1033
01:12:22,290 --> 01:12:24,690
第二在这个依靠指令之前

1034
01:12:24,690 --> 01:12:27,310
它其实还会把你这里面的三个参数

1035
01:12:57,490 --> 01:13:06,890
这一段类连汇编大致能表示出来我们用户台的应用

1036
01:13:06,890 --> 01:13:09,470
怎么能够向我们的OS发出一个系统调用

1037
01:13:09,470 --> 01:13:10,830
它就干这么多事情就行了

1038
01:13:10,830 --> 01:13:14,890
所以你看到这里面会有这个所谓的状态的保存有恢复吗

1039
01:13:14,890 --> 01:13:16,430
特定的状态保存有恢复吗

1040
01:13:18,670 --> 01:13:20,550
没有 没有

1041
01:13:20,550 --> 01:13:22,810
应用程序我们是要把普拉特业留给我

1042
01:13:22,810 --> 01:13:25,130
我们应用程序只要发出去就行了

1043
01:13:25,130 --> 01:13:26,590
它根本不管状态保存有恢复

1044
01:14:27,190 --> 01:14:30,110
好,那既然有了这个之后呢,有了Syscode这个实现,

1045
01:14:30,210 --> 01:14:34,430
我们就可以把SysWrite和SysAccess给它写好,

1046
01:14:34,670 --> 01:14:36,690
它直接调到Syscode就行了。

1047
01:14:36,930 --> 01:14:39,210
那这个是可以编起来帮我们搞定的,

1048
01:14:39,210 --> 01:14:42,370
但是Syscode本身由于有这个东西的存在,所以它搞不定。

1049
01:14:43,250 --> 01:14:45,270
这个就简单地把这个库,

1050
01:14:45,930 --> 01:14:49,030
有了这个之后,我们的库就大致就写好了。

1051
01:14:50,130 --> 01:14:54,110
那接下来的这些操作,大家不用细了解,

1052
01:14:54,110 --> 01:14:58,190
你去简单点以为就是一个对于Z原来是printf的一个距离实现

1053
01:14:58,190 --> 01:15:02,190
对于RAD而言就是也是一个println改单号的一个距离实现

1054
01:15:02,190 --> 01:15:04,370
这是一个达英宏的一个距离实现

1055
01:15:05,910 --> 01:15:07,390
这个不用细了解

1056
01:15:07,390 --> 01:15:13,370
只要知道它最终你这个在做这个println改单号或者printf的时候

1057
01:15:13,370 --> 01:15:17,570
它最终会掉到最终会掉到这个c-thright的函数就行了

1058
01:15:17,930 --> 01:15:19,730
它最终会掉那个eql

1059
01:15:19,730 --> 01:15:22,150
c-thright会掉c-thright,c-thright会掉eql

1060
01:15:22,150 --> 01:15:29,890
那就OK了,这意味着我们的应用程序设计里面,你管好你的地址空间,

1061
01:15:30,150 --> 01:15:33,210
你管好你的系统调用就行了。

1062
01:15:33,650 --> 01:15:40,350
而地址空间其实是,怎么说,写应用程序的,你了解一下就OK了,也不用专

1063
01:15:40,350 --> 01:15:41,030
门去设计。

1064
01:15:41,830 --> 01:15:45,470
对于这个库来说,如果你要设计库,比如说将来你要去实验新的系统调用,

1065
01:15:45,950 --> 01:15:47,930
那你必须要去在这个库上面做扩通。

1066
01:16:18,330 --> 01:16:21,830
你写的内联汇编还不是那种纯汇编代码

1067
01:16:21,830 --> 01:16:22,890
但你要写OS的话

1068
01:16:22,890 --> 01:16:25,350
你不得不还写一些纯汇编代码

1069
01:16:25,350 --> 01:16:28,690
这样才能够更好的能帮助我们的应用程序

1070
01:16:28,690 --> 01:16:32,210
能够正确的去方便的去执行

1071
01:16:32,210 --> 01:16:34,070
我们看看内核设计

1072
01:16:34,070 --> 01:16:35,110
我刚才写OS了

1073
01:16:35,110 --> 01:16:38,670
写OS你会发现你要设计这么几件事情

1074
01:16:38,670 --> 01:16:42,250
你需要去在编译阶段构造出一个单一镜像

1075
01:16:42,250 --> 01:16:43,390
在运行阶段

1076
01:16:43,390 --> 01:16:45,990
你要能够找到并加载应用程序

1077
01:16:45,990 --> 01:16:49,210
你要能够去在应用程序发出性标的时候

1078
01:16:49,210 --> 01:16:51,590
你要能够去做出正确的响应

1079
01:16:51,590 --> 01:16:53,950
完成特产级的切换

1080
01:16:53,950 --> 01:16:55,870
你还要能够去

1081
01:16:55,870 --> 01:16:57,090
就是加载完之后还要去执行

1082
01:16:57,090 --> 01:16:59,950
这就是整个这个我们说内核

1083
01:16:59,950 --> 01:17:01,410
程序设计里面要考虑问题

1084
01:17:01,410 --> 01:17:04,330
也意味着你需要去对这个ABC Manager

1085
01:17:04,330 --> 01:17:06,190
进行一个扩展

1086
01:17:06,190 --> 01:17:08,970
让他能够去支持查导和执行

1087
01:17:08,970 --> 01:17:11,730
你要对Syscall要做一个支持

1088
01:17:11,730 --> 01:17:12,490
做一个扩展

1089
01:17:12,490 --> 01:17:19,130
能够去详异 异常知识组织系统调用 正确返回

1090
01:17:19,870 --> 01:17:22,490
这一块要干的事情

1091
01:17:25,770 --> 01:17:29,230
给出了一个简单的描述 这个大家知道就行了

1092
01:17:29,230 --> 01:17:30,910
我觉得也不用细看

1093
01:17:30,910 --> 01:17:35,590
你可以知道OS.builder.rs或是一个Python程序

1094
01:17:35,590 --> 01:17:39,490
会帮助你把前面的那些生成的那个汇编

1095
01:17:40,010 --> 01:17:44,010
生成的那些应用程序的执行代码合在一起

1096
01:17:44,010 --> 01:17:45,390
有这个叫include binary

1097
01:17:45,390 --> 01:17:47,690
这里面就有写着NCBN

1098
01:17:47,690 --> 01:17:49,650
这是一种汇编红

1099
01:17:49,650 --> 01:17:51,450
大致就把这些合在一起

1100
01:17:51,450 --> 01:17:54,930
从而可以形成一个单一的一个

1101
01:17:54,930 --> 01:17:56,170
special的一个汇编文件

1102
01:17:56,170 --> 01:17:59,590
这文件嵌了所有的那个应用程序的Binary code

1103
01:17:59,590 --> 01:18:02,230
然后再和OS捆在一起 形成最终的一个emcee

1104
01:18:02,230 --> 01:18:04,030
这就是我们干的第一步事情

1105
01:18:04,030 --> 01:18:07,830
这个大家知道 看一下那个脚本 大致知道就行

1106
01:18:08,450 --> 01:18:11,710
因为大家不需要对它做太多的扩展

1107
01:18:11,710 --> 01:18:13,470
我也是大家莫读懂就OK

1108
01:18:14,410 --> 01:18:17,550
第二个就是要考虑就是找到并加载应用程序

1109
01:18:18,210 --> 01:18:19,210
安静字码

1110
01:18:19,210 --> 01:18:20,990
那么这个和这个结构相关

1111
01:18:20,990 --> 01:18:24,430
在这个会编程序 自动生制会编程序里面指出了

1112
01:18:25,050 --> 01:18:27,770
这个emcee里面的应用程序有几个

1113
01:18:27,770 --> 01:18:29,450
每个应用程序的位置在哪

1114
01:18:29,590 --> 01:18:32,930
有了这个信息,这是一些汇边级的一些全局变量

1115
01:18:32,930 --> 01:18:36,990
比如说这里面给出了一个ABP0的start和ABP0的end

1116
01:18:36,990 --> 01:18:41,050
那又是第0个APP的它的骑士地址和位置这个地方

1117
01:18:41,050 --> 01:18:42,790
有了这个变量

1118
01:18:42,790 --> 01:18:44,030
我们OS能找到这个变量

1119
01:18:44,030 --> 01:18:49,270
自然就可以把相应的APP从某一个位置

1120
01:18:49,270 --> 01:18:52,570
加载到它应该执行的一个内存骑士地址里面去

1121
01:18:53,490 --> 01:18:56,230
OK,就是要把对抗,这是img

1122
01:18:56,230 --> 01:19:01,390
要把这里面通过AppManager的查找功能找到它的起始地址和结束地

1123
01:19:01,390 --> 01:19:01,490
址

1124
01:19:01,490 --> 01:19:08,130
然后把这块区域从这儿烤焙到这个地方来之类

1125
01:19:08,130 --> 01:19:10,050
存在的一块固定的区域去执行

1126
01:19:11,010 --> 01:19:16,110
OK 那我想问一下它应该烤到哪一个地址去执行

1127
01:19:20,030 --> 01:19:23,270
想一想应该烤到哪个地址执行

1128
01:19:23,270 --> 01:19:25,950
我说一定要烤到某一个固定的地址

1129
01:19:56,430 --> 01:20:00,110
你还有一些处置化的工作,做好处置化的工作之后,你才能跳过去执

1130
01:20:00,110 --> 01:20:03,030
行。这是找到并加载的过程。

1131
01:20:03,950 --> 01:20:09,270
假设我们找到并加载,也做完处置化,让它去执行了。执行过程中,它

1132
01:20:09,270 --> 01:20:14,310
一定会有一个,不是一定了,它可能会有这个系统交用产生,比如说我们的print。

1133
01:20:14,730 --> 01:20:20,390
那它就会一步步下来,到这儿来,执行那个e-code指令。

1134
01:20:20,790 --> 01:20:24,930
接下来我们要考虑的是,一旦我们应用程序执行那条e-code指令之

1135
01:20:24,930 --> 01:20:25,490
后,

1136
01:20:25,570 --> 01:20:30,030
产生特形机切换的时候,接下来不管你自己。

1137
01:20:30,350 --> 01:20:34,990
我们都还很拼命对,就是这一块,特形机切换这一块之类的。

1138
01:20:35,030 --> 01:20:39,430
这一块稍微复杂一点,这个大家需要进一步去了解一下。

1139
01:20:40,990 --> 01:20:43,090
我们先看这个简单过一下这个AP Manager

1140
01:20:43,090 --> 01:20:46,730
它为了管理 它那边会有一个管道应用程序

1141
01:20:46,730 --> 01:20:49,750
当前跑了哪些应用程序 应用程序的其实地址在哪

1142
01:20:49,750 --> 01:20:53,210
这一星期它都会在处理化过程中会把这些信息填好

1143
01:20:53,210 --> 01:20:57,310
根据这个image会把它填好 就会把这一块说好

1144
01:20:57,310 --> 01:21:00,490
然后它有一个相应的全局变量 这个直接跳过

1145
01:21:00,490 --> 01:21:03,510
这个大家不是用ROS写的也不用看

1146
01:21:03,510 --> 01:21:08,130
你用ROS写的大致自己再去看看就OK了

1147
01:21:08,130 --> 01:21:09,130
没必要去了解

1148
01:21:09,130 --> 01:21:12,930
你只要知道说这个结构里面通过兔子化

1149
01:21:12,930 --> 01:21:14,790
我能够知道有多少个应用程序

1150
01:21:14,790 --> 01:21:17,070
当前要跑的应用程序是谁

1151
01:21:17,570 --> 01:21:20,350
所有应用程序的骑士地址在什么地方

1152
01:21:20,350 --> 01:21:24,270
这样就OK了

1153
01:21:24,270 --> 01:21:24,390
好

1154
01:21:24,390 --> 01:21:27,050
加载应用程序的时候

1155
01:21:27,050 --> 01:21:27,990
假设我自杀骑士地址

1156
01:21:27,990 --> 01:21:30,710
我家里人我会把代码从一个地方到另一个地方去

1157
01:21:30,710 --> 01:21:32,230
然后最终会去执行

1158
01:21:32,230 --> 01:21:34,430
这里面比较special一点

1159
01:21:34,430 --> 01:21:37,250
你看这里面又多了一个内线绘编叫做Fanshi

1160
01:23:07,250 --> 01:23:11,930
我们需要去小心应对的一个地方

1161
01:23:11,930 --> 01:23:13,570
特定性切换

1162
01:23:13,570 --> 01:23:16,610
相关的CSR我们前面介绍了不少

1163
01:23:16,610 --> 01:23:18,570
这里面给了一个简单的总结

1164
01:23:18,570 --> 01:23:20,450
会社交这些操作

1165
01:23:21,370 --> 01:23:24,770
那我们可以看到底怎么来做

1166
01:23:24,770 --> 01:23:28,050
第一个你要理解硬件在执行

1167
01:23:28,050 --> 01:23:31,310
在执行Eco这条指令之后

1168
01:23:31,310 --> 01:23:32,670
硬件要干的事情

1169
01:23:32,670 --> 01:23:35,350
这设置的写了这么四步

1170
01:24:07,910 --> 01:24:09,630
所以这里面会有一个记录

1171
01:24:09,630 --> 01:24:11,310
第二也是一个记录

1172
01:24:11,310 --> 01:24:15,400
就是记录产生依靠那个异常的条指令站的

1173
01:24:16,750 --> 01:24:19,250
就是我们的硬件会记录这个SEPC的条指令

1174
01:24:20,230 --> 01:24:24,250
我们的软件也需要根据它来到这个SEPC做调整

1175
01:24:25,230 --> 01:24:28,190
因为你的硬件只是记录了产生异常条指令

1176
01:24:28,190 --> 01:24:30,070
但真正我们的软件为什么要调整

1177
01:24:30,510 --> 01:24:32,670
因为一旦回去之后如果跟错的话

1178
01:24:32,670 --> 01:24:34,410
它应该回到下一条指令去执行

1179
01:24:34,410 --> 01:24:38,210
所以我们的软件在处理之后会根据SGPC的内容

1180
01:24:38,210 --> 01:24:40,890
来做一个加4的一个操作

1181
01:24:40,890 --> 01:24:42,750
使它执行到下一条指令

1182
01:24:42,750 --> 01:24:49,250
第三个 这也是硬件要去保存的内容

1183
01:24:49,250 --> 01:24:51,390
要保存S Code的原因是什么

1184
01:24:51,390 --> 01:24:52,790
我们的软件要读这个

1185
01:24:52,790 --> 01:24:54,810
我们的软件OS要读这种信息

1186
01:24:54,810 --> 01:24:56,630
来查出来到底是哪个S Code

1187
01:24:56,630 --> 01:24:57,790
是不是S Code

1188
01:24:57,790 --> 01:24:59,890
或者是其他的一种东西

1189
01:24:59,890 --> 01:25:01,410
要通过这儿读出来

1190
01:25:01,410 --> 01:25:02,470
然后第四步

1191
01:25:02,470 --> 01:25:04,370
我们硬件要把当前那一级CVS

1192
01:25:04,370 --> 01:25:05,850
并跳到这个入口地址

1193
01:25:05,850 --> 01:25:08,050
这是我们软件要去执行的地方

1194
01:25:08,050 --> 01:25:10,050
这四步是ECode之后

1195
01:25:10,050 --> 01:25:11,870
要完成的四个硬件逻辑

1196
01:25:11,870 --> 01:25:14,770
这个大家要有一个基本的了解

1197
01:25:14,770 --> 01:25:15,970
这样我们的软件才能够基于

1198
01:25:15,970 --> 01:25:17,570
它这个硬件逻辑来

1199
01:25:17,570 --> 01:25:19,150
完成进一步的一些处理

1200
01:25:20,950 --> 01:25:23,590
好 那么我们软件在处理之后

1201
01:25:23,590 --> 01:25:26,130
OS 最初所有五线所有软件的组织

1202
01:25:26,130 --> 01:25:27,430
OS 可总要干的事情

1203
01:25:28,050 --> 01:25:29,930
OS 处理之后

1204
01:25:29,930 --> 01:25:36,050
正面会有一个特点就是用户站和内核站,那就有一个问题了。

1205
01:25:36,190 --> 01:25:40,090
其实我们现在还没有业表,我们还没有讲业表这些东西,只讲业表这些东西。

1206
01:25:40,330 --> 01:25:44,090
业界线其实没有对这个内层做出隔离,没有隔离。

1207
01:25:44,770 --> 01:25:50,150
那我们为什么不用一个站,就用用户站就行了,我们只要用一个要根据内核单独

1208
01:25:50,150 --> 01:25:52,530
设置一个站,大家想一想。

1209
01:25:55,910 --> 01:25:57,890
我直接用用户站那个站不行吗?

1210
01:26:04,390 --> 01:26:10,970
这就是原理和实现的不同。我们原理根本不齐。原理上没有所谓的,我只

1211
01:26:10,970 --> 01:26:14,510
要保存状态、恢复状态,状态就把所有的系列都给掩盖。

1212
01:26:45,010 --> 01:26:51,010
或者它那个HP的系统器根本就是一个非法的定式,因为我不用嘛。那每天

1213
01:26:51,010 --> 01:26:52,970
你继承它,你OS就被包容了。

1214
01:26:55,230 --> 01:26:59,710
所以设置内核战很重要一点是在于,我根本就不信应用程序,因为我成

1215
01:26:59,710 --> 01:27:01,030
功了,我继续了,能不能就不信了。

1216
01:27:01,770 --> 01:27:08,390
我如果要用用户战,意味着我已经信任用户程序一定给我建好了一个战,给我

1217
01:27:08,390 --> 01:27:08,730
起用。

1218
01:28:08,730 --> 01:28:10,950
我还要保存一个所谓的状态

1219
01:28:10,950 --> 01:28:14,710
这个状态就是证明叫Trap Context

1220
01:28:14,710 --> 01:28:16,490
你会发现在我们的OS里面

1221
01:28:16,490 --> 01:28:18,350
这个Context条件非常不一样

1222
01:28:18,350 --> 01:28:21,010
但它的前缀经常被忽略

1223
01:28:21,010 --> 01:28:24,450
是Function Context就是函数调用的上下文

1224
01:28:25,570 --> 01:28:29,010
还是所谓的Trap就是所谓异常的上下文

1225
01:28:29,010 --> 01:28:30,890
还是所谓的中断上下文

1226
01:28:30,890 --> 01:28:35,070
还是我们的将来讲的任务或者进程上下文

1227
01:28:35,570 --> 01:28:37,290
所以由于你的前缀不一样

1228
01:28:37,290 --> 01:28:39,290
使得你上下文的东西也是会压

1229
01:28:40,170 --> 01:28:42,770
不能简单地靠一个上下文和一个状态

1230
01:28:42,770 --> 01:28:44,950
就能把这个东西给设计出来

1231
01:28:45,470 --> 01:28:48,210
对于我们的原理 讲超级统原理来说

1232
01:28:48,210 --> 01:28:51,190
我用一个词 上下文状态就够了

1233
01:28:51,190 --> 01:28:53,470
但是你如果要去实现它

1234
01:28:53,470 --> 01:28:55,430
你需要去理解细节

1235
01:28:55,430 --> 01:29:00,470
对于我们的特定性信号而言

1236
01:29:00,470 --> 01:29:02,490
当我们进行Z扣 什么Z扣

1237
01:29:02,490 --> 01:29:03,970
Z扣了之后你会发现

1238
01:29:03,970 --> 01:29:05,650
前面我们理解硬件了

1239
01:29:05,650 --> 01:29:10,750
事物里面,它没有对空无极能器做任何的保存的操作,那意味着

1240
01:29:10,750 --> 01:29:11,050
什么呢?

1241
01:29:11,050 --> 01:29:15,330
意味着,我们应用程序正在执行这一点的时候,其实应用程序它有很多技能

1242
01:29:15,330 --> 01:29:19,590
器已经保存了当前这个应用程序执行所需要的一些数据放在里面了。

1243
01:29:19,650 --> 01:29:24,510
你到内核里面执行的时候,内核也是一段代码,它一定会用到这些技能

1244
01:29:24,510 --> 01:29:28,150
器,编辑会用到这些技能器,一定会把这些技能器给充掉。

1245
01:29:28,710 --> 01:29:30,950
那你如果不够保存的话,你将来没法回去。

1246
01:29:31,550 --> 01:29:37,210
所以它很重要要把冲锋技能器,32的冲锋技能器,其实还肯定不用保存

1247
01:29:37,210 --> 01:29:37,330
它。

1248
01:29:37,390 --> 01:29:42,050
它为了统一性就写了个32技能器,S0到S32,全都保存起来。

1249
01:29:42,230 --> 01:29:45,090
然后呢,还有两个特殊的,就SStatus。

1250
01:29:45,690 --> 01:29:49,190
因为我们要回到将来的状态,也要保存起来。

1251
01:29:49,550 --> 01:29:51,370
然后SEPC也要保存起来。

1252
01:29:51,370 --> 01:29:59,190
主持人:"那我想问的是,我如果不保存sdatas和sdc,会出现问题吗?

1253
01:30:00,630 --> 01:30:05,830
我前面说保存通缉也是有必要的。那这俩好像十百年代的人一样。它

1254
01:30:05,830 --> 01:30:14,890
会被冲吗?这其实说明它会被冲掉吗?会被谁冲掉的?"

1255
01:30:17,530 --> 01:30:25,790
在执行这个时候,如果再次产生异常或者争端,就会成功。所以,为了避免应

1256
01:30:25,790 --> 01:30:31,350
对那种更复杂的情况,它还是需要把它保存起来。保存的目的是为了将来

1257
01:30:31,350 --> 01:30:39,070
即使里面的重调外面能够恢复。所以,这几个是必须要保存的,它

1258
01:30:39,070 --> 01:30:41,870
能够覆盖掉重调的一个意思。

1259
01:30:43,850 --> 01:30:46,890
第二个就是你们需要同意的就是我们要设置好这个入口点

1260
01:30:46,890 --> 01:30:50,570
再想一想还是要做大量的处置化的工作

1261
01:30:50,950 --> 01:30:55,210
你要通过stvc把这个入口地址给设置好out types

1262
01:30:55,650 --> 01:30:59,950
out types是一个汇变s里面的一个汇变函数

1263
01:31:01,190 --> 01:31:04,870
设置好这个之后才能够确保说当你直接依靠的时候一定会跳到这去

1264
01:31:07,510 --> 01:31:13,850
好,终于到了,把这个兔子办案也讲好了,大家知道要保存什么东西,然后看哪儿

1265
01:31:13,850 --> 01:31:21,550
去,都是我们软件做好准备了,接下来产生E-call了,产生E-call之

1266
01:31:21,550 --> 01:31:29,570
后,我们的OS首先经过硬件四步入轨之后,OS的offline程序会开启软

1267
01:31:29,570 --> 01:31:34,350
件的执行,软件执行干什么执行,准备打断应用程序的上下文。

1268
01:31:34,350 --> 01:31:41,430
就是要把刚才那个Trap Contest里面的那些技能器内容全都要导到

1269
01:31:41,430 --> 01:31:42,550
Memory里面去

1270
01:31:42,550 --> 01:31:43,570
Memory是什么地方

1271
01:31:44,330 --> 01:31:46,610
我们专门分配了一个客户次带

1272
01:31:46,610 --> 01:31:48,350
我们说前面分配了一个全聚变量

1273
01:31:55,190 --> 01:31:57,070
好 大家先休息一下

1274
01:37:03,390 --> 01:37:13,990
OK,那我们继续上课,我会抓紧一点,我想谈到的是这个切换Trap3小文,就是

1275
01:37:13,990 --> 01:37:23,490
这一次和这个Lecture3第三讲的重点,因为这里面涉及到硬件的操作,软

1276
01:37:23,490 --> 01:37:25,990
件的操作,软件怎么配合在一起,相关性的工作。

1277
01:37:26,550 --> 01:37:31,130
所以你看到特定期切换的时候已经提到了切换Trap上架

1278
01:37:31,130 --> 01:37:33,170
这个Trap对我们应用程序而言

1279
01:37:33,170 --> 01:37:35,530
它就是一个叫做 我们还有一个概念 异常的程序

1280
01:37:35,530 --> 01:37:39,110
你后面会讲到 就是太极接下来的处理

1281
01:37:39,110 --> 01:37:42,410
都跟我们应用程序没有任何关系了

1282
01:37:42,410 --> 01:37:44,210
感觉是一个特别特殊的程序

1283
01:37:44,210 --> 01:37:47,370
专门去做一个内核击的操作

1284
01:37:47,370 --> 01:37:50,710
所以它第一步要曹永来保存被打断的应用程序

1285
01:37:50,710 --> 01:37:52,170
就是Trap上架

1286
01:37:52,950 --> 01:37:54,350
我们以前函数这样的时候

1287
01:38:55,730 --> 01:38:58,630
把数据取出来之后,完成性交用的一个具体的执行。

1288
01:38:59,190 --> 01:39:04,530
我们在这里面只设计了两个性交用,一个是Ret,一个是Exit退出,就写

1289
01:39:04,530 --> 01:39:05,990
了字不算和退出。

1290
01:39:07,490 --> 01:39:11,570
一旦做完这个性交用操作之后,整个这个操作过程不一定要对得到特

1291
01:39:11,570 --> 01:39:11,850
别指令,

1292
01:39:11,930 --> 01:39:15,310
那可能很简单的一些正常的逻辑,这些正常的Ret或者是这些那种

1293
01:39:15,310 --> 01:39:17,710
高级人写的一些function做完之后。

1294
01:39:17,710 --> 01:39:24,170
但是你最后要从内核态回到用户态的时候,你就发现它又不得不执行

1295
01:39:24,170 --> 01:39:28,350
一些所谓的特权指令,又操作了别机的范畴,必须要走起回边了。

1296
01:39:28,450 --> 01:39:39,010
所以你会有一个叫做SIT这么一个指令,让我们能够从内核态回到用户

1297
01:39:39,010 --> 01:39:39,470
态去。

1298
01:39:39,850 --> 01:39:45,830
那为了能够回去,在SIT指令之前,我们还需要把所有刚才你保存的context

1299
01:39:45,830 --> 01:39:46,870
全部恢复回来。

1300
01:40:31,130 --> 01:40:41,010
所以你一定要有一个special的东西来帮我们来完成一个准准。这个准准什么呢?就是你

1301
01:40:41,010 --> 01:40:45,870
从哪儿开始写。本来这个信息应该放在SP里面,我们要写在占领,占领,

1302
01:40:46,310 --> 01:40:46,470
占领,这个信息应该放在SP里面,这个信息应该放在SP里面,这个信息

1303
01:40:46,470 --> 01:40:46,470
应该放在SP里面,这个信息应该放在SP里面,这个信息应该放在SP

1304
01:40:46,470 --> 01:40:46,470
里面,这个信息应该放在SP里面,这个信息应该放在SP里面,这个信息

1305
01:40:46,470 --> 01:40:46,470
应该放在SP里面,这个信息应该放在SP里面,这个信息应该放在SP

1306
01:40:46,470 --> 01:40:46,590
里面,这个信息应该放在SP里面,这个信息应该放在SP里面,这个信息

1307
01:40:46,590 --> 01:40:46,590
应该放在SP里面,这个信息应该放在SP

1308
01:40:46,590 --> 01:40:50,970
但你如果一旦把SD给付出之后,那以前用户带的那个SP就被冲掉了,

1309
01:40:51,030 --> 01:40:54,350
因为它只有一个SP,你放弃人气,只有一个SP。

1310
01:40:54,970 --> 01:40:59,630
所以,我一定要有一个地方能够把我这个站顶这个地方能够帮我划存起来,就是这个

1311
01:40:59,630 --> 01:41:00,030
Scratch。

1312
01:41:01,410 --> 01:41:02,370
这里面存着什么?

1313
01:41:32,670 --> 01:41:39,270
然后把Scratch内容放到SP里面去。通常就是大列的一个Scratch。这个操

1314
01:41:39,270 --> 01:41:42,570
作是一条指令搞定的。一旦搞定一条指令之后,那意味着我们当

1315
01:41:42,570 --> 01:41:49,550
前的那个用户态的SP会被缓存在Scratch这些里面。而现在的SP已经

1316
01:41:49,550 --> 01:41:53,370
变成了内核战的占领了。

1317
01:41:53,370 --> 01:41:59,250
OK 我的SP虽然改了,但是我还有一个地方缓存着。

1318
01:41:59,410 --> 01:42:04,370
然后再基于这个站点来完成所有其他技能器的一个恢复,这是一个细节。

1319
01:42:05,430 --> 01:42:12,570
OK 如果大家看这个outstripes操作的时候,它的第一条指令就干这个事情。

1320
01:42:13,010 --> 01:42:18,750
去完成一个内核站的一个设置,然后把用户站放到了Scratch这个技能器里

1321
01:42:18,750 --> 01:42:18,850
面。

1322
01:42:18,850 --> 01:42:24,210
然后就开始接下来存一堆的计程器内容 存到内核站里面去

1323
01:42:24,210 --> 01:42:28,130
这是他干的一个事情 这个我就不细讲了

1324
01:42:28,130 --> 01:42:30,550
除了存通路计程器之外 我们也讲到了

1325
01:42:30,550 --> 01:42:33,690
这个context里面还包含SATURUS和SEPC

1326
01:42:33,690 --> 01:42:36,150
把它也存到站顶上面去

1327
01:42:36,150 --> 01:42:41,050
这样我们就可以把trapcontext保存完毕 这是这一步

1328
01:42:41,050 --> 01:42:44,550
保存完毕之后 需要注意 这时候我们还没有存什么

1329
01:42:44,550 --> 01:42:47,150
我们还没有存SK 因为这个SK不能存自己

1330
01:42:47,150 --> 01:42:54,830
它现在这个内容是内核的占领信息

1331
01:42:54,830 --> 01:42:55,810
那怎么办呢

1332
01:42:55,810 --> 01:42:58,090
我再把刚才缓存的Scratch

1333
01:42:58,090 --> 01:42:59,570
这个计程器里面的内容

1334
01:42:59,570 --> 01:43:01,610
读到某一个计程器里面去

1335
01:43:01,610 --> 01:43:04,030
因为这里面所有信息都已经被缓存了

1336
01:43:04,030 --> 01:43:05,730
所以用T2也行 用什么也行

1337
01:43:06,250 --> 01:43:11,130
那么再把T2再塞到TrapContext里面

1338
01:43:11,130 --> 01:43:14,250
本来应该放用户在SP的位置的内容

1339
01:44:44,430 --> 01:44:48,030
我们讲假设你做完了SysCore一个处理之后

1340
01:44:48,030 --> 01:44:48,770
最后还要恢复

1341
01:44:48,770 --> 01:44:50,450
那这个恢复我们在后面会讲

1342
01:44:50,450 --> 01:44:52,770
SRIT包括怎么去恢复

1343
01:44:52,770 --> 01:44:55,250
大致DKD9S是一个反操作过程

1344
01:44:55,250 --> 01:44:56,990
只是最后一步是SRIT

1345
01:44:56,990 --> 01:45:00,030
但具体细节我们在后面稍微再进一步讲解

1346
01:45:00,030 --> 01:45:02,530
然后我们看一下TripHandler这一块

1347
01:45:02,530 --> 01:45:03,930
我们已经靠了TripHandler

1348
01:45:03,930 --> 01:45:04,850
TripHandler干什么事情

1349
01:45:05,390 --> 01:45:06,410
查竞争器

1350
01:45:07,070 --> 01:45:08,870
SCore和STVL

1351
01:45:08,870 --> 01:45:09,710
查找原因

1352
01:45:10,030 --> 01:45:13,390
这个原因有一定有会SCore这里面的一个字段

1353
01:46:14,070 --> 01:46:18,670
我说的是这个OS,这个我们很简单的批准OS,两种情况下会切换下一个程序

1354
01:46:18,670 --> 01:46:23,250
去执行。第一个,这个可以执行完毕,当前的程序执行完毕。第二个,这个程序

1355
01:46:23,250 --> 01:46:27,470
做了一些非法操作的事情。就这两个情况,它就会退出。

1356
01:46:27,790 --> 01:46:34,450
如果我写这个程序我不退出,举个例子,我就是一个路虎循环,对于我们现在的

1357
01:46:34,450 --> 01:46:37,730
OS来说,它能响应吗?它能打断它吗?

1358
01:47:08,970 --> 01:47:12,630
OK 最后讲执行 执行这个应用程序

1359
01:47:12,630 --> 01:47:15,150
这个应用程序 首先什么叫执行

1360
01:47:15,150 --> 01:47:17,810
你要完成相应的处组吧 操作要完成处组吧

1361
01:47:17,810 --> 01:47:21,630
你要这个应用程序做好相应的占空间 执行环境的一个建设

1362
01:47:22,230 --> 01:47:24,850
之后你才能够去执行应用程序

1363
01:47:26,330 --> 01:47:32,490
OK 那这里面也是一种是一个tricky的事情

1364
01:47:32,490 --> 01:47:35,330
我前面讲了说这个应用程序已经被执行了

1365
01:47:35,330 --> 01:47:37,210
但是第一个应用程序怎么执行

1366
01:47:38,170 --> 01:47:39,910
因为我现在一开始执行的时候

1367
01:47:39,910 --> 01:47:41,250
我还是在执行

1368
01:47:41,250 --> 01:47:43,450
我现在要签了应用程序执行

1369
01:47:43,450 --> 01:47:44,690
它会有一个过程

1370
01:47:44,690 --> 01:47:45,630
我执行第一个应用程序的时候

1371
01:47:45,630 --> 01:47:47,230
一定要会说

1372
01:47:47,230 --> 01:47:51,010
我要能够从内核态回到用户上去

1373
01:47:52,450 --> 01:47:54,630
但这时候应用程序第一个应用程序还没有开始执行

1374
01:47:54,630 --> 01:47:56,930
所以我们需要给这个第一个应用程序

1375
01:47:56,930 --> 01:47:58,970
建立好一个回去的环境

1376
01:47:59,590 --> 01:48:00,890
这个回去环境是什么呢

1377
01:48:01,430 --> 01:48:02,970
就是你要去构造出

1378
01:48:02,970 --> 01:48:04,770
即使这个应用程序还没有开始执行

1379
01:48:36,030 --> 01:48:44,250
比如说,我会给X0到X31除了SP之外的所有的其他基础清个零,

1380
01:48:44,330 --> 01:48:51,510
然后SP会指向我们内核给应用程序分配的那个占了70的例子,

1381
01:48:51,670 --> 01:48:56,090
然后再会给设置两个特殊的,就是Sdata和SEPC。

1382
01:48:56,250 --> 01:49:02,990
SEPC指向什么地方呢?SEPC指向应用程序的第一条指令的位置。

1383
01:49:02,990 --> 01:49:06,030
那这样的话 我在做SIT的时候就可以回得去了

1384
01:49:06,850 --> 01:49:11,310
因为SIT呢 第一个 所有的计程器已经设置好了 通行器已经设置好了

1385
01:49:11,310 --> 01:49:12,990
SIT干的事情是什么呢

1386
01:49:14,010 --> 01:49:16,790
它会根据你的status里面的那个前一个状态

1387
01:49:16,790 --> 01:49:18,910
前一段说是U mode 这也得构造出来

1388
01:49:19,590 --> 01:49:22,110
它会回到U mode 根据status里面回到

1389
01:49:22,110 --> 01:49:25,070
之前的一个从S mode回到U mode里去 这里构造的

1390
01:49:25,070 --> 01:49:26,390
第二个里面构造的

1391
01:49:26,390 --> 01:49:28,110
它会根据SEPC里面的

1392
01:49:28,110 --> 01:49:30,490
SEPC写错了 S EPC

1393
01:49:31,050 --> 01:49:37,210
SEPC里面的那个值去恢复PC继承器。既然这是你构造出来的,你把它

1394
01:49:37,210 --> 01:49:40,430
设成了第一条子型,它就回到第一条子型去执行。所以它就可以正常执行

1395
01:49:40,430 --> 01:49:44,690
了。这就是SRIT要干的事情。

1396
01:49:45,930 --> 01:49:50,710
刘仲敬:"好,我就问大家了。大家都是做过CPU的。这里面有一个PC,有一个SEP

1397
01:49:50,710 --> 01:49:56,230
C。那意味着SETC是一个继承器,那PTC是一个继承器。PC继承器

1398
01:49:56,230 --> 01:49:57,070
谁看得见?"

1399
01:49:57,070 --> 01:50:01,630
超级我们看见了吗 右边这些能看见了吗

1400
01:50:01,630 --> 01:50:05,550
看不见 就跟这个CPU的MODE一样

1401
01:50:06,110 --> 01:50:08,010
我们的RESPONSE设计 design设计

1402
01:50:08,010 --> 01:50:09,710
它认为你看见了没有意义

1403
01:50:10,350 --> 01:50:12,750
它就根本不给你看见 OK

1404
01:50:15,470 --> 01:50:19,490
好 这个你看这里面就讲它怎么去恢复的

1405
01:50:19,490 --> 01:50:22,430
就把这个构造出 虚构出了一个trapcode type

1406
01:50:22,430 --> 01:50:24,030
把这个入口地址设成这儿

1407
01:50:24,030 --> 01:50:29,710
这已经当时讲过了,主要是那个入口地址和SP,然后呢,接下来就是SIT

1408
01:50:29,710 --> 01:50:30,890
就返回了。

1409
01:50:31,550 --> 01:50:34,730
这个讲的是,第一个程序执行的时候,是要做这个事情的。

1410
01:50:34,730 --> 01:50:40,150
一旦这个程序执行起来之后,当应该正常执行之后,它再去通过

1411
01:50:40,150 --> 01:50:44,710
e-core执行下来之后,那个TrapContext我们之前要做一个保存。

1412
01:50:45,370 --> 01:50:49,950
那个呢,是下一次你要恢复回去的时候用到的地方,这不需要构造,你本来就要保

1413
01:50:49,950 --> 01:50:50,050
存。

1414
01:51:20,590 --> 01:51:25,630
这样子要处置的话,你要去把第一个TrapContext给伪造出来

1415
01:51:25,630 --> 01:51:28,590
这里面大致讲了一个大致的流程,细节我就不细讲了

1416
01:51:28,590 --> 01:51:30,350
大家知道ID就OK了

1417
01:51:30,350 --> 01:51:35,630
伪造完之后,你会通过执行一个叫做两个下滑线的restore

1418
01:51:35,630 --> 01:51:39,370
这是我们说的那个TrapX的汇变函数

1419
01:51:39,370 --> 01:51:44,850
这汇变函数里面就会完成基于刚才说到的TrapContext的内容

1420
01:51:44,850 --> 01:51:46,910
来把所有的节目器给回复过来

1421
01:51:46,910 --> 01:51:54,330
最后再拎一条SID指令,完成切换。这就是从内核弹回到用户台的

1422
01:51:54,330 --> 01:52:00,650
一个大致执行过程。这里面给出了相应的代码,这个我就不细讲了。

1423
01:52:01,170 --> 01:52:10,210
最后一个小问题,S-Scratch是何时会设置为内核占占顶的?大家试

1424
01:52:10,210 --> 01:52:10,570
搞一下。

1425
01:52:20,410 --> 01:52:24,310
我前面说的是我好像是执行性疗养用

1426
01:52:24,310 --> 01:52:25,970
E-Core执行完之后那个Splash

1427
01:52:25,970 --> 01:52:28,650
已经被设置为内核战的站点

1428
01:52:28,650 --> 01:52:30,130
但是你应该

1429
01:52:30,130 --> 01:52:31,310
这已经被设置了

1430
01:52:31,310 --> 01:52:34,070
它何止不应该被设置

1431
01:52:34,070 --> 01:52:35,850
这个大家可以先结合

1432
01:52:35,850 --> 01:52:36,850
无论是CNROS

1433
01:52:36,850 --> 01:52:38,190
给大家看一下代码

1434
01:52:38,190 --> 01:52:40,510
大致应该是在应用程序

1435
01:52:40,510 --> 01:52:41,150
处理化的时候

1436
01:52:41,150 --> 01:52:42,330
你要给它建好环境的时候

1437
01:52:42,330 --> 01:52:43,690
你要把它设置好

1438
01:52:43,690 --> 01:52:44,990
这样才能够

1439
01:52:44,990 --> 01:52:46,890
才能够去SIT回去之前

1440
01:53:16,890 --> 01:53:21,070
硬件上到底干什么事情,SRAID、SIT硬件上干什么事情

1441
01:53:21,070 --> 01:53:24,190
软件上还要再改进什么事情,才能确保

1442
01:53:24,190 --> 01:53:28,890
整个这个应用程序和内核能够相互正常的去切换执行

1443
01:53:29,910 --> 01:53:33,570
最终目的也要理解OS,所以我讲到这

1444
01:53:33,570 --> 01:53:35,950
你应该具有写第二个OS的能力

1445
01:53:35,950 --> 01:53:38,890
就上次当中已经可以写两个OS了,OK

1446
01:53:39,850 --> 01:53:42,110
后面还有更多的OS,大家应该一个一个写

1447
01:53:42,110 --> 01:53:44,990
或者一个一个看吧,你不想写,看着卖去

1448
01:53:44,990 --> 01:53:49,090
这是这一节我就算是Lecture 3就讲了

1449
01:53:50,570 --> 01:53:51,430
有什么问题吗

1450
01:53:53,730 --> 01:53:55,670
但大家可能没问题

1451
01:53:59,190 --> 01:54:00,390
问题有两种

1452
01:54:00,390 --> 01:54:01,510
一种问题是你的问答

1453
01:54:01,510 --> 01:54:02,590
一种是老师问答

1454
01:54:02,590 --> 01:54:03,810
还有就是考试

1455
01:54:03,810 --> 01:54:05,410
你要去应对

1456
01:54:06,390 --> 01:54:07,470
就是反正

1457
01:54:08,550 --> 01:54:10,930
总之你们需要去提出问题

1458
01:54:10,930 --> 01:54:11,870
如果你们提出问题

1459
01:54:11,870 --> 01:54:14,650
其实我认为是你们掌握的还不够

1460
01:55:15,390 --> 01:55:18,870
其实硬件越来越强大 内存越来越多 CPU越来越快

1461
01:55:18,870 --> 01:55:22,150
这时候我们发现我们应该有一些新的软件的方式

1462
01:55:22,150 --> 01:55:25,570
能够让我们这个CPU尽量忙起来

1463
01:55:25,570 --> 01:55:29,830
那想到一点就是 怎么说呢

1464
01:55:29,830 --> 01:55:33,370
当时的OI-3900大型机 它又多到P处理

1465
01:55:33,370 --> 01:55:36,630
它觉得内存多大了 我可以把多个程序一股脑全放到内存里

1466
01:55:36,630 --> 01:55:38,770
不像前面 我内存里只能放一个

1467
01:55:38,770 --> 01:55:42,970
那个也不是说我软件就这么笨 只能放一个

1468
01:55:42,970 --> 01:55:45,950
而是当时的硬件内存空间有限,我只能放一个

1469
01:55:45,950 --> 01:55:48,330
但现在内存大了之后可以放多个

1470
01:55:48,330 --> 01:55:51,750
放多了之后你既然切换起来就更加快了,不用每次漏的

1471
01:55:51,750 --> 01:55:55,330
第二个,大型机逐渐向小型机过渡

1472
01:55:55,330 --> 01:55:58,310
为什么它的工艺使用范围越来越广

1473
01:55:58,310 --> 01:56:01,370
那小型机过渡之后呢,人的控制力就是越来越强了

1474
01:56:01,370 --> 01:56:03,770
我们希望更加能有更好的交互

1475
01:56:03,770 --> 01:56:08,110
这时候,前面的批数比方是一旦接到之后就没有交互了

1476
01:56:08,110 --> 01:56:11,630
但是有了交互之后可以更好地去调试开发程序

1477
01:56:11,630 --> 01:56:15,870
因為這個需求使得分時越來越普遍

1478
01:56:15,870 --> 01:56:17,890
這是一個

1479
01:56:17,890 --> 01:56:20,470
在這個部分中我們發現有大量的術語有限

1480
01:56:20,470 --> 01:56:22,930
就是我們介紹這兩個喜歡造的造詞

1481
01:56:22,930 --> 01:56:26,530
我們發現有job、有task、有process

1482
01:56:26,530 --> 01:56:30,530
像這些不同的詞還有 program、money program等等

1483
01:56:31,090 --> 01:56:37,970
這些詞本質上來說都是想描述一個應用程序的執行過程

1484
01:57:08,070 --> 01:57:10,710
是不是和这个task就一定是有本质的区别

1485
01:57:10,710 --> 01:57:11,790
不用纠结这些东西

1486
01:57:15,530 --> 01:57:17,630
由于有了多道程序之后

1487
01:57:17,630 --> 01:57:20,090
那就存在一个谁用CPU的问题

1488
01:57:20,090 --> 01:57:21,790
这是一个调度

1489
01:57:21,790 --> 01:57:24,130
调度我们那边并不会展开讲

1490
01:57:24,130 --> 01:57:26,250
但你要知道一点

1491
01:57:26,250 --> 01:57:27,870
就是说有多个程序

1492
01:57:27,870 --> 01:57:29,270
就大家怎么去守护处理器

1493
01:57:29,270 --> 01:57:30,030
就是一个问题

1494
01:57:30,030 --> 01:57:31,790
所以我们在这里面

1495
01:57:31,790 --> 01:57:33,270
会有非常简单的处理方法

1496
01:57:33,270 --> 01:57:35,170
第一个方法是全叫应用

1497
01:57:35,170 --> 01:57:37,450
应用程序说我要你调度

1498
01:58:07,490 --> 01:58:10,450
这种多用户多任务的一个操作

1499
01:58:13,310 --> 01:58:14,630
这里面你看又多了个词

1500
01:58:14,630 --> 01:58:17,950
前面叫job工作一次工作

1501
01:58:17,950 --> 01:58:19,690
现在叫一次任务

1502
01:58:19,690 --> 01:58:20,850
以前叫multiprogramming

1503
01:58:20,850 --> 01:58:22,090
现在叫multi-task

1504
01:58:22,450 --> 01:58:23,970
其实表达的还是一个意思

1505
01:58:23,970 --> 01:58:25,490
就是在类型中跑多个程序

1506
01:58:27,230 --> 01:58:29,030
这里面我们提了一个词叫task

1507
01:58:29,030 --> 01:58:30,370
后面提了一个词叫process

1508
01:58:30,370 --> 01:58:33,070
你可以把这个task以为是process的前身

1509
01:58:33,070 --> 01:58:35,850
它想描述应用的一次执行过程

1510
01:58:35,850 --> 01:58:42,170
这是对Task的一个非常overview的一个表述

1511
01:58:43,850 --> 01:58:45,970
然后由于有了这个分十多任务

1512
01:58:45,970 --> 01:58:47,790
使得一个应用程序的执行阶段

1513
01:58:47,790 --> 01:58:50,390
它会切分成很多一些时间片

1514
01:58:50,390 --> 01:58:51,670
有的时间片是它来执行

1515
01:58:51,670 --> 01:58:52,810
有的时间片不是它来执行

1516
01:58:53,170 --> 01:58:56,270
它整个这个时间片的一个执行过程

1517
01:58:56,270 --> 01:58:58,230
形成了整个这个任务的执行过程

1518
01:58:58,230 --> 01:58:59,410
那么既然在一个时间片

1519
01:58:59,410 --> 01:59:01,190
这个在执行的就叫任务片

1520
01:59:01,190 --> 01:59:03,470
但是可以这么来做一些区分

1521
01:59:04,330 --> 01:59:08,210
这边就给出了把任务做了一个进一步明确的一个定义

1522
01:59:08,210 --> 01:59:11,750
什么叫任务呢 是一个具有独立功能的程序

1523
01:59:11,750 --> 01:59:14,410
在一个数学集合上的一次动态的执行过程

1524
01:59:14,410 --> 01:59:17,590
它是我们后面讲的这个进程的一个前身

1525
01:59:17,590 --> 01:59:20,390
进程更加强大 进程还管理很多资源

1526
01:59:20,390 --> 01:59:22,510
这边的任务它没有管太多资源

1527
01:59:23,750 --> 01:59:26,790
那么应用程序执行过程 那么就会有一个实验片来组成

1528
01:59:26,790 --> 01:59:31,130
在一个实验片上的执行片段或者空前片的称之为执行任务片

1529
01:59:31,130 --> 01:59:32,910
就计算任务片或者空前任务片

1530
02:00:03,530 --> 02:00:09,370
这也是一样,当你切换的时候,你会有代价,你的大脑里面要做一个保存与

1531
02:00:09,370 --> 02:00:13,370
恢复,这个过程多了的话,效率就不高了。

1532
02:00:13,410 --> 02:00:19,130
但是我们OS为什么要切换?因为我们的CPU太快了,它这个切换对它不算什么事,

1533
02:00:19,230 --> 02:00:20,750
所以它就各种各样的切换。

1534
02:00:21,030 --> 02:00:27,910
我们现在讲到第二个切换,就是任务切换,这个已经提过了。

1535
02:00:29,530 --> 02:00:32,910
那么抢单式调度,它这个执行特点是什么呢?

1536
02:00:34,910 --> 02:00:38,730
执行程序其实不用管什么时候要放弃处理器,我们操作用统一来管。

1537
02:00:39,350 --> 02:00:42,010
你只管执行就行了,我们操作用根据我们的一个理解,

1538
02:00:42,150 --> 02:00:46,390
按照时间片让你的某些时间在执行,某些时间不在执行,

1539
02:00:46,430 --> 02:00:49,230
它实际上整个执行过程变成一个暂停继续的过程。

1540
02:00:49,670 --> 02:00:52,970
而这个过程对我们的应用程序的执行来说是透明的,我们应用程序

1541
02:00:52,970 --> 02:00:53,850
根本改变不到。

1542
02:03:53,850 --> 02:03:55,610
好 那任务和程序的关系

1543
02:03:55,610 --> 02:03:57,250
任务是程序是执行过程

1544
02:03:57,250 --> 02:03:59,670
所以程序是什么 程序是一些静态的代码

1545
02:03:59,670 --> 02:04:02,370
无论是原代码的程序 还是可执行程序的静态代码

1546
02:04:02,370 --> 02:04:04,410
而你任务呢 实际上丢在类存里面去

1547
02:04:04,410 --> 02:04:06,750
已经被操纵丢在类存里面去 执行一个过程

1548
02:04:06,750 --> 02:04:08,310
这个程序执行过程叫做任务

1549
02:04:08,310 --> 02:04:12,090
它会有它的类存空间 还有它的执行过程 变化过程

1550
02:04:12,090 --> 02:04:14,210
而这里面呢 没有这些东西

1551
02:04:14,210 --> 02:04:17,850
这是大家很容易理解的一个静态动态的一个区别

1552
02:04:28,070 --> 02:04:43,310
这里面简单小节一下 程序是一个静态的文件

1553
02:04:43,310 --> 02:04:45,350
而任务是程序的一个执行过程

1554
02:04:45,350 --> 02:04:46,530
它会有不同的

1555
02:04:46,530 --> 02:04:47,830
在不同时间点不同执行状态

1556
02:06:47,830 --> 02:06:54,290
在某些时刻给记录下来。这不能在记录下来,因为我们要完成任务的切

1557
02:06:54,290 --> 02:06:55,710
换,就是干这个事情。

1558
02:06:56,310 --> 02:07:01,110
它如果不切换,那我没必要记录。你只有对它进行管理和切换的时候,我们

1559
02:07:01,110 --> 02:07:02,630
才需要记录这个状态信息。

1560
02:07:03,730 --> 02:07:09,150
整个这个状态包含了它的执行的位置,就是控制流相关。我们说的控制

1561
02:07:09,150 --> 02:07:10,790
流就是程序执行的位置。

1562
02:07:11,450 --> 02:07:13,530
这是一个代码执行的过程

1563
02:07:13,530 --> 02:07:16,130
在某个时间点上 它到底执行在哪

1564
02:07:16,130 --> 02:07:17,930
这个位置是它的一个状态

1565
02:07:17,930 --> 02:07:22,510
第二 它访问的数据 包含了memory和戒程器

1566
02:07:22,510 --> 02:07:24,270
那么这个memory 你再细分的话

1567
02:07:24,270 --> 02:07:27,250
就包含堆 杂 数据段 等等

1568
02:07:28,010 --> 02:07:29,710
这是它的一个组成

1569
02:07:30,510 --> 02:07:33,090
既然我们超级统要去管理它这个状态

1570
02:07:33,090 --> 02:07:34,610
你就要把某一个时刻

1571
02:07:34,610 --> 02:07:37,850
比如说这个任务被中断打断的时刻

1572
02:07:37,850 --> 02:07:39,590
这个任务执行系统掉用的时候

1573
02:08:39,730 --> 02:08:42,490
任務控制化你可以以為就是我們內核要管它

1574
02:08:42,490 --> 02:08:44,230
既然每一個任務都要有一個控制化

1575
02:08:44,230 --> 02:08:45,290
那通過這個TCB

1576
02:08:45,290 --> 02:08:47,730
我們的超級統就可以對它進行有效的管理

1577
02:08:47,730 --> 02:08:49,210
來記錄它的狀態

1578
02:08:49,210 --> 02:08:51,450
來測試它的一些狀態等等

1579
02:08:51,450 --> 02:08:53,630
這是任務控制化要幹的事情

1580
02:08:54,210 --> 02:08:57,930
比如說這裡面這類型中的任務

1581
02:08:57,930 --> 02:08:59,490
它在執行過程中

1582
02:08:59,490 --> 02:09:01,270
當產生中端系統電腦的時候

1583
02:09:01,270 --> 02:09:03,570
我們超級統就會把它的一些信息給記錄下來

1584
02:09:03,570 --> 02:09:06,550
比如它的PC值 它的彈值 還有其他記憶體等等

1585
02:09:06,550 --> 02:09:08,250
我們這還給一些原數據信息

1586
02:09:38,250 --> 02:09:40,110
可以控制这些信息

1587
02:09:41,150 --> 02:09:44,290
好 接下来我们会简单地把这个任务的一个

1588
02:09:44,290 --> 02:09:46,270
它执行过程中的一些不同的状态

1589
02:09:46,270 --> 02:09:47,350
给大家做个简单的介绍

1590
02:09:47,350 --> 02:09:49,270
这个状态跟它的执行相关

1591
02:09:49,270 --> 02:09:53,050
一开始的时候这个TCB还不存在

1592
02:09:53,050 --> 02:09:56,310
我们要创建一个TCB 那就是所谓创建过程

1593
02:09:56,310 --> 02:09:57,510
创建过程创建完之后

1594
02:09:57,510 --> 02:10:00,090
我要把它那个它所需要的那些站

1595
02:10:00,510 --> 02:10:02,190
继承器也给它设置好

1596
02:10:02,190 --> 02:10:05,030
代码的那个空间建好

1597
02:11:35,730 --> 02:11:39,190
我们超级种看了比较睡眠的,OK了,好,我这样去等待,设置的话就等待,

1598
02:11:39,310 --> 02:11:40,890
这样就属于一个等待状态了。

1599
02:11:40,910 --> 02:11:45,230
还有什么等待呢?比如说,这没讲到的,家常会讲到的,比如说我要读写文件

1600
02:11:45,230 --> 02:11:51,130
的时候,读写文件涉及到磁盘的操作,磁盘特别慢,然后干挡也是等,那还

1601
02:11:51,130 --> 02:11:55,910
没必要,我就让它干脆属于等待状态,然后把这个处理器让给其他的处

1602
02:11:55,910 --> 02:11:59,450
理器执行,这是很正常的一个逻辑,所以这是一个等待状态。

1603
02:16:30,050 --> 02:16:35,410
第三个切换是哪儿呢?你退出了,我要换下一个。这也是个切换。

1604
02:16:35,930 --> 02:16:41,830
所以至少在这里面我们看到了有三个点是跟切换相关的。

1605
02:16:41,850 --> 02:16:48,010
这是给了一个大致的一个结构图,是基于任务切换的一个大致的一个表示。

1606
02:16:48,010 --> 02:16:51,790
程序一、程序二,他们都在里面执行,任务性在执行的时候

1607
02:16:55,490 --> 02:16:59,770
由于Sleep系统调用,导致的切换过程

1608
02:16:59,770 --> 02:17:05,570
Sleep系统调用到内核弹,内核弹会做一个设置时钟唤醒

1609
02:17:06,330 --> 02:17:08,690
然后保存现场,恢复现场

1610
02:17:08,690 --> 02:17:12,750
保存现场之后保存什么现场,保存它的任务的context

1611
02:17:12,750 --> 02:17:16,210
然后再调度到下一个程序执行

1612
02:17:16,210 --> 02:17:19,250
然后这个执行执行一阶段之后 它也会有一个保证现场

1613
02:17:19,250 --> 02:17:22,350
然后再恢复回来去执行 轮流执行的一个过程

1614
02:17:22,350 --> 02:17:27,570
那这就是我们说这个任务切换的一个非常简单的一个表示

1615
02:17:29,050 --> 02:17:33,630
OK 这个现场就是我们说的context是一个含义

1616
02:17:34,710 --> 02:17:39,130
OK 我就大致的把原理讲完了 就是原理可以看到

1617
02:17:39,930 --> 02:17:43,390
其实大家学了前面的一些课程

1618
02:17:43,390 --> 02:17:44,750
特别是读成原理分之后

1619
02:17:45,850 --> 02:17:49,190
这一块的内容其实是比较简单的

1620
02:17:49,190 --> 02:17:49,550
是吧

1621
02:17:50,130 --> 02:17:50,950
有问题吗

1622
02:17:52,510 --> 02:17:54,550
但这个我觉得答案也没啥问题

1623
02:17:54,550 --> 02:17:56,070
但是你要去基于这个

1624
02:17:56,070 --> 02:17:58,250
这样说我就可以写个os了

1625
02:17:58,250 --> 02:18:00,270
我觉得好像还有点距离

1626
02:18:04,270 --> 02:18:07,170
所以我们会开一个头

1627
02:18:07,170 --> 02:18:08,790
还有一些时间我们开一个头

1628
02:18:08,790 --> 02:18:10,330
就是怎么去写这个os

1629
02:18:10,330 --> 02:18:11,410
我会简单说一下

1630
02:18:11,410 --> 02:18:14,290
因为本周我们会布置第一个实验

1631
02:18:15,290 --> 02:18:16,850
所以虽然没有讲完

1632
02:18:17,270 --> 02:18:20,890
但还是希望大家能够开始做这个实验

1633
02:18:20,890 --> 02:18:23,770
就是关于我们的第一次实验的内容

1634
02:18:23,770 --> 02:18:24,410
就这么讲

1635
02:18:24,410 --> 02:18:26,930
多道程序设计分超运动一个design

1636
02:18:28,750 --> 02:18:29,890
这是一个图

1637
02:18:29,890 --> 02:18:32,790
我觉得我接下来还有一点时间

1638
02:18:32,790 --> 02:18:34,270
我会把这个图给大家介绍一下

1639
02:18:34,270 --> 02:18:35,670
结果我只好OK了

1640
02:18:35,670 --> 02:18:38,530
你会发现这个图就是对前一个

1641
02:18:38,530 --> 02:18:42,110
叫做邓氏于OS的一个扩展

1642
02:18:42,110 --> 02:18:43,670
它进一步在进化

1643
02:18:43,670 --> 02:18:46,210
另外在哪呢 你会发现应用程序没有进化

1644
02:18:46,210 --> 02:18:49,750
第一个特点 应用程序是跟前几代是一样的

1645
02:18:49,750 --> 02:18:51,710
应用程序几乎没有什么变化 非常简单

1646
02:18:53,490 --> 02:18:55,810
但是我们的内核发生了比较大的变化

1647
02:18:55,810 --> 02:18:56,810
在哪呢

1648
02:18:56,810 --> 02:19:01,210
第一个 它把我们的App Manager做了个拆分

1649
02:19:01,730 --> 02:19:02,770
装了一个Loader

1650
02:19:02,770 --> 02:19:05,350
Loader就把两个人加载 查找加载

1651
02:19:05,350 --> 02:19:07,470
用Loader来这个模块小模块来执行

1652
02:19:08,010 --> 02:19:10,630
更复杂的一块功能就是任务切换相关的

1653
02:19:10,630 --> 02:19:11,510
叫做Task Manager

1654
02:19:11,510 --> 02:19:15,830
专门做了Task Manager来进行对TCB的管理

1655
02:19:15,830 --> 02:19:17,050
这一块单独拎出来了

1656
02:19:17,050 --> 02:19:19,830
就是把那个做了一个扩展

1657
02:19:19,830 --> 02:19:24,310
然后在这个

1658
02:19:26,170 --> 02:19:28,090
这是第一步 第一个OS

1659
02:19:28,090 --> 02:19:29,590
就是我们有这个之后

1660
02:19:29,590 --> 02:19:33,710
我们就可以在内存中放置多个APP

1661
02:19:35,050 --> 02:19:36,610
然后我们这边有这个之后

1662
02:19:36,610 --> 02:19:38,830
我们就可以对它APP执行方面切换就完了

1663
02:19:38,830 --> 02:19:45,730
这是一个没有中断的时候的一个非常简单的一个OS的一个Design

1664
02:19:45,730 --> 02:19:47,390
它最大的特点是引入了Task

1665
02:19:48,750 --> 02:19:52,050
我把这个架构给大家讲讲 细节下段跟在讲

1666
02:19:52,050 --> 02:19:53,470
这是第一个阶段

1667
02:19:54,350 --> 02:19:55,990
然后第二个阶段

1668
02:19:55,990 --> 02:19:58,630
这里面是我们说三个进化阶段的过程

1669
02:19:58,630 --> 02:20:01,330
这个细节我还是稍微跳一跳

1670
02:20:01,330 --> 02:20:02,610
第二个阶段在哪

1671
02:20:09,530 --> 02:20:13,070
第二就是说它要能够切换 主动切换

1672
02:20:13,070 --> 02:20:16,030
那意味着我们在这个系统调整里面会增加一个系统调整

1673
02:20:16,030 --> 02:20:20,070
叫作YAR 放弃

1674
02:20:20,510 --> 02:20:22,150
做这个放弃之后

1675
02:20:22,150 --> 02:20:24,110
那意味着在程序的执行过程中

1676
02:20:24,110 --> 02:20:26,650
我们在做这个管理的时候

1677
02:20:26,650 --> 02:20:32,630
你这个task需要把放弃的那个任务的上限文给存下

1678
02:20:33,390 --> 02:20:35,710
主动放弃那个任务

1679
02:21:35,710 --> 02:21:36,910
要完成任务的切换

1680
02:21:38,990 --> 02:21:41,010
你中断和异常和系统调用

1681
02:21:41,010 --> 02:21:42,910
它都是其实走同样一个通道

1682
02:21:43,330 --> 02:21:45,970
就是要从用户带到内核带来

1683
02:21:45,970 --> 02:21:48,430
它这里面的Trap Contacts是一样的

1684
02:21:48,430 --> 02:21:50,630
说对话的信息还是对程度

1685
02:21:50,630 --> 02:21:51,990
最主要在于你知道

1686
02:21:51,990 --> 02:21:53,690
你要去的不够去直接去想成中断

1687
02:21:53,690 --> 02:21:54,890
完成时间片的情况

1688
02:21:54,890 --> 02:21:57,870
这是它的一个重点的一个不同

1689
02:21:59,810 --> 02:22:01,950
好 今天就上到这 下课

