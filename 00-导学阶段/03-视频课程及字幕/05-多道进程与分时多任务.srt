1
00:00:34,940 --> 00:00:43,200
今天上课我们第一是继续上一次课的内容

2
00:00:43,200 --> 00:00:46,440
第二呢就是还有一个本节课的

3
00:00:46,440 --> 00:00:50,160
关于这个地址空间这一块的一些内容的介绍

4
00:00:50,960 --> 00:00:53,260
那首先我们也得到了一些反馈

5
00:00:53,880 --> 00:00:58,160
就是咱们同学啊咱们学生会啊找

6
00:01:00,600 --> 00:01:01,820
当中又做了一些调研

7
00:01:01,820 --> 00:01:07,260
然后我们也把调研结果拿到了

8
00:01:07,260 --> 00:01:10,320
调研结果之后我们会有进一步的一些分析

9
00:01:11,420 --> 00:01:13,200
希望能够更好地把这边各删好

10
00:01:13,200 --> 00:01:14,420
那先简单介绍一下

11
00:01:14,420 --> 00:01:15,680
这是一个简单的补充

12
00:01:15,680 --> 00:01:18,500
就是关于课程用到的参考书

13
00:01:18,500 --> 00:01:21,220
这都还更新到那个在线的slides上面

14
00:01:21,220 --> 00:01:25,540
所以大家也不用觉得好像没有更新

15
00:01:25,540 --> 00:01:27,000
这一块直接给上网看着

16
00:01:27,000 --> 00:01:28,460
就是第一是课程的slides

17
00:01:28,460 --> 00:01:34,840
也是在线随时可能有些更新就直接放在上楼

18
00:01:34,840 --> 00:01:36,880
关于OS

19
00:01:41,140 --> 00:01:42,480
一本参考书

20
00:01:42,480 --> 00:01:47,320
我们一般来说我在提前给大家说让大家如果有空的话去预习一下

21
00:01:47,320 --> 00:01:49,260
当然你如果不预习也没关系

22
00:01:49,920 --> 00:01:51,060
就是老师也会讲

23
00:01:51,060 --> 00:01:53,980
只是可能你理解程度可能会有些不一样

24
00:01:55,000 --> 00:01:59,040
还有一个RiskPubReader 这是一个硬件的手册

25
00:01:59,040 --> 00:02:01,140
我们重点看它其中的第十章

26
00:02:01,140 --> 00:02:05,360
关于它的特权籍内框

27
00:02:05,360 --> 00:02:07,140
就关于特权方面的一个Spec

28
00:02:07,620 --> 00:02:09,240
然后课程实践这也列出来了

29
00:02:09,240 --> 00:02:13,700
现在也增加了一些课程实验代码的API文档

30
00:02:13,700 --> 00:02:18,480
这个目前我们的助教还在努力的加注释

31
00:02:18,480 --> 00:02:21,440
现在注释还不够

32
00:02:21,440 --> 00:02:23,000
那么实验指导也是一样

33
00:02:23,000 --> 00:02:24,680
谁知道我们也做了进一步的改进

34
00:02:24,680 --> 00:02:27,840
就是包括也提供了API文档

35
00:02:31,320 --> 00:02:32,460
对于MuCore来说

36
00:02:32,460 --> 00:02:34,260
它直接是加了足够多的注释

37
00:02:34,260 --> 00:02:36,420
就在文档在那个代码里面

38
00:02:36,420 --> 00:02:37,660
而Archon它有一个工具

39
00:02:37,660 --> 00:02:39,280
比较方便可以生成一个Dock

40
00:02:39,280 --> 00:02:41,540
这样看起来会更加容易一点

41
00:02:41,540 --> 00:02:43,240
然后我们也请助教

42
00:02:43,600 --> 00:02:50,120
就是做了两个关于MuCore

43
00:02:50,120 --> 00:02:51,480
Archon框架的一个视频

44
00:02:51,980 --> 00:02:55,100
大家如果对代码还有一定的一些

45
00:02:57,480 --> 00:02:59,540
困惑的话可以去试评

46
00:02:59,540 --> 00:03:01,900
同时我们在昨天也安排昨天晚上安排了

47
00:03:02,440 --> 00:03:05,460
就是两个助教来给大家线下答疑

48
00:03:05,460 --> 00:03:09,480
如果大家觉得通过这种方式对大家有帮助的话

49
00:03:09,480 --> 00:03:11,880
我们后续还会持续这种类似的答疑

50
00:03:14,580 --> 00:03:15,620
这是这一块

51
00:03:15,620 --> 00:03:18,360
这一块我们就简单的说一下

52
00:03:27,940 --> 00:03:36,560
第二个,我们就开始我们这堂课的讲解,就是关于第五次课,地址空间。

53
00:06:23,800 --> 00:06:31,760
这个屏幕应该也是共享的吧?我理解,看不太出来,这屏幕到底共没共享

54
00:06:31,760 --> 00:06:32,760
啊?

55
00:06:37,240 --> 00:06:43,840
既然在录制 没共享 没共享我看不着

56
00:07:09,940 --> 00:07:11,880
OK 现在应该共享

57
00:07:13,740 --> 00:07:18,200
放大比例 没问题

58
00:07:37,040 --> 00:07:45,580
好,我假定现在正常了,如果现在同学有问题的话,也可以在微信里面说一下,我来

59
00:07:45,580 --> 00:07:47,840
到这边盯着微信。

60
00:07:56,340 --> 00:08:00,560
好 那我们说就是我们其实在持续地在改进我们的OS

61
00:08:01,160 --> 00:08:05,920
但是这个改进的过程其实也是希望大家在过程中能够逐步地了解我们操作

62
00:08:05,920 --> 00:08:07,660
系统的相关的一些知识点

63
00:08:07,660 --> 00:08:14,480
比如说从一行课 我们讲这个系统调用 讲去试一下这个Unix和Linux

64
00:08:14,480 --> 00:08:16,500
其实就在于让大家能够知道

65
00:08:16,500 --> 00:08:18,940
应用程序怎么取得超级功能服务

66
00:08:18,940 --> 00:08:19,980
那主要是通过系统调用

67
00:08:19,980 --> 00:08:22,140
我们给出了一些简单的系统调用

68
00:08:22,140 --> 00:08:24,500
这个大家在之前的课中或多或少被用过

69
00:08:24,500 --> 00:08:26,300
比如说读写文件等等

70
00:08:27,360 --> 00:08:29,940
那这个是非常容易理解的

71
00:08:29,940 --> 00:08:30,620
站在用户的角度

72
00:08:30,620 --> 00:08:32,480
站在应用程序的角度

73
00:08:32,480 --> 00:08:33,580
但到了第二堂课的时候

74
00:08:33,580 --> 00:08:36,860
你会发现我们就已经跟我们通常这个

75
00:08:36,860 --> 00:08:38,180
应用开发不太一样了

76
00:08:38,180 --> 00:08:39,480
你需要去了解逻辑程序

77
00:08:39,480 --> 00:08:40,480
怎么去开发

78
00:08:41,220 --> 00:08:43,700
直接面对硬件的这个LibOS

79
00:08:43,700 --> 00:08:47,920
在这里面 我们其实要关注三个知识点

80
00:08:47,920 --> 00:08:50,720
第一个你要知道硬件和软件怎么启动

81
00:08:52,580 --> 00:08:58,700
这一点 我现在讲的这些东西也许是将来大家可能会面对的一些东西

82
00:09:00,220 --> 00:09:02,080
软件怎么启动 你需要去了解

83
00:09:02,080 --> 00:09:04,080
第二个 函数调用

84
00:09:04,080 --> 00:09:07,960
我们历代的函数调用 大家在编译课学过

85
00:09:07,960 --> 00:09:11,320
但是我们现在讲的函数调用 跟编译课是不一样

86
00:09:11,320 --> 00:09:13,160
不一样在哪 你需要去了解

87
00:09:13,160 --> 00:09:16,420
第三个 我们看到 OS 已经不是最底层了

88
00:09:16,420 --> 00:09:18,260
最底层甚至还有更底层的软件

89
00:09:18,260 --> 00:09:21,720
叫 SBI 这个 RAS SBI 或者 OpenSBI 这种软件

90
00:09:21,720 --> 00:09:23,620
它可以给 OS 提供服务

91
00:09:23,620 --> 00:09:26,880
那为什么它能给 OS 提供服务呢

92
00:09:26,880 --> 00:09:28,260
它有什么样的一些特征

93
00:09:28,260 --> 00:09:30,440
它需要了解硬件

94
00:09:30,440 --> 00:09:32,840
我们要知道我们面对的硬件

95
00:09:32,840 --> 00:09:34,940
RES5 这个硬件是怎么一回事

96
00:09:34,940 --> 00:09:39,820
这个更多的是让你对硬件有更深入的了解

97
00:09:40,700 --> 00:09:42,040
第3次课的时候

98
00:09:42,760 --> 00:09:45,300
我们看到了我们支持的不是单个应用

99
00:09:45,300 --> 00:09:46,920
我们要跑多个应用

100
00:09:46,920 --> 00:09:47,940
要跑多个应用之后

101
00:09:47,940 --> 00:09:50,940
这应用已经是来自于四面八方

102
00:09:50,940 --> 00:09:53,300
它可能是不可信的

103
00:09:53,300 --> 00:09:55,560
所以我们引入了特权级的概念

104
00:09:55,560 --> 00:09:56,700
那有了特权级之后

105
00:09:56,700 --> 00:09:59,100
我们就有了用物态和内核态

106
00:09:59,100 --> 00:10:00,580
应用跑到用物态

107
00:10:00,580 --> 00:10:02,320
超运动跑到内核态

108
00:10:02,320 --> 00:10:03,780
他们这些是隔离的

109
00:10:03,780 --> 00:10:05,840
但这种隔离不是彻底的隔离

110
00:10:05,840 --> 00:10:07,880
它需要去沟通

111
00:10:07,880 --> 00:10:09,260
我们说了我们的应用程序

112
00:10:39,880 --> 00:10:41,860
在这个概念里面它讲到了

113
00:10:41,860 --> 00:10:46,240
它需要去保存应用程序发出系统

114
00:10:46,240 --> 00:10:48,540
要用那一点的时候的那些记存器的内容

115
00:10:48,540 --> 00:10:50,280
还有其他一些内容

116
00:10:50,280 --> 00:10:53,200
那你回去你怎么保存 怎么去恢复去执行

117
00:10:53,200 --> 00:10:54,640
这是需要考虑的问题

118
00:10:54,640 --> 00:10:59,140
那这是一些在原理上需要去掌握的

119
00:10:59,140 --> 00:11:01,280
那么在工程上

120
00:11:01,280 --> 00:11:02,580
其实你还需要知道的是

121
00:11:02,580 --> 00:11:03,180
我们在这里面

122
00:11:03,180 --> 00:11:04,180
因为要支持多个应用

123
00:11:04,180 --> 00:11:05,520
它实际上变成了一个image

124
00:11:05,520 --> 00:11:07,320
把多个应用和YF变成了一个image

125
00:11:07,320 --> 00:11:10,100
你要能够在这 image 里面去找到对应的 AGG 在哪

126
00:11:10,100 --> 00:11:12,660
然后把它加载去运行

127
00:11:12,660 --> 00:11:15,700
这个加载是涉及到内存拷贝

128
00:11:15,700 --> 00:11:19,780
但运行就涉及到了另外一种切换

129
00:11:19,780 --> 00:11:21,260
但这种切换前面也碰到了

130
00:11:21,260 --> 00:11:23,380
测验机里面就是从特权派

131
00:11:23,380 --> 00:11:25,820
就是 Smod 到 Umod 这个切换

132
00:11:26,620 --> 00:11:28,920
它怎么能够在一开始没有应用程序执行的时候

133
00:11:30,500 --> 00:11:34,740
它没有那个相应的所谓的线路上线文章的时候

134
00:11:34,740 --> 00:11:37,900
它就默切回去,是在于它构造了一个

135
00:11:37,900 --> 00:11:40,720
它伪造了一个初始的trap context

136
00:11:40,720 --> 00:11:43,900
从而可以使得我们的应用

137
00:11:43,900 --> 00:11:47,920
使得我们的应用能够正常地回到用户台去执行

138
00:11:47,920 --> 00:11:49,740
从第一条指令开始执行

139
00:11:50,340 --> 00:11:52,180
不光要执行,你还要把那个环境建好

140
00:11:52,180 --> 00:11:54,640
我意思说这个应用它需要有个执行环境

141
00:11:54,640 --> 00:11:58,020
这个时候的执行环境是啥

142
00:11:58,020 --> 00:12:00,280
那你要去再想一想

143
00:12:01,760 --> 00:12:04,280
然后上堂课我们还没有讲完的

144
00:12:05,080 --> 00:12:08,500
我们现在发觉为了提高整个应用的执行效率

145
00:12:08,500 --> 00:12:10,500
我们在内存中放了多个应用

146
00:12:10,500 --> 00:12:11,440
这应用有多个

147
00:12:11,960 --> 00:12:13,480
多个应用呢

148
00:12:13,480 --> 00:12:15,840
你首先要确保这多个应用

149
00:12:15,840 --> 00:12:19,740
他们之间可以都有机会去执行

150
00:12:20,200 --> 00:12:21,380
都有机会执行是什么

151
00:12:21,380 --> 00:12:22,220
设计调度

152
00:12:22,220 --> 00:12:24,220
就这里面调度我们讲的比较简单的

153
00:12:24,220 --> 00:12:25,280
第一个协作调度

154
00:12:25,280 --> 00:12:37,080
主要就是我这个应用 它主动的放弃处理器

155
00:12:37,920 --> 00:12:40,880
所谓的主动 它主动放不是说我不运行就行了

156
00:12:40,880 --> 00:12:42,920
它需要通过某种方式告读OS

157
00:12:42,920 --> 00:12:46,100
因为它自己没法去完成

158
00:12:46,100 --> 00:12:49,180
让另一个程序去运行这么一个功能

159
00:12:49,180 --> 00:12:52,660
它只有通过一个类似一样的这样的Syscall

160
00:12:52,660 --> 00:12:56,360
让我们OS得到这个请求之后

161
00:12:56,360 --> 00:12:57,360
我把你停下来

162
00:12:57,800 --> 00:12:59,000
让另一个程序执行

163
00:12:59,700 --> 00:13:01,820
实际上就涉及到就是我们说

164
00:13:01,820 --> 00:13:03,280
你要写一个特殊的软件

165
00:13:03,280 --> 00:13:08,040
这个OS它能够去加载运行不同的程序

166
00:13:08,040 --> 00:13:11,520
这种情况在我们以前的应用中是碰不到的

167
00:13:11,520 --> 00:13:13,300
我们OS需要有这个功能

168
00:13:13,300 --> 00:13:17,040
所以你会理解你要去加载和运行

169
00:13:17,040 --> 00:13:17,760
其他程序的时候

170
00:13:17,760 --> 00:13:20,760
那个程序它可能没有运行完

171
00:13:20,760 --> 00:13:21,620
它就出来了

172
00:13:22,240 --> 00:13:25,820
你要去做切换 这里面涉及到任务上下文

173
00:13:25,820 --> 00:13:27,520
第二个概念 任务上下文是出来的

174
00:13:28,260 --> 00:13:31,340
但是这个任务上下文和线路上下文

175
00:13:31,340 --> 00:13:32,740
这是两个不同的上下文

176
00:13:32,740 --> 00:13:35,000
这两个上下文合在一起才能够干什么

177
00:13:35,000 --> 00:13:37,180
才能够把这个让我们的应用

178
00:13:37,180 --> 00:13:38,460
上面跑的这个应用才是应用

179
00:13:38,460 --> 00:13:44,800
能够按照某种方式依次的去使用 处理去执行

180
00:13:45,360 --> 00:13:46,980
所以证明的关键是什么

181
00:13:46,980 --> 00:13:48,720
就是这两个上下文的切换

182
00:13:49,360 --> 00:13:55,920
这里面你可以看到所有和OS打交道比较麻烦的地方就是那些边界的地方

183
00:13:55,920 --> 00:13:59,800
特性级的切换 任务的切换 还有地址空间

184
00:13:59,800 --> 00:14:02,440
我们通过讲内存 地址空间的切换等等

185
00:14:02,440 --> 00:14:07,760
这种切换就会使得你要考虑一些比较底层复杂的东西

186
00:14:07,760 --> 00:14:11,740
从而才能够完成这种特殊的这种强大的系统级的功能

187
00:14:13,500 --> 00:14:15,180
好 这是这一块

188
00:14:15,180 --> 00:14:18,940
这是我就简单的回顾一下

189
00:14:27,300 --> 00:14:31,700
好 那这堂课我们要把上一讲的没讲完的

190
00:14:31,700 --> 00:14:33,820
要给大家简单的讲一下

191
00:14:33,820 --> 00:14:36,400
就是关于多道程序和分十多任务程序

192
00:14:42,160 --> 00:14:46,120
哟,这玩意儿,老是跑不出来。

193
00:15:09,300 --> 00:15:13,420
OK 好 那这个多道程序和分式多用其实是两个OS

194
00:15:13,880 --> 00:15:15,920
那这里面这个刚才我们看到的这是一个

195
00:15:15,920 --> 00:15:16,100
所谓一个分式多用程序

196
00:15:16,100 --> 00:15:18,720
所谓的多道程序的一个OS

197
00:15:18,720 --> 00:15:22,780
它需要应用主动的放弃处理器

198
00:15:22,780 --> 00:15:24,320
才能够完成所谓的

199
00:15:24,320 --> 00:15:27,700
让另一个应用去执行的那个效果

200
00:15:27,700 --> 00:15:29,440
当然我们后面还讲到分石

201
00:15:30,060 --> 00:15:32,160
分石这种多任务处理器

202
00:15:32,160 --> 00:15:34,740
这里面大致的步骤就是我们可以理解一下

203
00:15:35,560 --> 00:15:37,560
你通过这一讲能够知道什么呢

204
00:15:37,560 --> 00:15:39,960
知道你这个OS到底拿什么样的目标

205
00:15:39,960 --> 00:15:41,140
然后为了达这个目标

206
00:15:41,140 --> 00:15:43,120
我们要怎么样一个设计思路

207
00:15:43,120 --> 00:15:46,920
以及历史上有哪些OS是这么做的

208
00:15:46,920 --> 00:15:47,980
然后大致的有实验步骤

209
00:15:47,980 --> 00:15:50,540
特别是最后的就是我们的软件架构

210
00:15:50,540 --> 00:15:51,180
软件架构

211
00:15:51,180 --> 00:15:53,400
这套软件架构的话就是怎么去写程序

212
00:15:53,400 --> 00:15:56,400
那你还去了解这里面跟它相关的那些硬件内容

213
00:15:58,900 --> 00:16:00,780
这是我们整个的一个OV

214
00:16:01,860 --> 00:16:03,340
先看一下计划目标

215
00:16:03,340 --> 00:16:05,800
其实在这里面我们其实并没有提升

216
00:16:05,800 --> 00:16:06,920
单个应用的性能

217
00:16:06,920 --> 00:16:09,860
我们提升的是多个应用执行在一起执行的性能

218
00:16:10,300 --> 00:16:12,320
那一个方法就是把它全放到内存里面来

219
00:16:12,320 --> 00:16:13,560
这是一个很直接的方法

220
00:16:13,560 --> 00:16:15,920
这比前面的几个OS相比

221
00:16:15,920 --> 00:16:17,460
它最大的区别在哪里

222
00:16:17,460 --> 00:16:20,020
以前的OS只支持一个应用

223
00:16:20,020 --> 00:16:22,580
现在这个OS就是说Multi-Programming这个OS

224
00:16:22,580 --> 00:16:24,020
它支持多个应用

225
00:16:24,020 --> 00:16:25,120
这一点区别

226
00:16:26,480 --> 00:16:28,000
后面我们还需要去什么呢

227
00:16:28,000 --> 00:16:31,260
需要去支持多个应用可以分时处理

228
00:16:31,260 --> 00:16:36,380
以及多个应用能够协谈在一起处理

229
00:16:36,380 --> 00:16:37,480
这两种方式

230
00:16:37,480 --> 00:16:40,180
在这里面整个应用的执行过程

231
00:16:40,180 --> 00:16:41,620
它会被打成不同的段

232
00:16:41,620 --> 00:16:44,840
所以我们引入了一个新的抽象 叫做任务

233
00:16:44,840 --> 00:16:49,680
这个抽象就是为了能够便于不同的应用分时

234
00:16:49,680 --> 00:16:53,620
或者是大致分时的分时占用处理器这么一个效果

235
00:16:53,620 --> 00:16:57,500
最终我们可以形成两个不同类型的操作系统

236
00:16:57,500 --> 00:17:00,620
一个是多道程序操作系统和分时多任务操作系统

237
00:17:03,080 --> 00:17:06,620
总体思路看一下 第一步其实跟以前一样

238
00:17:06,620 --> 00:17:11,060
我们需要的是能把多个应用和内核单独变形成一个镜像

239
00:17:11,060 --> 00:17:14,880
这以前我们其实在上一个OS里面已经做到这一步了

240
00:17:14,880 --> 00:17:20,760
第二个不太一样是由于我们多个应用会放在类型中

241
00:17:20,760 --> 00:17:22,340
那么每个应用有自己的地址

242
00:17:22,340 --> 00:17:24,360
你的地址是统一编址

243
00:17:24,360 --> 00:17:26,700
需要注意这里面还没有讲虚纯

244
00:17:27,060 --> 00:17:28,780
你接触到的是物理地址

245
00:17:29,260 --> 00:17:30,980
所以大家在同一个物理地址里面

246
00:17:30,980 --> 00:17:31,840
你要统一编址的话

247
00:17:31,840 --> 00:17:34,960
你必须要位于不同的这个70地址

248
00:17:34,960 --> 00:17:36,300
才能够正确的执行

249
00:17:36,300 --> 00:17:37,600
而前面不需要在哪呢

250
00:17:37,600 --> 00:17:38,320
前面为什么不需要呢

251
00:17:38,320 --> 00:17:40,680
因为前面的OS只是一个应用

252
00:17:40,680 --> 00:17:43,240
每次只有一个应用在类型中,所以它不需要扛这个问题

253
00:17:43,240 --> 00:17:47,960
但现在你既然要放多个应用的话,必然有一个各自歧视例子里面的

254
00:17:47,960 --> 00:17:48,380
设计

255
00:17:48,380 --> 00:17:52,360
这导致你的编译要重新做一些改进

256
00:17:53,640 --> 00:17:56,360
然后后面我们要去让我们说干一句话

257
00:17:56,360 --> 00:17:59,540
就是你要让我们的应用主动的放弃处理器的话

258
00:17:59,540 --> 00:18:01,780
你要设计新的系统调用,但你自己做不到

259
00:18:01,780 --> 00:18:04,180
所以会有一个系统调用新的一个接口

260
00:18:04,180 --> 00:18:09,860
以及对这种程序执行的一个管理,我们把它称之为任务

261
00:18:09,860 --> 00:18:11,660
这个任务实际上是叫任务空置块

262
00:18:11,660 --> 00:18:15,920
通过任务空置块来完成对一个程序

263
00:18:15,920 --> 00:18:18,780
执行到一定阶段的一个状态的管理

264
00:18:18,780 --> 00:18:19,920
就像那些保存与恢复

265
00:18:19,920 --> 00:18:24,360
就任务上下文也称之为这个状态的它的一个管理

266
00:18:24,360 --> 00:18:28,460
然后同时你会发现这个任务的上下文的切换

267
00:18:29,580 --> 00:18:30,560
通常意义上理解

268
00:18:30,560 --> 00:18:32,180
我们看Oberview那个图来说

269
00:18:32,180 --> 00:18:35,140
我在应用程序我就提前来执行另一个程序

270
00:18:35,140 --> 00:18:36,920
但落实到具体实现的时候

271
00:18:36,920 --> 00:18:39,440
发现这个任务的所谓的上下文

272
00:18:39,440 --> 00:18:42,200
并不在用户态 而在内核态里面

273
00:18:42,200 --> 00:18:44,980
所以你需要完成的是在内核态里面

274
00:18:44,980 --> 00:18:47,280
才完成特形机切换之后

275
00:18:47,280 --> 00:18:49,840
再去进一步去完成任务机切换

276
00:18:49,840 --> 00:18:52,440
才能够彻底地让另一个用户去执行

277
00:18:52,440 --> 00:18:54,300
这一点是比较麻烦的一点

278
00:18:54,300 --> 00:18:56,340
大家需要去重点去了解

279
00:18:56,340 --> 00:18:58,440
然后后续我们看到

280
00:18:58,440 --> 00:19:00,340
不光是除了这个系统调整

281
00:19:00,340 --> 00:19:01,880
我们还可以通过中断方式

282
00:19:01,880 --> 00:19:03,840
强制地打断这个处理器的执行

283
00:19:03,840 --> 00:19:05,940
来完成所谓的主动的

284
00:19:05,940 --> 00:19:08,820
超级种主动去切换这个任务的那一过程

285
00:19:08,820 --> 00:19:10,120
那任务就是被动的

286
00:19:10,120 --> 00:19:12,100
任务你无论你想不想切换

287
00:19:12,100 --> 00:19:13,580
都是被超级种强制切换

288
00:19:13,580 --> 00:19:16,100
这是一个大致的一个我们想去这么做

289
00:19:16,100 --> 00:19:17,960
当然这只是一个总体的一个思路

290
00:19:17,960 --> 00:19:21,140
并不足以让我们写出这个代码或者写出这个OS

291
00:19:22,800 --> 00:19:24,660
好 这是简单的把这个思路说一下

292
00:19:24,660 --> 00:19:28,060
那么其实我们现在讲的内容

293
00:19:28,860 --> 00:19:31,960
还是一样在60年代的时候就已经接触到了

294
00:19:31,960 --> 00:19:35,040
所以大家接触是非常古老的超级社议思想

295
00:19:35,940 --> 00:19:39,380
但这种设计思想到现在为止依然会被使用

296
00:19:39,380 --> 00:19:42,200
并不是说这种思想已经没有用了

297
00:19:42,200 --> 00:19:44,780
这个是其实大家需要了解的

298
00:19:44,780 --> 00:19:48,620
很多的我们讲的支持并不意味着过时

299
00:19:48,620 --> 00:19:51,480
它在现在还有它一些特定的

300
00:19:51,480 --> 00:19:55,100
或者是一些比较适合的一些应用场景

301
00:19:55,100 --> 00:19:58,100
这个讲的就是一个Leo3这么一个计算机

302
00:19:58,100 --> 00:20:02,960
英国很早就在这里面去支持多个程序

303
00:20:02,960 --> 00:20:03,740
依次去执行

304
00:20:03,740 --> 00:20:05,740
就是我们典型的批处理程序

305
00:20:06,960 --> 00:20:09,560
那这个图只是一个示意图

306
00:20:09,560 --> 00:20:11,600
那你如果真正要去跑起来的话

307
00:20:11,600 --> 00:20:15,460
你发现你要去考虑很重要一点就是跟之前的不同

308
00:20:15,460 --> 00:20:17,880
这个程序执行到某一个阶段的时候

309
00:20:17,880 --> 00:20:20,260
要去完成一个切换

310
00:20:20,260 --> 00:20:21,380
所以你要有一个任务

311
00:20:21,380 --> 00:20:24,300
你会发现从前面的application manager

312
00:20:24,300 --> 00:20:25,740
会变成一个task manager

313
00:20:25,740 --> 00:20:29,980
它会完成对一个程序中间状态的保存和管理

314
00:20:29,980 --> 00:20:31,980
这我们称之为抽象出一个所谓的

315
00:21:01,980 --> 00:21:02,840
我们要去做的

316
00:21:03,360 --> 00:21:05,860
那你一样就是你可以简单的去取得

317
00:21:05,860 --> 00:21:08,500
相应的这个一个branch的代码

318
00:21:08,500 --> 00:21:10,000
然后就自己去实践一下

319
00:21:10,460 --> 00:21:13,140
我假定大家去

320
00:21:13,140 --> 00:21:14,660
假定大家实践过

321
00:21:15,220 --> 00:21:17,520
大家如果没有实践过的话也没关系

322
00:21:17,520 --> 00:21:19,740
到时候考试的时候会进一步实践一下

323
00:21:21,600 --> 00:21:22,700
这是大致的具体步骤

324
00:21:22,700 --> 00:21:24,260
能看出来它的一个指令效果

325
00:21:24,260 --> 00:21:25,500
那么对于这个来说

326
00:21:25,500 --> 00:21:27,160
它不会有分时

327
00:21:27,160 --> 00:21:30,600
它是靠我们的那个YAR的系统调用来完成切换

328
00:21:32,040 --> 00:21:37,600
比如这里面第一次 要执行五次 第一次 第二次 第三次等等

329
00:21:37,600 --> 00:21:41,280
那么这一次每次新化一变 它的计算之后 它会主动放弃

330
00:21:41,280 --> 00:21:44,720
所以看到这里面 大家是轮流使用处理器的

331
00:21:44,720 --> 00:21:49,080
这取决于我们的处理器 取决于我们的应用程序是友好的

332
00:21:53,060 --> 00:21:57,520
讲完这个之后 我们看看这个软件大致怎么去做相应的一些改动

333
00:21:57,520 --> 00:22:00,000
这里面只是大致讲讲

334
00:22:00,000 --> 00:22:02,520
就是如果大家有兴趣的话

335
00:22:02,520 --> 00:22:04,600
可以去看相应的代码

336
00:22:04,600 --> 00:22:06,560
但大致我给你说你布局怎么回事

337
00:22:06,560 --> 00:22:07,760
就是这个应用这一块

338
00:22:07,760 --> 00:22:09,500
你要做一些修改

339
00:22:09,500 --> 00:22:12,600
比如说靠6.py这个程序来构造

340
00:22:12,600 --> 00:22:16,100
给每个程序构造不同的link脚本

341
00:22:16,100 --> 00:22:18,380
它是用来生成定制的link脚本

342
00:22:18,380 --> 00:22:19,380
从而可以使得每个程序

343
00:22:19,380 --> 00:22:20,880
它的期值地址不一样

344
00:22:21,540 --> 00:22:23,240
然后这里面makefile要稍微改一改

345
00:22:23,240 --> 00:22:26,100
这样可以使得它在link的时候

346
00:22:26,620 --> 00:22:28,260
首先要生成相应的脚本

347
00:22:28,260 --> 00:22:29,180
就是build.py

348
00:22:29,180 --> 00:22:31,460
它完成了整个处理过程

349
00:22:31,460 --> 00:22:33,840
SRC里面就放了各种应用

350
00:22:33,840 --> 00:22:35,900
B目录下放了各种应用程序

351
00:22:35,900 --> 00:22:37,800
这是应用程序

352
00:22:37,800 --> 00:22:41,860
相当于说它的应用编写比较简单

353
00:22:41,860 --> 00:22:44,100
但编译过程稍微有做一定修改

354
00:22:45,720 --> 00:22:47,060
那么对于OS来说

355
00:22:47,060 --> 00:22:48,220
它改得就比较多一点了

356
00:22:48,720 --> 00:22:52,380
它首先会把家载和任务管理分开

357
00:22:52,380 --> 00:22:53,960
我们前面这个家载和任务管理放在一起

358
00:22:53,960 --> 00:22:55,880
不是App Manager干的事

359
00:22:55,880 --> 00:22:59,940
现在它把Loader和Task Manager分成两个指模块

360
00:22:59,940 --> 00:23:04,780
从而可以完成更好的一个功能分离

361
00:23:04,780 --> 00:23:09,760
然后其他部分就是在Syscore这一块

362
00:23:09,760 --> 00:23:11,820
它要去支持我们应用增加了一个新的Syscore

363
00:23:11,820 --> 00:23:15,040
就是那个YAR的那个性能夹缘

364
00:23:15,040 --> 00:23:16,300
放弃处理性能夹缘

365
00:23:16,300 --> 00:23:18,400
那么这个你要做相应的处理

366
00:23:18,400 --> 00:23:22,760
在这个里面你终会调到我们的Task指模块里面

367
00:23:22,760 --> 00:23:28,160
去完成状态的保存 恢复 切换 运行等等

368
00:23:28,160 --> 00:23:32,780
这一系列的工作就是放到由Task和Loader一起来协同完成

369
00:23:33,580 --> 00:23:35,540
这是OS的一个改动部分

370
00:23:35,540 --> 00:23:40,520
具体在Task里面会发现这里面为数不多的第二汇编程序

371
00:23:40,520 --> 00:23:42,980
叫switch.s 这里面会出现

372
00:23:42,980 --> 00:23:46,240
它为什么要这个汇编是在于我们做任务切换的时候

373
00:23:46,240 --> 00:23:48,700
也是在继承器级做切换

374
00:23:48,700 --> 00:23:53,580
所以你没法很方便的在高级园园去实现

375
00:23:53,580 --> 00:23:56,120
所以它会有一个特定的汇编程序

376
00:23:56,120 --> 00:23:57,720
就类似我们前面讲的trap.s一样

377
00:23:57,720 --> 00:23:59,760
它有一个switch.s

378
00:23:59,760 --> 00:24:03,560
这里面会定义一个很重要的汇编函数switch

379
00:24:03,560 --> 00:24:08,800
来帮助我们把两个任务的上下文给换过来

380
00:24:08,800 --> 00:24:09,760
这一块

381
00:24:09,760 --> 00:24:12,380
总体的任务很重要的数语结构

382
00:24:12,380 --> 00:24:13,760
就是任务空出化的核心数据结构

383
00:24:13,760 --> 00:24:15,100
就是放在task.s

384
00:24:16,140 --> 00:24:17,760
大家同学说了

385
00:24:17,760 --> 00:24:21,520
老是只讲Rust 不讲C 不太友好

386
00:24:21,520 --> 00:24:26,360
我如果讲C的话 确实这个时间耗的比较多

387
00:24:26,360 --> 00:24:30,440
我大致说还是Idea 这个里面对应了C代码

388
00:24:31,000 --> 00:24:33,400
C是Rust的一个子极 什么意思

389
00:24:33,400 --> 00:24:36,080
就是它的功能实现大致跟这个类似

390
00:24:36,080 --> 00:24:37,620
比这个还少一些

391
00:24:37,620 --> 00:24:40,460
大致你可以看到它总会有一个类似于Touch的

392
00:24:40,460 --> 00:24:42,000
那么一个控制框

393
00:24:42,000 --> 00:24:44,300
也有相应的切换的一些汇变函数

394
00:24:44,300 --> 00:24:46,780
这都是一样的 这个我觉得倒没有太大的区别

395
00:24:46,780 --> 00:24:49,660
所以我会提到

396
00:24:49,660 --> 00:24:52,120
但是如果差别不是那么大的话

397
00:24:52,120 --> 00:24:54,660
我觉得大家可以认为C和ROS是一回事

398
00:24:56,500 --> 00:25:00,980
好 那么为了做所谓的Multiprogramming OS

399
00:25:01,520 --> 00:25:04,160
我们的硬件有什么新的增加吗

400
00:25:04,160 --> 00:25:04,660
其实没有

401
00:25:04,660 --> 00:25:08,720
我们并不需要对我们的硬件增加新的feature

402
00:25:08,720 --> 00:25:10,260
我们用现有的硬件就OK了

403
00:25:10,260 --> 00:25:11,600
就是特权级

404
00:25:11,600 --> 00:25:14,300
我们前面讲到的特权级相关操作

405
00:25:14,300 --> 00:25:18,500
掌握之后就可以升级我们的 OS 来完成相关工作

406
00:25:18,500 --> 00:25:21,500
那我们软件干什么 主要是增加任务抽象

407
00:25:21,500 --> 00:25:24,840
把这个任务抽象给它设计出来

408
00:25:26,320 --> 00:25:28,880
OK 好 我们已经提到了这个任务

409
00:25:28,880 --> 00:25:32,300
这个任务其实就是我们后面会讲到的进程的一个前身

410
00:25:33,000 --> 00:25:35,380
那它代表什么 代表是我们前面也提到的任务

411
00:25:35,380 --> 00:25:37,540
就是一个程序的执行过程

412
00:25:37,540 --> 00:25:41,200
这是站在 OS 角度来考虑的话

413
00:25:41,200 --> 00:25:43,960
你这执行过程它的中间的一些状态

414
00:25:43,960 --> 00:25:45,160
我们需要去管理起来

415
00:25:45,920 --> 00:25:47,640
那么对于应用程序而言

416
00:25:47,640 --> 00:25:51,600
我们看到的任务其实没有啥

417
00:25:51,600 --> 00:25:54,680
就和我们通常看到的应用程序差不多

418
00:25:54,680 --> 00:25:57,300
只是它的起始地址一直在变

419
00:25:57,300 --> 00:26:00,240
因为它要让每个应用程序

420
00:26:00,240 --> 00:26:02,660
有它各自的一块空间

421
00:26:02,660 --> 00:26:03,840
一块物理空间

422
00:26:03,840 --> 00:26:06,240
所以它的起始地址会大致这么来设置

423
00:26:06,240 --> 00:26:07,800
这个数字编号就是你这个程序里面

424
00:26:07,800 --> 00:26:09,240
都加个0102作为前缀

425
00:26:09,240 --> 00:26:12,500
根据这个来形成了所谓它的歧视意识

426
00:26:12,500 --> 00:26:15,260
那这个也就意味着你的任何一个程序

427
00:26:15,260 --> 00:26:18,560
不能超过0x2 后面有5个0

428
00:26:18,560 --> 00:26:22,940
大约是两兆这么一个大小的一个空间

429
00:26:22,940 --> 00:26:24,820
就是你的应用程序不能超过两兆

430
00:26:24,820 --> 00:26:26,440
如果超过两兆的话那会出问题

431
00:26:26,440 --> 00:26:30,420
就是你覆盖 这就会有相应的一些问题

432
00:26:34,780 --> 00:26:36,400
在刚才我们举的例子里面

433
00:26:36,400 --> 00:26:37,460
看到它那个显示里面

434
00:26:37,460 --> 00:26:43,440
就会看到掉一个Yard,这么一个,对,这个应该用这个是不是好点

435
00:26:43,440 --> 00:26:46,180
掉了一个Yard,用一个处理,系统调用

436
00:26:46,180 --> 00:26:50,420
但是它体验出来这个函数,看不太清

437
00:26:50,980 --> 00:26:54,000
这函数,为什么是函数,在于我们之前也讲过

438
00:26:54,000 --> 00:26:57,180
为了能够更好地让我们用程序更加简单地编写

439
00:26:57,180 --> 00:27:01,880
我们在用户台还有一个库,这些Yard呢

440
00:27:01,880 --> 00:27:06,300
实际上是那个用户台的Lib库的一个函数

441
00:27:06,300 --> 00:27:09,120
那那个库的函数实际上是对Syscall的一个包装

442
00:27:09,120 --> 00:27:12,240
它会封装那个CCR的系统调用

443
00:27:12,240 --> 00:27:17,600
这样你就避免了去用CCR这么更底层的一个系统调用

444
00:27:17,600 --> 00:27:20,760
你就不会看到什么汇编程序 直接用函数就OK了

445
00:27:20,760 --> 00:27:23,980
这就是一个它的一个大致的一个处理流程

446
00:27:25,580 --> 00:27:26,940
这是应用程序

447
00:27:26,940 --> 00:27:29,000
那这里面它是系统调用号

448
00:27:29,640 --> 00:27:31,660
这个我觉得比较简单

449
00:27:31,660 --> 00:27:34,840
那么在库这一集呢 你会看到 这是它封装

450
00:27:34,840 --> 00:27:38,160
就是那个YAR的那个函数会封装成一个调SysYAR的

451
00:27:38,160 --> 00:27:39,580
SysYAR的会调到SysCode

452
00:27:39,580 --> 00:27:45,840
这个SysCode和我们之前讲的SysWrite的SysCode是一样的

453
00:27:45,840 --> 00:27:47,220
只是他们的编号不一样

454
00:27:47,220 --> 00:27:50,220
因为不同的系统调用它有自己的一个ID号

455
00:27:50,220 --> 00:27:51,680
然后有自己的参数

456
00:27:51,680 --> 00:27:53,120
那么对于SysWrite来说

457
00:27:53,120 --> 00:27:54,500
比如说我们输出字符串来说

458
00:27:54,500 --> 00:27:56,020
它有它的一个buffer的一个参数

459
00:27:56,020 --> 00:27:57,600
指针这个参数

460
00:27:57,600 --> 00:27:59,660
但是对于我们说这个YAR来说

461
00:27:59,660 --> 00:28:00,420
它不需要任何参数

462
00:28:00,420 --> 00:28:02,120
所以这里面直接跟了三个零

463
00:28:02,120 --> 00:28:03,660
其实没有任何意义

464
00:28:03,660 --> 00:28:07,660
我们后续的超级统在收到这个 Cisco ID 之后

465
00:28:07,660 --> 00:28:08,720
他就知道怎么处理了

466
00:28:08,720 --> 00:28:13,740
他没必要去再去做相应的参数的一个解析和使用

467
00:28:13,740 --> 00:28:15,880
这是在这一块

468
00:28:20,060 --> 00:28:22,060
那么这讲的更多的是在应用角度

469
00:28:22,060 --> 00:28:25,660
怎么你把这个类合和应用生成单一镜像

470
00:28:25,660 --> 00:28:28,380
以及应用大致的编写一个理解

471
00:28:28,380 --> 00:28:31,240
第二个需要去找的就是假设没有了这个镜像

472
00:28:31,240 --> 00:28:34,600
我们说你已经有了这个镜像 镜像在哪呢

473
00:28:34,600 --> 00:28:38,760
在这 我们说这个镜像已经放在内存中了

474
00:28:38,760 --> 00:28:42,000
我们的硬件模拟器

475
00:28:42,000 --> 00:28:45,920
它已经把这一块镜像放在了一块内存中

476
00:28:45,920 --> 00:28:48,200
我们OS要干的事情是loader

477
00:28:48,200 --> 00:28:53,060
这个loader需要把这个APP从这个镜像里面找着

478
00:28:53,060 --> 00:28:55,460
这其实我们之前有点类似

479
00:28:55,460 --> 00:28:59,260
前面也讲过 找到之后一个接一个的全都放到内存中来

480
00:28:59,260 --> 00:29:01,560
你看这里面已经放了一个一二三

481
00:29:01,560 --> 00:29:04,860
放了三个三三个APP不同的APP

482
00:29:04,860 --> 00:29:06,860
这是要加载

483
00:29:07,700 --> 00:29:09,500
我们讲这个加载就在这

484
00:29:16,760 --> 00:29:19,140
这里面前面已经提到了加载的时候

485
00:29:19,140 --> 00:29:23,240
它要根据那个镜像里面的描述

486
00:29:23,240 --> 00:29:24,860
加载到不同的物理地址

487
00:29:24,860 --> 00:29:28,760
这是它一个大致的一个拷贝的过程

488
00:29:28,760 --> 00:29:31,400
你简单理解为它找到了两个很重要的参数

489
00:29:31,820 --> 00:29:33,520
就是前一个APP的

490
00:29:34,760 --> 00:29:38,280
前一个APP的歧视地址和后一个APP的歧视地址

491
00:29:38,880 --> 00:29:39,880
这个应该用

492
00:29:42,380 --> 00:29:43,580
和后一个APP的歧视地址

493
00:29:43,580 --> 00:29:45,000
把这两个地址做一个减法

494
00:29:45,000 --> 00:29:47,520
然后就知道它那个长度

495
00:29:47,520 --> 00:29:50,560
从而可以把这块区域用copy这种方式

496
00:29:50,560 --> 00:29:52,520
内存拷贝的方式把它拷贝到

497
00:29:53,360 --> 00:29:57,220
拷贝到我们指定的地址里面去就OK了

498
00:30:27,240 --> 00:30:32,720
就是我们说有一个叫做runNextApplication这么一个应用

499
00:30:32,720 --> 00:30:35,880
那这个run的话其实就在于初始化的时候

500
00:30:35,880 --> 00:30:37,840
我们就要去run第一个程序

501
00:30:37,840 --> 00:30:41,000
然后后续过程中我们切换完某个

502
00:30:41,000 --> 00:30:43,240
就某个程序执行完毕或者要执行切换的时候

503
00:30:43,240 --> 00:30:46,680
你就会去选择下一个程序执行

504
00:30:46,680 --> 00:30:49,320
所以它的执行时机就在这 这两点

505
00:30:49,320 --> 00:30:53,140
那执行的方式我们会专门写一个相应的函数来完这个工作

506
00:30:53,140 --> 00:30:56,040
那么这是关于执行这一款

507
00:30:57,020 --> 00:31:01,520
那么切换,切换就涉及到两个功能,就是内核到用户态和用户态到

508
00:31:01,520 --> 00:31:02,160
内核态

509
00:31:02,160 --> 00:31:06,820
那么其实光讲这两个的话,你会发现这两个其实是什么呢?

510
00:31:06,820 --> 00:31:10,220
是我们说的就是线路上下稳,要做的事情

511
00:31:10,220 --> 00:31:15,040
就是从内核态回到用户态,和从用户态到内核态,这是线路上要做

512
00:31:15,040 --> 00:31:16,520
的事情

513
00:31:17,000 --> 00:31:22,100
我们看到这里面就是有一个Trapcontext的这个保存

514
00:31:22,100 --> 00:31:28,900
这里面 trap context 的保存与恢复的问题

515
00:31:30,740 --> 00:31:32,720
但是对于我们第一个程序

516
00:31:32,720 --> 00:31:34,160
第一个程序的时候

517
00:31:34,960 --> 00:31:36,780
我们需要注意我们前面说到了

518
00:31:36,780 --> 00:31:38,420
第一个程序我们先去再内核它

519
00:31:38,420 --> 00:31:40,880
它这个 trap context 还不存在

520
00:31:40,880 --> 00:31:44,040
所以我们需要构造一个 trap context

521
00:31:44,040 --> 00:31:48,180
使得我们的应用程序能够回到它的起始地方去开始

522
00:31:48,180 --> 00:31:51,340
这里面很重要的两个地方需要注意

523
00:31:51,340 --> 00:31:54,420
你要能让一个程序回到用户台去开始执行

524
00:31:54,420 --> 00:31:56,160
你要知道它开始在哪

525
00:31:56,160 --> 00:31:57,760
所谓一个entry point

526
00:31:57,760 --> 00:32:01,440
这个entry point实际上是我们这里面的

527
00:32:01,440 --> 00:32:03,140
这个trap contents里面的SEPC

528
00:32:05,800 --> 00:32:07,660
就是我们说内核认为

529
00:32:08,620 --> 00:32:10,600
应用程序从用户台到内核台切换的时候

530
00:32:10,600 --> 00:32:13,540
它有一个异常的一个地址

531
00:32:13,540 --> 00:32:15,980
就是这个地址实际上我们把它设成了

532
00:32:15,980 --> 00:32:17,760
entry的一个入口地址

533
00:32:17,760 --> 00:32:18,660
使得我们回去之后

534
00:33:18,660 --> 00:33:21,320
比如说SP会是一个通用继承器

535
00:33:21,320 --> 00:33:22,800
它里面某一个通用继承器

536
00:33:22,800 --> 00:33:25,080
SP这一块会设置好

537
00:33:25,080 --> 00:33:27,480
从而使得当它跳到

538
00:33:27,480 --> 00:33:30,420
Entry Point就是入口点去执行的时候

539
00:33:30,420 --> 00:33:33,180
这时候SP的那个站指正已经设置好了

540
00:33:33,180 --> 00:33:34,300
就站也准备好了

541
00:33:34,300 --> 00:33:37,380
然后地址空间的代码端数据端也准备好了

542
00:33:37,380 --> 00:33:39,420
当然我们的应用程序就可以正确执行了

543
00:33:39,420 --> 00:33:41,520
所以当执行SIT这条指令的时候

544
00:33:42,520 --> 00:33:45,900
我们说我们的应用

545
00:33:45,900 --> 00:33:47,560
就可以正确的执行

546
00:33:47,560 --> 00:33:52,160
这是这一块的一个讲解

547
00:33:56,780 --> 00:33:59,180
好 这是我们前面这一个中间阶段

548
00:33:59,180 --> 00:34:00,820
能把这一步完成

549
00:34:00,820 --> 00:34:04,240
其实就已经可以让我们的应用程序

550
00:34:04,240 --> 00:34:05,980
在内核中一个接一个的执行了

551
00:34:07,240 --> 00:34:09,800
这是一个非常简单的一个OS

552
00:34:09,800 --> 00:34:11,500
我们这就叫锯齿元OS

553
00:34:11,500 --> 00:34:13,960
但这一点还不足以去有效的支持

554
00:34:13,960 --> 00:34:15,600
我们说12的操作

555
00:34:16,160 --> 00:34:18,600
因为整个过程我们只是看到了

556
00:34:19,220 --> 00:34:20,920
trap context的保存与恢复

557
00:34:20,920 --> 00:34:24,600
我们并没有看到task的保存与恢复

558
00:34:25,400 --> 00:34:26,760
是吧 并没有讲这一块

559
00:34:27,460 --> 00:34:30,020
那你如果要把task的保存与恢复加进去之后

560
00:34:30,020 --> 00:34:31,000
你就形成一个新的OS

561
00:34:31,000 --> 00:34:32,600
就是我们说的multiprogramming OS

562
00:34:35,320 --> 00:34:36,840
为此你需要干什么

563
00:34:36,840 --> 00:34:42,920
你要有一个所谓的这一块

564
00:34:42,920 --> 00:34:45,540
就是任务既然它会有中间状态

565
00:34:45,540 --> 00:34:46,940
那么就要有中间状态的一个

566
00:34:46,940 --> 00:34:49,860
叫做touch context这么一个管理

567
00:34:49,860 --> 00:34:54,320
这实际上是我们目前应用执行

568
00:34:54,320 --> 00:34:55,980
这里面很重要的一个数据结构

569
00:34:55,980 --> 00:34:57,480
有了它之后我们就知道

570
00:34:58,740 --> 00:35:00,920
这个任务什么时候被打断了

571
00:35:00,920 --> 00:35:03,340
无论是它主动通过YAR的系统交用

572
00:35:03,340 --> 00:35:04,420
来主动被打断

573
00:35:04,420 --> 00:35:07,020
还是后续的通过时钟被打断

574
00:35:07,020 --> 00:35:08,520
总之你打断之后

575
00:35:08,520 --> 00:35:11,340
你要相应的信息保存就保存在这里面

576
00:35:11,340 --> 00:35:16,860
但需要注意的 这里面保存的内容是什么 是那些通用的既存器

577
00:35:17,660 --> 00:35:19,360
那么为什么是通用的既存器

578
00:35:19,360 --> 00:35:21,740
通用的既存器大家不觉得在TrapContent上面已经保存了吗

579
00:35:21,740 --> 00:35:22,960
为什么这还要保存

580
00:35:22,960 --> 00:35:26,020
其实我们前面已经说了有一个陷入上下文

581
00:35:28,080 --> 00:35:31,580
这里面保存的是从用户态到内核态切换的时候

582
00:35:31,920 --> 00:35:33,220
它保存了一堆既存器

583
00:35:33,900 --> 00:35:37,460
但是你现在也说在这里面又保存了一些既存器

584
00:35:37,960 --> 00:35:40,160
那这些既存器保存的是什么东西

585
00:35:40,160 --> 00:35:43,080
为什么把它称之为任务上下文 这需要大家去理解

586
00:35:43,080 --> 00:35:45,960
这里面就是比较重要的在于 你要去理解

587
00:35:47,000 --> 00:35:50,680
任务上下文以及任务上下文怎么去切换的这些内容

588
00:35:50,680 --> 00:35:52,560
那我们再回顾一下什么是任务

589
00:35:53,520 --> 00:35:56,040
前面解释非常抽象

590
00:35:56,040 --> 00:35:59,460
我说的抽象是针对实现来说 光这么一个解释

591
00:35:59,460 --> 00:36:03,120
你没法写出一个OS 或者支持这个所谓的任务的一个OS

592
00:36:03,120 --> 00:36:05,840
这是说任务是一个具有一定独立功能的程序

593
00:36:05,840 --> 00:36:08,280
在一个数据集合上的动态执行过程

594
00:36:08,280 --> 00:36:09,560
这只是一种描述

595
00:36:09,560 --> 00:36:11,660
它不解决实际的设计问题

596
00:36:11,660 --> 00:36:14,940
我们要把这个过程进一步去落实起来

597
00:36:14,940 --> 00:36:15,660
怎么去做

598
00:36:15,660 --> 00:36:16,920
这是我们要去考虑的问题

599
00:36:18,100 --> 00:36:20,580
第一个所谓的过程就意味着这个task

600
00:36:20,580 --> 00:36:23,200
比如说task1这带app1,app2,app3

601
00:36:24,020 --> 00:36:25,660
那么这个这是代表task2

602
00:36:25,660 --> 00:36:28,040
task2其实看它执行过程是断断续续的

603
00:36:28,560 --> 00:36:29,560
那它这一点的时候

604
00:36:29,560 --> 00:36:31,480
在这一点应该在这看

605
00:36:31,480 --> 00:36:32,380
在这一点的时候

606
00:36:33,000 --> 00:36:35,700
其实对于multiprogramming OS来说

607
00:36:35,700 --> 00:36:37,100
它为什么会有这么一个断下来

608
00:36:37,100 --> 00:36:39,840
在于它执行的系统调用一样的

609
00:36:39,840 --> 00:36:42,380
那真性来说意味着它会有一个

610
00:36:42,380 --> 00:36:44,240
Track-on-Test的一个保存与恢复

611
00:36:44,240 --> 00:36:46,300
进入到内核里面去了

612
00:36:46,300 --> 00:36:48,980
那么这一块是一个时间片

613
00:36:48,980 --> 00:36:50,980
那么假定我们做了一个切换

614
00:36:50,980 --> 00:36:52,100
假定我们做了切换

615
00:36:52,100 --> 00:36:53,620
内核里面做了切换之后

616
00:36:53,620 --> 00:36:54,680
当它回去之后

617
00:36:54,680 --> 00:36:56,180
它会回到这个应用区

618
00:36:56,180 --> 00:36:57,960
回到这个APP3去

619
00:36:57,960 --> 00:37:00,420
APP3去执行

620
00:37:00,420 --> 00:37:02,280
那么APP3的这个点

621
00:37:02,280 --> 00:37:05,840
这个点实际上就是它要去恢复的那个

622
00:37:36,140 --> 00:37:38,840
点的那个切换 这一块怎么做到

623
00:37:38,840 --> 00:37:40,520
这个是这样 我们需要去理解

624
00:37:44,380 --> 00:37:48,320
好 这是一个 第二个我们去对应一下

625
00:37:48,320 --> 00:37:50,680
这个任务它在运行过程中

626
00:37:50,680 --> 00:37:51,960
它的状态是什么状态

627
00:37:52,860 --> 00:37:54,980
如果它当前正在占用CPU执行

628
00:37:54,980 --> 00:37:55,700
比如在这个点

629
00:37:58,600 --> 00:38:00,480
这个点 它正在执行的时候

630
00:38:00,480 --> 00:38:01,620
这个CPU正在执行的时候

631
00:38:01,620 --> 00:38:03,300
那它属于running time

632
00:38:05,940 --> 00:38:09,500
其他的应用 比如任务1 任务3

633
00:38:09,500 --> 00:38:11,480
那么它处于什么time呢 处于ready time

634
00:38:11,480 --> 00:38:15,680
这属于就绪 它们可以执行 但是CPU只有一个

635
00:38:15,680 --> 00:38:18,780
它没法执行 这就和我们的状态对应起来了

636
00:38:18,780 --> 00:38:20,580
我们在设计里面确实有这几种状态

637
00:38:20,580 --> 00:38:22,300
其实还有几种状态 我们并没有

638
00:38:22,980 --> 00:38:24,500
现在还没设计到 比如说sleep

639
00:38:25,000 --> 00:38:27,740
等待状态 或者是还有一些

640
00:38:29,460 --> 00:38:32,680
跟管理相关 在应用程序看不到的

641
00:38:32,680 --> 00:38:35,620
创建任务的时候有一个非数字化的状态

642
00:38:35,620 --> 00:38:37,780
和最后退出是一个退出状态等等

643
00:38:37,780 --> 00:38:38,940
核心就是三个状态

644
00:38:38,940 --> 00:38:43,640
我们说的是ready running和block或者是sleep等等

645
00:38:45,140 --> 00:38:46,520
这是理解这个状态

646
00:38:50,380 --> 00:38:53,460
我们处理器在执行这个任务的时候

647
00:38:53,460 --> 00:38:54,900
当它掉了一个YAR的时候

648
00:38:54,900 --> 00:38:56,160
从这儿下来之后

649
00:38:56,160 --> 00:38:58,780
它当前应该是属于running type

650
00:38:59,120 --> 00:38:59,920
属于running type

651
00:38:59,920 --> 00:39:01,900
实际上我们就要把一个running type的一个task

652
00:39:01,900 --> 00:39:03,980
和一个 ready type task 做一个切换

653
00:39:03,980 --> 00:39:06,140
这是我们要干的事情

654
00:39:10,300 --> 00:39:12,660
切换实际上就是暂停一个任务的执行

655
00:39:12,660 --> 00:39:13,900
继续另一个任务的执行

656
00:39:14,800 --> 00:39:17,780
这个我想比较好理解

657
00:39:17,780 --> 00:39:19,520
好 那我们接下来怎么切换

658
00:39:19,520 --> 00:39:21,900
这是可能需要大家去注意的

659
00:39:24,320 --> 00:39:26,180
你会看到首先我们定义了一个

660
00:39:26,180 --> 00:39:27,820
跟类似于我们的

661
00:39:27,820 --> 00:39:30,200
叫做 trap 上下文

662
00:40:30,200 --> 00:40:35,200
前面是32个集成器,为什么12个呢?

663
00:40:36,440 --> 00:40:40,200
我们前面说过,有一个函数的调用约定

664
00:40:40,740 --> 00:40:42,020
函数调用约定是什么意思?

665
00:40:42,340 --> 00:40:47,040
函数调用约定里面,我们说的Color和Colly分别管了不同的集成器

666
00:40:47,040 --> 00:40:48,680
的保存和恢复

667
00:40:48,680 --> 00:40:53,060
Colly是要保存S0到S11,这是一个编号

668
00:40:53,060 --> 00:40:59,160
它其实对应了我们的X0到S31的某一些集成器

669
00:40:59,160 --> 00:41:02,080
它只是不同的编号 便于它这个表示

670
00:41:03,520 --> 00:41:04,520
那这个要保存

671
00:41:06,720 --> 00:41:08,020
那这意味着什么呢

672
00:41:08,020 --> 00:41:10,680
意味着当它回去的时候

673
00:41:10,680 --> 00:41:12,600
就是回到 就当这个

674
00:41:14,320 --> 00:41:16,120
它是context 返回的时候

675
00:41:16,120 --> 00:41:17,620
它需要把这个恢复回去

676
00:41:17,620 --> 00:41:18,820
当它进入的时候

677
00:41:18,820 --> 00:41:20,260
它需要把这个保存起来

678
00:41:20,260 --> 00:41:21,760
那这个保存

679
00:41:21,760 --> 00:41:23,520
和我们的应用程序有什么样的关系

680
00:41:23,520 --> 00:41:24,440
这个其实

681
00:41:26,320 --> 00:41:27,240
我们后面去看看

682
00:41:27,240 --> 00:41:28,200
至少我们看到了一些

683
00:42:28,380 --> 00:42:29,660
这里面在的是内核站

684
00:42:30,020 --> 00:42:33,040
然后我做上一文切换的时候在内核里面切换

685
00:42:33,040 --> 00:42:36,160
OK 所以我理解刚才我应该写的

686
00:42:36,160 --> 00:42:37,920
应该是写错了 应该是内核站

687
00:42:37,920 --> 00:42:39,580
应该是这个里面保存的那个SP

688
00:42:39,580 --> 00:42:42,020
这个SP是内核站里面的那个站子

689
00:42:42,020 --> 00:42:45,580
因为我要切一个任务 我在内核里面做切换

690
00:42:46,260 --> 00:42:48,000
我并没有去切用户

691
00:42:48,000 --> 00:42:51,140
跟用户相关的全是在那个trap context里面

692
00:42:51,140 --> 00:42:52,780
这个东西trap context里面

693
00:42:52,780 --> 00:42:56,160
trapctx里面去保存了

694
00:42:56,160 --> 00:42:57,680
保存了用户站的信息

695
00:42:57,680 --> 00:43:01,260
但是内核里面要去做两个任务的切换

696
00:43:01,260 --> 00:43:02,660
全在内核里面打交道

697
00:43:02,660 --> 00:43:03,880
所以切换是内核站

698
00:43:03,880 --> 00:43:05,520
你也可以看出来

699
00:43:06,640 --> 00:43:08,260
为了能够支持任务切换

700
00:43:08,260 --> 00:43:13,140
每一个任务除了有自己的用户站之外

701
00:43:13,140 --> 00:43:14,500
还必须要有自己的内核站

702
00:43:14,500 --> 00:43:21,000
这个内核站是为了完成用户间的切换存在的

703
00:43:21,460 --> 00:43:21,820
OK

704
00:43:33,860 --> 00:43:35,780
好 那我们看看怎么来切的

705
00:43:37,700 --> 00:43:40,160
在这样怎么切之前 我们还是要去理解上下文

706
00:43:40,160 --> 00:43:41,580
我们有个函数上下文

707
00:43:42,320 --> 00:43:45,220
trap上下文和任务上下文 这不太一样

708
00:43:45,220 --> 00:43:47,800
这个大家能看到吗

709
00:43:47,800 --> 00:43:50,740
就是我们现在又稍微又回顾一下 复习一下

710
00:43:50,740 --> 00:43:52,010
我们提了很多上下文了

711
00:43:53,200 --> 00:43:53,790
函数上下文

712
00:44:24,950 --> 00:44:27,730
大家休息一下

713
00:49:37,270 --> 00:49:39,750
好 我们继续讲 讲到这上下文

714
00:49:39,750 --> 00:49:42,970
其实上下文我们看到的理解来说是一个状态

715
00:49:42,970 --> 00:49:44,070
我们讲原理是创代

716
00:49:44,070 --> 00:49:45,230
但是对于我们的实现来说

717
00:49:45,230 --> 00:49:46,650
我们看到的是一堆计算器

718
00:49:46,650 --> 00:49:47,970
这看起来还是比较抽象

719
00:49:47,970 --> 00:49:49,050
但不管怎么说

720
00:49:49,050 --> 00:49:50,510
对于海数调养而言

721
00:49:50,510 --> 00:49:53,630
我们说当前海数方形A调了方形B之后

722
00:49:54,170 --> 00:49:58,570
那么方格芯B正在执行的时候,那是方格芯B的那个上下文,它有它的那个

723
00:49:58,570 --> 00:49:59,530
占领的信息

724
00:49:59,530 --> 00:50:04,450
方格芯B如果再调方格芯C,那么到了方格芯C那个函数的时候,它会有它的

725
00:50:04,450 --> 00:50:05,570
那个函数的上下文

726
00:50:05,570 --> 00:50:09,170
它所谓的上下文就是那一类技能器,它用那类技能器来做相应

727
00:50:09,170 --> 00:50:11,790
的继续的一些计算或者一些操作

728
00:50:11,790 --> 00:50:17,050
那不管怎么样,它再调多少层,所有这些函数都属于同一个应用

729
00:50:17,050 --> 00:50:19,610
就是我们编辑生成的那个代码,它是一个控制流

730
00:50:19,610 --> 00:50:21,810
在这个层面上,我们它是一个控制流

731
00:50:21,810 --> 00:50:23,010
但对于串盘而言

732
00:50:23,950 --> 00:50:27,970
当它完成系统调整的那一下 比如说一扣调整的核心之后

733
00:50:27,970 --> 00:50:30,450
你会发现它是两个软件

734
00:50:30,450 --> 00:50:33,750
一种软件是我们用过的那个应用 那是它自己的控制流

735
00:50:34,290 --> 00:50:38,170
但是底下那个回到哪了 回到内核里面 内核也是软件

736
00:50:38,170 --> 00:50:40,430
它有它自己的控制流 这两个控制流不一样

737
00:50:40,430 --> 00:50:42,610
这其实完全是一种控制流的切换

738
00:50:43,470 --> 00:50:47,390
对于任务而言 我们希望是通过某种方式

739
00:50:47,390 --> 00:50:49,650
我们能够把两个任务也给它切了

740
00:50:49,650 --> 00:50:54,690
就把两个应用也切了 让它能够去分别的占用处理器执行

741
00:50:54,690 --> 00:50:58,530
那么这里面 我们重点讲的是

742
00:50:59,670 --> 00:51:03,410
就是超纪拥涉及到两个上下文 任务上下文和性调上下文

743
00:51:03,410 --> 00:51:07,170
我们看到 任务上下文它那个继承器 保存那些继承器

744
00:51:07,170 --> 00:51:11,450
其实和科研机没有关系 它不涉及到科研机的切换 这是第一个

745
00:51:11,450 --> 00:51:16,770
第二个 这个任务上下文 它其实它保存 为什么只保存12个通路继承器

746
00:51:16,770 --> 00:51:23,090
是在于那12个技能器是我们编辑本来就要去这么约定的

747
00:51:23,090 --> 00:51:24,950
我们一定说了你是个callee这个函数

748
00:51:24,950 --> 00:51:26,670
我们switch实际上是一个函数

749
00:51:26,670 --> 00:51:31,870
这个函数本身它就要有责任去把那个12个技能器给保存恢复了

750
00:51:31,870 --> 00:51:34,370
只是我们希望有一个tricky的事情

751
00:51:34,370 --> 00:51:37,330
就是我们希望当这个函数法回来的时候

752
00:51:37,330 --> 00:51:39,570
回到了另一个任务的一个性责任去

753
00:51:40,550 --> 00:51:44,070
所以你会发现它里面除了12个技能器之外

754
00:51:44,070 --> 00:51:47,350
我们还有两个特殊的继承器

755
00:51:47,350 --> 00:51:48,750
一个RA 一个SP

756
00:51:48,750 --> 00:51:50,030
RA是返回地址

757
00:51:50,030 --> 00:51:51,270
一个是SP 是一个站

758
00:51:51,730 --> 00:51:52,550
那为什么要不同

759
00:51:52,550 --> 00:51:53,670
肯定是这两个地方

760
00:51:53,670 --> 00:51:58,330
是代表了两个任务的返回地址和站空间

761
00:51:58,330 --> 00:52:00,390
这也是为什么我们说内核有自己的内核站

762
00:52:00,390 --> 00:52:02,250
你要回到另一个任务的站里面去

763
00:52:02,250 --> 00:52:03,590
所以保存东西要更多一点

764
00:52:03,590 --> 00:52:05,010
但对于我们的音乐而言

765
00:52:05,010 --> 00:52:06,810
正常做个function call来说

766
00:52:06,810 --> 00:52:09,690
它不会去说我要跳到另外一个站去

767
00:52:09,690 --> 00:52:11,390
它本来就是同样一个站

768
00:52:11,390 --> 00:52:13,030
这里面就一个很tricky的事情

769
00:53:13,310 --> 00:53:19,290
但对于计算机组成员来说,它看到的对象不是程序,它看到的是CPU。

770
00:53:20,330 --> 00:53:25,430
所以处理器的控制流,处理器中的这个程序,叫PCR,Program Counter,

771
00:53:25,850 --> 00:53:30,930
程序处理器的这个控制转移序列,是它的控制流,它是一条机器码

772
00:53:30,930 --> 00:53:31,670
的一条自行流。

773
00:53:33,510 --> 00:53:35,610
这是计算机组成员里我们讲的这个控制流。

774
00:53:36,150 --> 00:53:40,950
对于超级网来说,我们需要把应用程序、超级网合在一起的控制流一起

775
00:53:40,950 --> 00:53:41,330
来考虑。

776
00:53:42,690 --> 00:53:45,830
那么我们如果还有一本书叫cshpp

777
00:53:47,990 --> 00:53:50,850
大家你们下一届同学就应该都要去上这门课了

778
00:53:50,850 --> 00:53:52,790
你们这些同学还没有上这门课

779
00:53:52,790 --> 00:53:54,130
在这门课里面

780
00:53:54,130 --> 00:53:56,470
他说从程序员的角度来看控制流

781
00:53:56,470 --> 00:53:58,750
那么从程序员的角度来说

782
00:53:58,750 --> 00:54:01,430
我们应用程序看到的就是普通的控制流

783
00:54:01,430 --> 00:54:04,130
因为它不涉及到两个应用的切换

784
00:54:04,130 --> 00:54:06,370
或者是应用和OS切换 没有

785
00:54:06,370 --> 00:54:08,510
所以它是普通的控制流

786
00:54:09,330 --> 00:54:10,590
但是从OS的角度来说

787
00:54:10,590 --> 00:54:13,790
你看这控制流就多了 你有多个应用

788
00:54:13,790 --> 00:54:16,010
因为你的眼里是不是一个应用

789
00:54:16,010 --> 00:54:18,050
你连你除了说自身我自己要跑之外

790
00:54:18,050 --> 00:54:19,510
还要管很多应用

791
00:54:19,510 --> 00:54:21,830
每个应用都有自己的控制流

792
00:54:21,830 --> 00:54:23,210
OS有自己的控制流

793
00:54:23,210 --> 00:54:25,510
而且OS还要负责管理这些应用的控制流

794
00:54:26,690 --> 00:54:28,150
这控制流就不太一样了

795
00:54:28,150 --> 00:54:33,610
而且我们这控制流特别把从应用到内核跳了一下

796
00:54:33,610 --> 00:54:36,190
无论是通过中断也好还是通过系统调也好

797
00:54:36,190 --> 00:54:39,350
跳了一下 控制流称之为一个异常控制流

798
00:54:39,350 --> 00:54:40,830
他把这都称之为异常

799
00:54:40,830 --> 00:54:44,110
因为他已经脱离了APP的一个视角

800
00:54:44,110 --> 00:54:45,530
APP已经看不到了

801
00:54:45,530 --> 00:54:46,730
它是有异常

802
00:54:46,730 --> 00:54:48,270
所以他叫ECF

803
00:54:48,270 --> 00:54:49,050
他取了一个词

804
00:54:49,050 --> 00:54:50,170
except in control flow

805
00:54:50,170 --> 00:54:53,910
我们是在ECF里面去玩各种花样

806
00:54:54,330 --> 00:54:55,270
我们已经看到了

807
00:54:55,270 --> 00:54:58,390
我们通过ECF可以来在OS里面

808
00:54:58,390 --> 00:55:01,150
来完成对应用的各种各样的管理

809
00:55:03,250 --> 00:55:05,430
那所谓的控制流

810
00:55:06,270 --> 00:55:08,590
就是普通控制流的上写文就是我们的函数

811
00:55:09,650 --> 00:55:14,270
那么Trap和Task这个控制流上下文

812
00:55:14,930 --> 00:55:18,250
其实对于Trap而言 它是异常控制流的上下文

813
00:55:18,250 --> 00:55:23,590
但对于Task而言 它是一个

814
00:55:24,170 --> 00:55:29,290
其实是一个普通的控制流的上下文

815
00:55:29,290 --> 00:55:30,810
并不是一个异常控制流的上下文

816
00:55:30,810 --> 00:55:33,730
只是这个普通是在内核里面的普通而已

817
00:55:33,730 --> 00:55:36,610
这是其实需要去理解的

818
00:57:06,610 --> 00:57:11,390
这一盒里面的韩束上海文,那和一般的应用的韩束上海文,在

819
00:57:11,390 --> 00:57:13,070
这里面有什么特殊的不同呢?

820
00:57:13,670 --> 00:57:17,810
这个不同是由于那个Switch函数造成的,那个函数很特别,那是用汇编写

821
00:57:17,810 --> 00:57:20,170
的,它不是我们通常的高级语言写的。

822
00:57:20,450 --> 00:57:24,870
用汇编写的,干了一个什么很特殊的事情呢?它这里面把两个任务给换

823
00:57:24,870 --> 00:57:27,190
了,它干就这么一个事情。

824
00:57:27,190 --> 00:57:32,110
所以它是一个针对switch的一个特殊的一个

825
00:57:33,230 --> 00:57:35,190
这个switch函数的一个上下文

826
00:57:35,190 --> 00:57:38,090
它是switch函数本身内核的一个函数

827
00:57:38,090 --> 00:57:39,870
所以它也是一个函数级的上下文

828
00:57:39,870 --> 00:57:43,970
这里面我们要去解决这个切换的问题

829
00:57:43,970 --> 00:57:45,790
你需要去掌握几个关键点

830
00:57:46,790 --> 00:57:49,350
我们已经看到了trap上下文

831
00:57:49,730 --> 00:57:50,730
任务上下文

832
00:57:50,730 --> 00:57:52,470
这东西都是一些数学结构

833
00:57:52,470 --> 00:57:53,190
放哪儿

834
00:57:54,310 --> 00:57:55,610
第二个怎么去切换

835
00:57:55,610 --> 00:57:59,850
讲说我怎么切换 这个切换意味着什么时候发生 什么时候切换

836
00:57:59,850 --> 00:58:01,870
能切换去还能切换回来吗

837
00:58:01,870 --> 00:58:04,130
这是你要在设计中要考虑的问题

838
00:58:04,130 --> 00:58:06,750
那首先看这个放哪 看这后页有没有

839
00:58:07,750 --> 00:58:09,570
放哪就放这kernel stack

840
00:58:11,710 --> 00:58:16,470
我们把这个hub上下文和任务上下文都放在kernel stack里面

841
00:58:16,470 --> 00:58:19,010
这个kernel stack是每个应用一个的

842
00:58:19,010 --> 00:58:21,690
比如说这里面就放的是APP1的kernel stack

843
00:59:21,690 --> 00:59:24,650
是不是放在栈里面 还是像这个串盘放在栈里面吗

844
00:59:24,650 --> 00:59:25,670
还是放在其他什么地方

845
00:59:26,490 --> 00:59:27,570
这个需要了解

846
00:59:29,890 --> 00:59:32,330
大家觉得应该放在栈里面 还是不放在栈里面

847
00:59:33,890 --> 00:59:36,930
这个像这个串盘 这个放在栈里面

848
00:59:41,830 --> 00:59:42,770
没有放在栈里

849
00:59:43,130 --> 00:59:47,630
它是单独的一个放在一个全局的一个税区里面

850
00:59:47,630 --> 00:59:49,850
并没有放在栈里面

851
00:59:49,850 --> 00:59:51,250
为什么 大家可以后面去看

852
01:00:51,690 --> 01:00:53,590
是一致的就OK了

853
01:00:53,590 --> 01:00:57,770
这是我对OS的要学好这门课的一个理解

854
01:01:04,870 --> 01:01:06,310
我们已经讲了

855
01:01:06,310 --> 01:01:08,610
我们说Tap context放在站底

856
01:01:08,610 --> 01:01:11,270
Task context放在一个全球变量里面

857
01:01:11,270 --> 01:01:12,330
它不在站里面

858
01:01:12,330 --> 01:01:13,570
那我们怎么来做这个事情

859
01:01:13,570 --> 01:01:15,450
怎么来切换呢

860
01:01:15,450 --> 01:01:17,010
我们切换的实际已经说过了

861
01:01:17,590 --> 01:01:19,470
对于那个multiprogram那个OS来说

862
01:01:19,470 --> 01:01:20,790
它掉个YAR就没有用

863
01:02:20,790 --> 01:02:24,990
使它返回到任务App去执行

864
01:02:24,990 --> 01:02:28,010
这个过程 核心就是这个函数

865
01:02:28,010 --> 01:02:29,190
干这个事情

866
01:02:29,790 --> 01:02:33,130
怎么来干的 我们看到它结合了

867
01:02:33,130 --> 01:02:33,890
结合了trap context

868
01:02:33,890 --> 01:02:35,970
结合了kernel stack

869
01:02:35,970 --> 01:02:37,530
结合了task context

870
01:02:37,530 --> 01:02:38,790
一块来玩这个事情

871
01:02:47,270 --> 01:02:48,150
核心

872
01:02:48,670 --> 01:02:56,130
核心什么 这切 左卫切 它跟我们通常的函数执行一个不同在哪

873
01:02:56,130 --> 01:03:04,150
前面说到这个Switch函数 它会 比如 核心这个 换站

874
01:03:05,010 --> 01:03:11,310
它把类合里面的那个应用A的站和应用B的站给做了一个切换

875
01:03:12,250 --> 01:03:16,050
那么这些信息放在哪 放在这里面

876
01:03:16,050 --> 01:03:18,290
放在Task Context上面

877
01:03:18,290 --> 01:03:21,690
Task Context前面已经说了很重要的三个部分

878
01:03:21,690 --> 01:03:26,550
一个是Return Address 一个是SP 一个是12个计程器

879
01:03:28,230 --> 01:03:34,270
SP和Return Address从哪来的 都从这里面来的

880
01:03:34,270 --> 01:03:36,710
然后12个计程器也是从这里面来的

881
01:03:36,710 --> 01:03:40,790
它把这些都构成了Task Context之后

882
01:03:40,790 --> 01:03:41,890
他就可以玩这个事情

883
01:03:42,550 --> 01:03:45,410
我们可以看看他大致怎么来完成

884
01:03:46,030 --> 01:03:49,710
这是他大致就是执行那个汇编函数

885
01:03:49,710 --> 01:03:50,910
你可以看他第一个

886
01:03:52,630 --> 01:03:55,490
这个Switch是掉到最终那个Switch汇编函数

887
01:03:55,490 --> 01:03:56,350
他有两个参数

888
01:03:57,290 --> 01:03:58,310
TrapContext

889
01:03:59,230 --> 01:04:01,710
就是current的TrapContext和next的TrapContext

890
01:04:01,710 --> 01:04:02,810
current代表什么

891
01:04:02,810 --> 01:04:07,230
current代表当前正在执行的那个应用

892
01:04:08,250 --> 01:04:08,650
current

893
01:04:08,650 --> 01:04:10,350
next是我下次要换的

894
01:04:10,350 --> 01:04:11,870
要换到另一个用户去仔细

895
01:04:11,870 --> 01:04:14,810
那他们都有一个对应的指针

896
01:04:14,810 --> 01:04:17,150
叫做Trap Contest

897
01:04:17,150 --> 01:04:20,790
Switch Trap Contest

898
01:04:33,350 --> 01:04:36,130
我想想这应该是Task Contest

899
01:04:38,390 --> 01:04:43,550
对,我理解应该是task context的指针,它这样才能够去完成切换,不是trap。

900
01:04:44,070 --> 01:04:49,710
时不时我们有些bug,希望大家能够理解。关键老师上课讲错的时候,大家能够

901
01:04:49,710 --> 01:04:50,650
及时提醒就更好。

902
01:04:50,910 --> 01:04:55,690
我觉得上次有一次老师讲错了或者写错了之后,同学及时反应我觉得就挺

903
01:04:55,690 --> 01:04:55,950
好。

904
01:04:55,950 --> 01:04:58,510
这里面其实我们要把这个

905
01:04:58,510 --> 01:05:01,510
这应该是Task Contest的指针

906
01:05:01,510 --> 01:05:04,630
两个指针作为参数传到这个Switch里面去

907
01:05:04,630 --> 01:05:06,790
那么它就可以做相应的一些事情了

908
01:05:06,790 --> 01:05:11,130
这个指针就是比如说这个current就指向这儿

909
01:05:11,130 --> 01:05:15,190
我们说的这个指针就指向这儿

910
01:05:15,190 --> 01:05:17,950
current指向这儿 那么next指向下一个

911
01:05:18,630 --> 01:05:23,850
这是两个Task Contest的位置

912
01:05:23,850 --> 01:05:27,970
那么这两个是什么 这两个是当前如果当前是A的话

913
01:05:27,970 --> 01:05:30,870
那么当前执行的这个站是在这里面执行的

914
01:05:31,350 --> 01:05:35,710
这一块的站 它是个B的站 并没有用到 需要注意

915
01:05:35,710 --> 01:05:38,630
我们Switch干的很重要的事情就是换站

916
01:05:38,630 --> 01:05:43,550
希望当这个Switch函数出来之后 站变成了它

917
01:05:44,250 --> 01:05:45,890
这是我们Switch要干的事情

918
01:05:45,890 --> 01:05:48,570
为了干这个事情 它花了四个步骤

919
01:05:48,570 --> 01:05:51,470
这四个步骤 大家可以看看哪四个步骤

920
01:06:00,790 --> 01:06:04,930
就是我们进入内核里面之后,执行内核的那个代码的时候

921
01:06:04,930 --> 01:06:07,630
Trap控制流A,这个A意味着代表APPA

922
01:06:07,630 --> 01:06:10,270
它电话switch之前,A的内核站上

923
01:06:10,950 --> 01:06:13,950
只有Trap上下方和Trap处理器函数的电话站信息

924
01:06:13,950 --> 01:06:17,370
而B是被签案图协的,这是一个

925
01:06:17,370 --> 01:06:19,310
我们说的一个初始状态,在这个状态下

926
01:06:19,310 --> 01:06:21,450
你看到这里面,这个信息是有的,这个信息是有的

927
01:06:21,870 --> 01:06:30,150
但是这里面的信息是 这里面的信息其实是没有用到的

928
01:06:30,150 --> 01:06:31,390
我们需要把这个信息给用进去

929
01:06:31,390 --> 01:06:33,390
就是这里面占的信息并没有用到

930
01:06:33,390 --> 01:06:37,050
这里面A里面的内核占只有这一块

931
01:06:37,050 --> 01:06:38,750
A里面是有这个东西

932
01:06:38,750 --> 01:06:40,670
用到的是这个占

933
01:06:41,350 --> 01:06:44,210
然后B的东西全都放在这里面的

934
01:06:44,210 --> 01:06:47,230
而这一块的占 就是我们说的这一块的占的内容

935
01:06:47,230 --> 01:06:48,490
现在并没有用到

936
01:06:48,490 --> 01:06:50,310
我们现在用的是它来做相应的

937
01:06:50,310 --> 01:06:51,870
trap控制流的一个执行

938
01:06:51,870 --> 01:06:53,070
这是一个粗子状态

939
01:06:57,530 --> 01:06:59,610
然后在执行switch的过程中

940
01:06:59,610 --> 01:07:03,170
它在A的任务上下文中

941
01:07:04,510 --> 01:07:05,630
A的任务上下文中

942
01:07:05,630 --> 01:07:07,850
保存CPU当前计程器快照

943
01:07:07,850 --> 01:07:09,410
A的任务上下文在哪

944
01:07:09,410 --> 01:07:11,950
就是我们说这一块它有一块区域

945
01:07:11,950 --> 01:07:13,070
它这本来是空的

946
01:07:13,070 --> 01:07:15,150
我在这里面switch会员函说里面

947
01:07:15,150 --> 01:07:17,830
会把那14个计程器

948
01:07:18,490 --> 01:07:22,790
存到这儿了 把这个存进去 这是做保存 OK

949
01:07:22,790 --> 01:07:26,730
保存完之后 当前的站还在这儿 没变啊 当前的站还在这儿

950
01:07:26,730 --> 01:07:30,490
这个还没用上 这个task-b的context没有用上 这是第二步

951
01:07:34,830 --> 01:07:38,850
第三步 这一步就是我们有两个指示 虽然有两个参数

952
01:07:38,850 --> 01:07:44,490
第二个参数是什么呢 第二个参数是叫做next-task-context

953
01:07:45,550 --> 01:07:47,550
这个团有指向了什么 指向这个地方

954
01:07:47,550 --> 01:07:50,230
指向这个地方 就是在这儿 指向这个地方

955
01:07:50,230 --> 01:07:53,850
我根据这个地方找了这块70地址

956
01:07:53,850 --> 01:07:56,490
然后把这里面的14个继承器

957
01:07:58,030 --> 01:08:01,390
这里面的内容重新给14个继承器进行复制

958
01:08:01,390 --> 01:08:04,530
就是把RA S0到S11

959
01:08:04,530 --> 01:08:07,950
还有那个SP重新进行复制 在这儿

960
01:08:07,950 --> 01:08:10,430
等于是一旦执行完这个复制之后

961
01:08:10,430 --> 01:08:12,230
需要注意 执行完这个复制之后

962
01:08:43,270 --> 01:08:45,470
因为我还没有执行什么,没有执行RT

963
01:08:46,770 --> 01:08:49,650
RT才是根据RA去返回的,是吧

964
01:08:49,650 --> 01:08:51,290
所以这个RA没有效果

965
01:08:51,290 --> 01:08:54,350
但是这些计算器也变了

966
01:08:54,350 --> 01:08:56,470
那意味着我回去之后

967
01:08:56,470 --> 01:09:02,110
本来由TaskB回去的那个

968
01:09:02,110 --> 01:09:04,380
Color那个函所需要的那些计算器

969
01:09:05,110 --> 01:09:07,870
这实际上已经是TaskB的那些计算器内容了

970
01:09:07,870 --> 01:09:10,230
就是TaskB的计算器已经换掉了

971
01:09:11,210 --> 01:09:17,230
然后TaskB的SP换掉了,TaskB的Return的地址换掉了,但这个R

972
01:09:17,230 --> 01:09:18,210
eturn地址还没有执行。

973
01:09:19,290 --> 01:09:26,230
所以换掉完之后,第四步干啥?第四步就要执行这个Return。

974
01:09:27,930 --> 01:09:35,830
执行Return之后,那意味着,大家想想我们的那个复理器应该做啥。

975
01:09:35,830 --> 01:09:42,670
根据RA回到 你现在新的RA回到它那个color的一个地方

976
01:09:42,670 --> 01:09:45,950
可能是这个地方 color的地方 就是调织位置之前那个地方

977
01:09:46,690 --> 01:09:49,910
然后计程器已经是color的那些计程器了

978
01:09:49,910 --> 01:09:52,050
因为S0到S1已经划了

979
01:09:52,050 --> 01:09:56,090
SP已经是taskB的SP了

980
01:09:56,090 --> 01:09:59,170
执行完这一步之后 就完成了换站

981
01:09:59,170 --> 01:10:01,730
也完成了任务上海湾切换

982
01:10:03,950 --> 01:10:05,290
OK 就是这一步

983
01:10:05,290 --> 01:10:07,290
就是当一旦执行完毕之后

984
01:10:07,290 --> 01:10:08,850
控制流全在这里面执行了

985
01:10:08,850 --> 01:10:09,990
这个已经没有了

986
01:10:11,490 --> 01:10:12,770
说这个switch函数

987
01:10:12,770 --> 01:10:16,870
它虽然是一个函数

988
01:10:16,870 --> 01:10:18,530
但这个函数很不一样

989
01:10:18,530 --> 01:10:20,070
这是比较tricky的一个东西

990
01:10:23,690 --> 01:10:25,230
OK 讲完了这一块

991
01:10:25,230 --> 01:10:26,170
有问题吗

992
01:10:29,910 --> 01:10:30,870
我问大家问题

993
01:10:32,250 --> 01:10:34,330
我这个整个切换在内核里面完成的

994
01:10:35,970 --> 01:10:38,310
我如果写个应用程序 我能不能在用战完成

995
01:10:39,070 --> 01:10:41,890
我也可以写一个special程序 我们的编辑没搞定

996
01:10:41,890 --> 01:10:43,930
我能不能在用战完成两个任务的切换

997
01:10:46,530 --> 01:10:49,670
就是整个这个切换过程 我不需要太

998
01:10:49,670 --> 01:10:52,370
我直接用战去完成两个任务的切换

999
01:10:52,370 --> 01:10:55,130
对于我们的money program这个OS来说 能不能做到这一个

1000
01:11:57,970 --> 01:12:00,990
好 我们再看看这个任务调度这一块

1001
01:12:00,990 --> 01:12:03,750
任务调度其实我们能切

1002
01:12:04,290 --> 01:12:06,430
这是切换 任务切换和任务调度不一样

1003
01:12:06,430 --> 01:12:07,570
任务调度是一种策略

1004
01:12:07,570 --> 01:12:10,250
就是说我什么时候需要去做这种换

1005
01:12:10,250 --> 01:12:13,430
当然我们还没有讲调度算法

1006
01:12:14,450 --> 01:12:15,790
这些东西我们后面会讲

1007
01:12:15,790 --> 01:12:18,290
但这里面至少已经体现了

1008
01:12:20,150 --> 01:12:21,510
因为我们这里面非常简单

1009
01:12:21,510 --> 01:12:23,410
就是这个task如果发出一样的操作

1010
01:12:23,410 --> 01:12:25,810
它就会去做一个切换

1011
01:12:26,170 --> 01:12:28,490
做完切换之后就算是完成了一次调度

1012
01:12:28,490 --> 01:12:30,650
只是这个调度对于OS而言它是被动的

1013
01:12:30,650 --> 01:12:33,890
它并没有做任何主动的策略的考虑

1014
01:12:33,890 --> 01:12:35,530
这是我们说的这种协作式调度

1015
01:12:35,970 --> 01:12:38,550
就是CCR和CCExit这种协作式调度

1016
01:12:39,510 --> 01:12:41,330
就是超级种等于是没有调度策略

1017
01:12:41,330 --> 01:12:45,550
只是完成根据用户的请求来完成相应的操作而已

1018
01:12:45,550 --> 01:12:47,150
这是这一块调度

1019
01:12:47,150 --> 01:12:50,110
这边会涉及到很重要的就是要把当前的

1020
01:12:50,110 --> 01:12:51,310
如果是调12的话

1021
01:12:52,510 --> 01:12:56,050
掉一二的话 那么可能把当前的那个suspend掉

1022
01:12:56,050 --> 01:12:57,110
然后再run next

1023
01:12:57,990 --> 01:13:02,830
这个suspend 其实就是里面会掉switch

1024
01:13:02,830 --> 01:13:05,790
它要把当前的停下来 换下一个去执行

1025
01:13:05,790 --> 01:13:09,690
那么这个run next掉什么 要掉context

1026
01:13:09,690 --> 01:13:11,530
前面这个掉的是task switch

1027
01:13:11,530 --> 01:13:14,250
而run next的时候会掉context switch

1028
01:13:14,250 --> 01:13:15,550
回到用户台去执行

1029
01:13:17,310 --> 01:13:19,590
OK 但是这时候context需要注意

1030
01:13:19,590 --> 01:13:21,990
是next task的context

1031
01:13:22,510 --> 01:13:24,210
是那个control context

1032
01:13:24,210 --> 01:13:27,970
包括它的task context和control context

1033
01:13:27,970 --> 01:13:29,470
这两个context都变了

1034
01:13:29,470 --> 01:13:30,550
这个需要注意

1035
01:13:30,550 --> 01:13:33,710
所以你会看到他们有各自的

1036
01:13:33,710 --> 01:13:34,730
对于一个应用而言

1037
01:13:34,730 --> 01:13:36,990
它在内核里面有各自的trap context

1038
01:13:36,990 --> 01:13:38,590
和task context

1039
01:13:47,310 --> 01:13:48,310
小问题

1040
01:13:49,190 --> 01:13:51,970
内核程序设计 第一次进入用物谈

1041
01:13:51,970 --> 01:13:55,310
原来他一直在操纵在处置化的时候一直在内核谈

1042
01:13:57,750 --> 01:13:59,710
那他怎么第一次进入用物谈

1043
01:14:05,290 --> 01:14:07,250
因为我就不太敢出同学了

1044
01:14:07,250 --> 01:14:09,550
同学给我一次多反馈是很紧张

1045
01:14:09,550 --> 01:14:11,410
出了同学回来回答问题

1046
01:14:11,410 --> 01:14:13,550
所以我现在还是自问自答的好

1047
01:14:14,530 --> 01:14:17,250
怎么实现 我前面其实已经提醒过了

1048
01:14:47,250 --> 01:14:48,990
前提是你前面都准备好了

1049
01:14:48,990 --> 01:14:49,970
代码已经放过去了

1050
01:14:49,970 --> 01:14:51,910
用户的代码已经放到类型中去了

1051
01:14:51,910 --> 01:14:53,150
然后你这个代码建好了

1052
01:14:53,150 --> 01:14:54,670
用户站 类合站建好了

1053
01:14:54,670 --> 01:14:57,250
建好了它的task context和check context

1054
01:14:57,250 --> 01:14:58,550
这些都搞好了之后

1055
01:14:58,550 --> 01:14:59,950
你当然可以回去

1056
01:15:00,310 --> 01:15:03,630
这就是这么来实现的

1057
01:15:04,550 --> 01:15:05,810
这个调度这一块

1058
01:15:05,810 --> 01:15:06,710
时钟这一块

1059
01:15:06,710 --> 01:15:08,250
我觉得很简单

1060
01:15:08,250 --> 01:15:11,950
它时钟也是一种类似于异常的处理

1061
01:15:12,970 --> 01:15:15,430
但是时钟是随时可能产生的

1062
01:15:15,430 --> 01:15:16,950
你只要试好之后随时可能产生

1063
01:15:16,950 --> 01:15:20,230
那么它总会打断当前一旦产生中断

1064
01:15:20,230 --> 01:15:21,390
可以有处理器的设计

1065
01:15:21,390 --> 01:15:24,070
这是硬件的一个它的逻辑

1066
01:15:25,410 --> 01:15:28,070
它产生中断之后就会从用户态

1067
01:15:28,670 --> 01:15:29,710
限制到Lag态

1068
01:15:29,710 --> 01:15:30,810
它如果当前在Lag态

1069
01:15:30,810 --> 01:15:32,030
它也会限制到Lag态

1070
01:15:32,970 --> 01:15:35,050
好 反正不管怎么它会限制到Lag态

1071
01:15:35,050 --> 01:15:37,050
Lag态之后我们可以去判断

1072
01:15:37,050 --> 01:15:38,890
你这个应用程序当前直线多少分钟

1073
01:15:38,890 --> 01:15:39,870
直线多少时间

1074
01:15:39,870 --> 01:15:41,710
这个也可以做个统计

1075
01:15:41,710 --> 01:15:42,450
然后做完统计之后

1076
01:15:42,450 --> 01:15:44,030
如果时间用完了我们切换

1077
01:15:44,030 --> 01:15:45,650
这里面设计比较简单

1078
01:15:45,650 --> 01:15:47,870
只要产生时钟中断 我就切换

1079
01:15:47,870 --> 01:15:49,210
这个是最简单的方式

1080
01:15:49,210 --> 01:15:54,070
所以我们的OS是以简单为主要目标 便于理解

1081
01:15:54,510 --> 01:15:56,370
OK 这一块 为了能够做到这一步

1082
01:15:56,370 --> 01:15:58,270
你要去设置一个定时器吧

1083
01:15:58,270 --> 01:16:00,310
这个设置定时器也不是我们自己写驱动

1084
01:16:00,310 --> 01:16:03,150
把交给SBI 交给下面一层帮我们去搞

1085
01:16:03,150 --> 01:16:04,430
它搞了个Send Timer

1086
01:16:05,370 --> 01:16:08,930
主要是设置一个下一次产生中断的时刻

1087
01:16:08,930 --> 01:16:11,530
设置好之后它就可以了

1088
01:16:11,530 --> 01:16:12,330
但是需要注意的是

1089
01:16:12,330 --> 01:16:16,050
你还要 Enable 一下 TimingDraw 这为什么

1090
01:16:16,050 --> 01:16:17,530
因为你不 Enable 一开始确诊

1091
01:16:17,530 --> 01:16:20,410
一开始实行的时候 出Draw 了之后是

1092
01:16:20,410 --> 01:16:22,030
确诊情况下 它是没有终端的

1093
01:16:22,030 --> 01:16:23,630
所以它要 Enable 这个时钟终端

1094
01:16:23,970 --> 01:16:26,390
才能够真正把这个给起起来

1095
01:16:26,390 --> 01:16:27,650
OK 留了这个之后

1096
01:16:27,650 --> 01:16:30,370
那么一旦产生了那个时钟终端的时候

1097
01:16:30,370 --> 01:16:32,430
我就会认为时间先到了

1098
01:16:32,430 --> 01:16:33,790
那么在TabPanel里面

1099
01:16:33,790 --> 01:16:35,750
我可以做类似于同样的工作

1100
01:16:36,130 --> 01:16:42,210
设置一下下一个时钟终端的时刻

1101
01:17:42,910 --> 01:17:44,610
这里面第一次出现终端机制

1102
01:17:44,610 --> 01:17:46,190
虽然我们终端机制大家都理解

1103
01:17:46,190 --> 01:17:48,050
但这里面你会看到

1104
01:17:48,050 --> 01:17:49,650
怎么来真正产生一个终端

1105
01:17:49,650 --> 01:17:52,390
你需要去完成相应的一些设置

1106
01:17:52,390 --> 01:17:53,710
才能够产生终端

1107
01:17:53,710 --> 01:17:55,930
把这个终端机制用起来之后呢

1108
01:17:55,930 --> 01:17:57,390
解决我们那个调度问题

1109
01:17:58,210 --> 01:17:59,650
这是这一块的内容

1110
01:17:59,650 --> 01:18:01,030
我就给大家讲完了

1111
01:18:02,590 --> 01:18:03,310
我相信

1112
01:18:05,550 --> 01:18:06,270
这怎么

1113
01:18:08,630 --> 01:18:10,630
有问题吗

1114
01:18:41,890 --> 01:18:46,350
我给你要的一个共识是说,至少你们老是认为你们懂了。

1115
01:18:46,470 --> 01:18:49,970
如果你们还没懂的话,我欢迎同学提问。

1116
01:18:58,710 --> 01:19:00,770
第五节讲下一代的地理空间。

1117
01:19:01,850 --> 01:19:04,270
我们前面讲的都是物理空间,在物理空间打断。

1118
01:19:05,070 --> 01:19:09,510
并没有提到非常以前时不时提到的高级的一个技术,

1119
01:19:09,510 --> 01:19:11,730
就是所谓虚拟空间

1120
01:19:12,350 --> 01:19:16,330
这里面我们就会逐渐的涉及到地质空间的一块操作

1121
01:19:19,370 --> 01:19:22,490
其实这里面要讲的地质空间还是要去重新理解一下

1122
01:19:22,490 --> 01:19:27,850
回顾一下我们计算机里面的跟存储 内存相关的有哪些东西

1123
01:19:27,850 --> 01:19:31,030
然后才对地质空间有可能更深入理解

1124
01:19:31,030 --> 01:19:34,410
这里面有好几个术语 又一堆术语

1125
01:19:34,410 --> 01:19:37,650
物理地质 逻辑地质 线性地质 虚拟地质

1126
01:19:37,650 --> 01:19:39,210
我认为没有列出来虚拟地址

1127
01:19:39,210 --> 01:19:42,210
在于在这里面线性地址就等于虚拟地址

1128
01:19:42,210 --> 01:19:43,430
什么叫物理地址

1129
01:19:43,730 --> 01:19:46,670
就是我们从内存芯片里面

1130
01:19:46,670 --> 01:19:48,530
读出来的那个地址叫物理地址

1131
01:19:48,530 --> 01:19:50,730
好比我们前面讲的那几个超级统

1132
01:19:50,730 --> 01:19:52,530
它读出来的地址都是物理地址

1133
01:19:52,530 --> 01:19:54,810
那什么叫逻辑地址

1134
01:19:54,810 --> 01:19:58,090
逻辑地址是我们写程序的时候看到的地址

1135
01:19:59,270 --> 01:20:01,690
因为我们编译器你写程序的时候

1136
01:20:02,070 --> 01:20:04,750
其实你并没有意识到你是什么物理地址还是虚地址

1137
01:20:04,750 --> 01:20:08,530
你是按照你认为的一个存在的一个合理的一个变量

1138
01:20:08,530 --> 01:20:12,930
在进行编程 或者是函数在进行编程

1139
01:20:12,930 --> 01:20:14,910
那其实变量函数都有地址

1140
01:20:14,910 --> 01:20:18,310
那个地址我们反映成一个函数名或者变量名

1141
01:20:18,310 --> 01:20:20,230
但对于我们的真正的编系而言

1142
01:20:20,230 --> 01:20:23,590
它会把它变成最终的一个地址 数字化的一个地址

1143
01:20:23,590 --> 01:20:25,030
那我们把它称为逻辑地址

1144
01:20:25,030 --> 01:20:28,490
那这种逻辑地址的概念在Intel这个处理器上

1145
01:20:28,490 --> 01:20:31,490
就X86处理器上它也提到过 叫逻辑地址

1146
01:20:31,490 --> 01:20:34,590
然后它也提到了物理地址 当然它提到了一个线性地址

1147
01:20:35,030 --> 01:20:36,610
为什么Intel处理器有个线性地址呢

1148
01:20:36,610 --> 01:20:38,450
是在于它有两种翻译模式

1149
01:20:38,450 --> 01:20:41,930
我们前面讲到它有种断的机制和业的机制

1150
01:20:41,930 --> 01:20:44,150
一个逻辑地址或者一个虚拟地址

1151
01:20:44,150 --> 01:20:47,890
经过它的断机制转换之后会变成一个线性地址

1152
01:20:47,890 --> 01:20:52,290
线性地址经过业机制转换之后会变成物理地址

1153
01:20:53,130 --> 01:20:57,070
这个内容应该是组成原理课的老师都应该给大家讲过

1154
01:20:57,070 --> 01:20:58,770
我只是再稍微回顾一下

1155
01:20:58,770 --> 01:21:01,410
在我们这里面Risk5并没有断机制

1156
01:21:01,410 --> 01:21:02,890
它只有业机制

1157
01:21:03,530 --> 01:21:06,870
所以它的限定粒子也就意味着就是它的虚粒粒子

1158
01:21:07,850 --> 01:21:09,690
这是这么一个概念

1159
01:21:09,690 --> 01:21:10,850
而限定粒子也很好理解

1160
01:21:10,850 --> 01:21:14,670
就是按照一个线排列的一个粒子要限定粒子

1161
01:21:14,670 --> 01:21:16,130
这非常直观的一个解释

1162
01:21:17,750 --> 01:21:20,690
怎么转换逻辑粒怎么转换成物理粒子呢

1163
01:21:21,730 --> 01:21:24,250
那就是通过我们的硬件机制

1164
01:21:24,250 --> 01:21:26,530
断机制和业机制来转换

1165
01:21:26,530 --> 01:21:27,410
由于没有断机制

1166
01:21:27,410 --> 01:21:28,970
那逻辑的就等于虚粒子

1167
01:21:28,970 --> 01:21:29,930
这前面已经说过了

1168
01:21:30,450 --> 01:21:31,770
这次我们看到一个层次结构

1169
01:21:32,890 --> 01:21:35,470
存储层次结构有几种

1170
01:21:35,470 --> 01:21:38,090
这里面提供了几种存储结构呢

1171
01:21:38,090 --> 01:21:39,070
我再简单回顾一下

1172
01:21:39,070 --> 01:21:40,890
这个大家都应该很熟悉

1173
01:21:40,890 --> 01:21:43,370
最快的计程器

1174
01:21:45,390 --> 01:21:47,890
然后慢点的高速缓存

1175
01:21:47,890 --> 01:21:49,450
再慢点的内存

1176
01:21:49,450 --> 01:21:50,790
再慢点的Io

1177
01:21:50,790 --> 01:21:51,770
就是我们的block

1178
01:21:51,770 --> 01:21:53,890
这是存储层次结构

1179
01:22:08,470 --> 01:22:14,430
给我们的应用提供服务

1180
01:22:14,430 --> 01:22:15,470
我们的应用提供好的服务

1181
01:22:15,470 --> 01:22:16,910
什么叫好的服务

1182
01:22:16,910 --> 01:22:19,070
给应用看到的就是这是一块大类组

1183
01:22:19,730 --> 01:22:21,210
这是一块大类组

1184
01:22:21,210 --> 01:22:21,930
这一块大类组

1185
01:22:21,930 --> 01:22:23,170
它不用care

1186
01:22:23,170 --> 01:22:23,690
什么

1187
01:22:23,690 --> 01:22:23,870
给应用提供服务

1188
01:22:25,650 --> 01:22:31,510
它不用管 它只管写代码 写那些变量数理结构就行了

1189
01:22:31,510 --> 01:22:34,130
所有这些是被我们OS管起来的

1190
01:22:34,130 --> 01:22:35,670
它会给它提供一个框

1191
01:22:36,110 --> 01:22:39,810
把应用APP框在这里面 框在这里面就让它去运行

1192
01:22:39,810 --> 01:22:43,510
这里面的框其实是这里面的一个虚拟的映射

1193
01:22:43,510 --> 01:22:48,190
给它建立了一个虚拟的一个数据地址空间的一个环境

1194
01:22:48,190 --> 01:22:49,750
这是我们要干的事情

1195
01:22:54,110 --> 01:22:56,830
那怎么虚拟 这里面看得出来一个虚拟

1196
01:22:56,830 --> 01:23:00,190
就是我们其实后面会逐步讲的内容

1197
01:23:00,190 --> 01:23:03,870
第一个虚拟是什么呢

1198
01:23:04,610 --> 01:23:06,870
逻辑地址空间是连续的

1199
01:23:09,250 --> 01:23:11,850
这里面说的这个逻辑地址空间是连续的

1200
01:23:11,850 --> 01:23:15,070
每一个程序在运作中叫进程 叫任务

1201
01:23:15,070 --> 01:23:17,870
它是连续的 连续的地址空间好编程

1202
01:23:19,290 --> 01:23:20,950
这是编写好处理

1203
01:23:21,450 --> 01:23:27,270
但这个连续内存空间其实在物理环境下它是分散的

1204
01:23:27,270 --> 01:23:30,870
你看到这里面的这一块P1这块区域

1205
01:23:30,870 --> 01:23:32,350
它是分散在这些地方

1206
01:23:33,070 --> 01:23:35,250
甚至还放在外存上面

1207
01:23:35,250 --> 01:23:37,250
把这些地方分散

1208
01:23:38,290 --> 01:23:40,790
通过虚拟化提供了一个更大的地质空间

1209
01:23:41,790 --> 01:23:43,050
这是一个更大为什么

1210
01:23:43,050 --> 01:23:43,930
为什么叫更大

1211
01:23:43,930 --> 01:23:47,430
内存加外存加在一起形成了一个虚拟地质空间

1212
01:23:47,430 --> 01:23:50,890
而且每一个地质空间它有一个保护

1213
01:24:50,950 --> 01:24:56,370
我们用程序去做,这是我们的大致的一个overview。

1214
01:24:57,790 --> 01:25:00,090
那为了做这件事情,其实我们有很多种技术,

1215
01:25:01,410 --> 01:25:03,530
包括恒定位、分段、分页,

1216
01:25:04,050 --> 01:25:05,990
还要把这合在一起的一个所谓虚拟存储技术。

1217
01:25:06,390 --> 01:25:08,350
而这些技术离开我们的意见是不是不一样?

1218
01:25:08,730 --> 01:25:11,070
我们的意见就是,前面已经讲了几点了,

1219
01:25:11,190 --> 01:25:14,650
异常、中断、特遣级。

1220
01:25:15,070 --> 01:25:18,410
那么我们还有一个,就是讲这个分页,

1221
01:25:18,410 --> 01:25:21,790
这是我们后面会讲到的类似分页这一块

1222
01:25:22,210 --> 01:25:25,750
这基本上是我们所有会碰到的

1223
01:25:25,750 --> 01:25:29,810
这个lecture5会碰到的硬件的feature

1224
01:25:29,810 --> 01:25:31,910
再往后可能碰到的

1225
01:25:31,910 --> 01:25:33,250
硬件特殊的东西越来越少

1226
01:25:33,250 --> 01:25:34,170
几乎就没有了

1227
01:25:34,170 --> 01:25:35,110
基本上就是在这里面

1228
01:25:35,110 --> 01:25:36,490
就基本上把硬件东西

1229
01:25:36,490 --> 01:25:38,430
和OS需要的硬件东西都讲的差不多了

1230
01:25:42,830 --> 01:25:44,330
好 那所有的物理粒子

1231
01:25:44,330 --> 01:25:46,610
虚粒子和逻辑粒子其实是一样的

1232
01:25:46,610 --> 01:25:49,030
这里面看到的它们的出发点是不一样

1233
01:25:49,030 --> 01:25:50,530
对逻辑地址而言

1234
01:25:50,530 --> 01:25:54,050
我们的编译器它有它的一个0到max

1235
01:25:54,050 --> 01:25:55,170
甚至不是0

1236
01:25:55,170 --> 01:25:57,670
它会有它自己设定的一个70地址

1237
01:25:57,670 --> 01:25:59,110
那么虚拟地址也是一样

1238
01:25:59,110 --> 01:26:00,350
这里面所谓的0max

1239
01:26:00,350 --> 01:26:04,870
实际上是取决于这块的虚地址的范围

1240
01:26:04,870 --> 01:26:06,090
取决于我们的OS

1241
01:26:06,090 --> 01:26:08,350
给我们应用程序提供的一个范围

1242
01:26:08,350 --> 01:26:10,950
而这个范围是取决于我们编译器

1243
01:26:10,950 --> 01:26:14,670
而这个范围取决于我们实际的物理硬件

1244
01:26:14,670 --> 01:26:15,330
它的范围

1245
01:26:45,330 --> 01:26:47,310
OS和Hardware要结合在一起

1246
01:26:47,310 --> 01:26:50,470
这里面就是我们要把物理空间给用好

1247
01:26:50,470 --> 01:26:54,090
通过MMU 通过我们的业绩制用好之后

1248
01:26:54,090 --> 01:26:56,870
才能够实现我们应用程序说的

1249
01:26:56,870 --> 01:26:58,670
更大的一个虚拟环境

1250
01:26:58,670 --> 01:26:59,790
所以OS里面是核心

1251
01:26:59,790 --> 01:27:03,250
它需要向下跟Hardware打交道

1252
01:27:03,690 --> 01:27:05,490
向上跟Compiler打交道

1253
01:27:05,490 --> 01:27:06,930
才能够让我们的OS

1254
01:27:06,930 --> 01:27:10,450
才能让我们的APP能够很好地运行起来

1255
01:27:13,610 --> 01:27:19,470
这一块假的逻辑里的生成,我们看到了高距语言,这是我们编辑的内容

1256
01:27:19,470 --> 01:27:27,570
高距语言,汇编语言,目标文件,link之后生成的执行程序

1257
01:27:28,150 --> 01:27:31,210
这个执行程序加了内存中的一个地址

1258
01:27:31,210 --> 01:27:37,490
这是一个大致的不同的阶段,我们的程序体现出不同的形式

1259
01:27:38,150 --> 01:27:41,290
那这里面有一个需要注意叫重定位

1260
01:27:41,290 --> 01:27:42,690
为什么叫重定位呢

1261
01:27:42,690 --> 01:27:46,450
这里面jump和这个的慈激的这个地址不一样

1262
01:27:46,850 --> 01:27:49,530
哪种情况会有这种情况出现

1263
01:27:49,530 --> 01:27:51,310
就是重定位的情况出现

1264
01:27:52,110 --> 01:27:53,430
我不知道大家有没有印象

1265
01:27:53,430 --> 01:27:54,710
可能更多的是用

1266
01:27:54,710 --> 01:27:58,610
并没有去考虑怎么去设计或实现

1267
01:28:00,570 --> 01:28:02,810
在我们的应用程序里

1268
01:28:02,810 --> 01:28:04,270
如果用到了动态链接库的时候

1269
01:28:04,270 --> 01:28:09,330
这个东台链接库本身就是一个需要重订位的一个程序

1270
01:28:09,330 --> 01:28:11,410
这是这里面讲到

1271
01:28:11,410 --> 01:28:13,830
对OS而言其实也有

1272
01:28:13,830 --> 01:28:17,310
但是这一块内容这个重订位本身

1273
01:28:17,310 --> 01:28:21,690
需要注意这个重订位本身并不需要OS的特别的支持

1274
01:28:21,690 --> 01:28:24,270
这个在用上就可以搞定重订位

1275
01:28:25,490 --> 01:28:28,350
当然我们OS会提供相应的内存空间给他用

1276
01:28:28,350 --> 01:28:30,070
这个是必须的

1277
01:28:34,270 --> 01:28:38,770
有几个时机,编译的时候会生成一个地址,加载的时候会生成一个地址,执行

1278
01:28:38,770 --> 01:28:40,610
的时候会生成一个地址。

1279
01:28:42,170 --> 01:28:45,390
那么在重点我们考虑什么,我们考虑执行。

1280
01:28:45,750 --> 01:28:49,230
因为执行是靠我们的OS来执行的。

1281
01:28:49,230 --> 01:28:54,190
在执行的时候,你需要注意几点,就是这个执行的代码是我们编辑生成的。

1282
01:28:54,230 --> 01:29:00,050
那么我们再去执行的时候,你要注意这些不同的区域中的数据,

1283
01:29:00,050 --> 01:29:02,010
无论是代码还是数据 它有不同的特征

1284
01:29:02,010 --> 01:29:05,610
比如说代码是不可修改 但是可执行

1285
01:29:05,610 --> 01:29:10,490
但对于数据而言 它是可读可写 但是它不可执行

1286
01:29:10,490 --> 01:29:14,050
这些我们都需要通过相应的机制来保证它

1287
01:29:14,050 --> 01:29:15,550
这个机制就是我们硬件

1288
01:29:15,550 --> 01:29:19,330
我们硬件的那个MMU和页机制

1289
01:29:19,330 --> 01:29:22,750
可以保证我们去对这一块做一个安全的检查

1290
01:29:33,570 --> 01:29:38,950
这一块好像都是在给大家复习组成原理

1291
01:29:38,950 --> 01:29:42,070
ALU MMU和CPU ALU完成计算

1292
01:29:42,070 --> 01:29:43,570
但它需要地址

1293
01:29:43,570 --> 01:29:48,430
地址交给谁 交给MMU来进行转换

1294
01:29:48,430 --> 01:29:52,910
然后这个内存最终会通过CPU

1295
01:29:52,910 --> 01:29:55,930
把这个内存从内存的数据取到这个集成器里面去

1296
01:29:55,930 --> 01:29:58,350
然后交给ALU去进行计算

1297
01:29:58,350 --> 01:30:04,870
OS需要完成的是这个逻辑地址和物理地址这个转换案的内容怎么转换

1298
01:30:04,870 --> 01:30:09,090
那OS要去负责来做相应的一些事情

1299
01:30:10,190 --> 01:30:14,270
这是在地址处理过程中会碰到的一些三者的一些关系

1300
01:30:16,710 --> 01:30:20,230
这个图是主持人李克老师应该讲过的

1301
01:30:20,230 --> 01:30:22,790
有同学能够给我讲讲这图啥意思

1302
01:30:24,690 --> 01:30:27,170
写了一个1234565

1303
01:30:29,270 --> 01:30:35,170
这个图想说是当我的AOU要完成一个内存的数据的读的时候

1304
01:30:35,170 --> 01:30:38,310
它可能碰到的一些处理过程

1305
01:30:38,310 --> 01:30:42,490
首先读 要读一个地址 那个地址这样是一个虚地址

1306
01:30:42,490 --> 01:30:46,450
假定我们那个业绩是打开了 这是第一步

1307
01:30:46,950 --> 01:30:52,590
第一步是读到一个虚地址 第二步这个虚地址

1308
01:30:52,590 --> 01:30:54,910
它最终是基于物理粒子已经搞了

1309
01:30:54,910 --> 01:30:56,650
所以它要去查MMU

1310
01:30:57,810 --> 01:30:59,510
查那个TLB的缓存

1311
01:30:59,510 --> 01:31:02,710
看有没有对应的那个虚粒子和物理粒子的映射关系

1312
01:31:02,710 --> 01:31:04,790
如果有TLB命中

1313
01:31:04,790 --> 01:31:07,070
那就是到这搞2.1命中之后呢

1314
01:31:07,070 --> 01:31:08,230
它得到了物理粒子

1315
01:31:08,230 --> 01:31:10,050
那我们就可以直接从内存中

1316
01:31:10,050 --> 01:31:13,250
把物理粒子这个对那个单元数据给读回来

1317
01:31:13,650 --> 01:31:14,670
完成AOV的计算

1318
01:31:14,670 --> 01:31:15,490
这是一种情况

1319
01:31:16,290 --> 01:31:16,930
如果没有

1320
01:31:17,890 --> 01:31:18,990
如果没有怎么办

1321
01:31:18,990 --> 01:31:19,990
没有的话

1322
01:31:20,730 --> 01:31:21,870
我们的硬件

1323
01:31:21,870 --> 01:31:26,770
我说的是现在Risk 5或者是X86或者是ARM

1324
01:31:26,770 --> 01:31:32,370
我们的硬件会查找

1325
01:31:32,370 --> 01:31:33,870
查找什么 查找页表

1326
01:31:33,870 --> 01:31:35,650
这页表谁建的 OS建的

1327
01:31:35,650 --> 01:31:40,750
页表里面会放VA和PA

1328
01:31:40,750 --> 01:31:43,410
虚粒子和物理粒子的一个映射关系

1329
01:31:43,410 --> 01:31:44,690
查页表 因为你有VA

1330
01:31:44,690 --> 01:31:46,130
跟VA查PA

1331
01:31:46,130 --> 01:31:48,350
如果查找了 OK

1332
01:31:48,350 --> 01:31:51,790
会把这个项放回到TOB里面去缓存起来

1333
01:31:52,370 --> 01:31:55,130
然后得到物理地址之后呢 同样可以完成补写

1334
01:31:55,130 --> 01:32:00,070
这是第三步 那么第四步还有查不着的情况

1335
01:32:00,690 --> 01:32:04,710
如果这个页表项里面没有对应的VA所对应的那个PA存在的话

1336
01:32:04,710 --> 01:32:08,170
那么就是其实产生了异常 这是一种异常

1337
01:32:08,170 --> 01:32:11,850
这种异常呢 会有异常处理 这就会到了我们的OS来进行处理

1338
01:32:12,370 --> 01:32:14,090
那OS处理有几种情况

1339
01:32:14,090 --> 01:32:19,090
他觉得这个地址实际上是程序合理的地址

1340
01:32:19,090 --> 01:32:21,150
那么他会重新建好页表

1341
01:32:21,150 --> 01:32:24,990
然后让这个指令重新执行

1342
01:32:24,990 --> 01:32:26,410
如果是不合理的地址

1343
01:32:26,410 --> 01:32:27,850
我应该把它care掉

1344
01:32:27,850 --> 01:32:29,870
如果这个地址不在内存中

1345
01:32:29,870 --> 01:32:32,910
全部数可能放在硬盘上某个区域

1346
01:32:33,570 --> 01:32:35,330
那么超纯还要把这个硬盘的数据

1347
01:32:35,330 --> 01:32:36,730
读到内核里面来

1348
01:32:36,730 --> 01:32:37,990
重新改写页表

1349
01:32:37,990 --> 01:32:39,930
然后再重新让这个指令重新执行

1350
01:32:41,270 --> 01:32:44,090
OK 我就大致的把这个流程讲过了

1351
01:32:44,590 --> 01:32:45,970
我觉得我只是在重复

1352
01:32:45,970 --> 01:32:47,250
这个我就不细讲了

1353
01:32:51,270 --> 01:32:55,270
好,我们已经看到了,有可能数据放在外存

1354
01:32:55,770 --> 01:32:58,270
这是为什么我们说虚存的作用

1355
01:32:58,270 --> 01:33:04,550
就是把这个给程序的运行所需要的地址空间给扩大了

1356
01:33:04,550 --> 01:33:07,410
因为你现在,你是把这两个合在一起嘛

1357
01:33:07,410 --> 01:33:10,490
所以说它是空间扩大了

1358
01:33:10,490 --> 01:33:13,110
而且为了提高效率,它会把常用的数据放在内存中

1359
01:33:13,110 --> 01:33:14,950
不常用的数据放在外存中

1360
01:33:14,950 --> 01:33:17,370
这就涉及到我们后期会讲到这个

1361
01:33:17,370 --> 01:33:20,350
你把哪些数据放在内存中,把哪些数据换到外头去

1362
01:33:20,350 --> 01:33:25,150
这有些算法的考虑 这是我们进一步的优化的一些设计

1363
01:33:29,670 --> 01:33:34,130
好 还有什么好处 我们需要得到它的好处

1364
01:33:34,130 --> 01:33:36,830
第一是扩大 再讲的是把这个内存扩大了

1365
01:33:36,830 --> 01:33:40,630
第二个好处 我们给每个应用程序提供独立地址空间

1366
01:33:41,150 --> 01:33:43,250
这样编程更简单了

1367
01:33:43,250 --> 01:33:45,330
我们前面讲到我们要给前面那个超级桶

1368
01:33:45,330 --> 01:33:49,470
我们还需要给每个应用程序各自不同的起始地址

1369
01:33:49,470 --> 01:33:53,470
但是有了虚存之后,我可以试试同样的虚粟粟粟粟粟粟粟粟粟粟

1370
01:33:53,470 --> 01:34:10,810
粟粟粟粟粟粟粟粟粟粟粟粟粟粟粟粟粟粟粟粟粟粟粟粟粟

1371
01:34:10,810 --> 01:34:19,410
粟粟粟粟粟粟粟粟粟粟粟粟粟粟粟粟�

1372
01:34:19,410 --> 01:34:21,730
音乐就简化了类似分配

1373
01:34:24,170 --> 01:34:26,350
好 大家可以休息一下

1374
01:36:40,770 --> 01:36:43,950
所以你们还要上两次课就要有一个期中考试

1375
01:38:21,410 --> 01:38:39,150
不不不不不不不不不不不不不不不不不不不不不不不不不

1376
01:38:39,150 --> 01:38:39,150
不

1377
01:39:32,290 --> 01:39:36,410
好 我们继续讲 前面讲到了虚纯的好处

1378
01:39:36,410 --> 01:39:39,270
第一个可以扩大空间 提高性能

1379
01:39:39,270 --> 01:39:41,330
第二个可以简化编程

1380
01:39:41,330 --> 01:39:44,210
简化我们的编程和执行

1381
01:39:44,210 --> 01:39:46,430
第三个安全

1382
01:39:46,430 --> 01:39:49,390
就性能方便 安全

1383
01:41:19,410 --> 01:41:21,190
其实我们的OS也是一个软件

1384
01:41:21,190 --> 01:41:23,030
它也会涉及到类似分配

1385
01:41:24,250 --> 01:41:28,250
但目前来说我们重点讲的是面向应用程序的类似分配

1386
01:41:28,610 --> 01:41:32,950
那么有两类 我们这里把这个稍微区分一下

1387
01:41:35,770 --> 01:41:38,250
这是一类 静态的分配和动态的分配

1388
01:41:38,250 --> 01:41:41,610
第二个是连续类分配和非连续类分配

1389
01:41:41,610 --> 01:41:44,090
这从字面意义上非常好理解

1390
01:41:44,090 --> 01:41:47,110
这是两类类分配

1391
01:41:48,830 --> 01:41:54,410
那为什么要讲内存分配呢 是在于让我们的应用更方便 灵活 高效地

1392
01:41:54,410 --> 01:41:55,950
使用有限的内存

1393
01:41:55,950 --> 01:42:00,870
因为我们的内存是有限的 我们希望它用得非常灵活 方便 高效 这是我们要

1394
01:42:00,870 --> 01:42:01,730
达到的目标

1395
01:42:01,730 --> 01:42:06,110
那我们应用程序本身 在运营的时候都可以看到这么一个区域

1396
01:42:08,590 --> 01:42:12,530
OK 那同学 我想问一下 咱们先考虑这个问题了

1397
01:44:13,650 --> 01:44:18,750
他们这些不是对立的

1398
01:44:18,750 --> 01:44:21,230
这一块前面已经讲到了

1399
01:44:23,470 --> 01:44:24,550
这个结构图

1400
01:44:24,550 --> 01:44:27,590
这个结构图是我们看到的

1401
01:44:27,590 --> 01:44:29,110
我们应用程序

1402
01:44:29,110 --> 01:44:29,970
你写应用程序的时候

1403
01:44:29,970 --> 01:44:32,030
你可能对于c程序就是这两个

1404
01:44:32,830 --> 01:44:38,150
有这两个来完成对堆的内存的申请与释放

1405
01:44:38,910 --> 01:44:39,310
OK

1406
01:44:39,310 --> 01:44:39,950
当你掉

1407
01:44:39,950 --> 01:44:42,470
你看后面会有讲这个这是动态的准备

1408
01:44:42,470 --> 01:44:43,370
我们其实讲的是动态

1409
01:44:43,370 --> 01:44:45,310
静态就不用讲了

1410
01:44:45,310 --> 01:44:46,650
因为它已经搞定了

1411
01:44:46,650 --> 01:44:47,790
就是我们编辑已经搞定了

1412
01:44:47,790 --> 01:44:48,690
我们不需要care

1413
01:44:48,690 --> 01:44:50,350
编译课已经学过了

1414
01:44:51,510 --> 01:44:54,730
但动态就是有两类

1415
01:44:54,730 --> 01:44:55,410
账和堆

1416
01:44:55,410 --> 01:44:56,750
那我们重点是堆

1417
01:44:56,750 --> 01:44:58,170
有个malloc和free

1418
01:44:58,570 --> 01:45:02,370
那malloc就是谁要是往上去申请新的内存

1419
01:45:02,370 --> 01:45:05,190
free就是往下减少这个堆的内存

1420
01:45:05,190 --> 01:45:07,190
这是他们一个上下的关系

1421
01:45:39,950 --> 01:45:41,110
这样效率很差

1422
01:45:41,850 --> 01:45:44,290
所以我们要想我们的应用更灵活

1423
01:45:44,290 --> 01:45:45,930
我们就需要动态度分配

1424
01:45:46,810 --> 01:45:47,930
就是为什么需要

1425
01:45:47,930 --> 01:45:49,990
这个也是有它的必要性

1426
01:45:51,330 --> 01:45:52,950
好 动态度分配有两类

1427
01:45:52,950 --> 01:45:55,290
一类显示 一类影视

1428
01:45:55,290 --> 01:45:56,910
我们说的Matterplay这个显示

1429
01:45:56,910 --> 01:45:58,610
因为这个什么时候申请 什么时候释放

1430
01:45:58,610 --> 01:46:00,970
全是由我们的程序员来控制

1431
01:46:00,970 --> 01:46:02,210
那影视是什么呢

1432
01:46:02,210 --> 01:46:04,250
影视只管申请 不管释放

1433
01:46:04,250 --> 01:46:06,270
那这个典型的例子就是

1434
01:46:08,270 --> 01:46:12,230
Java Python Go 这是只管申请不管释放

1435
01:46:12,230 --> 01:46:16,410
由运行时来帮助我们自动释放

1436
01:46:16,410 --> 01:46:20,250
Rust是由编辑器帮我们自动释放

1437
01:46:20,250 --> 01:46:21,090
不太一样

1438
01:46:21,090 --> 01:46:22,290
Rust不靠运行时

1439
01:46:22,290 --> 01:46:24,810
所以它的效率会显得更高一点

1440
01:46:25,750 --> 01:46:26,870
但是确实也更高一点

1441
01:46:26,870 --> 01:46:28,310
但是它的编程就麻烦一点

1442
01:46:28,310 --> 01:46:30,430
这是它的带来一些问题

1443
01:46:31,330 --> 01:46:33,550
这是写照影是一个区分

1444
01:46:33,550 --> 01:46:35,070
我们重点讲什么 讲显示

1445
01:46:35,930 --> 01:46:40,930
因为所有的影视最终也是要通过显示的向我们 OOS 发出请求

1446
01:46:40,930 --> 01:46:44,230
于是要给我的空间放得更大,还是要把我的空间变得小一点

1447
01:46:44,230 --> 01:46:49,270
对 HIP 做管理,就是 One Care 是对 OOS 的影响

1448
01:46:50,490 --> 01:46:54,530
而现在这个影视和显示更多是站在应用角度来说看到的一个效果

1449
01:46:54,530 --> 01:46:58,270
很多情况下,我们的 Lib 库就帮我们做了很多的事情

1450
01:49:29,730 --> 01:49:34,910
那么管理需要注意,这里的管理可以是内核管,但是为了提高效率,我们也可以是我们

1451
01:49:34,910 --> 01:49:35,550
的库来管。

1452
01:49:36,190 --> 01:49:42,130
这个库就是这一块区域,你可以看到上面这块区域里面,这块区域,这个是分配

1453
01:49:42,130 --> 01:49:42,730
的。

1454
01:49:42,910 --> 01:49:46,710
如果把它给它了,它这块就被分配出去了。没有给的,像这一块区域,那就是

1455
01:49:46,710 --> 01:49:48,030
福利的区域。

1456
01:49:48,830 --> 01:49:50,970
那中间这块区域其实也是一个福利的区域。

1457
01:49:50,970 --> 01:49:54,550
那如果我后续的分配都超过了这块区域

1458
01:49:54,550 --> 01:49:56,170
超过了这块区域的大小的话

1459
01:49:56,170 --> 01:49:57,810
那这块区域用不上了

1460
01:49:57,810 --> 01:49:59,450
那成为什么 这叫外碎片

1461
01:49:59,450 --> 01:50:00,590
这是外碎片

1462
01:50:00,590 --> 01:50:02,090
那如果给了这块区域

1463
01:50:02,090 --> 01:50:04,430
这块区域确实给它这么一块大的区域

1464
01:50:04,430 --> 01:50:05,830
但是这个应用程序

1465
01:50:05,830 --> 01:50:07,330
它只用了这么一小块

1466
01:50:07,330 --> 01:50:09,910
这一块没有用

1467
01:50:10,790 --> 01:50:12,490
那这个叫什么 叫内碎片

1468
01:50:12,490 --> 01:50:14,010
就这块区域叫内碎片

1469
01:50:14,010 --> 01:50:15,650
OK 这个是内碎片外碎片区别

1470
01:50:16,830 --> 01:50:19,350
你们之前有课程讲过这个内容吗

1471
01:50:19,350 --> 01:50:21,070
如果讲到我可以稍微讲得快点

1472
01:50:21,870 --> 01:50:27,610
有同学摇头 那我只好再不用翘着讲了

1473
01:50:29,890 --> 01:50:33,550
好 我们重点关注是要给这个应用程序提供支持

1474
01:50:34,230 --> 01:50:36,970
所以你要提高这个分配的效率

1475
01:50:36,970 --> 01:50:40,110
你要在这块打交道 就是你要在这块多琢磨一下

1476
01:50:40,110 --> 01:50:46,050
怎么去来分配这个内存 怎么来组织这些空闲内存

1477
01:50:46,050 --> 01:50:50,510
这是我们说要强调动态分区分配的一个重点

1478
01:50:50,510 --> 01:50:52,750
这相当于是在做分区

1479
01:50:53,410 --> 01:50:55,830
分配好的是一个区 没分配好的是一个区

1480
01:50:55,830 --> 01:50:58,690
你怎么组织管理它 来提高所谓的分配效率

1481
01:50:58,690 --> 01:50:59,910
这是我们要考虑的问题

1482
01:51:01,810 --> 01:51:02,930
如果要考虑这个问题的话

1483
01:51:02,930 --> 01:51:06,330
其实要把这个问题给它拆细化

1484
01:51:06,330 --> 01:51:09,930
把问题分解 提高分配的效率

1485
01:51:09,930 --> 01:51:13,150
问题分解 存在这四个小的问题

1486
01:51:13,810 --> 01:51:15,310
第一个空心化怎么组织

1487
01:51:15,310 --> 01:51:20,050
就是一系列空间块 这些空间块怎么给它有效地组织起来

1488
01:51:20,050 --> 01:51:24,010
第二个 你选择哪个空间块来进行分配

1489
01:51:24,010 --> 01:51:25,190
怎么来选择的问题

1490
01:51:26,910 --> 01:51:30,610
第三个 我如果有块大的空间块 你要求的比较小

1491
01:51:30,610 --> 01:51:33,370
那我怎么去做分割

1492
01:51:33,370 --> 01:51:34,790
就是你一次分不完

1493
01:51:34,790 --> 01:51:36,930
比如说我这次申请的时候可能只申请这么一块

1494
01:51:36,930 --> 01:51:39,910
那么剩下这一块怎么去做分割

1495
01:51:39,910 --> 01:51:42,430
还有你不光是卖了可能还要free

1496
01:51:42,430 --> 01:51:44,910
你把这一块给它free完之后

1497
01:51:44,910 --> 01:51:46,770
那么如果这也是一个福瑞的

1498
01:51:46,770 --> 01:51:48,490
那它是不是可以和这一块的福瑞的

1499
01:51:48,490 --> 01:51:50,830
形成一个更大的空闲的空间

1500
01:51:50,830 --> 01:51:52,170
怎么去合并的问题

1501
01:51:52,170 --> 01:51:54,410
你把这四个问题考虑明白之后

1502
01:51:54,410 --> 01:51:56,350
我们就可以设立一波合理的

1503
01:51:56,350 --> 01:51:58,150
或者高效的这个分配算法

1504
01:51:58,970 --> 01:51:59,930
或者分配策略吧

1505
01:51:59,930 --> 01:52:01,390
这个也可以叫策略 也叫算法

1506
01:52:02,650 --> 01:52:06,550
所以这里面我们讲了非常基本的

1507
01:52:07,390 --> 01:52:09,990
三类分配算法或者分配策略

1508
01:52:10,370 --> 01:52:13,710
叫first fit, best fit和 worst fit

1509
01:52:13,710 --> 01:52:15,910
不要根据致命意识来决定它的好坏

1510
01:52:16,570 --> 01:52:19,610
它致命意识不代表任何的好坏

1511
01:52:19,610 --> 01:52:21,570
只代表了它的操作方式

1512
01:52:21,570 --> 01:52:23,150
这个大家需要注意

1513
01:52:23,150 --> 01:52:24,670
不要看到Worth是最差

1514
01:52:24,670 --> 01:52:25,470
不是这么回事

1515
01:52:26,750 --> 01:52:28,950
先看Forcebit什么意思

1516
01:52:28,950 --> 01:52:33,190
Forcebit就是我这里面

1517
01:52:34,570 --> 01:52:35,690
这是黄色的是什么

1518
01:52:35,690 --> 01:52:37,430
黄色的是扣言框

1519
01:52:39,370 --> 01:52:41,250
然后有这个玩意

1520
01:52:44,490 --> 01:52:47,710
黄色空闲块 那么这空闲块我要去

1521
01:52:47,710 --> 01:52:48,970
比如说我要分配一个400

1522
01:52:49,550 --> 01:52:50,690
400那它怎么找

1523
01:52:50,690 --> 01:52:52,870
空闲块是可以给你们有个链接链起来的

1524
01:52:52,870 --> 01:52:53,990
那么它会从第一个开始找

1525
01:52:53,990 --> 01:52:56,110
假设这个链是从上往下链的

1526
01:52:56,830 --> 01:52:58,730
这个链这儿 这个链这儿

1527
01:52:58,730 --> 01:53:01,110
它第一个开始找 第一个找着找着找这个1k

1528
01:53:01,110 --> 01:53:03,030
找1k之后能不能满足这个400

1529
01:53:03,610 --> 01:53:05,230
第一个first 找着了之后

1530
01:53:05,230 --> 01:53:07,230
我就把这一块区域给它分配出去了

1531
01:53:07,230 --> 01:53:08,310
这块区域分配出去了

1532
01:53:08,310 --> 01:53:10,870
然后剩下的区域继续作为空闲块

1533
01:53:10,870 --> 01:53:12,650
那么这个链接还存在

1534
01:53:12,650 --> 01:53:14,970
这新的一个空间框的链就OK了

1535
01:53:16,110 --> 01:53:18,030
1K分了400 这还剩下600

1536
01:53:18,030 --> 01:53:21,110
如果下一个空间框是600

1537
01:53:21,110 --> 01:53:23,290
那正好满足 那把这个也会分出

1538
01:53:23,290 --> 01:53:24,910
但是下一个空间框如果是1K

1539
01:53:24,910 --> 01:53:25,970
那这个就不满足了

1540
01:53:26,530 --> 01:53:28,310
那它就会是跟这个链往下找

1541
01:53:28,310 --> 01:53:29,970
找到2K里面找到一个1K

1542
01:53:29,970 --> 01:53:32,450
那它这个是2K成为一个force fit

1543
01:53:32,450 --> 01:53:34,850
就这么来完成整个插槽过程

1544
01:53:34,850 --> 01:53:35,530
非常简单

1545
01:53:36,210 --> 01:53:38,450
缺点外置碎片会比较多

1546
01:53:38,450 --> 01:53:39,510
因为你越分越细之后

1547
01:53:39,510 --> 01:53:41,970
中间的这个会越来越小

1548
01:55:12,310 --> 01:55:14,810
如果你持续搞大的话 那它其实也有问题

1549
01:55:15,450 --> 01:55:18,050
所以这里面只是讲策略的思路

1550
01:55:18,050 --> 01:55:20,710
并没有一个说谁比谁更好的一个问题

1551
01:55:20,710 --> 01:55:21,790
这个需要注意

1552
01:55:21,790 --> 01:55:24,950
而且它每次什么时候能分辨什么时候不能分辨

1553
01:55:24,950 --> 01:55:28,570
取决于你应用发出的请求的特点

1554
01:55:29,990 --> 01:55:32,970
这是这三个就很快的给大家过完了

1555
01:55:36,310 --> 01:55:39,690
好 这三个我还没花多少时间讲

1556
01:55:39,690 --> 01:55:41,410
是在于它太简单了

1557
01:55:41,410 --> 01:55:43,750
我没有讲free怎么操作

1558
01:55:43,750 --> 01:55:44,790
free怎么操作

1559
01:55:44,790 --> 01:55:47,390
free需要考虑一点

1560
01:55:47,390 --> 01:55:49,570
你如果free了一个块之后

1561
01:55:49,570 --> 01:55:52,470
它的旁边 它的前面 就上面和下面

1562
01:55:52,470 --> 01:55:55,470
如果有没有跟它刚好靠近的那个free的块

1563
01:55:55,470 --> 01:55:57,950
如果有 它应该可以做个合并

1564
01:55:57,950 --> 01:56:00,310
因为我们一个基本的观点是说

1565
01:56:00,310 --> 01:56:03,910
越大的块越容易分配 越能够满足应用的需求

1566
01:56:03,910 --> 01:56:05,330
所以它有一个合并操作

1567
01:56:05,830 --> 01:56:07,610
OK 这个是需要注意的

1568
01:56:07,610 --> 01:56:09,610
并没有讲 但大家应该能够理解

1569
01:56:09,610 --> 01:56:12,950
但所有这些东西都会看到它的外碎片是比较严重的

1570
01:56:13,810 --> 01:56:15,150
为什么会比较严重呢

1571
01:56:15,150 --> 01:56:20,190
是在于我们对应用的申请的size没有任何约数

1572
01:56:20,510 --> 01:56:21,650
随便大小都可以

1573
01:56:21,650 --> 01:56:23,030
你分配一个字节

1574
01:56:23,850 --> 01:56:25,430
分配一K个字节

1575
01:56:25,430 --> 01:56:26,490
分配一兆个字节

1576
01:56:26,490 --> 01:56:27,370
我都能满足你

1577
01:56:27,370 --> 01:56:28,370
那很灵活

1578
01:56:28,370 --> 01:56:31,130
但这种灵魂性带来的就是效率不高

1579
01:56:31,130 --> 01:56:32,770
它有可能产生大量的碎片

1580
01:56:32,770 --> 01:56:34,050
特别是外碎片

1581
01:56:34,830 --> 01:56:37,430
所以另外一个思路就是我尽量减少外碎片

1582
01:56:38,370 --> 01:56:43,170
另外这边就是我要有些限制 我对应用程序有些限制 什么限制呢

1583
01:56:43,170 --> 01:56:46,490
我应用程序我可能就是有个约束 就是比如说

1584
01:56:46,970 --> 01:56:50,370
我每次申请的时候 你必须是这么一个size

1585
01:56:50,370 --> 01:56:54,830
2的u是方个4k 这么一个大小

1586
01:56:54,830 --> 01:56:57,790
你只能用这个大小来 这个uk是0

1587
01:56:57,790 --> 01:56:59,890
那就是最小单位是4k

1588
01:56:59,890 --> 01:57:04,190
你要分配4k 8k 16k 这么去分配

1589
01:57:04,190 --> 01:57:07,010
你按这个size来 我给你满足你的需求

1590
01:57:07,010 --> 01:57:14,330
这样带来的好处是什么呢,好处就是没有外水片,但内水片还是会有的

1591
01:57:14,890 --> 01:57:19,010
这个内水片取决于你怎么去用,如果用不满,那就是内水片,跟应用相关

1592
01:57:20,850 --> 01:57:29,190
第一是没有外水片,第二呢,它能够快速的申请释放,并能够快速的合

1593
01:57:29,190 --> 01:57:29,630
并

1594
01:57:29,630 --> 01:57:34,250
我们前面说free之后,快速的合并这么一个操作也是很方便的

1595
01:57:34,930 --> 01:57:40,530
它其实就是把这个整个空间按照

1596
01:57:40,530 --> 01:57:42,030
这是一个比如这是一个

1597
01:57:42,030 --> 01:57:45,350
底下是一个memory的一个空闲空间

1598
01:57:46,430 --> 01:57:49,350
那么它这个空闲空间呢

1599
01:57:49,350 --> 01:57:53,450
我就是把它按照你这里面一个块

1600
01:57:53,450 --> 01:57:55,190
你可以有一个4K size

1601
01:57:55,190 --> 01:57:57,090
那么这4K里面就是

1602
01:57:57,910 --> 01:58:00,830
这是所有的4K的大小的一个块

1603
01:58:00,830 --> 01:58:03,370
然后这是所有的16K大小的一块

1604
01:58:03,370 --> 01:58:09,830
然后一直到 这是多少 一共16个 就是16个块

1605
01:58:09,830 --> 01:58:10,690
这一共是16项

1606
01:58:10,690 --> 01:58:13,030
所以这个块的size按照4K来进去

1607
01:58:13,030 --> 01:58:14,950
能有16个4K的size

1608
01:58:14,950 --> 01:58:16,250
这是一块区域

1609
01:58:17,470 --> 01:58:19,430
它可以组织成这么一个结构

1610
01:58:19,430 --> 01:58:20,430
那我申请的时候

1611
01:58:20,930 --> 01:58:25,190
我会去基于这么一个塑状结构去查找

1612
01:58:25,190 --> 01:58:26,570
比如说我要申请一个

1613
01:58:27,450 --> 01:58:29,970
就是一个16个4K的页

1614
01:58:31,050 --> 01:58:34,970
那我一查 从这开始查 一查只有这个

1615
01:58:35,570 --> 01:58:39,370
这就是16 size为16的时候 有存在这么一个空闲块

1616
01:58:39,370 --> 01:58:41,950
那我就把整个给分给他就完了

1617
01:58:42,450 --> 01:58:45,570
但如果说这里面你已经分配了一半了

1618
01:58:45,570 --> 01:58:48,650
只有八个了 比如这个地方

1619
01:58:48,650 --> 01:58:51,290
这对应的这八个这些也被分配出去了

1620
01:58:51,290 --> 01:58:55,470
但这一块是free的 那我查这个是没有了

1621
01:58:55,470 --> 01:58:59,390
但是往下查 查这个这个link里面有一个1

1622
01:58:59,390 --> 01:59:01,250
它就可以把这个分配出去了

1623
01:59:01,250 --> 01:59:04,290
所以它这个插槽基于这么一个快速插槽

1624
01:59:04,290 --> 01:59:07,710
可以迅速的把满足它的这个块给找着

1625
01:59:07,710 --> 01:59:08,590
从而完成分配

1626
01:59:09,630 --> 01:59:10,810
即使是最小的块

1627
01:59:10,810 --> 01:59:13,990
那我也可以通过这种像二插数一样

1628
01:59:13,990 --> 01:59:18,130
插最底下来迅速的把它找到相应的一个

1629
01:59:18,130 --> 01:59:19,710
一个空前块给它分配出去

1630
01:59:19,710 --> 01:59:21,330
那么你可以把这个理解为什么

1631
01:59:21,330 --> 01:59:22,190
这是一个数字

1632
01:59:22,910 --> 01:59:24,750
这个数字里面会跟一个链表

1633
01:59:24,750 --> 01:59:28,330
这个链表里面链接了所有这些同样size的

1634
01:59:28,330 --> 01:59:29,970
数域块的一个结构

1635
01:59:29,970 --> 01:59:31,210
有这么一个结构之后

1636
01:59:31,210 --> 01:59:33,250
我就可以完成快速的申请和释放

1637
01:59:33,250 --> 01:59:35,130
你可以把这个理解为一个数域结构

1638
01:59:37,190 --> 01:59:42,910
那它的特例过程怎么回事呢

1639
01:59:42,910 --> 01:59:46,510
假定整个可分配的分区是2的u次方

1640
01:59:46,510 --> 01:59:47,890
需要分配的大小

1641
01:59:47,890 --> 01:59:52,030
如果是这个s落在了2的u减1和2的u之间的话

1642
01:59:52,030 --> 01:59:54,530
那么我就会把整个块给分配给它

1643
01:59:55,210 --> 01:59:59,530
就是意味着如果分配 它提的需求是size 9

1644
02:00:00,230 --> 02:00:02,830
那我还是一样把16分配给它

1645
02:00:02,830 --> 02:00:06,490
它会去使用

1646
02:00:06,490 --> 02:00:08,530
但是我们已经说过了

1647
02:00:08,530 --> 02:00:09,290
对我们英王而言

1648
02:00:09,290 --> 02:00:11,130
我们要求它就是按照20U4的分配

1649
02:00:11,130 --> 02:00:14,250
所以它一定也是按照这个1 2 4 8 16

1650
02:00:14,250 --> 02:00:17,750
这么size的分配 所以它这样分配

1651
02:00:17,750 --> 02:00:18,790
加这个约数之后

1652
02:00:18,790 --> 02:00:21,350
我们就不会产生外水片

1653
02:00:22,330 --> 02:00:23,710
这是分配的效果

1654
02:00:24,610 --> 02:00:27,290
但是如果说这一层满足不了

1655
02:00:27,290 --> 02:00:28,930
比如说这三层满足不了的话

1656
02:00:28,930 --> 02:00:30,370
它会降接

1657
02:00:30,370 --> 02:00:35,370
就是看这个S是否能够把这个S拆成

1658
02:00:35,370 --> 02:00:37,670
就是把这个整个

1659
02:00:37,670 --> 02:00:39,790
这个老师有这么一个东西

1660
02:00:39,790 --> 02:00:42,270
如果S小于就是升级这个S

1661
02:00:42,270 --> 02:00:44,670
小于等于2的i减1的话

1662
02:00:44,670 --> 02:00:50,310
那么会把大小为i的当前空间划分成两个

1663
02:00:50,310 --> 02:00:51,470
这证明一个拆分

1664
02:00:51,470 --> 02:00:52,450
什么意思呢

1665
02:00:52,450 --> 02:01:00,330
比如说,我现在想要分配的是4这么一个空间块

1666
02:01:00,690 --> 02:01:04,110
但现在我有一个更大的空间块,没有16,我有8

1667
02:01:04,110 --> 02:01:07,410
我有8的空间块,那我把8的空间块拆成两块

1668
02:01:07,410 --> 02:01:13,190
3和4,这个4还留着,把3对应的那4块分配出去

1669
02:01:13,190 --> 02:01:18,270
我现在做了一个拆分,然后可以逐步的往下走

1670
02:01:18,270 --> 02:01:22,250
可以完成最小力度的一个拆分,从而把空间块分配出去

1671
02:01:22,250 --> 02:01:28,810
当然,如果你这个最小力度全都分配完了,那它是没办法的,但只要有一个空

1672
02:01:28,810 --> 02:01:35,970
间框我可以分配出去,这是它的一个大致的一个逐步拆分向下分配内存的

1673
02:01:35,970 --> 02:01:37,930
方式,怎么去拆分也讲到了。

1674
02:01:38,570 --> 02:01:44,090
数据结构就这么一个二维数组,或者是一个一维数组加一个链表,这两种

1675
02:01:44,090 --> 02:01:46,630
结构能把这个空闲空间给组织起来。

1676
02:01:46,630 --> 02:01:50,030
分配过程是由小到大地在扣员号中找最小可用块

1677
02:01:50,030 --> 02:01:54,190
如果扣员号过大 则对可用空闲块进行

1678
02:01:54,950 --> 02:02:00,330
这个没显示完 进行切分 变成一半来进行划分

1679
02:02:00,330 --> 02:02:01,950
这是它一个大致的分配过程

1680
02:02:03,270 --> 02:02:04,390
这举了个例子

1681
02:02:09,030 --> 02:02:11,670
我一开始的初始块是一兆大小

1682
02:02:12,430 --> 02:02:17,950
这时候我发的请求是分配100k或者离级有128k

1683
02:02:17,950 --> 02:02:19,270
那怎么办呢

1684
02:02:19,270 --> 02:02:23,870
我会把一兆拆成两块512k和两个512k

1685
02:02:23,870 --> 02:02:25,690
但是还依然比这100k大很多

1686
02:02:26,130 --> 02:02:29,510
然后把其中的512k再拆成256k还是大

1687
02:02:29,510 --> 02:02:33,190
再把256k拆成两个128k

1688
02:02:33,190 --> 02:02:37,010
这个时候这个100是在64和128之间

1689
02:02:37,010 --> 02:02:39,110
它就会把这个请求给分配出去

1690
02:02:39,110 --> 02:02:40,870
那这时候困境框变成这三个了

1691
02:02:41,370 --> 02:02:44,810
削除于这边三个了,分别属于三个不同size的空间块

1692
02:02:49,050 --> 02:02:51,830
接下来如果再请求240K的时候

1693
02:02:52,250 --> 02:02:57,210
因为你在这里面有正好在128K和250K之间的一个空间块

1694
02:02:57,210 --> 02:02:59,030
所以会把这个空间块来分配出去

1695
02:02:59,030 --> 02:03:01,270
给240整个分配出去

1696
02:03:01,810 --> 02:03:02,970
如果要分配64的话

1697
02:03:03,650 --> 02:03:07,790
那么它会查找这个128K的隐秘分寸

1698
02:03:07,790 --> 02:03:09,870
还有一个空闲的128K

1699
02:03:09,870 --> 02:03:12,230
但是比64K要正好要大

1700
02:03:12,230 --> 02:03:13,910
所以它会把这个拆成两块

1701
02:03:14,510 --> 02:03:16,530
然后这个122K就变成64K

1702
02:03:16,530 --> 02:03:19,190
然后把这个64K分配给它

1703
02:03:19,930 --> 02:03:22,030
如果要分配256K

1704
02:03:22,590 --> 02:03:25,190
那你现在这个空闲的64K是不够的

1705
02:03:25,190 --> 02:03:27,170
但是我们直接查

1706
02:03:27,170 --> 02:03:29,170
查256K size的这个空闲块

1707
02:03:29,170 --> 02:03:31,010
没有 我们往上走

1708
02:03:31,010 --> 02:03:32,390
找到个512K

1709
02:03:32,930 --> 02:03:35,510
512K能够满足256K的需求

1710
02:03:35,510 --> 02:03:38,110
但是我可以把512K拆成两块

1711
02:03:38,110 --> 02:03:39,490
这一块是空闲的

1712
02:03:39,490 --> 02:03:40,690
这一块可以分配出去

1713
02:03:40,690 --> 02:03:42,810
到这个情况之后呢

1714
02:03:42,810 --> 02:03:44,750
你会发现它有两个空间块

1715
02:03:44,750 --> 02:03:45,990
一个是size-564的

1716
02:03:45,990 --> 02:03:47,490
一个size-256的

1717
02:03:47,490 --> 02:03:48,710
这是它的一个

1718
02:03:48,710 --> 02:03:51,030
一直在连续进行申请之后

1719
02:03:51,030 --> 02:03:52,910
产生的一个现状

1720
02:03:52,910 --> 02:03:54,810
那么release

1721
02:03:54,810 --> 02:03:56,350
我们这时候录release-b

1722
02:03:56,350 --> 02:03:58,990
release-b就是把这个

1723
02:03:58,990 --> 02:03:59,790
把这一块

1724
02:03:59,790 --> 02:04:01,590
这个区域的这个size给释放掉

1725
02:04:01,590 --> 02:04:05,310
那么你相信是把这个256给回收了

1726
02:04:05,310 --> 02:04:07,270
把这一块给回收了

1727
02:04:07,270 --> 02:04:08,430
回收完之后需要注意

1728
02:04:08,430 --> 02:04:12,770
虽然它和64K Free这个框是连接的

1729
02:04:12,770 --> 02:04:14,950
但它们是不同Size的

1730
02:04:14,950 --> 02:04:17,430
我们要合并是基于相同Size

1731
02:04:17,430 --> 02:04:21,750
且是在一个大框之下的两个Size才能合并

1732
02:04:21,750 --> 02:04:23,590
所以这里面 虽然它们连接

1733
02:04:23,590 --> 02:04:26,170
它也不会有合并操作 需要注意

1734
02:04:26,170 --> 02:04:27,410
Release A

1735
02:04:27,410 --> 02:04:29,630
A是哪儿 是128在这儿

1736
02:04:29,630 --> 02:04:30,510
它本来也没有连接

1737
02:04:30,510 --> 02:04:32,550
所以它还是一个独立的框

1738
02:04:32,550 --> 02:04:35,370
但是这里面它有64、128、256

1739
02:04:35,370 --> 02:04:36,490
256有两个框

1740
02:04:36,490 --> 02:04:40,090
这是一个大致的一个空闲跨的情况

1741
02:04:40,090 --> 02:04:41,990
再接下来request75的时候

1742
02:04:42,430 --> 02:04:46,790
它又会把这个128K给分配掉

1743
02:04:47,310 --> 02:04:51,470
然后做什么releaseC把64K给release掉

1744
02:04:51,470 --> 02:04:54,030
这里面就需要注意在release64K的时候

1745
02:04:55,230 --> 02:04:58,670
这两个64K是属于同一个128K

1746
02:04:58,670 --> 02:05:01,950
所以它会把这两个64K

1747
02:05:01,950 --> 02:05:04,510
空闲64K合并成一个128K

1748
02:05:04,510 --> 02:05:10,790
OK,由于这个还分配出去了,这128K和这个256K不能合并

1749
02:05:11,410 --> 02:05:16,530
只有在什么时候呢?只有在把这个也给释放掉之后

1750
02:05:16,530 --> 02:05:22,250
把这个也给释放掉之后,那么它有可能把这个128K和这个128K合并

1751
02:05:22,250 --> 02:05:23,550
成256K

1752
02:05:23,550 --> 02:05:27,610
然后再把两个256K再合并成52K,这才会合并

1753
02:05:27,610 --> 02:05:31,530
如果把这个也再释放掉的话,整个就会恢复到原状

1754
02:05:31,530 --> 02:05:33,270
这是它一个大致的处理过程

1755
02:06:03,270 --> 02:06:07,890
好 重点关注的是就是释放的合并条件需要注意

1756
02:06:08,370 --> 02:06:11,270
好 这个我就把Body System讲完了

1757
02:06:11,270 --> 02:06:15,590
这个Body System是我们很多实际的OS中

1758
02:06:15,590 --> 02:06:19,610
或者实际的库中会用到的一种针对固定size

1759
02:06:19,610 --> 02:06:24,810
就是门次房这种固定size的一个类型分配的一种有效的算法

1760
02:06:24,810 --> 02:06:28,430
在像Linux 像Windows

1761
02:06:28,430 --> 02:06:30,030
至少Linux我知道是它的内核

1762
02:06:30,030 --> 02:06:32,130
Windows没看过原代码 所以不太了解

1763
02:06:32,130 --> 02:06:35,430
零零四元大量是由巴黎深圳來完成基於一頁的

1764
02:06:36,270 --> 02:06:40,550
這個二的N次方size分配的一個代碼

1765
02:06:40,550 --> 02:06:43,530
它裡面的巴黎深圳可能會更靈活一點

1766
02:06:43,530 --> 02:06:46,490
它可能還有一些在二的

1767
02:06:46,490 --> 02:06:49,410
比如二的四和二的五之間的一些size

1768
02:06:49,410 --> 02:06:51,570
一些分配的一些

1769
02:06:51,570 --> 02:06:53,170
做了一些擴展吧 可以這麼來理解

1770
02:06:53,170 --> 02:06:55,750
這是它的一個巴黎深圳的做法

1771
02:06:55,750 --> 02:06:58,550
那我們其實還沒有講更實際的

1772
02:06:58,550 --> 02:07:01,470
比如說就是有些小的size

1773
02:07:01,470 --> 02:07:06,630
比如说我们在4K以内,它可能是一次分个512字节,或者一次分个108字

1774
02:07:06,630 --> 02:07:08,750
节,或者是270字节。

1775
02:07:08,850 --> 02:07:15,590
这种小size的内存分配,有没有更高效的算法呢?有,只是我们由于课程

1776
02:07:15,590 --> 02:07:16,690
时间问题我们并没有讲。

1777
02:07:16,950 --> 02:07:21,170
比如说,我只给大家列个名字,大家有兴趣的时候可以看一下slab。

1778
02:07:22,010 --> 02:07:28,790
这个slab算法就是一种针对小的不定size的一个调度算法跟内存分

1779
02:07:28,790 --> 02:07:30,290
配算法的一个体现。

1780
02:08:30,850 --> 02:08:32,670
内核看到的是连续的

1781
02:08:32,670 --> 02:08:34,690
我们的应用看到的是连续地址空间

1782
02:08:34,690 --> 02:08:38,910
这样我们可以轻松地解决内存分配的碎片问题

1783
02:08:38,910 --> 02:08:41,730
大家觉得奇怪是怎么就解决内存碎片问题了

1784
02:08:43,750 --> 02:08:48,630
这两块比如这两个黄的隔着的

1785
02:08:49,130 --> 02:08:51,010
这段情况下我们要分配一个

1786
02:08:52,030 --> 02:08:53,610
如果说我这个黄的这个区域

1787
02:08:53,610 --> 02:08:56,050
这个进程我要分配一个8K的size的话

1788
02:08:56,630 --> 02:08:57,230
我满足不了

1789
02:08:57,230 --> 02:08:59,750
因为它不连续 是吧

1790
02:08:59,750 --> 02:09:05,010
但是我通过页表,把这两个物理地址不连续的两个页,通过页表

1791
02:09:05,010 --> 02:09:10,430
变成了连续的两个虚拟页,它就连续了,就可以使用,这样就可以解决碎片

1792
02:09:10,430 --> 02:09:10,830
问题。

1793
02:09:11,130 --> 02:09:17,950
这是基本的一个解释,我想大家应该能够理解。所以,非连续类质分配是对连

1794
02:09:17,950 --> 02:09:23,090
续类质分配的一个支持和补充,它们之间不是一个替换关系。

1795
02:09:32,310 --> 02:09:35,910
这就会带来另一个问题是当有了这个业表机制之后

1796
02:09:36,650 --> 02:09:40,110
我们的应用程序当发出内存请求的时候

1797
02:09:40,570 --> 02:09:43,510
是不是每一次内存请求都要通过我们OIS来进行支持呢

1798
02:09:43,510 --> 02:09:45,230
不是 我们还有一个库

1799
02:09:45,230 --> 02:09:48,530
我们还有一个库来帮助我们来进行管理

1800
02:09:48,530 --> 02:09:53,730
我们的库它真正需要内存的时候

1801
02:09:53,730 --> 02:09:55,450
它会向我们OIS发出请求

1802
02:09:56,750 --> 02:09:59,430
但是为了能够减少应用程序

1803
02:09:59,430 --> 02:10:01,890
和内核之间的上海门切换

1804
02:10:02,470 --> 02:10:04,310
就是特定机切换的话

1805
02:10:04,310 --> 02:10:05,510
那我们通常来说

1806
02:10:05,510 --> 02:10:07,050
我们是一个基本思路是说

1807
02:10:07,050 --> 02:10:09,990
我们的库一次性向内存申请一块大内存

1808
02:10:09,990 --> 02:10:11,650
像超级种申请一块大内存

1809
02:10:11,650 --> 02:10:13,710
然后我们的应用程序

1810
02:10:13,710 --> 02:10:16,550
每次从我们的库里面申请小内存就行了

1811
02:10:16,550 --> 02:10:18,530
所以你会看到以Glibc

1812
02:10:18,530 --> 02:10:19,990
比如说我们Linux的那个

1813
02:10:19,990 --> 02:10:22,570
Glibc标准的那个Libc库为例

1814
02:10:22,570 --> 02:10:25,870
它一次向内存申请是64兆内存

1815
02:10:25,870 --> 02:10:27,850
它如果再不够了

1816
02:10:27,850 --> 02:10:29,490
它就可以再分配128兆

1817
02:10:29,490 --> 02:10:31,210
找我们OS去申请

1818
02:10:31,210 --> 02:10:32,450
当然OS是有求必应

1819
02:10:32,450 --> 02:10:33,990
你申请多少我给你多少

1820
02:10:33,990 --> 02:10:35,590
但那个是真给假给

1821
02:10:35,590 --> 02:10:36,470
那是取决于超级的

1822
02:10:37,050 --> 02:10:38,490
我们说虚的

1823
02:10:38,850 --> 02:10:40,210
但是给了之后

1824
02:10:40,210 --> 02:10:41,510
我们的应用程序就可以

1825
02:10:41,510 --> 02:10:43,370
在我们酷的帮助之下

1826
02:10:44,310 --> 02:10:45,950
来基于连续内存

1827
02:10:45,950 --> 02:10:47,950
进行内存的申请和释放

1828
02:10:47,950 --> 02:10:49,090
就连麦克和福瑞

1829
02:10:49,090 --> 02:10:50,090
得到都是连续的

1830
02:10:51,890 --> 02:10:53,650
这是大致处理方式

1831
02:10:53,650 --> 02:10:56,790
所以你要看到酷的管理

1832
02:10:56,790 --> 02:10:59,090
我们通常应用程序酷的管理

1833
02:10:59,750 --> 02:11:01,990
它是一个连续内存分配的管理

1834
02:11:01,990 --> 02:11:04,090
我们的OS为了支持它

1835
02:11:04,090 --> 02:11:06,790
在底下会把它不连续的

1836
02:11:06,790 --> 02:11:11,630
给它提供一个大的地址空间

1837
02:11:11,630 --> 02:11:13,170
这个虚储地址空间

1838
02:11:13,170 --> 02:11:17,350
然后管的是把不连续的物理空间管起来

1839
02:11:17,350 --> 02:11:19,550
提供一个连续的给它去使用

1840
02:11:19,550 --> 02:11:22,110
那靠的是什麼?靠的是我們硬件提供的頁表機制

1841
02:11:29,950 --> 02:11:33,730
那麼能不能用軟件實現這個虛實地址轉換

1842
02:11:33,730 --> 02:11:34,470
大家想想

1843
02:11:39,530 --> 02:11:40,650
對沒錯可以

1844
02:11:41,510 --> 02:11:43,270
那為什麼要用硬件實現

1845
02:11:43,270 --> 02:11:44,350
效率

1846
02:11:44,350 --> 02:11:45,930
硬件就效率高嘛

1847
02:11:46,610 --> 02:11:47,890
那麼硬件實現

1848
02:12:18,590 --> 02:12:20,210
每个段的一个描述

1849
02:12:20,610 --> 02:12:22,090
然后有一个机子有一个长度

1850
02:12:22,090 --> 02:12:23,930
映射到代码段或者数据段

1851
02:12:23,930 --> 02:12:24,630
然后check

1852
02:12:24,630 --> 02:12:27,190
它会有一个在MMU做一个check

1853
02:12:27,190 --> 02:12:28,910
来判断你是否这个

1854
02:12:28,910 --> 02:12:30,890
对段的访问是否越界

1855
02:12:30,890 --> 02:12:32,410
是否符合相应特遣级

1856
02:12:32,410 --> 02:12:34,530
那么这些操作呢

1857
02:12:34,530 --> 02:12:35,970
都是当你访问一个

1858
02:12:36,490 --> 02:12:37,830
基于段的一个地址的时候

1859
02:12:37,830 --> 02:12:39,510
我们的硬件会做个检查

1860
02:12:39,510 --> 02:12:40,970
那么我们的OS要干什么事情呢

1861
02:12:40,970 --> 02:12:42,990
OS要把这一块段表给建好

1862
02:12:43,970 --> 02:12:45,610
这是在内核中央去管理的事情

1863
02:12:45,610 --> 02:12:46,850
就是被内核管理

1864
02:12:46,850 --> 02:12:52,970
那么断表和我们的任务和进程是有一个对应关系的

1865
02:12:52,970 --> 02:12:54,810
在这个断表里面,如果断表特别大的话

1866
02:12:54,810 --> 02:12:57,190
可以放多个任务的断信息

1867
02:12:57,190 --> 02:12:59,250
如果断表小的话,那么一个任务就有一个

1868
02:12:59,770 --> 02:13:01,290
这是取决于断表的设计

1869
02:13:01,290 --> 02:13:03,150
那么这种断表机制呢

1870
02:13:03,150 --> 02:13:05,230
在我们的查白录里面还是存在的

1871
02:13:05,230 --> 02:13:08,850
在我们现在的RMIPS和Risk5里面是没有的

1872
02:13:10,270 --> 02:13:12,850
是这一块,断表

1873
02:13:12,850 --> 02:13:16,730
第二个 页 页也是有个区分

1874
02:13:16,730 --> 02:13:18,790
你要理解物理上的那个按页来划分

1875
02:13:18,790 --> 02:13:21,090
把那个叫做页针 或者叫物理页针

1876
02:13:21,790 --> 02:13:23,590
physical page frame

1877
02:13:23,970 --> 02:13:26,150
那么虚拟的页叫virtual page frame

1878
02:13:26,150 --> 02:13:27,910
virtual page 或者叫page

1879
02:13:27,910 --> 02:13:29,310
简称page就是页

1880
02:13:29,310 --> 02:13:31,530
这是虚拟的页 或者叫逻辑页

1881
02:13:31,530 --> 02:13:34,230
那我们要干的事情就是要完成这个转换

1882
02:13:34,230 --> 02:13:37,090
逻辑页的地址到虚拟页地址的转换

1883
02:13:37,090 --> 02:13:38,030
这次要靠什么

1884
02:13:38,030 --> 02:13:40,750
靠我们硬件机制来帮助我们搞定

1885
02:13:41,170 --> 02:13:47,670
有个页表,以及为了能够加速它执行的TOB

1886
02:13:47,670 --> 02:13:53,050
这个是一个控制单元,明明是控制单元

1887
02:13:53,050 --> 02:13:55,750
内存管理单元,简称是内存管理单元

1888
02:13:59,110 --> 02:14:02,830
看这个页表和我们刚才说的断表很多类似的地方

1889
02:14:03,430 --> 02:14:06,810
它有一个这么一个结构

1890
02:14:06,810 --> 02:14:09,750
这个结构里面,它的页号是它的index

1891
02:14:10,370 --> 02:14:13,590
业号在哪呢 就是你把整个业分成了两段

1892
02:14:13,590 --> 02:14:17,030
一个是业号 一个是业类的偏移

1893
02:14:17,030 --> 02:14:19,650
那么这业号会作为index查这个业表

1894
02:14:19,650 --> 02:14:22,450
找到对应的物理业真号

1895
02:14:22,450 --> 02:14:25,530
然后物理业真号再和我们刚才的offset合在一起

1896
02:14:25,530 --> 02:14:27,810
形成一个物理地址 这是它的一个转型过程

1897
02:14:27,810 --> 02:14:30,890
所以它这个查找是在这里面查业表

1898
02:14:31,830 --> 02:14:35,390
是硬件来完成的 但是业表内容的构建

1899
02:14:35,390 --> 02:14:38,590
是os来完成的 这个也是需要注意

1900
02:14:38,590 --> 02:14:43,830
而且也是一样 我们要给不同的应用

1901
02:14:43,830 --> 02:14:46,010
提供相同的虚拟地址空间

1902
02:14:46,010 --> 02:14:47,130
几乎相同的虚拟地址空间

1903
02:14:47,450 --> 02:14:51,370
所以你会发现页表和任务也是一一对应的

1904
02:14:51,370 --> 02:14:53,790
可以说一个任务或者一个进程就有一个页表

1905
02:14:53,790 --> 02:14:55,110
这是一个结构

1906
02:14:58,010 --> 02:15:00,610
这是概念上大家都应该很容易理解

1907
02:15:00,610 --> 02:15:01,850
那页表性能问题

1908
02:15:01,850 --> 02:15:03,370
页表无与暖的 页表很大

1909
02:15:03,370 --> 02:15:05,650
不与内存中 它放不了CPU里面

1910
02:15:05,650 --> 02:15:07,450
这个内存就会涉及到读页表

1911
02:15:07,450 --> 02:15:08,910
这样才能够访问到数据的一个问题

1912
02:15:08,910 --> 02:15:10,710
所以它这个性能是一个问题

1913
02:15:10,710 --> 02:15:14,870
第二个呢 业表如果按照刚才这种建立方式的话

1914
02:15:14,870 --> 02:15:16,970
内存的业表容量也很大

1915
02:15:16,970 --> 02:15:20,190
我们需要减少业表本身占的这个容量

1916
02:15:20,190 --> 02:15:21,730
当然 这是一道题

1917
02:15:21,730 --> 02:15:25,910
64位机器如果每一1024级的一个单级业表

1918
02:15:25,910 --> 02:15:27,990
会要耗多大的空间

1919
02:15:27,990 --> 02:15:29,850
这个大家应该能够计算

1920
02:15:31,810 --> 02:15:33,550
解决性能问题怎么做

1921
02:15:33,550 --> 02:15:36,250
缓存 通常我们说加一层

1922
02:15:36,250 --> 02:15:37,450
当解决不了一个问题的时候

1923
02:15:37,450 --> 02:15:38,730
加一层的问题它解决了

1924
02:15:38,730 --> 02:15:40,210
这加一层什么 加一层缓存

1925
02:15:40,210 --> 02:15:41,870
就间接的来访问

1926
02:15:41,870 --> 02:15:43,510
所以你看到这里面

1927
02:15:43,510 --> 02:15:46,610
我们有一个TOB来缓存页表内容

1928
02:15:46,610 --> 02:15:48,530
有catch来缓存数据内容

1929
02:15:48,530 --> 02:15:50,310
通过这两点来提升我们的性能

1930
02:15:50,310 --> 02:15:52,830
使得大部分的对数据的访问

1931
02:15:52,830 --> 02:15:55,070
对类型数据访问集中在CPU内就完成了

1932
02:15:55,070 --> 02:15:57,610
这是我们说的这个性能的解决方式

1933
02:15:58,710 --> 02:15:59,610
但是需要注意

1934
02:15:59,610 --> 02:16:01,210
我们OS关注什么呢

1935
02:16:01,210 --> 02:16:10,490
关注的是 这两个之间这里面放了个页表

1936
02:16:10,490 --> 02:16:14,410
page table 这两个之间的数据是否一致的问题

1937
02:16:15,190 --> 02:16:17,670
这个需要注意 如果不一致

1938
02:16:17,670 --> 02:16:19,750
我们超级统有义务让它一致

1939
02:16:19,750 --> 02:16:21,250
这是你的一个责任

1940
02:16:23,490 --> 02:16:25,170
那么对于容量问题来说

1941
02:16:25,170 --> 02:16:27,810
我们可以把单级页表变成多级页表

1942
02:16:27,810 --> 02:16:31,050
通过多级页表来减少开销

1943
02:16:32,110 --> 02:16:35,270
它把所有的虚实地址转换都要囤下来

1944
02:16:35,270 --> 02:16:36,730
所以单界表会比较大

1945
02:16:36,730 --> 02:16:38,230
但是多级业表的话

1946
02:16:38,230 --> 02:16:43,590
有些没有用到的那些虚实地址转换的业表内容

1947
02:16:43,590 --> 02:16:44,550
我就可以不需要转换

1948
02:16:44,550 --> 02:16:45,990
所以通过多级业表

1949
02:16:45,990 --> 02:16:47,290
有效地可以解决容量问题

1950
02:16:47,290 --> 02:16:48,220
这是一种方法

1951
02:16:49,330 --> 02:16:50,210
多级业表

1952
02:16:52,950 --> 02:16:54,610
但是多级业表也一样

1953
02:16:54,610 --> 02:16:59,750
它减少了业表的size

1954
02:16:59,750 --> 02:17:05,490
提高了所谓的整个页表的可以支持的数量

1955
02:17:06,010 --> 02:17:09,850
但是带来的空间优化 但你的时间更慢

1956
02:17:09,850 --> 02:17:12,030
因为你要查多次页表项

1957
02:17:12,030 --> 02:17:13,330
每次页表项都是内存房

1958
02:17:13,330 --> 02:17:17,030
这个问题一样是靠TOB来帮助缓存来解决的

1959
02:17:19,770 --> 02:17:23,170
还有一种比较少见的方式解决容量问题

1960
02:17:23,170 --> 02:17:24,770
它反其道而行之

1961
02:17:24,770 --> 02:17:26,250
就是我们前面是说

1962
02:17:26,250 --> 02:17:31,750
业表里面是基于虚拟业号作为index来查那个表

1963
02:17:31,750 --> 02:17:32,810
那个表将是一个数组

1964
02:17:32,810 --> 02:17:36,890
数组的index是那个业号 虚拟业号

1965
02:17:37,210 --> 02:17:39,170
那反制业表的意思是反过来

1966
02:17:39,170 --> 02:17:41,970
把物理业号作为index的

1967
02:17:41,970 --> 02:17:45,290
这个反制业表的index来查虚拟的业号

1968
02:17:45,290 --> 02:17:47,570
就基于物理业号查虚拟的业号

1969
02:17:47,570 --> 02:17:50,170
正好到过来 这是属于反制业表

1970
02:17:51,050 --> 02:17:52,610
大家想想我们CPU在访问的时候

1971
02:17:52,610 --> 02:17:53,530
一开始访问是虚例子

1972
02:17:53,530 --> 02:17:54,830
你怎么知道物理的例子

1973
02:17:54,830 --> 02:17:55,250
不知道

1974
02:17:55,690 --> 02:17:58,050
我们本来是想通过页表查找物理地址

1975
02:17:58,690 --> 02:18:01,090
现在你要是基于物理地址来查虚地址

1976
02:18:01,090 --> 02:18:01,710
那怎么来做

1977
02:18:01,710 --> 02:18:04,070
它实际上有一个所谓的哈希利的机制

1978
02:18:04,070 --> 02:18:05,550
硬件哈希利的机制

1979
02:18:05,550 --> 02:18:09,930
来把你的根据你的进程ID或者任务ID

1980
02:18:09,930 --> 02:18:12,950
和页号做一个哈希利计算

1981
02:18:12,950 --> 02:18:14,990
得到什么 得到物理地址

1982
02:18:14,990 --> 02:18:16,230
或者得到 应该不是得到

1983
02:18:16,230 --> 02:18:17,010
因为不叫得到物理地址

1984
02:18:17,010 --> 02:18:20,410
得到反制页表里面的一个index

1985
02:18:21,030 --> 02:18:22,270
然后根据这个index

1986
02:18:22,270 --> 02:18:24,550
来查index所对应的虚地址

1987
02:18:56,430 --> 02:19:01,490
这个页号如果和这个页号是一致的

1988
02:19:01,490 --> 02:19:03,390
那就意味着我找着了

1989
02:19:03,390 --> 02:19:04,870
但很有可能不一致

1990
02:19:04,870 --> 02:19:05,850
假设一致的话

1991
02:19:05,850 --> 02:19:07,930
那么我这个index就会作为这

1992
02:19:07,930 --> 02:19:10,410
把它和offset拼在一起

1993
02:19:10,410 --> 02:19:11,370
新出来的物理地址

1994
02:19:11,370 --> 02:19:13,770
这是理想情况

1995
02:19:14,610 --> 02:19:15,830
那还有不理想情况

1996
02:19:17,450 --> 02:19:18,250
糟糕

1997
02:19:18,250 --> 02:19:19,510
找不到了

1998
02:19:39,210 --> 02:19:48,850
也可能找不准,比如说你这里面PID是0,VPN是1,这是PID是0,VPN是1,

1999
02:19:49,010 --> 02:19:54,530
算了一下哈希之后呢,得到的一个值是0,得到的值是0,然后查这个硬

2000
02:19:54,530 --> 02:19:54,530
带是0,这个硬带是1,这个硬带是2,这个硬带是3,这个硬带是4,这个硬

2001
02:19:54,530 --> 02:19:54,530
带是5,这个硬带是6,这个硬带是7,这个硬带是8,这个硬带是9,这个硬

2002
02:19:54,530 --> 02:19:54,530
带是10,这个硬带是11,这个硬带是12,这个硬带是13,这个硬带是14,这个硬

2003
02:19:54,530 --> 02:19:54,530
带是14,这个硬带是15,这个硬带是15,这个硬带是16,这个硬带是17,这个硬

2004
02:19:54,530 --> 02:19:54,530
带是

2005
02:20:24,670 --> 02:20:28,910
和pid为0的vpn为1的这么一个需要号

2006
02:20:28,910 --> 02:20:31,130
它们今天是同一个哈希值

2007
02:20:31,130 --> 02:20:32,370
所以它就算出来了

2008
02:20:32,370 --> 02:20:33,290
那没关系

2009
02:20:33,290 --> 02:20:35,450
这是一个哈希通速的解决方案

2010
02:20:35,450 --> 02:20:39,170
我会查这个next 0x18f1b

2011
02:20:39,170 --> 02:20:40,130
查这了

2012
02:20:40,130 --> 02:20:45,650
我看这里面有一个查的

2013
02:20:45,650 --> 02:20:45,950
我也是

2014
02:20:47,050 --> 02:20:49,230
我怎么老跑这了

2015
02:20:58,210 --> 02:21:05,050
018f1b会找到这个反制页表的另一个index就是在这

2016
02:21:05,050 --> 02:21:06,570
找到这个页表之后就查

2017
02:21:06,570 --> 02:21:10,690
发现这里面存的这个pid和这个vpn是0和1

2018
02:21:10,690 --> 02:21:11,670
就找到了

2019
02:21:11,670 --> 02:21:15,270
这实际上就是一个哈希冲突链的一个解决方案

2020
02:21:15,270 --> 02:21:17,950
这是它的原理上来说

2021
02:21:17,950 --> 02:21:20,710
我们怎么能通过反制页表来解决哈希冲突问题

2022
02:21:21,230 --> 02:21:26,270
这种方式,反制业表的方式在现在的物理意见上用的很少

2023
02:21:26,270 --> 02:21:29,270
我们已知的就是PowerPC这种处理器

2024
02:21:29,270 --> 02:21:33,710
64位PowerPC,IBM那个PowerPC有这种设计方式

2025
02:21:35,230 --> 02:21:39,530
OK,这是它的一个大致的处理过程

2026
02:21:39,530 --> 02:21:49,150
最后再小节一下就是我们的段式和页式有各自的特点

2027
02:21:49,150 --> 02:21:53,950
但是由于这个夜市相对来说更适合我们的系统进行管理

2028
02:21:53,950 --> 02:21:55,970
所以我们现在看到夜市用的比较多

2029
02:21:55,970 --> 02:22:00,190
但是段式和夜市有它各自存在的一些位置

2030
02:22:00,190 --> 02:22:02,710
而且我们可以看着在x86里面

2031
02:22:02,710 --> 02:22:04,370
它可以把段表和夜表合在一起

2032
02:22:04,370 --> 02:22:08,710
这段夜市也一样可以实现更加灵活复杂的

2033
02:22:08,710 --> 02:22:10,570
这种灵活体验在复杂性上

2034
02:22:10,570 --> 02:22:13,150
灵活复杂的一种存储管理方式

2035
02:22:14,450 --> 02:22:16,750
OK 这种方式目前我看到的就是x86

2036
02:22:18,610 --> 02:22:25,250
好 最后 这一节最后 我会还有两分钟给大家讲个例子

2037
02:22:25,250 --> 02:22:29,010
APP调Malloc 这是大家写的小程序 C程序

2038
02:22:29,010 --> 02:22:34,970
调了个Malloc 申请了一个size的一个数据框

2039
02:22:34,970 --> 02:22:38,190
然后它应该返回一个指针 然后对指针进行相应的操作

2040
02:22:38,190 --> 02:22:40,870
这是它大致的一个逻辑 这我不写英文谁这么写

2041
02:22:40,870 --> 02:22:43,770
那结合我们刚才讲的内容 怎么来体现它的一个执行过程

2042
02:22:45,490 --> 02:22:47,750
我们讲的是 OS 要把这个程序加起来

2043
02:22:47,750 --> 02:22:49,930
这是我们站在系统角要说第一步

2044
02:22:49,930 --> 02:22:51,490
要把程序加起来

2045
02:22:51,490 --> 02:22:53,050
然后你当掉 MATLAB 的时候

2046
02:22:53,050 --> 02:22:55,650
它会知道是在这个地方 在 HIP 这个区域

2047
02:22:55,650 --> 02:22:57,470
HIP 这个区域已经分配 这是一个

2048
02:22:57,470 --> 02:23:00,390
第二个 当掉 MATLAB 完之后呢

2049
02:23:00,390 --> 02:23:01,550
MATLAB 掉了谁

2050
02:23:01,550 --> 02:23:04,710
第二个是这个

2051
02:23:04,710 --> 02:23:07,030
是这个函数 我们说的

2052
02:23:07,030 --> 02:23:09,110
Lib 用过它的 Lib 库这个函数

2053
02:23:09,110 --> 02:23:10,510
它里面会有一套管理

2054
02:23:10,510 --> 02:23:13,290
在这个管理里面 它是一个连续地址空间的管理

2055
02:23:13,290 --> 02:23:16,650
需要注意这个虚的地址空间是谁来建的呢

2056
02:23:16,650 --> 02:23:18,610
是由我们的OS来帮助建的

2057
02:23:18,610 --> 02:23:19,430
OS帮助建的

2058
02:23:19,870 --> 02:23:22,990
所以OS会帮助我们

2059
02:23:22,990 --> 02:23:25,130
首先要把这个虚的地址空间建好

2060
02:23:25,130 --> 02:23:26,290
这个虚的地址空间建好

2061
02:23:26,870 --> 02:23:28,010
这个地址空间建好

2062
02:23:28,010 --> 02:23:29,050
建好之后

2063
02:23:29,050 --> 02:23:34,650
在这里面让我们的库能够基于堆来进行申请和释放

2064
02:23:34,650 --> 02:23:37,850
而这个堆的这一块区域大的区域

2065
02:23:37,850 --> 02:23:42,630
是由我们的OS通过比如说SYS、SBRK

2066
02:23:42,630 --> 02:23:45,050
我们说这种系统表达分别一块大的空间

2067
02:23:45,050 --> 02:23:48,750
然后MineLog这个函数所对应的那个Lib库

2068
02:23:48,750 --> 02:23:51,410
会对于这个大的空间做一个更细致的优化力

2069
02:23:51,410 --> 02:23:54,550
来满足我们的MineLog3的一个实现

2070
02:23:55,730 --> 02:23:58,010
这是我一下把好几步讲完了

2071
02:23:58,010 --> 02:23:59,330
这是第一步

2072
02:23:59,330 --> 02:24:00,710
第二步是啥

2073
02:24:00,710 --> 02:24:02,770
第二步就是程序发出MineLog

2074
02:24:02,770 --> 02:24:05,050
其实是找的LibC

2075
02:24:05,050 --> 02:24:07,570
Lib库它来完成这个MineLog的响应

2076
02:24:07,990 --> 02:24:10,050
那么它会找一块区域

2077
02:24:10,050 --> 02:24:12,390
这块区域如果有的话

2078
02:24:12,390 --> 02:24:13,690
那我直接分配给它就完了

2079
02:24:13,690 --> 02:24:15,330
相对你这个白的是空闲的

2080
02:24:15,330 --> 02:24:18,470
但如果满了没有怎么办

2081
02:24:18,470 --> 02:24:20,870
通过SPRK找我们OS分配一块区域

2082
02:24:22,010 --> 02:24:22,730
就这块区域

2083
02:24:22,730 --> 02:24:24,810
这块区域然后给到之后

2084
02:24:24,810 --> 02:24:26,890
再去得到相应的一个处理

2085
02:24:27,750 --> 02:24:29,010
OK 这就两步吧

2086
02:24:29,970 --> 02:24:32,150
好 讲完了 下课

2087
02:24:37,570 --> 02:24:38,980
多謝

