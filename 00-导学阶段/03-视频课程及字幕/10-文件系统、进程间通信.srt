1
00:01:21,080 --> 00:01:29,460
如果能听到 麻烦某位同学能够在聊天区里面回一下

2
00:01:29,460 --> 00:01:29,980
这样我去听一下

3
00:01:29,980 --> 00:01:33,060
我确保大家能听见我说话

4
00:01:33,060 --> 00:01:35,600
OK,好,谢谢

5
00:01:35,600 --> 00:01:38,480
现在我为了节省带宽

6
00:01:38,480 --> 00:01:40,780
我就看不到同学

7
00:01:40,780 --> 00:01:44,100
是不是我要把我自己打开

8
00:01:44,100 --> 00:01:47,160
看到人了

9
00:01:47,160 --> 00:01:49,400
有没有人呢

10
00:01:49,400 --> 00:01:50,600
OK,好像还有

11
00:01:51,800 --> 00:01:53,820
我看到有人

12
00:01:54,540 --> 00:01:55,580
有人,有人

13
00:01:55,580 --> 00:01:57,320
还搞了个背景

14
00:01:57,320 --> 00:02:00,740
这个背景也体现出像我们上课的样子

15
00:02:00,740 --> 00:02:07,040
那今天我们就开始上课

16
00:02:07,040 --> 00:02:10,220
然后因为咱们现在都变成网课了

17
00:02:10,760 --> 00:02:12,360
所以我看不到同学

18
00:02:12,880 --> 00:02:15,160
那为了能够和同学互动

19
00:02:15,620 --> 00:02:16,440
简单一点

20
00:02:16,440 --> 00:02:17,640
为了简单一点的话

21
00:02:18,220 --> 00:02:21,100
我是希望大家能够通过聊天

22
00:02:21,100 --> 00:02:22,700
咱们就继续同学会议就行了

23
00:02:22,700 --> 00:02:24,340
就通过聊天能够回答一下

24
00:02:24,340 --> 00:02:26,120
文字敲一下就OK了

25
00:02:26,120 --> 00:02:32,020
这样的话,我问一些问题,大家可以在这里面回答,我大致能够扫描一下,能看到大家的

26
00:02:32,020 --> 00:02:36,120
回答情况,我觉得也就算是一种沟通,咱们可以试一试。

27
00:02:38,620 --> 00:02:44,840
好,首先我们简单回顾一下我们上上课讲的内容,上上课就开始讲文件系

28
00:02:44,840 --> 00:02:45,500
统了。

29
00:02:45,640 --> 00:02:50,460
那这个文件系统这一块呢,其实我们是站在几个层面,第一个站在什么用

30
00:02:50,460 --> 00:02:53,340
的层面来讲,就是站在用户的角度来看这个文件系统是什么。

31
00:02:53,720 --> 00:03:03,340
那我们看到的像,这个结构那就是我们通常意义上能够在

32
00:03:04,380 --> 00:03:10,660
我们的Windows或者是Mac或者是你的Linux里面环境看到的内容

33
00:03:10,660 --> 00:03:13,560
但这个内容其实和我们的手机内容不太一样

34
00:03:13,560 --> 00:03:15,700
因为手机做更高层的一个抽象

35
00:03:16,080 --> 00:03:18,780
它可能就不是一种文件目录的结构展现给大家

36
00:03:20,000 --> 00:03:24,900
当然如果同学对安卓或者是IOS比较了解的话

37
00:03:24,900 --> 00:03:27,620
在它内部通过一些系统软件

38
00:03:27,620 --> 00:03:30,220
还是可以看到类似于这样的一个文件系统

39
00:03:30,220 --> 00:03:31,860
在这里面我们看到有什么呢

40
00:03:31,860 --> 00:03:35,080
有目录 有文件

41
00:03:35,080 --> 00:03:38,320
然后还有一些所谓的文件编名

42
00:03:38,320 --> 00:03:42,800
这个也是我们专门强调过有所谓的硬链接和软链接

43
00:03:42,800 --> 00:03:45,580
这个是希望大家能够有了解的

44
00:03:45,580 --> 00:03:51,080
这是我们看到的这个关于文件的一个站在用的角度看到的情况

45
00:03:51,080 --> 00:03:52,020
同时呢

46
00:03:52,020 --> 00:03:56,000
我们其实也看到这个设计实现

47
00:03:56,000 --> 00:03:59,980
在设计实现的就是是从另外一个角度就是从这个

48
00:04:01,340 --> 00:04:04,580
开发的角度就是我怎么去实现这个角度来考虑问题

49
00:04:04,580 --> 00:04:06,160
那从这个角度考虑问题的话

50
00:04:06,160 --> 00:04:08,620
那么确实相对于我们的应用而言

51
00:04:08,620 --> 00:04:11,540
你要设计的细节要多不少

52
00:04:11,540 --> 00:04:14,680
比如说你要知道你这个文件存储在什么地方

53
00:04:14,680 --> 00:04:17,000
那存储在我们的比如说这个这一块

54
00:04:21,280 --> 00:04:23,620
我们说这个磁盘块磁盘块

55
00:04:23,620 --> 00:04:25,720
和我们先SSD等等

56
00:04:25,720 --> 00:04:28,040
这样的话就会涉及到有一个磁盘驱动

57
00:04:28,040 --> 00:04:29,400
当然我们现在还没有讲

58
00:04:29,400 --> 00:04:30,800
磁盘驱动之后呢

59
00:04:30,800 --> 00:04:31,040
还有什么

60
00:04:31,040 --> 00:04:32,460
还有一个类似的一个catch

61
00:04:32,460 --> 00:04:33,800
这里面有一个catch

62
00:04:33,800 --> 00:04:36,000
块的一个设备的缓冲

63
00:04:36,000 --> 00:04:36,860
然后呢

64
00:04:36,860 --> 00:04:37,980
在上面还有文件系统

65
00:04:38,520 --> 00:04:39,380
文件系统的话

66
00:04:39,380 --> 00:04:42,940
再通过我们的应用程序

67
00:04:42,940 --> 00:04:47,840
向文件系统发出的Syscall就这些命令行的程序

68
00:04:47,840 --> 00:04:49,460
这些应用程序发出的Syscall

69
00:04:49,920 --> 00:04:53,840
来访问文件系统来补取所有的这些数据

70
00:04:53,840 --> 00:04:56,180
这些数据最终是存在这上面的

71
00:04:56,180 --> 00:04:59,620
这个你要了解整个这么一个可能的执行过程

72
00:04:59,620 --> 00:05:01,460
而且这里面其实分了两块

73
00:05:01,460 --> 00:05:03,540
一块是整个OSlevel

74
00:05:04,720 --> 00:05:06,240
就是比如说FS

75
00:05:06,240 --> 00:05:09,880
FS在OSlevel去做相应的一些处理

76
00:05:09,880 --> 00:05:11,100
同时你的应用程序呢

77
00:05:11,100 --> 00:05:13,100
应用程序实际上属于一个进程

78
00:05:15,580 --> 00:05:18,380
进程其实是以进程

79
00:05:18,380 --> 00:05:21,060
就是应用程序通过以进程的形式

80
00:05:21,060 --> 00:05:22,900
然后给我们的FS发出请求

81
00:05:22,900 --> 00:05:29,140
FS再给BlockDriver发出请求

82
00:05:29,140 --> 00:05:32,960
把这个数据读入或者写出

83
00:05:32,960 --> 00:05:35,520
大致这么一个过程

84
00:05:35,520 --> 00:05:37,500
那这个过程其实还是比较

85
00:05:37,500 --> 00:05:38,500
层次比较多的

86
00:05:38,500 --> 00:05:42,000
那我们希望我们同学能够对这个有一个初步的了解

87
00:05:42,000 --> 00:05:43,760
这是我们在概念上的了解

88
00:05:43,760 --> 00:05:46,020
只是我们讲这个设计实现

89
00:05:46,020 --> 00:05:47,100
然后在这个

90
00:05:49,780 --> 00:05:50,720
如果有问题

91
00:05:50,720 --> 00:05:54,280
大家可以在这个腾讯会议的聊天里面提

92
00:05:54,280 --> 00:06:00,000
我也能够看到现在我专门开了一个这个在侧面开了一个聊天会议

93
00:06:00,000 --> 00:06:01,860
这样会随时看到大家的一些提问

94
00:06:03,560 --> 00:06:03,960
好

95
00:06:03,960 --> 00:06:06,520
那我们再说这个第三个部分呢

96
00:06:06,520 --> 00:06:09,520
我们讲这个就是高可靠的文件系统

97
00:06:12,440 --> 00:06:13,520
这一块呢

98
00:06:15,360 --> 00:06:18,600
我觉得我们现在其实并没有去实现

99
00:06:18,600 --> 00:06:22,240
更多在原理层面讲这个内容

100
00:06:22,240 --> 00:06:24,520
那这一块主要考虑什么情况呢

101
00:06:24,520 --> 00:06:26,520
主要考虑就是说我们的这个

102
00:06:28,500 --> 00:06:31,640
我们这个文件系统如果出现掉电

103
00:06:31,640 --> 00:06:34,000
或者系统超线出现崩溃的情况下

104
00:06:34,000 --> 00:06:40,940
有可能有些数据是放在内存中,还没有及时写回到这个磁盘上去,这样

105
00:06:40,940 --> 00:06:47,220
就可以导致什么,这里面的一些数据,一些原数据或者是不是原数据的这些所谓

106
00:06:47,220 --> 00:06:53,200
一致性问题会出现一些不一致的现象,这样就可以导致我们后续的这对文

107
00:06:53,200 --> 00:06:57,700
件的操作出现一些各种各样奇怪的问题,甚至导致系统崩溃,这都是有

108
00:06:57,700 --> 00:07:03,520
可能,这是所谓这个叫做崩溃一致性的文件系统,在这里面我们讲了各种

109
00:07:03,520 --> 00:07:03,980
各样的,

110
00:10:37,660 --> 00:10:45,580
嗯,抱歉啊,总算快速恢复,这个说明一点,我们的这个Windows里面的NTFS

111
00:10:45,580 --> 00:10:51,140
是一个高可靠的知识崩溃一致性的文件系统,确实恢复的比较

112
00:10:51,140 --> 00:10:56,420
快,我先共享屏幕。

113
00:11:04,280 --> 00:11:08,480
它能够正确的回到刚才打断的地方

114
00:11:08,480 --> 00:11:10,420
ok 好吧

115
00:11:11,360 --> 00:11:18,420
证明这个Microsoft的这个browser也是支持以外的一些保存的

116
00:11:19,300 --> 00:11:20,420
好 我们继续讲

117
00:11:23,060 --> 00:11:24,430
还差一个没打开

118
00:11:38,900 --> 00:11:39,280
OK

119
00:11:41,320 --> 00:11:42,920
看到这个屏幕

120
00:11:42,920 --> 00:11:46,460
然后我们刚才讲到的就是

121
00:11:46,460 --> 00:11:48,700
随时可以出现这种掉电的系统崩溃情况

122
00:11:51,100 --> 00:11:55,660
我们这里面分析了关于这一块的文件系统

123
00:11:55,660 --> 00:11:58,480
由于这个地方或者这个地方等等

124
00:11:58,480 --> 00:11:59,540
这几个地方

125
00:11:59,540 --> 00:12:03,600
任何几个地方都会出现没有完全写

126
00:12:03,600 --> 00:12:04,440
写到纸盘上的情况

127
00:12:04,440 --> 00:12:06,440
那么就会导致这个不一致

128
00:12:06,440 --> 00:12:08,860
可能有多种情况

129
00:12:08,860 --> 00:12:14,880
我们这里面其实在后面给出了

130
00:12:14,880 --> 00:12:17,020
崩溃场景的多种表示

131
00:12:18,480 --> 00:12:22,960
以及在后面我们看到在后面的集中解决办法

132
00:12:22,960 --> 00:12:27,020
包括我们说的一般的解决办法

133
00:12:27,020 --> 00:12:31,000
但这种办法相当于说它不需要的文件系统有特别的一些设计

134
00:12:31,000 --> 00:12:34,920
它就是通过一个事后的一个程序来保证

135
00:12:34,920 --> 00:12:36,940
或者是这种所谓的log

136
00:12:36,940 --> 00:12:38,180
基于log这种文件系统

137
00:12:38,180 --> 00:12:39,340
比如说预写机制

138
00:12:39,340 --> 00:12:41,800
基于这种log我们可以有效的解决它

139
00:12:41,800 --> 00:12:42,860
而这里面有系统的两类

140
00:12:42,860 --> 00:12:46,620
一类是把原数据和数据都做log

141
00:12:46,980 --> 00:12:50,160
另一列是只做原数据的log,数据log不做。

142
00:12:50,460 --> 00:12:57,600
那么这个两种方式各有特点,不是说一定是一个比另一个更好,

143
00:12:57,680 --> 00:13:03,700
那肯定是在可靠性和速度上面做出一定的一些妥协看得一般,也看

144
00:13:03,700 --> 00:13:04,280
得更重。

145
00:13:04,740 --> 00:13:10,120
这就是我们说这个崩溃一致性的文件系统的一个情况的介绍。

146
00:13:11,200 --> 00:13:20,560
然后呢,再接下来我们讲到了,对,讲到了这个Lab,就是我们要去实现一个支持文件的

147
00:13:20,560 --> 00:13:28,180
一个操作,支持文件的操作,那这里面就是会讲这个整个这个我们在现有的这个

148
00:13:28,180 --> 00:13:30,220
OS之上做了哪些破绽,

149
00:13:30,220 --> 00:13:41,400
你可以看到进程要支持一个FDTable

150
00:13:41,400 --> 00:13:45,380
FDTable里面是记录了所有进程要打开的这些文件

151
00:13:45,380 --> 00:13:48,000
在APP这个层面,你要打开一个文件

152
00:13:48,000 --> 00:13:49,820
打开文件,这里面就有一项记录

153
00:13:49,820 --> 00:13:54,860
有项记录之后,你就可以通过所谓的一个FD

154
00:13:54,860 --> 00:13:57,580
就是一个文件描述符来进行访问

155
00:13:57,580 --> 00:14:06,580
读或者写,这个读写底下有大量的一些操作了,包括文件系统本身的一些

156
00:14:06,580 --> 00:14:07,300
操作。

157
00:14:07,580 --> 00:14:14,780
而整个文件系统其实是存在一开始的时候,在OS还没有启动之前,它就是存在

158
00:14:14,780 --> 00:14:16,740
我们的快设备上面。

159
00:14:17,440 --> 00:14:22,500
那么OS启动之后呢,会把位于快设备他们的文件系统给加载的类

160
00:14:22,500 --> 00:14:25,380
似中来,就这一块,进行访问。

161
00:14:25,380 --> 00:14:34,240
那么最终你的读和写实际上是对这个block device里面的比如说这里面的data

162
00:14:34,240 --> 00:14:36,160
进行读写

163
00:14:36,160 --> 00:14:44,500
这就是一个大致的OS做了进一步扩展之后支持文件之后看到的一块

164
00:14:44,500 --> 00:14:46,660
当然这里面设计的面比较多

165
00:14:46,660 --> 00:14:50,500
你看这里面整个这一块文件系统管理比较复杂

166
00:14:50,500 --> 00:14:51,900
它分了多个层次

167
00:14:51,900 --> 00:14:54,920
但它的整个逻辑是比较线性的

168
00:14:54,920 --> 00:15:00,740
像我们讲地址空间,或者讲这个进程的时候都会讲切换,我没有听说什么文件

169
00:15:00,740 --> 00:15:06,400
要切换,这倒不需要,我们只是知道从上到下一层一层的怎么把文件读出来,或者

170
00:15:06,400 --> 00:15:14,100
怎么把文件写回去,这个就是我们说在这个文件系统里面的实现需要具体注意

171
00:15:14,100 --> 00:15:20,700
的问题,这是我们上堂课的简单的回顾了一下。

172
00:15:25,900 --> 00:15:35,360
那我们三段课我刚刚大约讲到了,我觉得是记录了一下,刚刚好像30多页,讲

173
00:15:35,360 --> 00:15:39,280
到这个地方,就是我们要去理解文件。

174
00:15:39,500 --> 00:15:45,760
那么这个理解文件呢,其实文件就是说是一个线性的宿主。

175
00:15:45,760 --> 00:15:51,300
实际上它是一个线性字节的宿主

176
00:15:51,300 --> 00:15:53,500
然后其实和我们的内存很相近

177
00:15:53,500 --> 00:15:55,500
只是它的读写的单位呢

178
00:15:55,500 --> 00:15:57,240
不是一个一个的字节

179
00:15:57,240 --> 00:15:58,700
而是一个一个的框而已

180
00:15:58,700 --> 00:16:01,700
这就是为什么靠文件系统来做相应的处理

181
00:16:01,700 --> 00:16:05,760
那具体这个文件内容的解析取决于我们的应用程序

182
00:16:05,760 --> 00:16:08,360
比如说我们如果像这个文本文件

183
00:16:08,360 --> 00:16:12,280
比如这个我们写的这个编程的这个程序

184
00:16:13,380 --> 00:16:16,300
那你用一个editor打开的就是一个文本文件

185
00:16:16,300 --> 00:16:17,720
这里面看到的内容

186
00:16:17,720 --> 00:16:18,940
但是你用换一个程序打开

187
00:16:18,940 --> 00:16:20,280
比如hacks-editor

188
00:16:20,280 --> 00:16:23,140
我们就换到所有精致的格式来展现这个文件内容

189
00:16:23,140 --> 00:16:26,340
它就把整个文件内容的解析

190
00:16:26,340 --> 00:16:28,280
就交给了我们的应用程序

191
00:16:28,280 --> 00:16:31,420
而不是我们的os

192
00:16:32,240 --> 00:16:32,600
ok

193
00:16:32,600 --> 00:16:35,360
os只是把它理解为一个线性的字节数据就完了

194
00:16:35,360 --> 00:16:37,580
这是一个简化了os的一个操作

195
00:16:37,580 --> 00:16:39,320
的一个很有效的一个办法

196
00:16:41,020 --> 00:16:45,720
然后呢,但是这个文件本身除了数据之外,它还有很多原信息,我们说的这个什么

197
00:16:45,720 --> 00:16:52,140
时候创建的,它大小是多少,以及它内部的一些很重要的一些,比如说我们说的这个,

198
00:16:52,860 --> 00:16:59,660
它的这个I know的信息,这个I know的信息,在这边我们用的是,我们用的是这个Lin

199
00:16:59,660 --> 00:17:05,080
ux,Linux其实也是一种基于所有的文件系统,所以它是用的叫XT4,在

200
00:17:05,080 --> 00:17:09,300
这边就是一种高可靠的支持crash consistency的一种,

201
00:17:09,840 --> 00:17:12,580
文件系统是基于索引结构的

202
00:17:12,580 --> 00:17:14,920
这里面可以看到我们以前学的一些原理上的知识

203
00:17:14,920 --> 00:17:17,220
都能够看到,比如硬列一些个数

204
00:17:17,220 --> 00:17:19,700
这些个数写的是1

205
00:17:19,700 --> 00:17:21,080
然后文件的大小

206
00:17:22,360 --> 00:17:25,040
等等,包括这些我们还没有实际到的

207
00:17:25,040 --> 00:17:27,700
一些简单提到的,比如它这个读写权限

208
00:17:27,700 --> 00:17:29,380
最近的一些访问信息等等

209
00:17:29,380 --> 00:17:32,540
这都是记录在什么,记录在这个Illinois里面,通过这种

210
00:17:32,540 --> 00:17:35,240
比如说一条命令,state,这条命令可以得出

211
00:17:35,240 --> 00:17:37,760
对某一个文件的一个

212
00:17:37,760 --> 00:17:42,180
各种属性的一个展示

213
00:17:42,180 --> 00:17:43,700
这就是对这个inode形态的展示

214
00:17:43,700 --> 00:17:46,760
实际上就是说我们这个文件除了这个真正管理的时候

215
00:17:46,760 --> 00:17:48,420
需要一个原数据

216
00:17:48,420 --> 00:17:50,120
这各种原数据我们其实也能看到

217
00:17:50,120 --> 00:17:52,100
当然我们自己在实现一个文件系统的时候

218
00:17:52,600 --> 00:17:54,640
不一定像这样实现那么复杂

219
00:17:54,640 --> 00:17:55,920
这是这一块

220
00:17:57,760 --> 00:17:58,640
第二是目录

221
00:17:58,640 --> 00:18:01,440
目录和文件还是不太一样

222
00:18:01,440 --> 00:18:04,420
目录它是也算是一种文件

223
00:18:04,420 --> 00:18:07,420
但它的内容不像前面刚才看的那样

224
00:18:07,420 --> 00:18:10,860
就是我们仅仅是把它当作字节流了

225
00:18:10,860 --> 00:18:12,300
而对于这个目录而言呢

226
00:18:12,300 --> 00:18:14,100
其实我们还是一个我们前面说的是一个

227
00:18:17,120 --> 00:18:18,700
有这么一个这么一个

228
00:18:18,700 --> 00:18:21,400
它内容实际上是一个表

229
00:18:21,400 --> 00:18:22,920
这里面记录的是名字

230
00:18:22,920 --> 00:18:23,660
一般是

231
00:18:25,900 --> 00:18:26,360
名字

232
00:18:26,360 --> 00:18:27,340
这里面是inode

233
00:18:28,180 --> 00:18:30,100
这只要是以属性结果来为例的话

234
00:18:30,100 --> 00:18:31,020
这不是两个表

235
00:18:31,020 --> 00:18:33,860
那么我根据这个整个这里面的内容

236
00:18:33,860 --> 00:18:34,680
这个表里面的名字

237
00:18:34,680 --> 00:18:35,940
我们就知道在这个目录下

238
00:18:35,940 --> 00:18:40,640
具有哪些属于这个目录下的那些文件或者目录

239
00:18:40,640 --> 00:18:43,700
以及这个文件和目录它的Inode信息在什么地方

240
00:18:43,700 --> 00:18:44,840
这个Inode信息在什么地方

241
00:18:44,840 --> 00:18:46,340
那在有这个信息之后

242
00:18:46,340 --> 00:18:49,440
我们就能够从目录一层一层地往下找

243
00:18:49,440 --> 00:18:52,020
它的层次目录 找到对应的文件

244
00:18:52,020 --> 00:18:55,260
那这个就是我们说这个目录里面的内容

245
00:18:55,260 --> 00:18:59,860
其实这个内容它是一个以文件名为key

246
00:18:59,860 --> 00:19:04,080
然后以这个Inode为索引的一种列表

247
00:19:04,940 --> 00:19:07,680
这是目录的一个情况

248
00:19:10,260 --> 00:19:11,560
那在具体点

249
00:19:11,560 --> 00:19:13,400
其实我们看到我们在具体实现的时候

250
00:19:13,400 --> 00:19:15,700
其实就用到了这么一个结构

251
00:19:15,700 --> 00:19:17,800
就是这个叫di entry

252
00:19:17,800 --> 00:19:19,480
你可以有这个列表中的一项

253
00:19:20,460 --> 00:19:21,740
列表中的一项

254
00:19:21,740 --> 00:19:23,800
这里面就看这很明显的两块

255
00:19:23,800 --> 00:19:25,400
一个名字一个idle number

256
00:19:25,400 --> 00:19:31,480
这就是它的一个内部的一项的一个具体的展现

257
00:19:32,640 --> 00:19:39,960
好,那我们大致知道了,就是如果我们要去设计一个这样的,或者设计一个文件系统

258
00:19:39,960 --> 00:19:45,480
的话,其实你就要把这个目录文件给整理好,但其实这还很高层,这并不是非常

259
00:19:45,480 --> 00:19:49,500
底层的,但我们先从上面讲可能会变得容易一点,从哪里讲呢?从应用程序

260
00:19:49,500 --> 00:19:50,480
角度来入手。

261
00:19:50,480 --> 00:19:54,380
那我们知道应用程序,它为了能够返回一个文件,它需要通过一定的系统

262
00:19:54,380 --> 00:19:54,760
调用

263
00:19:54,760 --> 00:20:00,180
我们讲过最基本的一系列就是Open、Read、Write、Close

264
00:20:00,180 --> 00:20:02,480
那么这Open就证明很明确的Open里面

265
00:20:02,880 --> 00:20:06,180
它具体的话就有一个Cisco的ID

266
00:20:07,860 --> 00:20:09,640
然后这个打开的文件名

267
00:20:10,160 --> 00:20:15,320
这个flag是表明一些打开的一些一些设定

268
00:20:15,320 --> 00:20:16,880
比如说打开也是为了创建

269
00:20:16,880 --> 00:20:18,360
还是说只是为了打开

270
00:20:18,360 --> 00:20:23,680
最后会返回一个FD,实际上是一个有不好的整形

271
00:20:23,680 --> 00:20:26,660
但如果出错了,打不开,比如说这个文件根本不存在

272
00:20:26,660 --> 00:20:29,440
我们打开了,根本不存在的话,那么就会返回附议

273
00:20:29,920 --> 00:20:31,300
这是它的一个基本的语意

274
00:20:31,300 --> 00:20:34,240
大家其实要重视这个Syscode语意

275
00:20:34,240 --> 00:20:39,820
就是我们看到的很多的应用程序的出错

276
00:20:39,820 --> 00:20:41,460
甚至包括内核的出错

277
00:20:41,460 --> 00:20:44,720
都是在于对这个语意的理解不正确

278
00:20:44,720 --> 00:20:46,140
或者还有一种情况是说

279
00:20:46,140 --> 00:20:49,840
应用程序理解这个语义和OS理解语义是不一致的

280
00:20:49,840 --> 00:20:51,700
而这种不一致意味着什么?意味着BAR

281
00:20:53,680 --> 00:20:57,820
很多情况下,出现了各种各样的BAR,都是和这个相关的

282
00:20:57,820 --> 00:21:02,220
所以大家学这边课的时候,你需要知道

283
00:21:02,220 --> 00:21:05,960
我们这个OS,其实它的SYSCO在逐步的增加

284
00:21:05,960 --> 00:21:08,960
但是每个SYSCO到底它的含义是什么

285
00:21:08,960 --> 00:21:13,100
这样才能够正确的理解我们应该怎么去实现这个SYSCO

286
00:21:13,100 --> 00:21:14,580
我们怎么应该去用这个SYSCO

287
00:21:14,580 --> 00:21:20,460
这个我建议大家一定要重视对Syscode的理解

288
00:21:22,800 --> 00:21:25,280
那第二个Close,Close就是关闭了

289
00:21:25,280 --> 00:21:26,500
等于是我们打开那个表

290
00:21:27,000 --> 00:21:29,580
我们要打开一个文件,那意味着什么

291
00:21:29,580 --> 00:21:33,780
意味着我们这个FD的Table里面

292
00:21:33,780 --> 00:21:35,580
那么FDTable里面这一项

293
00:21:35,580 --> 00:21:36,900
这一项是打开了

294
00:21:36,900 --> 00:21:38,480
这个会C一下

295
00:21:38,480 --> 00:21:40,300
但是Close的话就把这项给清掉

296
00:21:40,300 --> 00:21:41,240
就变成Free了

297
00:21:41,240 --> 00:21:43,080
那就是所谓的Close这一项

298
00:21:43,080 --> 00:21:48,200
Close之后,自然你这个进程不可能通过这个FDTable找到相应的in

299
00:21:48,200 --> 00:21:48,340
ode

300
00:21:48,340 --> 00:21:51,160
也就不可能访问这个文件了,这是一个很自然的过程

301
00:21:54,320 --> 00:22:00,720
再下来是read的话,你可以看到这里面的有几个参数

302
00:22:00,720 --> 00:22:06,640
第一个FD,这个FD是前面的Open打开的那个FD

303
00:22:06,640 --> 00:22:08,220
反而一个字就是FD

304
00:22:08,220 --> 00:22:11,360
第二是buffer,就是你要读这个文件

305
00:22:11,360 --> 00:22:16,940
把读文件的内容放到buffer里去,然后这是buffer,你要读多少个sign,

306
00:22:17,160 --> 00:22:26,660
当然这个length不应该大于buffer的length的话,那么这是一种buff,

307
00:22:26,880 --> 00:22:31,260
明显的就会出现一出的问题,一般小于buffer的sign,这样才能确

308
00:22:31,260 --> 00:22:35,900
保把数据能够合理的放在用户的空间里面去。

309
00:22:35,900 --> 00:22:42,840
那么这个返回值是什么呢?返回值是你这个读取这个文件,它这个字结束。

310
00:22:43,300 --> 00:22:49,300
OK,好,那这个Sysread我给大家讲完了,我还是提个小问题啊。

311
00:22:49,300 --> 00:22:55,420
我希望在线上的同学能够通过腾讯会议的这个聊天,我们可以打开聊

312
00:22:55,420 --> 00:22:55,800
天。

313
00:22:56,220 --> 00:22:58,540
我们来看看同学的回答。

314
00:23:00,900 --> 00:23:10,240
就是我第一次执行SysRead的时候,那么我一个文件,这是一个文件的size,比如说16个

315
00:23:10,240 --> 00:23:10,740
字节。

316
00:23:11,100 --> 00:23:18,080
第一次执行这个Read的时候,那么它从哪儿?从文件哪个地方开始读?然后这个Lens,第一

317
00:23:18,080 --> 00:23:26,480
次是4,然后第二次这个SysRead的时候,我读了一个8,然后第三次读了一个12。

318
00:23:28,000 --> 00:23:36,980
请问你读这个buffer里面的内容,就是比如说SYSREAD,FD,比如F

319
00:23:36,980 --> 00:23:41,340
D是打开,是前面打开的FD,然后是buffer是订好的一个buffer,那

320
00:23:41,340 --> 00:23:50,860
是4,8,12,这里面放了一个1到12这么一个字,请问我读了三次之后,这个

321
00:23:50,860 --> 00:23:56,460
buffer里面的内容应该是什么,请,这是制服,应该是说错了,

322
00:23:57,980 --> 00:24:02,180
12个字符,A到ABCD一直到某一个地方。

323
00:24:03,000 --> 00:24:07,340
ABCDEFGHIJKL

324
00:24:08,380 --> 00:24:12,020
那请问这里面这个buffer里面的内容应该是啥?

325
00:24:12,860 --> 00:24:18,620
请回答,给大家一分钟的时间。

326
00:24:18,780 --> 00:24:22,920
我理解这个问题应该可以回答出来。

327
00:24:22,920 --> 00:24:24,720
我看同学的回答怎么样

328
00:24:27,260 --> 00:24:28,440
我可以喝点水

329
00:24:34,360 --> 00:24:35,920
现在还没有人回答

330
00:24:36,440 --> 00:24:36,880
我不知道

331
00:24:38,600 --> 00:24:41,320
能不能回答出我提的这道问题

332
00:24:42,080 --> 00:24:42,980
A到L

333
00:25:55,560 --> 00:26:12,820
哦,对,16之后,这个同学说的对啊,我这,有点没把这个推到P,OK。

334
00:26:15,900 --> 00:26:23,380
buffer size没变,然后我调了三次,每次的length这个参数在变,其他参数

335
00:26:23,380 --> 00:26:24,120
都没变。

336
00:26:24,460 --> 00:26:34,360
请问buffer一开始没空,然后请问最后这个buffer里面的内容是啥?

337
00:27:04,340 --> 00:27:08,700
如果你想看看咱们这边达尔同学是否对啊,

338
00:27:10,180 --> 00:27:11,720
我觉得我不知道为什么有个空格,

339
00:27:11,840 --> 00:27:13,440
我在里面没有空格,

340
00:27:13,440 --> 00:27:15,080
那是空格吗?

341
00:27:15,180 --> 00:27:16,280
对,我看有一个空格,

342
00:27:16,300 --> 00:27:18,620
就是你可以试一下这个,

343
00:27:18,660 --> 00:27:19,920
你可以编一个小程序,

344
00:27:20,940 --> 00:27:23,780
就是最正确的做法就是你编个小程序,

345
00:27:26,160 --> 00:27:29,120
在Linux里面和在这个RcodeTour里面,

346
00:27:29,140 --> 00:27:32,860
如果你完成了这个文件系统的实验的话,

347
00:27:33,220 --> 00:27:33,880
或者没完成,

348
00:27:33,880 --> 00:27:38,800
然后应该可以做这个实验,看看结果是什么。

349
00:27:39,980 --> 00:27:44,300
我觉得很不错,我已经看到有同学有回答了。

350
00:27:45,820 --> 00:27:49,040
这里面其实需要注意一点,是哪一点呢?

351
00:27:49,900 --> 00:27:56,400
就是这个read它里面并没有说它的offset从哪个地方开始读,没有这个offset的一个值。

352
00:27:57,160 --> 00:28:00,320
那这是由于我们一个约定,我们约定是说

353
00:28:00,320 --> 00:28:06,780
就是它打开文件之后,它的offset从文件读或者写的其实位置,在这个文件

354
00:28:06,780 --> 00:28:07,540
头这个位置

355
00:28:08,580 --> 00:28:13,400
然后呢,你读一次,比如读了四个字节之后呢,它的offset会偏移到四个字

356
00:28:13,400 --> 00:28:14,200
节这个地方

357
00:28:14,200 --> 00:28:16,520
那下次读是从四个字节之后去读的

358
00:28:17,120 --> 00:28:21,040
所以这个offset的内容呢,在我们这个sysread里面并没有体现

359
00:28:21,040 --> 00:28:22,200
那它存在什么地方

360
00:28:22,200 --> 00:28:25,960
那一定是存在我们的OS的某一个地方

361
00:28:25,960 --> 00:28:28,660
来帮你管理这个offset

362
00:28:28,660 --> 00:28:35,760
至于这个地方在哪,我希望有兴趣的同学可以去看一下OS代码实现,从而可以

363
00:28:35,760 --> 00:28:37,420
更好地理解这道题。

364
00:28:40,880 --> 00:28:49,440
这是关于C3的一个回答,我觉得能回答的同学我都觉得很不错,能够很

365
00:28:49,440 --> 00:28:51,000
积极地去尝试一下。

366
00:28:51,000 --> 00:28:56,320
大家没有回答的同学也挺好,因为你们都还在认真地听讲

367
00:28:56,320 --> 00:29:03,840
至少我们知道来上课的同学都已经是很好的同学了

368
00:29:03,840 --> 00:29:07,960
不来上课的同学也很好,因为他们有足够的能力,不用上课就可以把课学好

369
00:29:07,960 --> 00:29:09,900
我觉得这种同学也值得表扬

370
00:29:09,900 --> 00:29:13,800
总之能把这边课过来的同学都是好同学

371
00:29:14,700 --> 00:29:18,880
我们再看这个Cis Wright,Cis Wright其实和刚才一样

372
00:29:18,880 --> 00:29:24,200
你会发现它只是跟刚才区别在哪的,只是把这个差数都一样,就是这个Read

373
00:29:24,200 --> 00:29:24,660
-Band-Write

374
00:29:24,660 --> 00:29:32,180
那意味着它也是一样,它应该有一个offset,从两边开始写

375
00:29:32,980 --> 00:29:38,180
那么所以从写的角度来说呢,我从头写的话很容易把以前的文件内容给

376
00:29:38,180 --> 00:29:39,140
覆盖掉了

377
00:29:39,140 --> 00:29:43,360
所以写的时候我们一般是从尾开始写,那意味着什么呢?

378
00:29:43,440 --> 00:29:47,240
我应该还有一种机制,当然这里面我们并没有用到,因为还有一种机制

379
00:29:49,540 --> 00:29:54,800
如果这个文件已经存在的话,那么我想给这个文件添加内容的话,

380
00:29:55,100 --> 00:29:58,080
那很明显就是我要把这个offset要移到这个尾巴上去。

381
00:29:58,860 --> 00:30:01,960
那我们现在并没有这种syscall,其实如果你去查,

382
00:30:02,220 --> 00:30:05,240
就是我们现在讲的是最基本的,其实还有一个叫lsig。

383
00:30:07,520 --> 00:30:12,920
这个syscall就可以说我可以调整一下这个offset,把它调整到尾巴上去。

384
00:30:13,360 --> 00:30:15,520
调整到尾巴之后呢,你再做syswrite的话,

385
00:30:15,520 --> 00:30:23,120
那么这个地方就可以做扩展,这就是我们说的SysWrite需要注意的。

386
00:30:24,100 --> 00:30:29,320
那它和SysWrite不同在哪呢?SysWrite我读到这个地方,不会再读了,这

387
00:30:29,320 --> 00:30:30,440
章结束了。

388
00:30:30,640 --> 00:30:35,040
在写不一样,我是到了尾巴,我在写的时候会把这个文件给扩展出来。

389
00:30:35,660 --> 00:30:38,420
所以这个读和写还是很不一样的。

390
00:30:38,420 --> 00:30:42,040
那么它也是一样,返回写的字结束,如果读出错的话,返回复一。

391
00:30:42,540 --> 00:30:46,460
出错源有很多种,这里面只给出了一种。

392
00:30:48,900 --> 00:30:55,700
大家其实可以想象,就像我们想的各种各样的异常情况一样,

393
00:30:56,080 --> 00:30:57,960
超级种要应对各种各样的异常情况,

394
00:30:58,120 --> 00:31:03,460
所以SysWide出现的异常有哪些,大家可以去看看这个所谓的出错情况,

395
00:31:03,660 --> 00:31:05,380
到底还有哪些情况,你们可以考虑一下。

396
00:31:06,020 --> 00:31:08,440
这是关于SysWide这一块。

397
00:31:40,280 --> 00:31:43,080
这是我们之前讲进程的时候用到的一个Syscode

398
00:31:44,080 --> 00:31:45,780
那我们就要看程序

399
00:31:45,780 --> 00:31:51,200
既然我们知道怎么去用这几个Syscode的含义之后

400
00:31:51,200 --> 00:31:52,540
我们就可以写出这样的程序

401
00:31:53,100 --> 00:31:58,560
这个程序其实就是在我们这个Archive Tutorial里面就存在

402
00:31:58,560 --> 00:32:00,780
就是我们的OS里就有

403
00:32:00,780 --> 00:32:01,780
你可以看出来

404
00:32:03,160 --> 00:32:04,860
大致定义了两个字符串

405
00:32:04,860 --> 00:32:07,360
这是一个文集想写的文件内容

406
00:32:07,360 --> 00:32:13,560
这个是文件的名字,所以一开始我要打开这个文件名,打开这个文件名,如果这个

407
00:32:13,560 --> 00:32:18,300
文件不存在的话,你就有这个flag,文件不存在的话就会创建这个文件,这是

408
00:32:18,300 --> 00:32:24,780
这个打开的一个含义,然后这里面可读可写,所以你既然可读可写了,就可以写

409
00:32:24,780 --> 00:32:29,160
了,所以我一旦打开这个文件,返回那个fd之后呢,我继续这个fd呢,

410
00:32:29,160 --> 00:32:33,600
把这个字幕串写进去,就是虽然用ros写的,但我觉得大家还是能看到,

411
00:32:33,600 --> 00:32:37,660
这大致就是一个这么一个处理流程

412
00:32:37,660 --> 00:32:39,960
你如果换成C是一样的

413
00:32:39,960 --> 00:32:41,840
写完之后你要确保写回

414
00:32:41,840 --> 00:32:42,860
那么就要close一下

415
00:32:42,860 --> 00:32:44,140
把它彻底写回回去

416
00:32:44,140 --> 00:32:45,580
这就是我们说

417
00:32:47,320 --> 00:32:52,040
它完成了一次打开写关闭的过程

418
00:32:52,040 --> 00:32:53,260
那到底有没有写回呢

419
00:32:53,260 --> 00:32:54,420
你可以再次确认一下

420
00:32:54,420 --> 00:32:57,580
再次打开同一个文件

421
00:32:58,240 --> 00:32:59,080
然后再做什么

422
00:32:59,080 --> 00:33:00,360
做读操作

423
00:33:00,360 --> 00:33:02,640
那由于它给的size是100

424
00:33:37,340 --> 00:33:38,300
带码

425
00:33:39,200 --> 00:33:46,000
前面说过它有一个Length长度,但这里面并没有一个Length长度的展现。

426
00:33:46,200 --> 00:33:52,420
那我们可以看看这个Wallpish,稍微快速的把这个查出来。

427
00:34:04,140 --> 00:34:11,260
嗯,确实没有这个,没有这个Lens长度,那么这个Lens长度往哪儿去了?

428
00:34:14,880 --> 00:34:27,040
可能是在C4,这个机器刚才崩了一次之后,现在好像速度一下也变慢了,不知道

429
00:34:27,040 --> 00:34:29,920
是什么原因,速度还变慢。

430
00:34:57,180 --> 00:35:00,140
OK 我查了一下原来这个RAID操作

431
00:35:00,140 --> 00:35:10,080
确实这么一个操作,它没有这个Length,原因是在于,我只能说是Rust的一个写

432
00:35:10,080 --> 00:35:15,000
法,它把这个Length,就是按照这个buffer size,把它作为一个,buffer本来可以得

433
00:35:15,000 --> 00:35:19,840
到一个长度,把这个Length作为第三个参数,直接在这个Sysconic最底层那个

434
00:35:19,840 --> 00:35:21,260
level里面把它展现出来了。

435
00:35:21,260 --> 00:35:24,260
如果大家看一下云带码,可以看到

436
00:35:25,860 --> 00:35:30,000
这次RAID的时候,确实这个参数里面是三个

437
00:35:30,000 --> 00:35:35,020
FD是一个,然后Buffer的头指针

438
00:35:35,020 --> 00:35:37,520
第三个是它的Length在这

439
00:35:38,120 --> 00:35:40,880
但对于它来说,它确实只有两个参数

440
00:35:40,880 --> 00:35:43,560
它真正传到超线网label的时候是三个参数

441
00:35:44,040 --> 00:35:47,200
所以对超线网label来说,它确实需要有三个参数

442
00:35:47,200 --> 00:35:50,560
当然还包括Syscall Read本身的ID

443
00:35:51,040 --> 00:35:52,620
这个给大家简单解释一下

444
00:35:52,620 --> 00:35:54,520
大家看的时候也不会特别奇怪

445
00:35:57,160 --> 00:35:57,520
OK

446
00:35:58,340 --> 00:35:58,700
好

447
00:35:58,700 --> 00:36:00,560
这个应用程序最后一步close

448
00:36:00,560 --> 00:36:02,140
这个应用程序我就给大家解释完了

449
00:36:02,500 --> 00:36:07,380
那么更重要的是我们知道这个应用程序怎么是能够被我们的超级统去实现

450
00:36:07,380 --> 00:36:07,980
具体实现

451
00:36:07,980 --> 00:36:10,200
这是我们关注的重点

452
00:36:15,360 --> 00:36:19,140
好 我们看看内核怎么写程序 这要写内核代码

453
00:36:19,140 --> 00:36:26,340
这类的代码其实主要是两部分 一部分是关于这个关键的数据结构

454
00:36:26,340 --> 00:36:30,080
就是包括这个 我们说一块是跟进程相关的

455
00:36:30,080 --> 00:36:35,000
进程相关的话主要是在这一块 这一块怎么去组织它

456
00:36:35,000 --> 00:36:37,280
第二个是跟什么相关 跟空间系统相关

457
00:36:37,280 --> 00:36:40,340
文件系统是这一块非常大的一图

458
00:36:40,340 --> 00:36:43,540
这一图呢,而且还会写到我们DIX上面去

459
00:36:43,540 --> 00:36:44,540
文件系统管理相关

460
00:36:44,540 --> 00:36:46,900
这是两块相关的数据结构

461
00:36:46,900 --> 00:36:47,860
我们会逐一展开

462
00:36:47,860 --> 00:36:50,240
第二个部分是在于

463
00:36:50,240 --> 00:36:51,900
我们正在让它Work的话

464
00:36:51,900 --> 00:36:53,620
它一定有一个执行的过程

465
00:36:53,620 --> 00:36:57,000
这过程从超线系统一开始就要做好准备

466
00:36:57,380 --> 00:36:59,140
包括文件系统本身的处理化工作

467
00:36:59,140 --> 00:37:02,100
当你做了这个Open打开操作的时候

468
00:37:02,100 --> 00:37:05,020
你要把这个FD和这最里面的一个

469
00:37:05,020 --> 00:37:10,360
给他建立好联系,跟这个建立好联系,建立好联系之后呢,才能够

470
00:37:10,360 --> 00:37:15,140
最终把这条路打空,把这条路打空,最终能够去把磁盘上的这

471
00:37:15,140 --> 00:37:21,520
些数据给一步一步的通过这个Blockdriver,传给Blockcache,然后再传给

472
00:37:21,520 --> 00:37:29,400
文件系统,然后再传到进程,最终写到这个,写了这个APP,我们APP里面的B

473
00:37:29,400 --> 00:37:35,000
uffer里面去,这个它的一个过程,这个就是读写,然后这是一个读写的过程,这个就是读

474
00:37:36,160 --> 00:37:41,100
而且还有很多问题,我们后面当我们有文件系统之后呢,我们就我们的应用程序

475
00:37:41,100 --> 00:37:46,660
就不像以前那样是一个什么image,在外面有个大的image,OS和这个都放在一起,我们

476
00:37:46,660 --> 00:37:53,440
可以把OS和这个和应用程序分开,应用程序位于单独的一个一个Ease

477
00:37:53,440 --> 00:37:58,640
FS里面,我可以基于文件,基于文件来加载并执行应用,就更加的

478
00:37:58,640 --> 00:38:01,760
灵活和便捷来执行这个系统。

479
00:38:01,760 --> 00:38:04,600
这就是我们在有了这个运行程序之后

480
00:38:04,600 --> 00:38:07,220
我们OS的能力进一步增强

481
00:38:08,540 --> 00:38:09,780
这是两部分的内容

482
00:38:09,780 --> 00:38:12,160
一个是数据构,一个是管理

483
00:38:13,260 --> 00:38:14,900
那么在数据结构这一块呢

484
00:38:14,900 --> 00:38:15,880
也是一样分层次

485
00:38:15,880 --> 00:38:17,860
就是我们看到的应用程序看的是什么

486
00:38:17,860 --> 00:38:21,080
看的是目录和文件

487
00:38:21,080 --> 00:38:22,960
那么访问的时候用的是什么

488
00:38:22,960 --> 00:38:23,720
文件描述符

489
00:38:24,420 --> 00:38:25,760
然后管理的时候呢

490
00:38:25,760 --> 00:38:26,780
就是我们进程是

491
00:38:27,200 --> 00:38:29,760
这些都是在进程层面管的是文件描述符表

492
00:38:31,520 --> 00:38:37,820
然后你这里面的表,表中的最终是指向什么,指向一个文件名,指向一个in

493
00:38:37,820 --> 00:38:38,080
ode。

494
00:38:38,500 --> 00:38:42,960
这个inode呢,是实际上就到了这个我们说的这个ezfs里面,在文件系统里

495
00:38:42,960 --> 00:38:44,080
面去管理的。

496
00:38:44,140 --> 00:38:45,240
inode是什么地方?就这个地方。

497
00:38:45,540 --> 00:38:49,660
这个inode里面它有大量的一些元素信息,它还指向了data。

498
00:38:49,920 --> 00:38:52,980
通过inode我们可以把data做相应的读或者写操作。

499
00:38:53,540 --> 00:38:56,860
这个是这个核心数据结构里面的内容。

500
00:38:58,120 --> 00:39:05,320
这里面又看到了,我们在做Easy Files的时候其实做了个简化,这是我们通常看到的

501
00:39:05,320 --> 00:39:10,820
一个正常的一个视图,就是比较简短的文件系统的话,那么它会有一个多级

502
00:39:10,820 --> 00:39:12,600
层次的目录结构。

503
00:39:13,480 --> 00:39:18,860
但对于Easy Files为了简化这个设计,我们现在只搞了一集,只有这么一层

504
00:39:18,860 --> 00:39:23,020
叫root的DIR跟目录。

505
00:39:24,180 --> 00:39:29,100
那么,目录也是一个文件,所以它会有一个专门跟目录所对应的一个叫做入

506
00:39:29,100 --> 00:39:29,760
手的inode。

507
00:39:30,420 --> 00:39:37,140
在这个入手的inode下面呢,有各种各样的文件,或者是DLR,或者是目录。

508
00:39:37,300 --> 00:39:39,840
当然为了讲话起见,也是为了讲话起见,我们这个目录没有。

509
00:39:40,500 --> 00:39:44,000
目录下面,一层目录下面,只有一层目录,下面有一堆文件。

510
00:39:44,040 --> 00:39:46,580
这个文件就可以是我们的一些执行程序。

511
00:39:47,380 --> 00:39:49,380
那每一个文件呢,也是一个inode。

512
00:39:49,380 --> 00:39:51,080
也是一個inode

513
00:39:54,640 --> 00:39:57,460
所以在這個root.di下面

514
00:39:57,460 --> 00:39:59,080
會有這麼一個它的內容

515
00:39:59,080 --> 00:40:01,240
實際上就是一些就是它裡面的data

516
00:40:01,240 --> 00:40:02,860
這個目錄裡面的data

517
00:40:02,860 --> 00:40:09,120
就是以這個為一項的形成的一個表

518
00:40:09,120 --> 00:40:10,600
所謂的一個列表

519
00:40:10,600 --> 00:40:14,340
包含了在這個目錄下的所有的文件的內容

520
00:40:14,340 --> 00:40:15,320
這裡面就包含了兩塊

521
00:40:15,320 --> 00:40:15,920
一個是名字

522
00:40:15,920 --> 00:40:19,400
文件的名字和文件名所对应的那个iNode

523
00:40:21,620 --> 00:40:24,580
法比说我打开一个file.file.file

524
00:40:24,580 --> 00:40:27,480
那就是意味着我会在这个根目录下

525
00:40:27,480 --> 00:40:28,940
如果这个文件不存在

526
00:40:28,940 --> 00:40:29,800
那我在根目录下

527
00:40:29,800 --> 00:40:31,880
它这个表里面创建一个新的项

528
00:40:31,880 --> 00:40:34,960
把它名字写成这一项名字写成这个file

529
00:40:35,780 --> 00:40:36,320
file.a

530
00:40:36,320 --> 00:40:38,780
然后在这里面会创建一个iNode

531
00:40:38,780 --> 00:40:41,660
然后它如果是文件为0的话

532
00:40:41,660 --> 00:40:42,400
那可能没有block

533
00:40:42,400 --> 00:40:43,680
但一旦往里面写了内容

534
00:40:43,680 --> 00:40:45,400
比如说后面再做一个write的话

535
00:40:46,180 --> 00:40:49,560
Write操作的话,这里面还分配相当于一个DiskQuark

536
00:40:49,560 --> 00:40:53,260
然后你这里面的iLoad的信息还只能是DiskQuark

537
00:40:53,260 --> 00:40:55,760
这样就形成了一个完整的文件的内容

538
00:40:57,180 --> 00:41:01,860
这是关于核因数据结构的一个展现

539
00:41:03,680 --> 00:41:05,740
这一块打开的文件在FDTable里面

540
00:41:09,020 --> 00:41:13,320
这实际上是我们说的文件通过Quark里面很核心的一个结构

541
00:41:13,320 --> 00:41:15,000
在结构体里面就有个FDTable

542
00:41:15,940 --> 00:41:20,620
当然还有其他的东西,就是我们在不停地扩展我们的进程,

543
00:41:22,280 --> 00:41:26,460
这不叫文件控制化,叫进程控制化,进程控制化里面不停地扩

544
00:41:26,460 --> 00:41:26,780
展什么呢?

545
00:41:26,780 --> 00:41:33,080
扩展我们说进程管理的资源,这个FD,就是打开的文件,就是它管理的

546
00:41:33,080 --> 00:41:34,040
一种资源。

547
00:41:34,580 --> 00:41:38,800
那么最终这个FD特殊里面记录的是一种叫做进程管理的inode,我们

548
00:41:38,800 --> 00:41:40,000
称之为OSI node。

549
00:41:41,220 --> 00:41:47,640
OSI-Node里面最核心的就是这么一个结构,iNode结构,像这个是存

550
00:41:47,640 --> 00:41:55,300
储设备的iNode,这个只是为了便于管理,搞成这个层次稍微多了一点,

551
00:41:55,740 --> 00:42:02,100
基本上你区分进程级的和系统级的,就是系统范围还是进程范围而已,

552
00:42:02,380 --> 00:42:07,640
那么这里面的OSI-Node是属于FDTable里面管的,都属于进程

553
00:42:07,640 --> 00:42:08,320
类的。

554
00:42:08,320 --> 00:42:13,520
但一旦说属于E-ZFS面管,那些inode的属于系统面管,OK

555
00:42:15,120 --> 00:42:24,120
那么进程系统是进程里面的PCB里面的Table里面的一项,会指

556
00:42:24,120 --> 00:42:30,800
向系统里面的E-ZFS串里面的一个inode

557
00:42:32,200 --> 00:42:37,600
最终会指向这儿来,然后这个inode再去找到相应的disk,这么一个大致

558
00:42:37,600 --> 00:42:38,300
的过程

559
00:42:41,720 --> 00:42:48,660
这是站在进程角度看到的,站在文件系统角度看到的,不光是文件,它

560
00:42:48,660 --> 00:42:56,200
需要整个这么一个结构,它要把整个文件系统给管起来。

561
00:42:56,280 --> 00:43:00,540
文件系统要管起来的话,文件里面包含了文件,所以会涉及到很重要

562
00:43:00,540 --> 00:43:04,980
的超级块,还有两个bitmap,

563
00:43:04,980 --> 00:43:09,400
表明了哪些inode区域和data区域被分配了

564
00:43:09,400 --> 00:43:10,620
什么都被分配

565
00:43:10,620 --> 00:43:14,200
这里面有这个所谓的数据块

566
00:43:15,860 --> 00:43:18,180
这是inode的那个块

567
00:43:18,700 --> 00:43:19,060
OK

568
00:43:19,940 --> 00:43:20,940
那这一块是什么

569
00:43:20,940 --> 00:43:22,700
这一块实际上是这个地方

570
00:43:22,700 --> 00:43:23,180
这个地方

571
00:43:23,180 --> 00:43:24,240
这是在内存中存在的

572
00:43:24,240 --> 00:43:25,380
这实际上不在内存中存在

573
00:43:25,380 --> 00:43:26,640
一旦说我们

574
00:43:26,640 --> 00:43:30,060
你无论是inode还是data的

575
00:43:30,060 --> 00:43:31,160
那其实都是一个块

576
00:43:31,160 --> 00:43:32,220
那这个块

577
00:43:32,220 --> 00:43:38,840
我们是会把这个Inode的一个Lumber,或者是Data的一个Lumber,会映射到一个D

578
00:43:38,840 --> 00:43:40,580
ata的一个Quad上面去

579
00:43:40,580 --> 00:43:45,520
所以我们在底层有一个叫BlockCache,会以Quad为单位来进行读或者写,

580
00:43:45,880 --> 00:43:47,500
把它作为一个缓存存在

581
00:43:47,500 --> 00:43:54,320
那这个东西就实际上是在BlockDriver,就是我们这块设备和这个文件系

582
00:43:54,320 --> 00:43:55,380
统之间

583
00:43:55,380 --> 00:44:00,280
会有一个就是等于是我们看到的,这是Driver

584
00:44:00,280 --> 00:44:04,040
这是一层BufferCache或叫BlockCache

585
00:44:04,940 --> 00:44:06,580
这一块是FS

586
00:44:06,580 --> 00:44:13,860
这样的话我的FS会把我们应用程序发出的一个读或者写的一个请求

587
00:44:13,860 --> 00:44:15,940
变成对一个块的读写请求

588
00:44:15,940 --> 00:44:18,500
而这块会在这个地方会有缓存

589
00:44:18,500 --> 00:44:19,960
如果没有缓存

590
00:44:19,960 --> 00:44:26,820
那这个由BlockCache向我们的Driver发出申请来进行读操作

591
00:44:26,820 --> 00:44:27,860
那写也是一样

592
00:44:27,860 --> 00:44:35,540
我先写到Blockcatch里面,那就快速返回了,我是延迟写,最终是由B

593
00:44:35,540 --> 00:44:41,800
lockcatch统一写回到这个专案里面去,这是通过专案来完成真实的写

594
00:44:41,800 --> 00:44:48,340
操作,所以这个Blockcatch是一个提高性能,提高效率,很有效的一种机制,

595
00:44:48,580 --> 00:44:52,600
就是一种Catch机制,这是它的一个层次结构。

596
00:44:52,600 --> 00:44:56,360
所以这里面我们首先要关注CyberBlock管的啥

597
00:44:56,360 --> 00:45:00,260
CyberBlock管的就是所有Block的一个状态信息

598
00:45:00,260 --> 00:45:01,740
就是这里面会记录

599
00:45:01,740 --> 00:45:04,360
比如说这里面到底有多少个DataBlock

600
00:45:04,360 --> 00:45:06,600
有多少个Bitmap,有多少个Area等等

601
00:45:06,600 --> 00:45:08,600
这些信息整个都要记录下来

602
00:45:09,820 --> 00:45:13,940
这个是CyberBlock的一个信息的保证

603
00:45:13,940 --> 00:45:16,020
第二个是Bitmap

604
00:45:16,020 --> 00:45:17,220
Bitmap有两类Bitmap

605
00:45:17,220 --> 00:45:19,540
一个是InodeBitmap,一个是DataBitmap

606
00:45:19,540 --> 00:45:27,620
那么这里面的一个bit,就对应着这里面的一个块,这一块,这所谓看到这里面,我们

607
00:45:27,620 --> 00:45:35,860
会以bit为单位,记录这个块的一个使用情况,那么到底有多少块呢,这里面会有

608
00:45:35,860 --> 00:45:43,180
一个记录这个blocks,记录有多少块呢,这是我们说的,前面讲原理的时候也讲到,

609
00:45:43,240 --> 00:45:47,980
文件系统的原理的时候也讲到,用未图的方式来管理这个池方空间

610
00:45:47,980 --> 00:45:48,980
的申请与分配。

611
00:45:52,840 --> 00:46:00,100
那么这个inode,在文件系统这个level叫diffinode,在我们进程那个level叫osin

612
00:46:00,100 --> 00:46:09,640
ode,那只是为了一个后来是设计的一个方便,那么直接来看的话,这个OK,这确实

613
00:46:09,640 --> 00:46:15,780
很方便,现在十点三十五,大家先休息一下,五分钟之后上课。

614
00:51:20,700 --> 00:51:25,900
好,到点了,我们继续开始上课。

615
00:51:27,000 --> 00:51:31,540
刚才讲到Disk Anode,就是我们说的这块区域。

616
00:51:44,020 --> 00:51:46,400
这里面存了大量的Anode信息,

617
00:51:48,520 --> 00:51:56,560
这里面记录了JBlock,就是文件的数据的一个分布情况,包括这个文件的size,

618
00:51:56,920 --> 00:52:04,720
包括它的直接锁引,一级间接锁引,二级间接锁引。

619
00:52:04,820 --> 00:52:11,480
但需要注意这里面,我们在实际的EDFS里面并没有三级间接锁引。

620
00:52:11,480 --> 00:52:16,940
是不是没有,就彻底没有,其实可以讲,只是我们这个为了简单,并没有设计这一块,那加

621
00:52:16,940 --> 00:52:22,600
上3G间接属性之后,你可以访问更大的size的这个文件,很明显啊,那这里

622
00:52:22,600 --> 00:52:30,340
面经常会考大家的,就是在有给出这么一个结构,请问一个最大的文件有多

623
00:52:30,340 --> 00:52:36,620
大size,如果我给出一个箱里这么一个布局的一个图,比如说Bitmap有多少个,那么

624
00:52:36,620 --> 00:52:40,120
这里面可以放多少个文件,多少个file,

625
00:52:42,700 --> 00:52:49,620
那么这些约定,这些约束一定确定之后,那么我们到底整个这个文件系统能

626
00:52:49,620 --> 00:52:56,500
放多少个文件,每个文件多少个size等等,这些信息都应该可以算出来,所以你要

627
00:52:56,500 --> 00:53:04,640
会做这样这种类型的一种纯粹的计算体,我觉得这个是需要大家注意的,虽然,

628
00:53:04,640 --> 00:53:11,380
虽然其实我觉得还是比较直接的,但是你要把这个所有的一些细节想清楚的话,还是不容易啊,

629
00:53:11,820 --> 00:53:18,660
如果纯计算我觉得还好,但如果说我们给出一些像刚才那样的编程题,出现

630
00:53:18,660 --> 00:53:23,480
了所谓的反方的负一怎么回事,你能不能灵活的解释这些情况,那这个

631
00:53:23,480 --> 00:53:27,640
我觉得就更加有挑战一点,需要大家注意一下。

632
00:53:30,820 --> 00:53:36,780
再加一点就是在于我们其实读写文件的时候,大家都知道是按照字节来进行一个一个

633
00:53:36,780 --> 00:53:38,040
字节写的一个buffer。

634
00:53:38,440 --> 00:53:46,720
那么这个buffer其实会转成什么呢,你一边会把对一个线性的buffer的

635
00:53:46,720 --> 00:53:52,980
访问变成一个一个的disc的访问,它可能位于这儿位于这儿位于这

636
00:53:52,980 --> 00:53:53,500
儿。

637
00:53:53,680 --> 00:53:59,640
那么这些disc就是我们靠的readat和writeat来由我们的文件系统把文件

638
00:53:59,640 --> 00:54:05,680
偏移转成一系列的数据块的编号,然后才能够去相应一些读写。

639
00:54:05,680 --> 00:54:15,020
但是这个读写呢,它这个文件系统FS,FS向下访问的是Blockcatch,Blockc

640
00:54:15,020 --> 00:54:21,200
atch再往下访问的是所谓的这个driver,这是这么一个结构,所以我要读写的话,我必须

641
00:54:21,200 --> 00:54:27,380
得到相应的看这catch中有没有,如果有的话,我就直接对这个catch好的这个数据

642
00:54:27,380 --> 00:54:34,420
块进行读和写操作,那由于这个块里面呢,也是整个这个bubblecatch

643
00:54:34,420 --> 00:54:35,660
也是容量有限的。

644
00:54:35,680 --> 00:54:41,760
那么我们可以采取比较简单的LRU算法,我们前面提到的就是我们的页

645
00:54:41,760 --> 00:54:44,820
面自动算法里面提到的各种各样的算法,至少有个经典的L

646
00:54:44,820 --> 00:54:49,520
RU算法,在我们的页面自动算法里面很难实现,但是在BufferC

647
00:54:49,520 --> 00:54:59,500
atch里面是可以实现,那我想这个可能还是不太容易抽同学吧,我还是自问自答

648
00:54:59,500 --> 00:55:02,000
吧,就是我想问的同学什么问题呢?

649
00:55:02,000 --> 00:55:07,200
为什么LRU这个算法能够在这个Uppercatch里面能够实现

650
00:55:07,200 --> 00:55:12,560
但是在我们的虚重管理中的那个页面自划算法里面

651
00:55:12,560 --> 00:55:16,500
这其实也是一种自划,因为这都是有限的,自划算法不能实现

652
00:55:16,500 --> 00:55:18,620
也不能给出一个合理的解释

653
00:55:18,620 --> 00:55:20,020
这也是一个问题

654
00:55:20,020 --> 00:55:24,900
我来这儿,希望大家能够在课后能够去思考一下

655
00:55:25,940 --> 00:55:31,540
这就是我们说课后,大家希望有些题是直接布置在了那个我们的文档上面

656
00:55:31,900 --> 00:55:37,780
就是还有一些题是老师在课上提到的,也希望大家课后去做一做。

657
00:55:38,020 --> 00:55:43,540
这个做呢,我们并不要求大家一定要写下来,但是至少你要清楚啊,有一个合理的回答。

658
00:55:47,560 --> 00:55:52,020
这又再次出现了这个数据块和木木的一个结构。

659
00:55:52,160 --> 00:55:56,100
这还是数据结构啊,数据块就是一个非常简单的一个,比如说BlockSide 512

660
00:55:56,100 --> 00:55:57,780
字结构,没有buffer。

661
00:55:57,780 --> 00:56:01,760
嗯,这个就不用讲,这是这个数一块的梦的结构

662
00:56:01,760 --> 00:56:05,580
BubbleCatch的结构,你看BubbleCatch里面,它

663
00:56:10,660 --> 00:56:14,380
它有多个,它有多个BubbleCatch

664
00:56:16,140 --> 00:56:16,500
那么

665
00:56:19,420 --> 00:56:21,680
这里面应该是给一个

666
00:56:22,140 --> 00:56:24,140
这是一个,这代表一个BubbleCatch

667
00:56:24,140 --> 00:56:29,060
那么它会有一个一个大的宿主来形成一个多个的一个bubble catch

668
00:56:29,060 --> 00:56:30,940
然后再进入IU的管理

669
00:56:32,420 --> 00:56:35,880
这是bubble catch的一个结构

670
00:56:37,700 --> 00:56:38,060
OK

671
00:56:38,060 --> 00:56:40,040
正面比较关键的是哪个属性

672
00:56:40,800 --> 00:56:43,240
除了这个block ID

673
00:56:43,240 --> 00:56:45,580
实际上它代表的是磁盘上的某一块

674
00:56:45,580 --> 00:56:48,740
把这边某一块它缓存到了这里面来

675
00:56:48,740 --> 00:56:50,000
缓存到这里面来

676
00:56:50,480 --> 00:56:52,380
那如果它对它做了写操作

677
00:56:52,380 --> 00:56:57,240
那最终如果确保,你一定要确保说把这个数据要写回去,写到这里面来,要确

678
00:56:57,240 --> 00:57:04,780
保它一字形,如果写回去的话就出现我们前面说的这个文件就不可靠了,

679
00:57:04,800 --> 00:57:10,380
因为你没把真实的数据写回去,这是这一块,然后有没有写在这里面有个标

680
00:57:10,380 --> 00:57:18,920
识,OK,这是关于管存这一块的一个介绍,然后关键数据以后就介绍完

681
00:57:18,920 --> 00:57:22,360
毕了,那这样,接下来我们就看到了就是

682
00:57:52,440 --> 00:57:54,880
这讲的是EFZ线条的一个改进

683
00:57:55,720 --> 00:57:59,500
那么还有一个是直接的是通过Operate和Write来读写文件

684
00:57:59,500 --> 00:58:02,780
你把这几个控制逻辑了解清楚之后

685
00:58:02,780 --> 00:58:05,860
那我们就能够理解我们怎么去执行文件

686
00:58:05,860 --> 00:58:09,220
怎么去执行程序,怎么去读写文件内容

687
00:58:09,220 --> 00:58:10,880
这就比较清楚了

688
00:58:11,560 --> 00:58:13,600
第一个来看一看,第一个是处置化

689
00:58:13,600 --> 00:58:16,060
处置化首先你要知道这个Block device

690
00:58:16,520 --> 00:58:19,260
我们现在并不讲驱动,驱动放在最后

691
00:58:19,820 --> 00:58:21,080
你知道还有Block device

692
00:58:21,080 --> 00:58:27,820
这个其实就你以为就是有个系统帮我们知道了你这个快设备它的Device试

693
00:58:27,820 --> 00:58:28,220
试

694
00:58:28,220 --> 00:58:29,960
然后有这个Device之后呢

695
00:58:29,960 --> 00:58:32,100
我们会从这个Device里面找到什么

696
00:58:32,840 --> 00:58:36,880
找到它的这个文件系统一个结构EFS

697
00:58:38,720 --> 00:58:45,240
就怎么说的包含了从Civablock到Bitmap到Inode到Datablock这么

698
00:58:45,240 --> 00:58:46,520
一个总体结构

699
00:58:46,520 --> 00:58:49,520
Civablock信息放在这里面EFS

700
00:58:49,520 --> 00:58:54,260
通过这个EFS我们还进一步会找到什么,找到这所谓的root inode,就是我们

701
00:58:54,260 --> 00:58:59,840
说的根文件,就是根目录,root inode就是根目录。

702
00:59:00,480 --> 00:59:05,580
我们其实这个EFS它只有一层目录,所以我们只要找到根目录之后,我们其余

703
00:59:05,580 --> 00:59:07,540
根目录就可以找到根目录下面的文件。

704
00:59:07,840 --> 00:59:15,720
所以这一次处置化的时候很重要一点,你要能够把这个根目录所对应的inode给

705
00:59:15,720 --> 00:59:19,100
找找,这是一个全局变量,就是这一款。

706
00:59:19,820 --> 00:59:25,680
有了这个之后,接下来就够了,我们文件系统的处置化工作就完成了,现在

707
00:59:25,680 --> 00:59:26,640
就开应用了。

708
00:59:26,740 --> 00:59:29,960
假设应用要执行,它会打开一个文件的话,那么会执行一个SysOpen。

709
00:59:30,600 --> 00:59:36,120
SysOpen的话,你会看到,这都是内核里面的识箱,SysOpen。

710
00:59:36,660 --> 00:59:43,000
SysOpen它会干什么呢?这里面其实是一个关键代码的部分,一个局部。

711
00:59:43,000 --> 00:59:48,000
它为什么打开这个Parse,比如说刚才说的一个FileA,这是一个文件名吗?

712
00:59:49,320 --> 00:59:55,400
它就会查,会基于这个FileA不是一个文件名,我们会查这个幕幕里面的

713
00:59:55,400 --> 01:00:00,240
那一项,它这里面全是文件的名字,这是它的Iknow的信息,查这个文件名

714
01:00:00,240 --> 01:00:01,360
这里面有没有存在。

715
01:00:01,760 --> 01:00:07,640
如果有存在,我就可以把它打开。如果没有存在的话,那你要看这个属性,这个属性说是

716
01:00:07,640 --> 01:00:09,720
可以Create,创建一个文件。

717
01:00:09,720 --> 01:00:15,880
那取决于你这个属性来决定它打开的进一步的操作数上

718
01:00:15,880 --> 01:00:17,600
好,假定我们这个是个文件存在

719
01:00:17,600 --> 01:00:19,740
这最简单的方法,这个文件这里面正好一样

720
01:00:19,740 --> 01:00:21,940
有个FileA这边一条文件名

721
01:00:21,940 --> 01:00:24,860
这里面它的这个inode在这儿存着

722
01:00:24,860 --> 01:00:27,720
那么存在之后,那么这个我就会知道这个文件存在

723
01:00:27,720 --> 01:00:30,980
然后我会指向把这个在这个FDTable里面

724
01:00:30,980 --> 01:00:32,460
FDTable里面分配一个空闲项

725
01:00:32,460 --> 01:00:35,520
这个FD只要是一个空闲的一个index

726
01:00:35,520 --> 01:00:38,280
然后这个FDTable里面记录什么

727
01:00:38,280 --> 01:00:42,300
在这个index里面记录什么,记录这个iNode,把iNode填进去

728
01:00:42,300 --> 01:00:47,660
这就相当于是就在这个进程的这个FDTable里面把这个文件给打

729
01:00:47,660 --> 01:00:48,360
开了

730
01:00:48,360 --> 01:00:50,040
那返回返回什么呢?返回这个FD

731
01:00:50,700 --> 01:00:53,780
当然它会有失败情况,失败就是返回-1

732
01:00:53,780 --> 01:00:56,940
这就是我们说这个SysOpen要干的事情

733
01:00:56,940 --> 01:00:59,920
那关键函是什么?Open file

734
01:01:01,140 --> 01:01:07,100
Open file你可以看到,就是取决于我们这个flag有什么标记

735
01:01:07,940 --> 01:01:11,420
如果flag是有个create标志,且没有找这个文件的话,

736
01:01:11,520 --> 01:01:15,780
那么它就会执行这个inode的这个对应的一个操作,

737
01:01:16,000 --> 01:01:19,860
就是inode里面,这是一个inode,inode有create操作。

738
01:01:20,540 --> 01:01:26,580
所谓create就是在它那个目录里面,增加一下,增加一下。

739
01:01:26,700 --> 01:01:29,840
这是它的那个文件的名字,这是它那个新的一个inode。

740
01:01:30,220 --> 01:01:33,140
这就是它干的事情,这是创建新的inode。

741
01:01:33,660 --> 01:01:35,740
OK,这就是create的情况。

742
01:02:05,940 --> 01:02:12,780
而这个node信息存在哪里呢?存在我们的硬盘上,我们知道我们的EFS它的

743
01:02:12,780 --> 01:02:17,980
主要内容都在硬盘上,包括这个iNode信息,所以我们会把这个Disk iN

744
01:02:17,980 --> 01:02:22,360
ode从磁盘上的那个区域,从iNode区域里面读到这边来,然后再通

745
01:02:22,360 --> 01:02:27,520
过OSiNode把它做了个通装,然后交给了我们的进程去做管理,这是它

746
01:02:27,520 --> 01:02:30,160
大致的一个过程,这是主要打开的一个操作。

747
01:02:30,160 --> 01:02:32,700
Close 那就因为反操作了

748
01:02:32,700 --> 01:02:36,020
就直接把这个FB table里面的项给去掉

749
01:02:36,020 --> 01:02:37,780
take就是去掉

750
01:02:37,780 --> 01:02:38,560
清空

751
01:02:38,920 --> 01:02:42,680
但需要注意是这里面会导致这个文件的引用技术会减移

752
01:02:42,680 --> 01:02:44,060
当一件事为零的时候

753
01:02:44,060 --> 01:02:46,160
这个文件就占了资源会释放

754
01:02:47,280 --> 01:02:50,160
这是关于SysClose的一个简单介绍

755
01:02:52,200 --> 01:02:53,760
这讲怎么加载应用程序

756
01:02:53,760 --> 01:02:55,140
那就是看这个EXEC

757
01:02:55,140 --> 01:02:57,280
就是这个EXEC的实现

758
01:02:59,900 --> 01:03:05,280
你认为多了一个文件名,所以它还是调同样一个函数,open file

759
01:03:06,160 --> 01:03:12,080
但是它读需要注意,前面是调了一个read,这是调了read all这么一个操作

760
01:03:12,080 --> 01:03:17,600
read all把所有的文件内容都读到内存中来,这是all data里面

761
01:03:17,600 --> 01:03:21,600
为什么所有文件呢?因为它其实需要把这个解析出来,这个elf格式

762
01:03:21,600 --> 01:03:23,580
Alph格式执行文件全都要加进来

763
01:03:23,580 --> 01:03:25,540
然后对这个Alph格式

764
01:03:25,540 --> 01:03:27,360
这个all data就是这个Alph格式

765
01:03:28,440 --> 01:03:29,800
一个一块buffer

766
01:03:29,800 --> 01:03:31,340
这个buffer做解析

767
01:03:31,340 --> 01:03:34,820
把里面的代码段、数据段

768
01:03:34,820 --> 01:03:36,540
等等信息给识别出来

769
01:03:36,540 --> 01:03:40,340
然后来进行后续的创建进程的一个工作

770
01:03:40,340 --> 01:03:42,940
我们会建立它所谓的memory set

771
01:03:42,940 --> 01:03:44,600
就是所谓它的地址空间

772
01:03:48,600 --> 01:03:50,160
这就是我们进程的地址空间

773
01:03:50,160 --> 01:03:54,100
就靠你把all data解析完之后创建的

774
01:03:54,100 --> 01:03:55,880
就是代码的数据等等

775
01:03:55,880 --> 01:04:01,160
这就是关于EXEC有了文件之后

776
01:04:01,160 --> 01:04:02,620
它会做的一个改进

777
01:04:02,620 --> 01:04:05,220
这样我们可以很方便地加载这个执行程序

778
01:04:07,980 --> 01:04:09,500
那么写恶读

779
01:04:09,500 --> 01:04:11,180
就是我们其实已经看到了

780
01:04:11,180 --> 01:04:11,500
写恶读

781
01:04:11,500 --> 01:04:14,040
其实就是你有一个FD

782
01:04:14,040 --> 01:04:16,000
有一个FD

783
01:04:16,000 --> 01:04:19,100
那么会从这边FDTable里面找到这个

784
01:04:19,100 --> 01:04:22,240
然后做相应的写操作

785
01:04:22,660 --> 01:04:26,280
需要注意的是这个buffer

786
01:04:26,280 --> 01:04:28,620
这个buffer需要translate一下

787
01:04:29,340 --> 01:04:30,800
因为我们前面说过

788
01:04:30,800 --> 01:04:36,580
我们的内核和我们的应用程序

789
01:04:36,580 --> 01:04:39,020
它们是不同的地址空间

790
01:04:39,780 --> 01:04:42,360
所以这个应用程序传达的buffer

791
01:04:42,360 --> 01:04:43,980
是应用程序的地址空间

792
01:04:43,980 --> 01:04:44,980
你真正要用的时候

793
01:04:44,980 --> 01:04:49,080
你要把这个应用程序的地址空间

794
01:04:49,080 --> 01:04:53,580
所以一定需要一个translate,buffer这么一个操作

795
01:04:53,580 --> 01:04:58,080
这个之前在讲地址空间的时候

796
01:04:58,520 --> 01:05:00,180
或者是address space的时候

797
01:05:00,180 --> 01:05:02,660
应该给大家提到过这种非常重要

798
01:05:02,660 --> 01:05:05,490
因为它需要在地址空间中来完成一个转换

799
01:05:07,440 --> 01:05:09,200
这是写读也是一样

800
01:05:09,200 --> 01:05:11,200
读就是同样操作

801
01:05:11,200 --> 01:05:12,520
只是一个是反过来

802
01:05:12,520 --> 01:05:16,360
是从第一刻把这个数据读进来

803
01:05:16,360 --> 01:05:18,160
这是同样的一个操作

804
01:05:18,940 --> 01:05:23,320
最终读起来之后,会把它写回到用户程序的buffer里面去

805
01:05:23,700 --> 01:05:25,860
这是它的一个处理过程

806
01:05:27,460 --> 01:05:33,200
那我就大致把这个它的类和关于运行系统实现部分给大家简单介绍完

807
01:05:33,200 --> 01:05:33,800
毕

808
01:05:33,800 --> 01:05:37,420
我觉得比较关键的是在于你知道这个文件目录的概念是什么

809
01:05:37,420 --> 01:05:40,620
就是概念的对应的实现是什么

810
01:05:40,620 --> 01:05:49,020
这实现包含了数字结构,证明Data和对应的Control,就是它的所谓的

811
01:05:49,020 --> 01:05:49,540
控制流

812
01:05:50,580 --> 01:05:54,700
然后呢,这是站在一个进程角度来考虑,我考虑的是文件和目录

813
01:05:54,700 --> 01:05:57,620
但是你要站在一个系统设计角度来考虑,要考虑整个文件系统

814
01:05:58,160 --> 01:06:01,340
整个文件系统是怎么一个组织结构

815
01:06:01,960 --> 01:06:06,180
它的组织结构,有很多东西是我们的应用程序看不到的

816
01:06:06,180 --> 01:06:10,740
比如Cyperblock,比如Bitmap,Inode,这些都是看不到的

817
01:06:10,740 --> 01:06:16,360
因为有些人看到的只是文件名和文件名所对应的那些文件内容

818
01:06:17,360 --> 01:06:22,120
但是你文件系统就有更多的信息需要去理解和掌握

819
01:06:23,100 --> 01:06:25,780
这是我们说关于文件系统这一块

820
01:06:25,780 --> 01:06:27,740
还有一个很重要的点在于你要能够

821
01:06:28,240 --> 01:06:33,640
所有讲文件系统的时候可能讲文件系统本身Cyperblock有所谓的Inode

822
01:06:33,640 --> 01:06:36,740
但是并没有讲他们这些怎么结合的

823
01:06:36,740 --> 01:06:41,840
所以我希望你们通过这个整个实验或者对实践的能够知道

824
01:06:42,380 --> 01:06:48,460
通用程序发出一个打开、读、写、关闭操作之后

825
01:06:48,460 --> 01:06:51,140
怎么最终在文件程序中实现

826
01:06:51,140 --> 01:06:53,820
甚至一层一层传到最后的Disk上面去

827
01:06:54,540 --> 01:06:57,420
这一块整个流程你要清楚

828
01:06:57,420 --> 01:07:01,180
首先你要把这些点的知识变成一根线

829
01:07:01,180 --> 01:07:02,720
而不是一个一个闪落的点

830
01:07:02,720 --> 01:07:08,480
你要把这些点串起来,形成一个线,这样才能够把整个理解的比较清楚

831
01:07:08,480 --> 01:07:10,880
尤其是文系统相当于说比较大

832
01:07:11,820 --> 01:07:18,620
所以这样我觉得才能够算是比较透彻的掌握文系统的一些内容

833
01:07:18,620 --> 01:07:20,360
这样可以写出所谓的霸王功能

834
01:07:20,360 --> 01:07:25,540
这是我们关于Lecture 9这一部分就给大家介绍完毕

835
01:07:25,540 --> 01:07:41,460
OK,好,那我们接下来进入,再重启一把,这个怎么都没了,再去下一张,第十

836
01:07:41,460 --> 01:07:44,030
讲的内容,我稍微打开一下,稍微点,

837
01:08:01,510 --> 01:08:04,550
我们进入了下一个环节,就是进程间通讯。

838
01:08:06,210 --> 01:08:12,090
首先,你要理解进程间通讯和前面讲的内容有什么很大的一个不同在哪儿

839
01:08:12,090 --> 01:08:12,370
呢?

840
01:08:12,450 --> 01:08:14,010
前九讲,我们进入了下一个环节,就是进程间通讯。

841
01:08:14,010 --> 01:08:18,610
基本上把我们说超级这种最关键的三个抽象讲完了

842
01:08:18,610 --> 01:08:21,570
进程、地址、通阶、门键

843
01:08:21,570 --> 01:08:22,870
这三部分讲完了

844
01:08:22,870 --> 01:08:25,630
但这三部分虽然讲完了

845
01:08:25,630 --> 01:08:28,510
它也确实是我们OS很重要的一个组成部分

846
01:08:28,510 --> 01:08:30,910
但是它有一个地方还不够

847
01:08:30,910 --> 01:08:32,330
就是讲这些进程

848
01:08:32,330 --> 01:08:33,910
虽然它也支持多进程去运行

849
01:08:33,910 --> 01:08:35,810
但进程和进程界没有任何的交互

850
01:08:35,810 --> 01:08:37,250
这就是一个问题

851
01:08:37,250 --> 01:08:39,510
但是如果进程和进程界没有任何交互

852
01:08:39,510 --> 01:08:40,230
会带来什么样的问题

853
01:08:40,230 --> 01:08:42,970
就是你实现单个进程它的能力

854
01:08:42,970 --> 01:08:45,050
它的这个程序的本身的功能是有限的

855
01:08:45,650 --> 01:08:47,550
如果要实现一个非常复杂的需求的话

856
01:08:47,550 --> 01:08:48,370
其实需要

857
01:08:49,210 --> 01:08:51,010
当然我可以开发一个非常复杂的程序

858
01:08:51,850 --> 01:08:53,530
来实现这种复杂的应用需求

859
01:08:53,530 --> 01:08:55,250
但这种情况其实不符合软件工程

860
01:08:55,590 --> 01:08:56,830
或者不符合我们一般的思维

861
01:08:56,830 --> 01:08:58,970
我们希望把一些大的应用需求的

862
01:08:58,970 --> 01:09:00,590
拆成一个一个的功能模块

863
01:09:00,930 --> 01:09:04,270
然后实际上由相对独立的一些进程来完成

864
01:09:04,730 --> 01:09:06,470
那这个相对独立的进程完成的话

865
01:09:07,110 --> 01:09:08,190
进程之间是隔离的

866
01:09:08,190 --> 01:09:09,390
如果他们这边没有任何交互的

867
01:09:09,390 --> 01:09:10,090
没法进行合作

868
01:09:10,090 --> 01:09:11,790
所以我们还需要让他进行合作

869
01:09:11,790 --> 01:09:18,350
这种合作性,我们从这一章开始就进入了另外一个非常有意思也非常有挑战

870
01:09:18,350 --> 01:09:20,810
的一点,就是你要实现合作。

871
01:09:21,110 --> 01:09:29,950
如果相对独立,其实管好自己比较容易,但你要合作的话就存在他们之间有一些

872
01:09:29,950 --> 01:09:35,670
交互,这个交互性就会带来一些对OS设计来说的一些挑战。

873
01:09:35,670 --> 01:09:40,210
对我们应用来说,你就更加灵活了,你可以实现各种各样的,很方便的这

874
01:09:40,210 --> 01:09:43,210
种数据的传递、法文控制等等。

875
01:09:44,330 --> 01:09:51,030
但是OS要干什么?OS能确保这种交互是一种可靠的、不会出错的一种

876
01:09:51,030 --> 01:09:52,510
交互,这就比较麻烦。

877
01:09:52,730 --> 01:09:57,770
这就会进一步引入我们后面会讲到的所谓的并发错、并发执行

878
01:09:57,770 --> 01:09:58,610
等等一些的这种问题。

879
01:09:58,610 --> 01:10:04,650
但现在我们还在进程这个level,所以进程它帮我们做了隔离,我们说有这个地址

880
01:10:04,650 --> 01:10:10,330
空间,帮我们做了隔离,在这种情况下,出现错误的概率会小一些,这个是

881
01:10:10,330 --> 01:10:11,250
IBC这一块。

882
01:10:13,990 --> 01:10:17,170
由于有了IBC的引入之后,进程间通信的引入之后,我们可以把进

883
01:10:17,170 --> 01:10:21,590
程分成两大类,第一类是所谓的独立进程,这类进程就是我自己跑自己

884
01:10:21,590 --> 01:10:24,650
的,和别的进程没什么关系,这是独立进程。

885
01:10:24,650 --> 01:10:30,610
协作性是什么呢?这两个精神之间至少要传递数据和信息,这里面

886
01:10:30,610 --> 01:10:35,270
我们现在的网络是非常典型的协作式的,它需要在Client Service之间进行各

887
01:10:35,270 --> 01:10:38,710
种传输,这是这一点。

888
01:10:38,970 --> 01:10:44,210
这就涉及到所谓的发售和接收,这个很重要的一个情况。这里面我们给了例

889
01:10:44,210 --> 01:10:49,250
子,比如说Cat和Grip是两个应用程序。

890
01:10:49,250 --> 01:10:54,050
那么我们这个cat readme是干什么的,是把这个文件给显示出了

891
01:10:54,610 --> 01:11:02,090
grip是查找你的输入,你的字符输入里面是否有,有这么rcode这个关键

892
01:11:02,090 --> 01:11:02,450
字

893
01:11:03,450 --> 01:11:09,610
那么把它合在一起是什么意思呢,就是cat的输出,屏幕输出会作为grip的输

894
01:11:09,610 --> 01:11:09,850
入

895
01:11:10,550 --> 01:11:17,610
使得它们俩可以合作来完成对readme.md中rcode关键字的一个查询

896
01:11:17,610 --> 01:11:17,950
工作

897
01:11:18,290 --> 01:11:22,430
然后再可以查出来一系列的这个带拉二扣,因为这边带拉二扣,这也带了

898
01:11:22,430 --> 01:11:24,910
二扣,所以把这些查出来,没带二扣就查不出来。

899
01:11:25,510 --> 01:11:29,110
所以这就是用典型的那种进程间合作的一种方式。

900
01:11:29,290 --> 01:11:33,750
这种方式,你看这个一根出现什么?像管道。所以我们说这是一种管道的方式。

901
01:11:33,930 --> 01:11:40,130
这是我觉得UNIX超巨峰里面非常有意思的一个设计,就是搞了一根棍,看着就

902
01:11:40,130 --> 01:11:41,890
像管道一样来完成连接。

903
01:11:42,250 --> 01:11:43,950
这个是很有意思的一个design。

904
01:11:44,990 --> 01:11:50,030
好,那我们这里面稍微总结一下,就是把这个背景再总结一下,就是竞争间能够

905
01:11:50,030 --> 01:11:53,730
共享和传递数据就算是竞争间通讯,这是我们一个对竞争间通讯的

906
01:11:53,730 --> 01:12:00,750
一个简单的定义,那么在Unix里面有各种各样的IPC机制,这里面给

907
01:12:00,750 --> 01:12:08,330
了几类,第一类是Communication,我们通常说这个通信,包括Data Transfer,Data Transfer包括我们

908
01:12:08,330 --> 01:12:13,070
后面会讲到的PAP,包括你们正在上的网络课,如果你们正在上网络课,

909
01:12:13,210 --> 01:12:13,890
它的socket,

910
01:12:13,890 --> 01:12:17,790
这就是所谓的基于字节流的腾讯

911
01:12:17,790 --> 01:12:21,430
那么也有一些基于结构化的一些数据的一些腾讯

912
01:12:21,430 --> 01:12:26,910
更加灵活和更加有这种所谓的结构

913
01:12:26,910 --> 01:12:28,230
不像这里面没有结构

914
01:12:28,230 --> 01:12:30,210
那这边比如说这个消息队列

915
01:12:30,210 --> 01:12:31,490
这是一种

916
01:12:32,070 --> 01:12:33,950
还有这种数据包这种socket

917
01:12:34,410 --> 01:12:36,730
这是所谓的这种传输方式

918
01:12:36,730 --> 01:12:39,790
那么其实在我们没有讲NPC之前

919
01:12:39,790 --> 01:12:42,890
我们其实也有一种可以实现进程间共享的机制

920
01:12:42,890 --> 01:12:51,310
虽然我们没有重点题,就是share memory,大家都学了这个虚纯,所以都知道我们其实我们的

921
01:12:51,310 --> 01:12:57,090
超级种是把物理类存通过页表变成虚纯的方式,让我们的应用

922
01:12:57,090 --> 01:12:57,930
程序来访问。

923
01:12:58,410 --> 01:13:04,490
在这种情况下,如果我们两个进程,它们的虚粒子应用到同一块物理

924
01:13:04,490 --> 01:13:07,270
粒子,那意味着就是一种share。

925
01:13:07,970 --> 01:13:13,950
因为我对某一个地址的法文可以被另一个进程发现

926
01:13:13,950 --> 01:13:17,610
这里面就是所谓的share-mary这种方式

927
01:13:17,610 --> 01:13:20,590
同时我们现在可以跟文件来进行一个映射

928
01:13:20,590 --> 01:13:24,750
其实某种程度上来说,它也是可以作为一种共享的介质

929
01:13:24,750 --> 01:13:29,710
进程A,把数据写到这个文件里面去,关闭

930
01:13:29,710 --> 01:13:32,210
进程B,再把这个文件打开,读出

931
01:13:32,210 --> 01:13:34,730
这也完成了某种数据的共享

932
01:13:34,730 --> 01:13:40,410
只是,当然这种操作起来相当于说更加繁琐一点,我要对文件进行各种

933
01:13:40,410 --> 01:13:45,510
各样的操作才能玩这种东西,那像这种Pipe这种方式呢,更加

934
01:13:45,510 --> 01:13:52,270
简单一点,所以我们有不同的这种communication的方式,这是一类,这是关于数据的一

935
01:13:52,270 --> 01:13:58,210
种传输的一种方式,第二类signal,我们说信号,信号更多的这种通

936
01:13:58,210 --> 01:14:03,650
知,就是像铃声一样,很简洁,它就是一个铃声,通知我上课下课。

937
01:14:05,390 --> 01:14:06,990
这是我们上课用到的情况

938
01:14:06,990 --> 01:14:11,610
那么对于我们通常的超系统而言

939
01:14:11,610 --> 01:14:12,950
我可能需要说

940
01:14:12,950 --> 01:14:15,470
现在我要让这个程序给关掉

941
01:14:15,470 --> 01:14:17,150
Condorc一下就把它关掉了

942
01:14:17,150 --> 01:14:18,470
这也是一种信号机制

943
01:14:18,470 --> 01:14:21,550
然后这个程序访问了一个什么非法地址

944
01:14:21,550 --> 01:14:22,890
那我们的超系统通知说

945
01:14:22,890 --> 01:14:23,950
你访问非法地址了

946
01:14:23,950 --> 01:14:25,070
要把你杀掉

947
01:14:25,070 --> 01:14:26,410
也发出了个信号

948
01:14:26,410 --> 01:14:27,770
让你赶快停止

949
01:14:27,770 --> 01:14:30,450
这所谓的信号机制也很有用

950
01:14:30,450 --> 01:14:32,110
一种通知

951
01:14:32,110 --> 01:14:33,070
还有一种是同步

952
01:14:33,070 --> 01:14:44,090
这个我们后面会讲到的同步了,包括数、互次、条件变量、信号量等等。

953
01:14:44,330 --> 01:14:49,650
这一块对于有些书籍来说,它把它归为IPC机制。

954
01:14:49,930 --> 01:14:56,490
我们会放在后面讲解,讲这个并发操作的时候,会把这一块放在后面来

955
01:14:56,490 --> 01:14:56,610
讲。

956
01:14:56,610 --> 01:15:01,990
那我们在这一讲里面,我们重点是讲Data Transfer和这个Signal,

957
01:15:02,190 --> 01:15:14,290
把一种视线通知和一种数据传输,这种机制就是会集中在这一

958
01:15:14,290 --> 01:15:19,370
块,还有Signal,

959
01:15:19,550 --> 01:15:24,410
这里面甚至会设计到实现,那么在原理上讲解,原理上的简解包括什么

960
01:15:24,410 --> 01:15:24,590
呢?

961
01:15:25,070 --> 01:15:29,650
Message Queue,包含Share Memory,这是原理上的讲解

962
01:15:31,930 --> 01:15:36,510
这是我们这次课的内容,给大家简单的overview一下

963
01:15:36,510 --> 01:15:38,010
好,那我们看看

964
01:15:38,490 --> 01:15:42,310
既然说它能够既成间共享传递数据,就算既成间通讯的话

965
01:15:42,310 --> 01:15:47,430
其实我们在讲IPC之前,我们也有两种办法

966
01:15:48,130 --> 01:15:51,430
就是共享内存和文件,多个进程共享一块物内存

967
01:15:51,430 --> 01:15:53,330
多个进程可以访问同一文件

968
01:15:54,970 --> 01:16:00,190
这里面又有一个通讯方式的定义,叫做直接通讯和间接通讯

969
01:16:00,190 --> 01:16:04,390
这个直接通讯什么意思?就是两个进程之间不需要通过内核的中转就可以相互

970
01:16:04,390 --> 01:16:04,830
发消息

971
01:16:04,830 --> 01:16:09,970
比如ShareMemory它这两个进程都对同一个物理地址进行读和写

972
01:16:09,970 --> 01:16:10,730
操作

973
01:16:10,730 --> 01:16:14,850
这个过程完全不需要通过OS,这是用直接通讯

974
01:16:14,850 --> 01:16:20,030
但间接通讯就是说你这个所谓的这种传递数据的方式都绕不过

975
01:16:20,030 --> 01:16:20,390
内核

976
01:17:20,390 --> 01:17:25,930
绝大部分的这个IPC机制都是要通过内核的

977
01:17:25,930 --> 01:17:27,830
所以它是一种间接的发射

978
01:17:27,830 --> 01:17:32,890
那是不是还有除共享内存之外的一些直接通用的方式呢

979
01:17:32,890 --> 01:17:35,090
有,你只要知道屏下标准就行了

980
01:17:35,090 --> 01:17:37,370
就是它经过内核的一个中轴

981
01:17:37,370 --> 01:17:40,070
或者是不是要经过内核的处理之后才能完成

982
01:17:40,070 --> 01:17:42,410
而不像这个ShareMemory一样

983
01:17:42,410 --> 01:17:44,210
整个过程中不需要内核的介入

984
01:17:44,830 --> 01:17:49,310
这是取决于你怎么去判断这个直接间接的一个原则

985
01:17:50,830 --> 01:17:55,790
那基于这种方式,我们后面讲到的管道,消息对列,信号,socket,其实都

986
01:17:55,790 --> 01:17:57,150
算是一种间接通讯

987
01:17:57,150 --> 01:17:59,210
但他们的含义是不一样的

988
01:17:59,210 --> 01:18:01,170
管道实际上是单方向传送字节流

989
01:18:02,210 --> 01:18:05,350
消息对列是通过对列来收发消息

990
01:18:05,350 --> 01:18:07,450
我可以对消息有一个标识

991
01:18:07,450 --> 01:18:10,830
所以它不是一个纯粹的单方向

992
01:18:12,150 --> 01:18:15,770
这是顺序的一个收获的发

993
01:18:15,770 --> 01:18:17,390
而这个可以不顺序

994
01:18:17,390 --> 01:18:21,070
也可以是以结构方式来进行收发

995
01:18:21,070 --> 01:18:23,390
就是以数据结构一块一块的进行收发

996
01:18:23,390 --> 01:18:24,190
这是小业队列

997
01:18:24,190 --> 01:18:25,390
信号呢

998
01:18:25,390 --> 01:18:30,130
它其实主要目的不是为了能够传递大量的数据

999
01:18:30,130 --> 01:18:31,450
而是发一个通知

1000
01:18:31,450 --> 01:18:32,290
发个Event

1001
01:18:32,290 --> 01:18:34,870
所以信号的标识就是一个整形

1002
01:18:34,870 --> 01:18:36,010
非常简单的一个整形

1003
01:18:36,010 --> 01:18:40,550
代表一个信号的一个不同的含义

1004
01:18:40,550 --> 01:18:45,830
socket的网络这个留给网络课的老师进一步给大家讲解

1005
01:18:45,830 --> 01:18:50,370
我们这里面只是提一下就OK了

1006
01:18:50,370 --> 01:18:50,870
好

1007
01:18:52,370 --> 01:18:54,970
那我们说前面讲的直接通信建成两种方式

1008
01:18:54,970 --> 01:18:56,350
它的发送接口

1009
01:18:56,350 --> 01:18:58,930
一般来说有这个send receive

1010
01:18:59,810 --> 01:19:04,150
这是我们看到的在网络里面通常用的两个词

1011
01:19:04,150 --> 01:19:06,330
那么对于我们超级统来说一般用什么词呢

1012
01:19:06,330 --> 01:19:07,630
用write和read

1013
01:19:13,150 --> 01:19:18,590
这说明了什么,这说明了我们都是把这些方式看成了一种File来进

1014
01:19:18,590 --> 01:19:24,990
行处理,这个等于是File的含义不仅仅是说它代表的只是一个Disk

1015
01:19:24,990 --> 01:19:32,030
上的一段数据,它还代表了其他的一些交互的一些抽象,所以这个File的

1016
01:19:32,030 --> 01:19:37,110
抽象没发现它在进一步扩大,就它抽象的范围在扩大,这数据

1017
01:19:37,110 --> 01:19:40,450
这一块,第二块呢,实际上不光是说我们要传递数据,我们还可以

1018
01:19:40,450 --> 01:19:44,770
进行远程的这种 Remote Procedural Core 叫 RPC

1019
01:19:45,390 --> 01:19:48,850
这个 Remote Procedural Core 实际上它是把数据

1020
01:19:48,850 --> 01:19:52,390
以数据的方式来完成了对这个

1021
01:19:52,390 --> 01:19:54,670
类似于函数调用这样的一种操作

1022
01:19:54,670 --> 01:19:55,630
但是用远程的操作

1023
01:19:55,630 --> 01:19:58,450
比如说进程A给进程B发了一个函数调用

1024
01:19:58,450 --> 01:20:00,450
那怎么来做就是 RPC 方式

1025
01:20:00,450 --> 01:20:03,650
但这种方式我们并不会展开讲解

1026
01:20:03,650 --> 01:20:04,630
但大家要知道

1027
01:20:04,630 --> 01:20:06,690
这种方式也是大量存在

1028
01:20:10,250 --> 01:20:19,490
Android裡面有大量的RPC方式來實現所謂的進程間的一種訪問

1029
01:20:19,490 --> 01:20:24,950
它服務的很好,這樣可以靈活的來完成進程間的一種合作

1030
01:20:24,950 --> 01:20:27,170
包括還最快的回覆消息等等

1031
01:20:27,610 --> 01:20:30,230
這是我們說消息傳遞的一些基本接口

1032
01:20:33,170 --> 01:20:37,890
那这个你发消息发完之后呢,其实还需要注意一点,它有这个所谓的主色和

1033
01:20:37,890 --> 01:20:39,770
非主色这么一个特点。

1034
01:20:40,030 --> 01:20:44,630
所以主色就是比如说READ,我发出这个READ操作之后,发出这个操作之后

1035
01:20:44,630 --> 01:20:46,810
呢,要经历这么一系列的过程。

1036
01:20:47,190 --> 01:20:52,370
我们说进入超级桶,超级桶里面会去查,从第四个读,读完之后再

1037
01:20:52,370 --> 01:20:55,530
写回到用户空间,然后最后才返回。

1038
01:20:55,530 --> 01:21:02,130
那么在这个过程中,你这个进程挡在这儿,你这个read不会返回。

1039
01:21:03,110 --> 01:21:10,710
这个阻射的含义很直白,这是阻射,这是阻射的一种接收方式,接收阻

1040
01:21:10,710 --> 01:21:11,570
射的发送方式。

1041
01:21:11,730 --> 01:21:20,550
我write也是一样,我真正写回,write是send,真正写回之后才返回,这个阻

1042
01:21:20,550 --> 01:21:23,170
射的时间也是比较长,是随着阻射发送。

1043
01:21:24,090 --> 01:21:32,650
这是一种情况,还有一种情况是我只是把这个请求发出去了,这个数据并没有读到,我就

1044
01:21:32,650 --> 01:21:37,510
快速发回来,这是一种非组织的方式,这同样是一样,也非组织节

1045
01:21:37,510 --> 01:21:38,550
奏发送的方式。

1046
01:21:38,950 --> 01:21:42,570
那么既然没有完成之后,它可以干其他事儿,它可以干其他事情。

1047
01:21:42,570 --> 01:21:49,390
然后当我们的OS完成之后,通过那种方式通知,通知就是通知,这种易步

1048
01:21:49,390 --> 01:21:53,930
通知,因为我这时候正在干其他事情,我并没有等在这儿。

1049
01:21:54,010 --> 01:22:00,890
那么它会打断当前正在的执行,然后去响应这个通知,然后再完成后续的

1050
01:22:00,890 --> 01:22:03,550
事情,这所谓的非主涉IP的方式。

1051
01:22:03,690 --> 01:22:10,190
那这种通知就是我们后面讲的SIG signal,就可以帮助你完成这种易步的通

1052
01:22:10,190 --> 01:22:10,710
知方式。

1053
01:22:10,710 --> 01:22:13,770
这就是所谓的这个主设和非主设两种模式

1054
01:22:14,530 --> 01:22:16,770
相当于说主设方式比较容易实现

1055
01:22:16,770 --> 01:22:19,570
异步这种非主设方式比较困难一点

1056
01:22:20,510 --> 01:22:22,590
然后既然你要传输数据的这个数据

1057
01:22:22,590 --> 01:22:24,510
又特别是在经过内核的情况下

1058
01:22:24,510 --> 01:22:25,690
这个内核是一个中间

1059
01:22:25,690 --> 01:22:26,590
作为一个中间

1060
01:22:27,650 --> 01:22:28,670
中间层存在的话

1061
01:22:28,670 --> 01:22:30,030
那么这个内核

1062
01:22:30,030 --> 01:22:31,890
你这中间的缓冲有多少

1063
01:22:32,890 --> 01:22:33,730
那有几种方式

1064
01:22:33,730 --> 01:22:34,830
无限缓冲

1065
01:22:34,830 --> 01:22:36,670
所以无限缓冲其实也不是真正的无限

1066
01:22:36,670 --> 01:22:37,730
只是说

1067
01:22:37,730 --> 01:22:40,690
你在内核里面的这个buffer远大于要发送的数据

1068
01:22:40,690 --> 01:22:42,210
然后这称之为一个无线缓冲

1069
01:22:42,210 --> 01:22:43,370
比如这里面这么一点点

1070
01:22:43,370 --> 01:22:44,770
但是这里面有这么多

1071
01:22:44,770 --> 01:22:48,330
还有一种是buffer内存小于要发生的数据

1072
01:22:48,330 --> 01:22:49,330
这有线缓冲

1073
01:22:49,330 --> 01:22:52,290
因为它总会发现我不停的塞的时候

1074
01:22:52,290 --> 01:22:54,330
可能这里面空间不够了

1075
01:22:54,330 --> 01:22:55,250
满了

1076
01:22:55,250 --> 01:22:56,770
会出现这种情况就是有线缓冲

1077
01:22:57,750 --> 01:22:59,450
还有一种零缓冲

1078
01:22:59,450 --> 01:23:00,450
没有缓冲

1079
01:23:00,870 --> 01:23:01,690
没有缓冲的话

1080
01:23:01,690 --> 01:23:04,790
我要发的时候必须要等这边迅速的从这里面接

1081
01:23:04,790 --> 01:23:05,470
一个一个接

1082
01:23:05,470 --> 01:23:07,530
中间我不设置这种缓冲区

1083
01:23:07,530 --> 01:23:08,710
没有缓冲区

1084
01:23:08,710 --> 01:23:09,570
这是零缓冲方式

1085
01:23:09,570 --> 01:23:10,490
这是不同的实验方式

1086
01:23:10,490 --> 01:23:13,690
对于我们一般来说,我们会实现有线缓冲比较容易一点

1087
01:23:17,730 --> 01:23:22,190
而且效率会高一些,这是我们对缓冲的方式的一个介绍

1088
01:23:22,950 --> 01:23:26,750
前面是大致的对这个IPC做了一个 review

1089
01:23:26,750 --> 01:23:30,330
那我们现在讲具体的IPC机制,第一种管道

1090
01:23:30,330 --> 01:23:36,750
管道是UNIX里面非常经典的一种近人间通信的手段

1091
01:23:36,750 --> 01:23:42,890
它借助了Five抽象来完成了进程之间的一种数据的传递

1092
01:23:43,570 --> 01:23:45,450
我们可以看看这里面管道怎么回事

1093
01:23:45,450 --> 01:23:46,570
但是它大致的示意图

1094
01:23:46,570 --> 01:23:51,990
这个示意图就是进程A通过管道向进程B传递数据

1095
01:23:52,910 --> 01:23:55,370
那么整个这个管道也是具有同样的一个特点

1096
01:23:55,370 --> 01:23:57,810
这个读写是一个字节的一个序列

1097
01:23:57,810 --> 01:24:00,450
那么它是按照序列按照顺序

1098
01:24:01,070 --> 01:24:04,410
sequential这种方式来进行数据的读写

1099
01:24:05,910 --> 01:24:10,830
比如说我写了我send了第一个字节,接下来第二个字节一定在第一个字

1100
01:24:10,830 --> 01:24:15,070
节之后来send,不能说我第二个字节会放第一个字节前面去了,这是不允

1101
01:24:15,070 --> 01:24:17,390
许的,所谓的不是这种sequential的方式。

1102
01:24:17,650 --> 01:24:21,110
整个管道的处理是以文件的方式来描述,用文件描述服务来

1103
01:24:21,110 --> 01:24:25,270
表示,所以这怎么操作就可以基于文件的方式来进行操作。

1104
01:24:25,270 --> 01:24:33,650
只是在最开始创建的时候,稍微特别一点,它是要创建一个双文件描述符这么

1105
01:24:33,650 --> 01:24:40,130
一个结构,这后面会逐一展开讲解,就这个。

1106
01:24:42,030 --> 01:24:46,730
这是它的,不像我们的叫Open,我们打开一个文件叫Open,是打开一个管道用Type

1107
01:24:46,730 --> 01:24:51,570
为什么要用Type呢,是在于Open只打开了一个FD,而Type要打开两个

1108
01:24:51,570 --> 01:24:52,350
FD

1109
01:24:52,350 --> 01:24:56,070
一个FD要容易读,另一个FD容易写,所以要打开两个

1110
01:24:56,730 --> 01:24:57,750
这是这一块

1111
01:24:57,750 --> 01:25:02,690
那么我们的内核在看到这个Type系统的样子的时候呢,我还要准备好一块

1112
01:25:02,690 --> 01:25:04,090
buffer

1113
01:25:04,090 --> 01:25:10,930
这是一块空间,一块空间加两个FD,这是两个FD,来形成对内核

1114
01:25:10,930 --> 01:25:16,130
里面结构的一个设置,这样才能够完成后续的一个操作。

1115
01:25:16,410 --> 01:25:27,070
你看这里面可以看出来,我打开了空开pipe,打开了两个FD之后,我会把

1116
01:25:27,070 --> 01:25:29,150
其中一个用于读,一个用于写。

1117
01:25:29,510 --> 01:25:34,390
如果我是关注读的话,我会把写给关闭掉,不是关注写的话,我会把读给关

1118
01:25:34,390 --> 01:25:35,350
闭掉。

1119
01:25:35,790 --> 01:25:40,910
这里面看到也很奇怪,现在这个Process A和Process B,他们怎么去用同一个FB呢?

1120
01:25:42,130 --> 01:25:43,630
这又涉及到我们进程的Fock。

1121
01:25:45,890 --> 01:25:50,490
我们的进程通过,假如这是主进程或者副进程的话,那么这是只进程。

1122
01:25:50,990 --> 01:25:53,070
那么主进程通过Fock会创建只进程。

1123
01:25:53,710 --> 01:25:58,110
创建只进程的时候呢,只进程会继承副进程的所有的资源,

1124
01:25:58,990 --> 01:26:01,180
包括FDTable里面的打开的文件

1125
01:26:04,130 --> 01:26:04,470
所以

1126
01:26:04,470 --> 01:26:08,350
你这个PAP,主机程执行到PAP之后,再进行放的时候呢

1127
01:26:08,910 --> 01:26:09,770
你的直径程

1128
01:26:09,770 --> 01:26:13,410
也拥有这两个FD,也能看到这两个FD

1129
01:26:13,410 --> 01:26:14,070
那么

1130
01:26:14,070 --> 01:26:14,790
那么就

1131
01:26:15,830 --> 01:26:17,570
会存在一个

1132
01:26:19,110 --> 01:26:19,950
Buffer

1133
01:26:19,950 --> 01:26:22,210
通过两个FD来进行访问的情况

1134
01:26:22,750 --> 01:26:27,190
如果我要做Send操作,那么我会把这个主机程把这个FD1给关掉

1135
01:26:27,750 --> 01:26:32,290
我要做Receive操作,我这里面会把这个FD0给关掉

1136
01:26:32,290 --> 01:26:39,470
这样的话,我通过主进程,就是附进程通过FD0来进行所谓的Read操

1137
01:26:39,470 --> 01:26:40,550
作

1138
01:26:40,550 --> 01:26:48,190
然后FD,此进程Process B呢,通过FD1来做这个Read操作

1139
01:26:50,190 --> 01:26:54,330
那么它中间这个数据呢,就在这里面,就放在这个所谓的缓冲区里面

1140
01:26:54,330 --> 01:26:59,250
这样就可以很灵活的完成两个进程的一个数据的传递了

1141
01:26:59,250 --> 01:27:02,770
这是它的一个大致的一个指引过程

1142
01:27:02,770 --> 01:27:04,950
这里面就是前面的指引层会继承

1143
01:27:04,950 --> 01:27:06,390
指引层会继承

1144
01:27:06,390 --> 01:27:07,730
这一本就描述服务

1145
01:27:10,450 --> 01:27:11,550
需要注意一点

1146
01:27:11,550 --> 01:27:20,690
它仅仅是继承了这个FD

1147
01:27:23,030 --> 01:27:27,090
它复制了一个Dtable,但它并没有把这个buffer复制

1148
01:27:27,090 --> 01:27:33,870
这个buffer只有一个buffer,并没有又fork了一下

1149
01:27:33,870 --> 01:27:36,510
只有把buffer也fork了,变成两个buffer

1150
01:27:36,510 --> 01:27:39,690
没有,大家其实看实现就会更加清楚一点

1151
01:27:40,790 --> 01:27:42,790
当我把这个相机关掉之后呢

1152
01:27:42,790 --> 01:27:48,070
那我就可以做这种所谓的一个读一个写的操作了

1153
01:28:18,070 --> 01:28:20,750
这是一个比较有挑战的事情

1154
01:28:20,750 --> 01:28:22,590
比如这不是一个负质关系

1155
01:28:22,590 --> 01:28:25,470
应该怎么来实现他们管道的一个创建

1156
01:28:25,470 --> 01:28:26,250
大家想一想

1157
01:28:28,450 --> 01:28:32,010
如果我有个A进程

1158
01:28:32,010 --> 01:28:33,230
有个B进程

1159
01:28:33,230 --> 01:28:33,910
这两个程序

1160
01:28:33,910 --> 01:28:34,970
AB是两个程序

1161
01:28:35,490 --> 01:28:38,550
那么请问你怎么能够让他们

1162
01:28:38,550 --> 01:28:41,210
能够看到同一个PAP

1163
01:28:45,270 --> 01:28:46,650
这是一个问题

1164
01:28:48,170 --> 01:29:00,610
我看看这个,我又提了一个问题,现在聊天,聊天打不开吗,OK,第二个问题出现了,

1165
01:29:00,810 --> 01:29:04,410
然后请同学能够在三层的这里回答一下这个问题。

1166
01:29:04,890 --> 01:29:10,770
AB两个进程,我现在是父子才能够共享这个,那现在AB两个进程不是两

1167
01:29:10,770 --> 01:29:14,410
个代码,我只能跟他共享一个PAP,只能说这一步。

1168
01:29:15,690 --> 01:29:17,410
请问你有什么办法?

1169
01:29:18,690 --> 01:29:24,670
有同学能够在聊天区里面回答一下吗?其实我希望每个人都回答,但是

1170
01:29:24,670 --> 01:29:26,490
这样又显得我太强势了。

1171
01:29:26,990 --> 01:29:34,490
所以我只能请大家想回答就回答,不想回答就等我回答

1172
01:29:36,430 --> 01:29:39,310
有同学能回答吗?我正好可以喝口水

1173
01:30:13,790 --> 01:30:19,450
如果要是想要A和B两个程序来执行的话

1174
01:30:20,410 --> 01:30:22,650
而且它A和B之间不是父子关系

1175
01:30:22,650 --> 01:30:24,070
那我怎么来做这个事情

1176
01:30:25,090 --> 01:30:26,470
那其实我们

1177
01:30:26,470 --> 01:30:28,530
是靠另外一个东西

1178
01:30:28,530 --> 01:30:29,950
我看这里面后面有没有讲

1179
01:30:30,710 --> 01:30:32,730
这也其实没讲

1180
01:30:32,730 --> 01:30:34,470
在这来看吧

1181
01:30:35,390 --> 01:30:36,710
看这个图吗

1182
01:30:36,710 --> 01:30:38,470
看这个图

1183
01:30:39,490 --> 01:30:40,530
还有一个东西

1184
01:30:45,950 --> 01:30:46,910
share

1185
01:30:46,910 --> 01:30:49,110
大家前面其实关注的是什么

1186
01:30:49,110 --> 01:30:51,310
share 我前面有个cat

1187
01:30:51,310 --> 01:30:52,570
一个file

1188
01:30:53,430 --> 01:30:54,590
file1 然后一个

1189
01:32:24,990 --> 01:32:31,590
这个大家可以看到,假设我前面,这是属于cat,这个属于我们说的grip

1190
01:32:34,130 --> 01:32:38,950
这是两个紫进层,然后它上面有个share是复进层

1191
01:32:38,950 --> 01:32:43,710
那么share一开始创建的时候,每个进度创建的时候都会在它012这三项建

1192
01:32:43,710 --> 01:32:46,090
立一个所谓的一个标准的Io文件

1193
01:32:46,090 --> 01:32:49,770
就SDIN,SDOUT,SDARO,我们做点困两个就行

1194
01:32:49,770 --> 01:32:53,570
IN就是读,OUT就是写

1195
01:32:55,350 --> 01:32:58,850
那么我们进程在做相应处理的时候

1196
01:32:59,850 --> 01:33:03,890
我们会share,会在创建cat的时候

1197
01:33:03,890 --> 01:33:07,490
会把他的,会把他什么,会把他这个

1198
01:33:09,050 --> 01:33:20,870
stdint给,stout给,我看应该是把这个关掉,把这个stdout给关了,把

1199
01:33:20,870 --> 01:33:22,190
这个关了之后意味着什么?

1200
01:33:22,810 --> 01:33:27,430
意味着这个e这个地方是free的,是空的,这样是空的。

1201
01:33:28,510 --> 01:33:33,610
然后这个时候呢,我再去,我还创建了一个pipe,这不是创建两个pipe吗?

1202
01:33:33,610 --> 01:33:37,950
然后我要做一个比如说做一个DAPDUP

1203
01:33:37,950 --> 01:33:39,830
这是一个系统调用

1204
01:33:39,830 --> 01:33:41,390
DAP一个FD

1205
01:33:41,390 --> 01:33:43,490
DAP一个FDPUB1

1206
01:33:44,310 --> 01:33:46,570
就是PFE

1207
01:33:46,570 --> 01:33:48,430
DAP的时候我们的超级统

1208
01:33:49,230 --> 01:33:57,830
会查找在这个FD table中的编号最小的空余项

1209
01:33:57,830 --> 01:33:58,530
那意味着什么呢

1210
01:33:58,530 --> 01:34:00,050
我刚刚不是把这个F1给关了吗

1211
01:34:00,050 --> 01:34:01,410
把这1给关了吗

1212
01:34:01,410 --> 01:34:02,170
Close1了吗

1213
01:34:02,170 --> 01:34:04,850
我做了一个CloseE这么一个操作

1214
01:34:04,850 --> 01:34:07,770
做可疑它说了之后呢 这里是空的了

1215
01:34:07,770 --> 01:34:09,530
所以我dub的时候 我要分配的时候

1216
01:34:09,530 --> 01:34:13,390
相当于是把这个这里面这个iNode的信息

1217
01:34:13,390 --> 01:34:14,510
也填到这里面来了

1218
01:34:14,510 --> 01:34:18,710
它们指向同一个iNode

1219
01:34:18,710 --> 01:34:21,090
它都指向同一个iNode

1220
01:34:21,090 --> 01:34:23,330
这复制了一份 这dub的意思

1221
01:34:24,830 --> 01:34:26,430
那复制了一份之后呢

1222
01:34:26,430 --> 01:34:30,190
意味着我接下来再让这个cat

1223
01:34:30,190 --> 01:34:36,970
我创建了cat,作为所谓的这个输出的时候,是基于stdout的输出的,那就

1224
01:34:36,970 --> 01:34:41,830
变成了基于这个输出,意味着它就写到这,写到buffer去了,这是inode

1225
01:34:41,830 --> 01:34:49,470
指向实际上的buffer,是pip,pip的buffer,而之前的这个e指向

1226
01:34:49,470 --> 01:34:58,310
哪,还是一定要指向的是uart这样的串口,就把这个改成了这个地方,做了一次修改,

1227
01:34:58,390 --> 01:35:00,170
这谁来改的,sher来改的,

1228
01:35:00,190 --> 01:35:04,550
Share改了之后 我在去创建紫晶层的时候

1229
01:35:04,550 --> 01:35:08,390
紫晶层不知道 紫晶层我作为Cat而言

1230
01:35:08,390 --> 01:35:11,810
我前一时认为012都是上运报建好了

1231
01:35:11,810 --> 01:35:14,930
我就是往sd-out输出 应该输出到串口上去

1232
01:35:14,930 --> 01:35:17,410
但其实你输出到了pipe上去

1233
01:35:17,410 --> 01:35:19,030
这一步是Share帮我们做好的

1234
01:35:19,030 --> 01:35:20,630
同理也是一样的

1235
01:35:20,630 --> 01:35:23,730
Grip它认为它的输入来自于sd-in

1236
01:35:24,650 --> 01:35:26,750
其实我们通过刚才那种方式

1237
01:35:26,750 --> 01:35:33,490
我们的share也把这个stdint变成了fd0这一块

1238
01:35:34,070 --> 01:35:38,990
所以我们的stdout是往pipe里面写

1239
01:35:38,990 --> 01:35:42,630
stdint的读是从pipe里面去读 读操作

1240
01:35:42,630 --> 01:35:45,730
这样就可以实现两个不相干的进程

1241
01:35:45,730 --> 01:35:47,650
在相互不知道的情况下

1242
01:35:47,650 --> 01:35:50,010
通过我们的share 通过我们的副进程

1243
01:35:50,010 --> 01:35:51,550
帮他们建立好管道

1244
01:35:51,550 --> 01:35:54,530
帮他们建立好这种所谓的这种重用机制

1245
01:35:54,530 --> 01:36:00,530
重新复制了一下 来实现了一种灵活的组合

1246
01:36:00,530 --> 01:36:05,050
把它的输出作为Grip的输入

1247
01:36:05,050 --> 01:36:08,270
通过这两个来进行相应的操作

1248
01:36:08,270 --> 01:36:12,270
这个就是我们讲的这个管道实现的非常有意思的一个特点

1249
01:36:12,270 --> 01:36:18,370
实现了任意两个进程的灵活的数据交换

1250
01:36:19,330 --> 01:36:21,090
OK 那咱们休息一下

1251
01:39:51,530 --> 01:39:53,430
老师我能问个问题吗

1252
01:41:24,810 --> 01:41:26,950
好,我们继续开个商课

1253
01:41:27,910 --> 01:41:31,530
刚才我看到那个聊天区里面两位同学在聊天,挺好的

1254
01:41:46,250 --> 01:41:51,530
这个我可能还要再等会了,现在我不足以回答这些问题了

1255
01:41:52,190 --> 01:41:53,790
咱们先继续讲解吧

1256
01:41:55,490 --> 01:42:02,170
讲这个管道机制可以灵活实现不同进程之间来进行这个数据贡献,数

1257
01:42:02,170 --> 01:42:07,250
据传递,这是他的一个大致的一个思路给大家介绍,主要是通过share,所以sh

1258
01:42:07,250 --> 01:42:07,930
are很重要。

1259
01:44:08,270 --> 01:44:10,550
我们所谓的任意两个进程的一个原因

1260
01:44:11,370 --> 01:44:13,650
那由于这种所谓的父子关系和自主关系的联系

1261
01:44:13,650 --> 01:44:15,430
我们可以非常方便的用PAC

1262
01:44:15,430 --> 01:44:17,190
这是所谓的匿名管道

1263
01:44:17,810 --> 01:44:21,730
但是如果我们要想让任意两个进程进行这种通讯的话

1264
01:44:21,730 --> 01:44:24,150
也想用这种类似于管道上的机制的话

1265
01:44:24,150 --> 01:44:29,010
那我们就一定要有一个大家能够找到一个所谓的一个一个一个编码

1266
01:44:29,010 --> 01:44:31,470
这个编码什么就是一个管道的名字

1267
01:44:32,730 --> 01:44:34,770
所以对于Unix而言呢

1268
01:44:34,770 --> 01:44:37,170
它还有专门的一种所谓的有名管道这种机制

1269
01:44:37,170 --> 01:44:38,350
或者秘密管道

1270
01:44:38,350 --> 01:44:42,490
它专门建立了叫Make MK FIFO

1271
01:44:42,490 --> 01:44:44,950
这FIFO实际上体现了这个所谓的读写的方式

1272
01:44:45,570 --> 01:44:47,550
就是先进先出的这种读写方式

1273
01:44:47,550 --> 01:44:51,310
从这种方式能够实现所谓的一个有名管道和秘密管道

1274
01:44:51,310 --> 01:44:54,410
可以支持任意进程间的数据通信

1275
01:44:54,410 --> 01:44:58,350
那么这个文件本身

1276
01:44:58,350 --> 01:45:00,130
这文件本身是存在磁盘上的

1277
01:45:00,130 --> 01:45:00,470
需要注意

1278
01:45:00,470 --> 01:45:01,470
它不像我们的Pipe

1279
01:45:01,470 --> 01:45:03,030
整个是在内存中

1280
01:45:03,450 --> 01:45:08,990
这个文件本身存在磁盘上,本身只是指它的inode信息,它本身并不具

1281
01:45:08,990 --> 01:45:15,010
有那种data,因为它不需要data,data是memory,所以从这种方式我们可以建

1282
01:45:15,010 --> 01:45:19,550
立一个所谓的有名管道,对有名管道进行这样的操作,那需要注意的是,无

1283
01:45:19,550 --> 01:45:25,250
论是有名还是无名管道,都是专项统计仪式,这是需要注意的。这里面给了个

1284
01:45:25,250 --> 01:45:31,250
例子,这里面第一步我们建好了一个有名管道,你看这里面有个P,代表它的属性

1285
01:45:31,250 --> 01:45:33,010
是有名管道的一个含义。

1286
01:46:14,710 --> 01:46:23,370
一边做读,同时做写的话会出现奇怪的现象,因为它opted只有一个,这是这一

1287
01:46:23,370 --> 01:46:23,650
块。

1288
01:46:24,370 --> 01:46:31,530
如果想要解决这种所谓的更加复杂点的情况,比如说你要基于某种数

1289
01:46:31,530 --> 01:46:32,970
据结构还有先后顺序,

1290
01:46:32,970 --> 01:46:38,310
而这个顺序我可以提前读一个,厚读一个,这个消息本身或者这个数据本身是

1291
01:46:38,310 --> 01:46:39,550
有一定的编号的

1292
01:46:39,550 --> 01:46:44,950
如果这么一些复杂的需求的话,那么我们可以建立一个更加复杂的或者灵活的一

1293
01:46:44,950 --> 01:46:47,210
种机制,称之为消息对列

1294
01:46:47,210 --> 01:46:51,230
这个消息对列的机制就是由超线维护一个以结构数据为单位的见

1295
01:46:51,230 --> 01:46:52,190
解通信机制

1296
01:46:52,190 --> 01:46:56,170
每一个消息是放在消息对列里面的,是一个字节序列

1297
01:46:56,490 --> 01:47:02,870
但是它和刚才那个不一样,在于刚才是整个buffer是一个buffer

1298
01:47:02,870 --> 01:47:05,270
然后大家都是一样的一个字节流

1299
01:47:05,270 --> 01:47:07,230
而这里面的一个消息是一个

1300
01:47:08,050 --> 01:47:08,690
单元

1301
01:47:08,690 --> 01:47:11,150
每个消息有自己的一个类型标识

1302
01:47:12,130 --> 01:47:15,990
那比如说这个消息1,P2发消息2,P1发消息1

1303
01:47:15,990 --> 01:47:18,690
这边可能有大量的消息1消息2的

1304
01:47:18,690 --> 01:47:20,210
一个形成的对列

1305
01:47:20,210 --> 01:47:21,510
那么接收方呢

1306
01:47:21,510 --> 01:47:24,990
我可以只接收消息1的,那我会从这个对列里面自把消息1给领

1307
01:47:24,990 --> 01:47:25,610
出来

1308
01:47:25,610 --> 01:47:27,830
这样消息2我就跳过了

1309
01:47:27,830 --> 01:47:29,310
这就是所谓这个

1310
01:47:29,310 --> 01:47:30,150
它可以

1311
01:47:30,970 --> 01:47:32,650
有一定的灵活性

1312
01:47:32,650 --> 01:47:36,190
来完成有更加方便的消息的传递

1313
01:47:36,190 --> 01:47:37,870
这是它的一个大致的处理过程

1314
01:47:37,870 --> 01:47:39,790
这里面

1315
01:47:40,590 --> 01:47:41,650
遭遇麻烦点是你看

1316
01:47:41,650 --> 01:47:43,770
它有所谓的一个Key

1317
01:47:43,770 --> 01:47:46,310
Key是为了建立所谓的一个

1318
01:47:46,310 --> 01:47:47,370
消息队列的ID

1319
01:47:47,370 --> 01:47:49,150
这是我们建立的消息队列

1320
01:47:49,630 --> 01:47:52,970
有Key能建出一个消息队列

1321
01:47:52,970 --> 01:47:54,130
然后这个消息队列

1322
01:47:54,130 --> 01:47:57,810
能够通过Send和Receive这个操作

1323
01:47:57,810 --> 01:47:58,950
这是Send

1324
01:48:01,510 --> 01:48:07,910
这是Receive来形成一个匹配,这个发送这个接收,这里面会有相应的一些消

1325
01:48:07,910 --> 01:48:18,790
息对每一个的消息,然后通过Control可以把这个对列给删除掉,这是相应的

1326
01:48:18,790 --> 01:48:19,950
一个处理。

1327
01:48:23,390 --> 01:48:29,890
这里面我们看到了前面说的这个Message是有一个它的一个ID信息的,就是相当

1328
01:48:29,890 --> 01:48:31,450
于它的一个类型信息,

1329
01:48:31,470 --> 01:48:35,830
这里面就有一个,比如说这里面这个这是一个消息,这是另外一个消息。

1330
01:48:36,070 --> 01:48:44,790
在这里面呢,属于E这个类型的有三个消息,比如说这三个,E,E,E。

1331
01:48:47,250 --> 01:48:51,910
那么这里面会按照它这个消息类型来进行一个链接

1332
01:48:51,910 --> 01:48:54,430
同时你这里面还有一个顺序

1333
01:48:54,430 --> 01:48:57,210
就整个这个红线链接的顺序就是按这个来

1334
01:48:57,210 --> 01:48:59,270
一个一个的链起来 串起来的

1335
01:48:59,270 --> 01:49:01,130
那么我用了这两部分这个信息之后呢

1336
01:49:01,130 --> 01:49:06,390
我就可以让接收者可以由选择的来选择

1337
01:49:06,390 --> 01:49:07,830
比如我只接收一的

1338
01:49:07,830 --> 01:49:10,390
或者先接收一再接收二的这个消息

1339
01:49:10,390 --> 01:49:13,450
来完成对这个消息队列里面的数据的一个访问

1340
01:49:13,450 --> 01:49:15,730
这是它的一个灵活的一个方式

1341
01:49:15,730 --> 01:49:18,030
这是它对应的一个数据结构的一个进一步的表示

1342
01:49:18,970 --> 01:49:20,490
我不会太深入讲解

1343
01:49:20,490 --> 01:49:23,730
大家可以看看一个Message里面包含了一个Type

1344
01:49:23,730 --> 01:49:27,450
和它对应的一个字部序列

1345
01:49:31,530 --> 01:49:34,530
Send和Receive都有相应的一个

1346
01:49:34,530 --> 01:49:36,890
你对哪个消息队列进行发送

1347
01:49:36,890 --> 01:49:38,650
对哪个消息队列进行接收

1348
01:49:38,650 --> 01:49:41,330
这里面它的那个Flag是啥

1349
01:49:41,330 --> 01:49:43,310
这现在是一些控制性性的

1350
01:49:43,310 --> 01:49:44,890
主要是这个buffer和side

1351
01:49:45,970 --> 01:49:47,390
然后这里面很重要一点

1352
01:49:47,390 --> 01:49:49,010
就是receive的一个type

1353
01:49:50,310 --> 01:49:51,490
这是type上面一个

1354
01:49:51,490 --> 01:49:53,710
这样可以有选择来接收消息

1355
01:49:53,710 --> 01:49:58,310
然后control可以来删除消息对联

1356
01:49:58,310 --> 01:50:00,070
制作一些相关的管理控制工组

1357
01:50:00,070 --> 01:50:01,290
是大致的一个结构

1358
01:50:01,850 --> 01:50:05,290
我这就稍微快的把这个给过了一下

1359
01:50:07,730 --> 01:50:09,950
这是send,save操作

1360
01:50:14,050 --> 01:50:20,550
重点看看Receive,Receive里面Type的信息很重要,这样我可以根据Type

1361
01:50:20,550 --> 01:50:26,850
的曲子不同,我来选择从队列里面返回哪一种类型的消息。

1362
01:50:26,850 --> 01:50:30,670
在这边可以返回等于这个的,或者返回小于等于这个的,

1363
01:50:30,730 --> 01:50:32,930
这是它一些灵活的一些参数的设置。

1364
01:50:34,010 --> 01:50:36,550
这个现在是返回第一条队列,它不管类型,

1365
01:50:36,790 --> 01:50:38,350
但是后面两种是管类型的。

1366
01:50:38,750 --> 01:50:40,050
三零操作过程。

1367
01:50:42,130 --> 01:50:42,510
FLAG。

1368
01:50:44,750 --> 01:50:48,610
FLAG表明这是怎么去进行接收的时候的一些行为,

1369
01:50:49,070 --> 01:50:49,710
是要不要等。

1370
01:50:51,730 --> 01:50:55,350
这里面给了例子,其实我觉得就是这些例子呢,

1371
01:51:25,530 --> 01:51:32,090
其实就是我们前面讲到,用我们之前的这个,我们说的这个虚存的一种管理方式

1372
01:51:32,090 --> 01:51:32,870
就可以做到。

1373
01:51:33,510 --> 01:51:37,790
但是呢,它为了能够更方便的,就是超运动为了更方便的让不同进程

1374
01:51:37,790 --> 01:51:41,950
能够来进行这种share memory的一种共享呢,

1375
01:51:42,130 --> 01:51:45,350
它还是设计了一些的cisco来帮助我们来做这个事情。

1376
01:51:46,290 --> 01:51:47,370
就是它对应的Cisco

1377
01:51:47,370 --> 01:51:50,470
其实刚才那个Circular很类似

1378
01:51:50,470 --> 01:51:51,810
它有个MessageGate

1379
01:51:51,810 --> 01:51:54,490
这样就创建一块共享区域

1380
01:51:54,990 --> 01:51:56,570
然后这个通过ShareAd

1381
01:51:57,470 --> 01:52:00,230
来把共享端映射到竞争地址中间

1382
01:52:00,230 --> 01:52:01,970
等于是我就是访问这个地址

1383
01:52:01,970 --> 01:52:06,390
就等同于访问一个同一个这块物理地址中间了

1384
01:52:06,390 --> 01:52:08,350
这个地址是一个虚地址

1385
01:52:09,430 --> 01:52:10,470
那你取消它

1386
01:52:10,470 --> 01:52:11,430
因为你不想共享

1387
01:52:11,430 --> 01:52:12,430
你把它取消掉

1388
01:52:12,430 --> 01:52:13,570
取消这个映射

1389
01:56:44,110 --> 01:56:51,350
然后,诶,这还是Ads,这是Ads是说它的这个参数的一个标识,参数的一个标识,

1390
01:56:51,450 --> 01:56:52,750
这里看出什么含义。

1391
01:56:53,190 --> 01:57:00,670
然后这也给了一个例子,大家可以去尝试一下,就是放在背体上面,有这么一个wra

1392
01:57:00,670 --> 01:57:02,570
pper,这里面有一些小例子。

1393
01:57:32,570 --> 01:57:37,330
我们讲了三种,Type、MessageQ和ShareMemory

1394
01:57:37,330 --> 01:57:41,610
重点是讲到Type的设计实现

1395
01:57:41,610 --> 01:57:46,930
包括我们后面的实验,其实也是有Type的设计实现

1396
01:57:46,930 --> 01:57:49,790
第二个很重要的概念在于数据的传输

1397
01:57:49,790 --> 01:57:52,650
其实不叫数据传输,叫信息的传输

1398
01:57:52,650 --> 01:57:54,370
就是我们这种通知

1399
01:57:54,370 --> 01:57:56,630
前面讲的更多是俱加在说

1400
01:57:56,630 --> 01:57:59,010
我要去把这个数据有效的去传过去

1401
01:57:59,010 --> 01:58:00,750
让一个进程把数据传给另一个进程

1402
01:58:00,750 --> 01:58:05,610
其实很多情况下,我们不需要那么高开销的这种数据传输

1403
01:58:05,610 --> 01:58:07,270
我们只需要通知一下

1404
01:58:07,270 --> 01:58:11,970
这很轻量的,我们只需要让当权人知道来了一个事件

1405
01:58:11,970 --> 01:58:15,310
那么其实大家回顾一下,我们之前讲的这个所谓的中断

1406
01:58:15,310 --> 01:58:17,810
就是一种消息

1407
01:58:17,810 --> 01:58:21,670
它只是这个消息从哪儿来,那是从我们的硬件来

1408
01:58:21,670 --> 01:58:23,930
我们说是从这儿来

1409
01:58:23,930 --> 01:58:26,530
硬件给我们的OS发了一个消息

1410
01:58:26,530 --> 01:58:28,190
我们把它称之为中断

1411
01:58:28,730 --> 01:58:36,150
那所谓的信号是我们的OS给我们的进程发一个消息

1412
01:58:36,150 --> 01:58:37,210
这叫信号

1413
01:58:37,210 --> 01:58:39,750
当然进程和进程之间也可以发消息

1414
01:58:39,750 --> 01:58:40,610
都可以发消息

1415
01:58:40,610 --> 01:58:42,530
这是所谓的信号机制

1416
01:58:42,530 --> 01:58:44,790
它其实也是一种异步的通知机制

1417
01:58:45,490 --> 01:58:46,050
什么叫异步

1418
01:58:46,050 --> 01:58:47,350
异步就是说

1419
01:58:47,350 --> 01:58:48,610
我什么时候收到这个信号

1420
01:58:48,610 --> 01:58:49,290
我根本不知道

1421
01:58:49,290 --> 01:58:50,510
它随时可以来

1422
01:58:50,510 --> 01:58:51,190
就跟中断一样

1423
01:58:51,190 --> 01:58:52,290
什么时候来的中断

1424
01:58:52,290 --> 01:58:52,810
我也不知道

1425
01:58:52,810 --> 01:58:54,810
中断信号也是不知道的

1426
01:58:54,810 --> 01:58:56,910
那这种情况其实还是挺有用的

1427
01:58:56,910 --> 01:59:02,990
比如说我们看到Ctrl-C,我们是一个程序,如果说死程序死到那儿了,我们可以

1428
01:59:02,990 --> 01:59:08,170
通过Ctrl-C结束程序,这种第2个Key,5Key命令来结束

1429
01:59:08,170 --> 01:59:13,570
一个进程的执行,那这些都是用到什么?用到信号机制,怎么用的?

1430
01:59:43,890 --> 01:59:49,170
我们信号谁来发,有几种发的方式,一种发的是进程,我直接通过Kill,

1431
01:59:50,670 --> 01:59:54,090
进程给进程发。

1432
01:59:54,510 --> 01:59:58,510
但进程发出一个系统调用的时候,一定要进入内核,内核来通知它,所以它是

1433
01:59:58,510 --> 01:59:59,570
一种间接的方式。

1434
02:00:00,990 --> 02:00:08,910
第二个是内核,比如说你这个进程做了一个什么非法的操作,做了一个比如说

1435
02:00:08,910 --> 02:00:10,530
非法文地址的操作。

1436
02:00:10,530 --> 02:00:17,270
那么我们内核给它发一个信号,让它崩溃,让它不要崩溃,让它被Kill了,

1437
02:00:17,310 --> 02:00:18,530
被杀了。

1438
02:00:19,450 --> 02:00:26,770
对美举了另外一个例子,比如说我在这个进程在从管道读数据的时候,这时候管

1439
02:00:26,770 --> 02:00:28,990
道的读全线被关闭了。

1440
02:00:29,090 --> 02:00:34,850
发现根本没有全线读这个管道,这么内核就给进程发这么一个信号,提示

1441
02:00:34,850 --> 02:00:36,090
读管道出错了。

1442
02:00:36,090 --> 02:00:41,730
这就是内核直接给进程发信号的一种例子

1443
02:00:41,730 --> 02:00:44,050
还有一种例子,还有一种例子我们说的外设

1444
02:00:44,050 --> 02:00:48,230
外设,比如说我敲了Control-C这么一个组合键

1445
02:00:48,230 --> 02:00:52,270
敲这个组合键之后呢,首先Driver

1446
02:00:52,270 --> 02:00:55,270
比如说键盘的Driver会收到这个Control-C

1447
02:00:55,850 --> 02:00:58,170
那么键盘收到Control-C之后呢

1448
02:00:58,170 --> 02:01:03,590
我们往上捅,捅到了我们正在管理这个当前运行进程的一个超级组

1449
02:01:03,590 --> 02:01:09,530
曹俊勇发现当前正在运行的进程收到了controversy的案件

1450
02:01:09,530 --> 02:01:15,190
那么曹俊勇会认为现在有可能这个controversy是某个人发出来的

1451
02:01:15,190 --> 02:01:18,670
有用户可能希望要把这个当前这个进程给终止掉

1452
02:01:19,290 --> 02:01:26,190
所以他会给当前正在运行的进程发出一个signal的interrupt

1453
02:01:26,190 --> 02:01:28,830
中断的信号将其异常终止

1454
02:01:28,830 --> 02:01:35,270
这就是通过外设,外设来给一个竞争发信号的一个例子。

1455
02:01:38,730 --> 02:01:49,750
好,我又留一个小问题,我们现在的实验里面,我们现在实验里面也可以接收按键。

1456
02:01:50,650 --> 02:02:02,830
请问有没有同学知道,当我在实验里按住Ctrl-C之后,我们当前的进

1457
02:02:02,830 --> 02:02:06,970
程收到的是什么信息?

1458
02:02:07,070 --> 02:02:12,550
是收到两个键,Ctrl键和C键的信息,还是收到一个单个键的信息?

1459
02:02:12,610 --> 02:02:16,930
比如说像按A键一样,是A键信息,B键信息,单个键的信息呢?

1460
02:02:16,930 --> 02:02:19,330
还是可能是那种组合键,两个键的信息

1461
02:02:20,410 --> 02:02:28,530
我们走的是串口,我们的键盘是通过串口给我们的进程产生的一个数据

1462
02:02:28,530 --> 02:02:30,750
大家都知道,前面我们学过有一个

1463
02:02:32,550 --> 02:02:33,950
通过getchart

1464
02:02:37,410 --> 02:02:42,850
通过getchart来得到这个信息,但现在我们是

1465
02:02:42,850 --> 02:02:44,330
你不发出getchart

1466
02:02:45,010 --> 02:02:47,690
我也可以得到信息,而且还会把他切掉。

1467
02:02:48,150 --> 02:02:49,070
Ctrl-C就是一个例子。

1468
02:02:49,370 --> 02:02:51,330
那我们创口怎么来做到这一步呢?

1469
02:02:53,010 --> 02:02:53,970
有没有同学知道?

1470
02:03:02,010 --> 02:03:04,430
我觉得同学需要去尝试。

1471
02:03:04,730 --> 02:03:08,270
我这边只是提示,Ctrl-C对于创口而言,

1472
02:03:08,510 --> 02:03:10,170
UART而言,

1473
02:03:11,250 --> 02:03:18,030
它会把Condorcet编码成一个特殊的value,一个值,就类似于A一样的

1474
02:03:18,030 --> 02:03:19,790
一个值,它可能是另外一个值。

1475
02:03:20,050 --> 02:03:25,850
这个值会传给内核,内核收到这个值之后,它会认为是CondorcetN

1476
02:03:25,850 --> 02:03:31,990
了,通过串口N了,然后会把当前的进程给终止掉。

1477
02:03:31,990 --> 02:03:36,370
那这个尝试,你们可以在哪儿尝试呢?

1478
02:03:36,370 --> 02:03:39,130
在我们的第七章?

1479
02:03:39,130 --> 02:03:42,230
第七章,chapter 7,第七章

1480
02:03:42,230 --> 02:03:44,230
R code tutorial里面去尝试一下

1481
02:03:44,730 --> 02:03:45,790
看看它怎么来处理

1482
02:03:45,790 --> 02:03:48,010
这边就有一个相应的信号的处理过程

1483
02:03:49,690 --> 02:03:52,230
那信号接收进程的处理方式

1484
02:03:52,230 --> 02:03:55,170
怎么来处理?看处理方式

1485
02:03:55,170 --> 02:03:56,990
这处理方式有好几种

1486
02:03:56,990 --> 02:03:58,910
第一种是忽略

1487
02:03:58,910 --> 02:04:00,670
信号就像没发生一样

1488
02:04:30,670 --> 02:04:34,940
一般情况下是直接杀死进程,这是最主要的处理方式。

1489
02:04:39,370 --> 02:04:41,810
所以你为什么Ctrl-C,那就是缺省你。

1490
02:04:41,810 --> 02:04:43,570
在某种情况下就是把这个care掉。

1491
02:04:44,270 --> 02:04:48,870
如果带你捕获了Ctrl-C,那你可以让自己不死,不被care掉。

1492
02:04:49,810 --> 02:04:55,270
当然,这学了一个design,这是我们说的三种节奏方式。

1493
02:04:59,310 --> 02:05:06,790
这举个例子,我们如果要让进程B接收信号的话,怎么来做?

1494
02:05:08,850 --> 02:05:15,990
建立Handler,它针对这个信号,设置个Mask,不要屏蔽掉了。

1495
02:05:18,230 --> 02:05:22,070
建好之后,它应该干其他事情,做其他的处理。

1496
02:05:22,070 --> 02:05:27,750
做瞎处理之后,进程A在某个时刻,它发出这么一个命令,或者发出这么

1497
02:05:27,750 --> 02:05:37,130
一个系统调用,需要注意,这个PID是进程B的PID,这是B的PID,给B的

1498
02:05:37,130 --> 02:05:43,090
PID发这么一个信号,那么发之后,它实际上这个系统调用会传给内核,

1499
02:05:43,310 --> 02:05:49,570
内核会去查,你前面不是已经注册了Handler吗,会把这个信号转给这个

1500
02:05:49,570 --> 02:05:50,330
Handler去执行。

1501
02:05:51,290 --> 02:05:57,690
这是它的一个大致的一个执行过程,细节其实还是比较复杂的,这个需要大家再结

1502
02:05:57,690 --> 02:06:01,370
合,后面我们讲这个距离实现的时候会记录看,这里面我们讲大致的原理。

1503
02:06:01,510 --> 02:06:06,850
它就会把当前这个正在执行的这个逻辑给断下来,去执行这个handle。

1504
02:06:07,310 --> 02:06:10,710
在handle执行完毕之后,再回到这个被打断的地方去继续执行。

1505
02:06:11,170 --> 02:06:15,550
既然一个断下来和继续执行的过程,就和我们的中断处理之类似,

1506
02:06:15,590 --> 02:06:22,250
它会有一个打断这个地方的上下文的保存和恢复的一个处理。

1507
02:06:22,290 --> 02:06:26,490
但这个处理过程全是内壳来搞定的,你作为应用程序不用Key,把

1508
02:06:26,490 --> 02:06:31,090
内壳帮你搞好这些事情,使得完成了所谓的一个对信号的异部的响

1509
02:06:31,090 --> 02:06:32,690
应的一个过程。

1510
02:06:34,370 --> 02:06:42,450
联系室其实有很多信号,看这里有62个,非常多,用点非常的广泛,你通过这个命

1511
02:06:42,450 --> 02:06:48,630
令就可以看到当前你的超级风里面,特别是联系室里面到底有多少个信号,

1512
02:06:48,850 --> 02:06:50,690
这不写64吗?为什么62呢?

1513
02:06:51,590 --> 02:06:57,190
你同学知道吗,这中间一定是跳了某个数,有些值给跳过去了,跳哪儿,

1514
02:06:57,190 --> 02:06:58,890
大家可以去找一找。

1515
02:07:00,390 --> 02:07:05,030
OK,然后为什么这么多信号,因为它有这么多事件要处理,每一个信号代表某种

1516
02:07:05,030 --> 02:07:05,730
事件。

1517
02:07:06,050 --> 02:07:12,570
然后我们通常看到的就是1到34号是通常,你们又跑上去了。

1518
02:07:13,370 --> 02:07:18,810
通常是看到的是一些常用的信号,我们希望是理解,不是备用,没必要备。

1519
02:07:18,810 --> 02:07:21,070
你没有必要把64的都背下来

1520
02:07:21,070 --> 02:07:22,710
62的都背下来

1521
02:07:22,710 --> 02:07:24,910
这里面大致给大家讲讲常见的型号

1522
02:07:24,910 --> 02:07:28,970
比如说cskill

1523
02:07:29,910 --> 02:07:31,190
这是Ctrl-C

1524
02:07:31,190 --> 02:07:35,510
这个cskill等于是我就通过kill命令

1525
02:07:35,510 --> 02:07:38,510
给某一个进程发信号

1526
02:07:38,510 --> 02:07:43,310
确诊就是cskill这个信号

1527
02:07:43,890 --> 02:07:45,930
它的编号是9

1528
02:07:46,630 --> 02:07:53,770
第二个,SIGINT就是Ctrl-C,Ctrl-C之后,一般会发出编号为2

1529
02:07:53,770 --> 02:07:57,130
的信号,缺省操作就是终止,终止

1530
02:07:58,290 --> 02:08:06,490
SIGV是Segment Word,就是出错的一个意思,断出错的意思

1531
02:08:08,670 --> 02:08:13,730
这样主要是指无效率能访问,它也会终止,编号是11

1532
02:08:14,830 --> 02:08:19,690
比如说非法法文的一个地址,我们经常会报Jugger.net port的错误

1533
02:08:19,690 --> 02:08:26,490
那就是由于我们的潮系统在看到我们的应用程序非法法文的某个地

1534
02:08:26,490 --> 02:08:27,590
址之后就把他care掉

1535
02:08:27,590 --> 02:08:29,210
所以产生这么一个信息

1536
02:08:30,270 --> 02:08:31,610
这是常见的三个

1537
02:08:31,610 --> 02:08:32,930
还有其他的

1538
02:08:33,970 --> 02:08:35,510
这是说Unix

1539
02:08:35,510 --> 02:08:37,050
比如说Charge

1540
02:08:37,050 --> 02:08:41,610
我们讲Charge的时候,其实讲说只进程DXIT

1541
02:08:41,610 --> 02:08:44,430
退出,然後複印層就是wait PID

1542
02:08:47,970 --> 02:08:50,330
那麼這裡面退出之後

1543
02:08:51,050 --> 02:08:55,450
其實我們的指令層會產生一個給複印層產生這麼一個信號

1544
02:08:55,450 --> 02:08:58,670
我的複印層會收到這個信號就會

1545
02:08:58,670 --> 02:09:01,830
做相應的處理,這也是一種我們說

1546
02:09:03,290 --> 02:09:05,930
複指令層之間一種通知一種方式

1547
02:09:06,670 --> 02:09:10,130
我們當然可以用它也可以不用它,這在於我們超久實現

1548
02:09:10,130 --> 02:09:15,130
标准的像Memix超级统统,它会产生这么一个信息。

1549
02:09:30,370 --> 02:09:32,150
这是常见的一些信号。

1550
02:09:32,630 --> 02:09:35,130
这是一个非常简单的例子,大家可以去看看。

1551
02:09:35,450 --> 02:09:37,550
当然我们也有些实际的例子。

1552
02:09:38,230 --> 02:09:39,890
看看这里面有没有新化的例子

1553
02:09:54,850 --> 02:09:56,470
我这边还没有给出新化的例子

1554
02:09:56,470 --> 02:09:57,030
但没关系

1555
02:09:57,030 --> 02:10:00,090
到时候大家可以去直接在这个

1556
02:10:00,090 --> 02:10:02,870
我们说那个ArcoTutorial里面去看有新化

1557
02:10:02,870 --> 02:10:05,750
第七章就有新化的一个基本实现

1558
02:10:07,650 --> 02:10:18,170
我看看,这是这一块,然后它的大致的一个红线,刚才讲的更多是一种就是站

1559
02:10:18,170 --> 02:10:24,050
在应用程序角度来说,怎么去用这个信号,但怎么去实现它,这是我们关注

1560
02:10:24,050 --> 02:10:33,270
的另一点,实现它呢,其实就是我们一开始说要有一些的系统雕用,你要注册,要

1561
02:10:33,270 --> 02:10:35,730
信号处理历程,这个是一个信号雕用,这个是一个信号处理历程,这个是一个

1562
02:10:35,730 --> 02:10:44,190
等于是我们要让我们的OS知道当前进程对于某一个信号它应该有做

1563
02:10:44,190 --> 02:10:45,770
相应的什么样的处理

1564
02:10:46,310 --> 02:10:48,730
所以大致理解会有一个在进程里面会一张表

1565
02:10:49,470 --> 02:10:54,730
这个表里面会记录一个SIG number

1566
02:10:55,350 --> 02:10:56,690
这里面会记录什么呢

1567
02:10:56,690 --> 02:10:58,730
记录一个handle的address

1568
02:11:01,490 --> 02:11:02,650
那么我查的时候

1569
02:11:02,650 --> 02:11:03,350
比如我注册的时候

1570
02:11:33,350 --> 02:11:39,170
可能是在这个地方,而你的handle呢,在这个地方,那你怎么办呢?

1571
02:11:39,350 --> 02:11:43,290
你需要注意的是,金融内核之后,你这个进程其实已经被停下来了。

1572
02:11:43,410 --> 02:11:47,890
这个进程被停下来了,停下来之后呢,它已经在某个地方,

1573
02:11:47,970 --> 02:11:51,110
通过系统量量或者中断的原因,停在了某个地方。

1574
02:11:52,230 --> 02:11:55,210
所以,比如停在这个地方,停在这个地方,所以它会需要干什么呢?

1575
02:11:55,250 --> 02:12:00,130
首先第一步就是要把这个context做一个保存,把它的上下文保存一下。

1576
02:12:00,130 --> 02:12:09,770
就是锁什么上下文,trapctx,就是特先级切换的上下文,

1577
02:12:10,030 --> 02:12:19,070
就是所谓的线路上下文要保存一下,然后构建一个新的trapctx。

1578
02:12:19,410 --> 02:12:24,390
在这个新的上下文ctx里面,会把它的返回地址设置,设置到这个hand

1579
02:12:24,390 --> 02:12:25,370
ler里面去。

1580
02:12:26,050 --> 02:12:31,070
这样使得我最终再去通过调度,让进程回到用户台的时候,

1581
02:12:31,810 --> 02:12:33,530
就回到这个地方去执行。

1582
02:12:34,530 --> 02:12:38,390
OK,这是它一个大致的思路,这就是为什么回到这里去执行。

1583
02:12:38,670 --> 02:12:41,090
但还有一点,你执行完毕之后怎么办?

1584
02:12:41,610 --> 02:12:43,750
执行完毕之后应该回到这个地方继续执行。

1585
02:12:43,750 --> 02:12:59,710
所以JM1之后,它会执行一个叫做SIGRETURN-SIGRETURN

1586
02:13:00,730 --> 02:13:05,790
作为信号处理函数的最后一条操作

1587
02:13:05,790 --> 02:13:08,350
那SIGRETURN又进入内核,进入内核干什么呢?

1588
02:13:08,350 --> 02:13:15,710
进入内核之后,恢复之前保存的TrapContext,把这个不要了。

1589
02:13:15,810 --> 02:13:21,510
恢复它的好处在哪呢?恢复它之后,就意味着我再次回去的时候,就回到

1590
02:13:21,510 --> 02:13:22,670
这个点去执行。

1591
02:13:23,890 --> 02:13:29,410
所以你看到,在信号处理里面,它也是对TrapContext,主要对TrapContext做

1592
02:13:29,410 --> 02:13:30,210
了一定的处理,

1593
02:13:30,450 --> 02:13:36,810
使得能够去产生信号之后,能够去让进程直行相对性能。

1594
02:13:36,810 --> 02:13:44,330
这是一种注册的情况,如果没有注册Default操作,一般情况还是把它K了,这是实

1595
02:13:44,330 --> 02:13:46,150
现机制的一个讲解。

1596
02:13:46,490 --> 02:13:49,810
这里面把整个条目又缩了一下。

1597
02:13:55,630 --> 02:13:57,430
注册,这是注册。

1598
02:13:58,270 --> 02:14:03,550
然后内核在进程返回用户之前发生有信号要处理,这个进程有信号

1599
02:14:03,550 --> 02:14:04,090
要处理。

1600
02:14:04,650 --> 02:14:09,110
因为它会有一个专门记录,收到什么信号的一个结构

1601
02:14:09,110 --> 02:14:16,290
然后内核会压入这个信息,模拟这个调用

1602
02:14:16,290 --> 02:14:20,950
我大致理解为我刚才讲到的那个chip上下我们一个设计

1603
02:14:20,950 --> 02:14:25,310
这样的话就可以使得内核返回用户台的时候跳到这个地方去

1604
02:14:25,310 --> 02:14:29,970
然后Signal返回到旧代码具体字形

1605
02:14:29,970 --> 02:14:32,050
这个实际上就是我前面讲到的

1606
02:14:32,050 --> 02:14:34,630
他要在内核里面去把这个context重新切换一下

1607
02:14:34,630 --> 02:14:35,510
才能做这一步

1608
02:14:35,510 --> 02:14:37,050
当然这里面给出的是非常

1609
02:14:37,970 --> 02:14:39,030
general的一种说法

1610
02:14:40,090 --> 02:14:41,790
这个是比较general的

1611
02:14:41,790 --> 02:14:42,690
不是一种特别

1612
02:14:45,530 --> 02:14:47,450
特别detail的一种设计实现

1613
02:14:49,710 --> 02:14:52,370
这一块我就把这个整个这个

1614
02:14:52,370 --> 02:14:54,730
信号机制大致说了一下

1615
02:14:54,730 --> 02:14:56,270
OK 这里面可以看出来

1616
02:14:56,270 --> 02:14:57,210
我们讲了什么

1617
02:14:57,210 --> 02:14:59,410
讲了管道消息队列共享内存

1618
02:14:59,410 --> 02:15:00,990
还有信号

1619
02:15:00,990 --> 02:15:02,530
那也是一样

1620
02:15:02,530 --> 02:15:04,630
你们要去理解是进程之间

1621
02:15:04,630 --> 02:15:07,490
怎么和这些机制已经配合

1622
02:15:07,490 --> 02:15:08,230
进程

1623
02:15:08,230 --> 02:15:08,990
站在进程上

1624
02:15:08,990 --> 02:15:12,030
站在PCB的角度

1625
02:15:12,030 --> 02:15:13,450
你怎么能够理解

1626
02:15:13,450 --> 02:15:16,230
它怎么去设计实现这几种机制

1627
02:15:16,230 --> 02:15:19,410
特别是管道和信号

1628
02:15:19,410 --> 02:15:24,890
当然这还会基于我们

1629
02:15:32,170 --> 02:15:40,330
第二节,关于支持IPC的OS,讲实践,实践实验内容中,你可以更清楚知道怎么去

1630
02:15:40,330 --> 02:15:45,410
实现,这个就讲的比较detail一点,就是前面讲的这个知识,能够具体实现。

1631
02:15:46,210 --> 02:15:48,070
这个我们也有

1632
02:15:49,630 --> 02:15:51,810
IOS不是我们的苹果

1633
02:15:51,810 --> 02:15:53,890
应该是我们自己写的小os

1634
02:15:53,890 --> 02:15:56,350
它的一个支持IBCD OS

1635
02:15:56,350 --> 02:15:57,350
成为IOS

1636
02:15:57,350 --> 02:15:58,630
它的一个怎么实验情况

1637
02:15:58,630 --> 02:16:00,490
我们可以看看

1638
02:16:00,490 --> 02:16:02,830
这里面还是一样的步骤

1639
02:16:02,830 --> 02:16:03,530
改变在哪

1640
02:16:04,730 --> 02:16:05,570
改变在这

1641
02:16:06,170 --> 02:16:09,050
FD table里面

1642
02:16:09,050 --> 02:16:11,130
Table里面会多有一些

1643
02:16:11,130 --> 02:16:13,130
指向的是一种pipe的iNode

1644
02:16:13,130 --> 02:16:14,170
是special iNode

1645
02:16:14,170 --> 02:16:20,370
而那个012指向也是一种SDD in SDD out这种情况

1646
02:16:20,370 --> 02:16:25,150
所以在这里面的file这种抽象已经扩展到了什么呢

1647
02:16:25,150 --> 02:16:29,010
支持所谓的IPC支持所谓的device

1648
02:16:29,890 --> 02:16:31,830
比如这个数数就是串口

1649
02:16:31,830 --> 02:16:34,570
串口的device也支持disk

1650
02:16:36,570 --> 02:16:38,650
所以这个file的抽象进步扩大

1651
02:16:38,650 --> 02:16:40,350
有了IPC之后进步扩大

1652
02:16:40,350 --> 02:16:44,150
第二部分是什么呢

1653
02:16:45,630 --> 02:16:52,150
这一块机制它重点是需要把TrapContext

1654
02:16:52,890 --> 02:16:57,010
TrapContext这一块能够进行一个有效的处理

1655
02:16:57,010 --> 02:17:00,190
使得能够及时的产生信号之后

1656
02:17:00,190 --> 02:17:07,050
及时的去响应应用层的SignalHandler这个程序的执行

1657
02:17:08,270 --> 02:17:10,190
这是在之前文件

1658
02:17:11,110 --> 02:17:15,630
支持文件系统 OS 之上我们进一步的一个改进

1659
02:17:15,630 --> 02:17:17,390
这是 iOS 它干的事情

1660
02:17:22,310 --> 02:17:24,350
所以这个相当于是比较简单点

1661
02:17:24,350 --> 02:17:27,690
前面我们到了文件之后

1662
02:17:27,690 --> 02:17:31,890
它实际上支持的是数据的持久保存的问题

1663
02:17:31,890 --> 02:17:34,090
它解决了 解决得不错

1664
02:17:35,110 --> 02:17:36,550
然后有了这个之后

1665
02:17:36,550 --> 02:17:39,470
我们最大的一个特点就是支持竞争间交互

1666
02:17:39,470 --> 02:17:40,790
使得应用更加灵活

1667
02:17:42,910 --> 02:17:45,870
为此我们扩展了文件的抽象

1668
02:17:46,730 --> 02:17:47,950
扩展文件的抽象

1669
02:17:47,950 --> 02:17:50,710
然后以文件的形式来进行进程间的交换

1670
02:17:51,390 --> 02:17:54,830
当然我们还实现了非常灵活

1671
02:17:54,830 --> 02:17:56,710
轻量的信号机制

1672
02:17:59,070 --> 02:18:00,230
不是信号机制

1673
02:18:00,230 --> 02:18:02,890
实际上信号机制来实现这种易补通知

1674
02:18:02,890 --> 02:18:05,650
可以使得进程间可以或者内核进程间

1675
02:18:05,650 --> 02:18:08,830
进行快速的这种易补通知这种操作

1676
02:18:08,830 --> 02:18:14,710
这就是称之为软件的中断,我们叫硬件中断,那实际上就是一种软件

1677
02:18:14,710 --> 02:18:15,090
中断。

1678
02:18:18,170 --> 02:18:23,110
所以我们需要理解什么,文件出现IPC机制的设计实现Pipe signal会写这个,

1679
02:18:23,130 --> 02:18:25,030
这是我们对同学的一个期望。

1680
02:18:28,030 --> 02:18:33,490
总理思路,Pipe是啥?Pipe我们其实已经看到了,简单说一下。

1681
02:18:34,010 --> 02:18:39,490
两个fd,一个buffer,这就是pipe,那么怎么访问这个pipe呢?

1682
02:18:40,850 --> 02:18:48,030
一个读,一个写,这个应该是写,这个是读,这是write,这是read,对一个buffer进行操作,

1683
02:18:48,250 --> 02:18:49,390
然后通过不同fd来完成。

1684
02:18:50,010 --> 02:18:57,050
这就是访问,管理就是确保它正常存在,然后在它满了之后应该怎么办,

1685
02:18:57,170 --> 02:19:00,250
在它空的时候怎么办,这些通常的管理操作。

1686
02:19:04,070 --> 02:19:05,630
顺序读写 这个关键什么

1687
02:19:05,630 --> 02:19:08,090
就是pipe实际上是一块内存

1688
02:19:08,490 --> 02:19:09,510
顺序读写

1689
02:19:09,510 --> 02:19:11,310
它和我们虽然可以串通文件

1690
02:19:11,310 --> 02:19:13,490
但它和disk没有半毛关系

1691
02:19:14,410 --> 02:19:15,490
没有关系

1692
02:19:16,830 --> 02:19:18,330
我们既然跟disk没关系

1693
02:19:18,330 --> 02:19:19,650
那就意味着跟EZFS

1694
02:19:20,350 --> 02:19:21,610
这些都没有关系

1695
02:19:21,610 --> 02:19:23,670
它更多的是跟进程

1696
02:19:23,670 --> 02:19:24,570
进程有什么关系

1697
02:19:24,930 --> 02:19:27,430
有FD table

1698
02:19:28,310 --> 02:19:29,510
FD table里面的一项

1699
02:19:29,510 --> 02:19:31,090
会指向一个pipe

1700
02:20:01,090 --> 02:20:04,310
给它操作,这是一个实际的PAP的程序

1701
02:20:04,310 --> 02:20:05,530
我们可以看到

1702
02:20:07,470 --> 02:20:09,770
创建,这里面创建PAP

1703
02:20:09,770 --> 02:20:12,630
这是一个新的创建FD,然后通过Fock

1704
02:20:12,630 --> 02:20:14,890
这Fock是一个指令层,它会关闭一个

1705
02:20:16,050 --> 02:20:18,310
然后呢,留着0,再做Read

1706
02:20:18,310 --> 02:20:21,030
这个呢,留着1,做Write

1707
02:20:21,030 --> 02:20:24,350
关闭了0,这是关闭了1,再关闭了0

1708
02:20:24,350 --> 02:20:27,550
通这种方式来实现他们所谓的一个交互

1709
02:20:27,550 --> 02:20:40,170
OK,这个程序看起来也是非常的简单,结构在这儿。

1710
02:20:40,210 --> 02:20:45,630
和这个是对应的,和这个文件是对等的,对等的一种方式,它其实也是一

1711
02:20:45,630 --> 02:20:46,130
种资源,

1712
02:20:46,290 --> 02:20:49,030
既然证明它也是进程公司化的一种资源。

1713
02:20:51,090 --> 02:20:56,910
所以,这里面讲资源,其实很重要一点就是你要知道对资源就有管理,

1714
02:20:56,910 --> 02:21:03,230
你要什么时候申请,什么时候释放,有时候我们通常说,有时候搞不干净在于我把

1715
02:21:03,230 --> 02:21:05,950
进程给释放之后,结果这些没有释放,

1716
02:21:06,170 --> 02:21:10,630
这导致内存泄漏,后面会出现内存不够的一些情况。

1717
02:21:12,450 --> 02:21:17,170
这个是容易出现,需要避免的一些问题。

1718
02:21:19,390 --> 02:21:24,230
signal呢?signal呢?其实也是一样,signal是啥?

1719
02:21:24,630 --> 02:21:31,750
signal是一个整形,只是整形里有一堆signal,就是整形成一个signal的

1720
02:21:31,750 --> 02:21:32,170
一个list

1721
02:21:36,790 --> 02:21:40,590
那么它的signal里面只是一个整形编号

1722
02:21:40,590 --> 02:21:45,770
它的整个体现是一种软件的一种中断,异部的一种中断

1723
02:21:46,430 --> 02:21:49,010
那么我如果要对某个signal建一个handle的话

1724
02:21:49,010 --> 02:21:51,310
那么很明显我们前面已经说了一张表

1725
02:21:51,310 --> 02:21:53,170
这里面是signal

1726
02:21:53,170 --> 02:21:54,970
这里面是它的handle

1727
02:21:55,630 --> 02:21:56,750
这么一个映射表

1728
02:21:56,750 --> 02:21:59,870
这会放在我们的那个竞争空注画里面

1729
02:21:59,870 --> 02:22:01,110
这样我们可以去查找

1730
02:22:01,490 --> 02:22:02,950
所以执行的时候呢

1731
02:22:02,950 --> 02:22:06,150
会向某个超级桶或者是竞争

1732
02:22:07,490 --> 02:22:09,950
向另外一个竞争发signal的时候呢

1733
02:22:09,950 --> 02:22:13,150
会打断当前竞争执行转的设断处理

1734
02:22:13,150 --> 02:22:15,130
你需要注意这个打断

1735
02:22:16,090 --> 02:22:23,330
和中断的打断不是一个意思

1736
02:22:24,050 --> 02:22:29,370
所谓的软件中断,比这个硬件中断要弱一些

1737
02:22:29,790 --> 02:22:31,050
为什么要弱一些?

1738
02:22:31,290 --> 02:22:33,310
这个有硬件机制的支持

1739
02:22:33,310 --> 02:22:36,310
如果是硬件产生一个,Device产生一个中断的话

1740
02:22:36,310 --> 02:22:42,310
那么你这个应用程序App正在用户台执行,这是OS

1741
02:22:42,310 --> 02:22:47,390
来了一个中断,你在这儿执行的时候,可以迅速打断

1742
02:22:48,370 --> 02:22:50,410
你在哪儿执行都会被迅速打断

1743
02:22:54,710 --> 02:22:58,390
但是,如果是一个信号的话

1744
02:22:58,390 --> 02:23:01,470
我现在这个APP正在执行,在用户在执行

1745
02:23:02,190 --> 02:23:04,150
你说你这OS产生了个信号

1746
02:23:05,730 --> 02:23:09,250
如果,首先确保说这个APP在执行的时候

1747
02:23:09,250 --> 02:23:13,770
它其实是 它只有到了内核之后才会让OS去处理中断执行

1748
02:23:13,770 --> 02:23:15,190
如果它用不太执行的时候

1749
02:23:16,130 --> 02:23:19,970
这个所谓的这个 我们说这个信号它是没法去响应的

1750
02:23:20,690 --> 02:23:23,950
它不能说我在这儿执行的时候 信号有

1751
02:23:23,950 --> 02:23:27,210
我就迅速的把它敲掉

1752
02:23:27,210 --> 02:23:30,430
现在迅速的把它打断 让它去执行 这是不行的

1753
02:23:30,430 --> 02:23:36,290
这是一定要说我们的OS在内核它进行操作的时候

1754
02:23:37,210 --> 02:23:41,050
将要返回到这个APP进行执行的过程中

1755
02:23:41,750 --> 02:23:44,330
才会对它这个信号进行相应的处理

1756
02:23:44,330 --> 02:23:46,170
这一点它们还是有点不一样

1757
02:23:50,370 --> 02:23:54,910
那APP的用户它也扣的

1758
02:23:54,910 --> 02:23:56,690
这是它扣的 这是最简单的扣的

1759
02:23:56,690 --> 02:23:57,270
这怎么回事

1760
02:23:57,270 --> 02:23:59,270
可以看到这边有一个例子

1761
02:23:59,270 --> 02:24:01,430
大家可以去看 再去下载

1762
02:24:01,430 --> 02:24:14,710
去執行這一步,SigAction給這個信號設置一個Handle

1763
02:24:14,710 --> 02:24:18,050
但這是一個結構,SigAction的結構,設置一個這麼一個Handle

1764
02:24:18,050 --> 02:24:21,990
Handle就幹這個事情,寫這個字幕串,做SigReturn

1765
02:24:21,990 --> 02:24:27,250
我們說SigReturn是一個系統雕用,讓它被打到地方繼續執行

1766
02:24:27,250 --> 02:24:33,970
那么这个是panic,然后如果失败了就panic,但是如果设置成功之后呢

1767
02:24:33,970 --> 02:24:35,790
那么它是自己给自己发

1768
02:24:36,670 --> 02:24:38,250
kill get PID

1769
02:24:39,230 --> 02:24:42,570
等于自己的PID知道吗,给PID发这么一个信号

1770
02:24:42,570 --> 02:24:46,770
一旦发出信号之后呢,大家想一想,可以思考一下,当发出信号,这是个系

1771
02:24:46,770 --> 02:24:48,050
统调用,所以进入内核

1772
02:24:49,190 --> 02:24:53,030
进入内核,kill进入内核之后,如果正常情况下

1773
02:24:53,730 --> 02:24:58,130
这个系统代用返回应该返回到Keyer的后一条语句去执行

1774
02:24:58,130 --> 02:25:02,190
正常情况下,我做完这个系统代用执行,然后再返回到用户台去执行

1775
02:25:02,190 --> 02:25:07,370
但是你现在是说,我这个系统代用是产生一个信号,给自己产生一个信号

1776
02:25:07,370 --> 02:25:11,430
所以在返回那一下的时候呢

1777
02:25:12,070 --> 02:25:17,190
我们的OS会去check,会去check说你现在已经建立好这么一个表了

1778
02:25:17,190 --> 02:25:21,570
你对这个user1来说,它应该去执行这么一个函数

1779
02:25:21,570 --> 02:25:27,930
查了这个设置之后呢 我就会为这个函数专门建立一个TrapContext

1780
02:25:29,990 --> 02:25:33,050
然后返回去执行 执行完毕之后呢

1781
02:25:33,050 --> 02:25:36,910
再通过Sigreturn回来 又再次回到内核里面来

1782
02:25:36,910 --> 02:25:42,570
之后呢 我再恢复OS的

1783
02:25:43,750 --> 02:25:50,330
不是恢复 应该恢复刚才被打断的这一点 从这个点再继续往下执行

1784
02:25:50,330 --> 02:25:55,670
也意味着Keyer系统调用和Keyer后面那条指令中间

1785
02:25:55,670 --> 02:25:57,970
会执行一次这个发动性操作

1786
02:25:57,970 --> 02:26:00,070
所以你要清楚这个流程怎么回事

1787
02:26:00,070 --> 02:26:03,370
这样当然我这个讲的时候可能还没有细讲这个

1788
02:26:03,910 --> 02:26:04,830
它的具体的实现

1789
02:26:04,830 --> 02:26:06,450
但是我想大家也应该能够知道

1790
02:26:08,350 --> 02:26:09,890
好吧现在又到点了

1791
02:26:11,110 --> 02:26:12,830
我们先讲到这

1792
02:26:12,830 --> 02:26:14,770
好今天就到这下课

