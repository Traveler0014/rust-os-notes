1
00:00:49,460 --> 00:00:51,020
好 我们开始上课

2
00:00:52,120 --> 00:00:56,460
今天课是继续把上一讲的那个实验部分讲完

3
00:00:56,460 --> 00:00:59,280
然后就开始新的关于虚存这项内容的讲解

4
00:00:59,280 --> 00:01:03,000
总该说这两部分都还是比较重要的

5
00:01:03,680 --> 00:01:05,980
一个是偏实践 一个是偏原理

6
00:01:06,360 --> 00:01:08,500
而且第二部分虚存管理的原理部分

7
00:01:09,080 --> 00:01:11,380
没有对应的具体的实践

8
00:01:11,380 --> 00:01:12,520
虽然我们会讲实践

9
00:01:12,520 --> 00:01:15,540
但是没有对应的具体代码可以给大家去参考

10
00:01:15,540 --> 00:01:18,060
所以这也是一个需要大家更深刻的理解

11
00:01:18,060 --> 00:01:22,600
就是说我们讲后面讲虚存的自然算法

12
00:01:22,600 --> 00:01:24,100
这个自然算法在我们实际上

13
00:01:24,100 --> 00:01:26,460
里面怎么能够真正的运行起来

14
00:01:26,460 --> 00:01:31,110
这一块其实需要大家有一个很好的就是全局的把握

15
00:01:32,760 --> 00:01:34,940
在讲到之前我看还是应该

16
00:01:38,760 --> 00:01:39,700
这个怎么下去

17
00:01:41,280 --> 00:01:44,180
FC我们先看看就是我们收到学生的反馈

18
00:01:46,100 --> 00:01:49,360
比较极端一个说上课不用讲实验

19
00:01:49,360 --> 00:01:51,460
老师只要把原理讲好就行了

20
00:01:51,460 --> 00:01:53,220
一个同学说要讲实验

21
00:01:53,220 --> 00:01:54,580
否则我根本看不懂

22
00:01:54,580 --> 00:01:57,100
甚至认为要一行一行的讲代码

23
00:01:57,960 --> 00:01:59,480
这个可能老师还做不到

24
00:01:59,480 --> 00:02:00,420
一行一行的讲代码

25
00:02:00,980 --> 00:02:04,440
所以通过和助教的协商就是讲解部分

26
00:02:04,440 --> 00:02:07,220
我们其实专门有一个视频放在了

27
00:02:07,220 --> 00:02:08,620
就让我请我们的助教

28
00:02:11,680 --> 00:02:15,480
把这个实验的视频在哪

29
00:02:15,480 --> 00:02:20,100
应该有一个视频的部分应该放在上面了

30
00:02:20,100 --> 00:02:24,560
就是有一个这里面没有列吗

31
00:02:55,380 --> 00:02:57,660
你看ARCOID其实也有类似一些问题

32
00:02:59,560 --> 00:03:03,180
这是关于实验部分的一个说明

33
00:03:03,180 --> 00:03:04,900
就是我们会请我们助教

34
00:03:06,140 --> 00:03:08,200
在通过视频的方式给大家

35
00:03:08,200 --> 00:03:10,000
就是讲解这个框架

36
00:03:10,000 --> 00:03:12,160
和一些实验就要注意的事项

37
00:03:12,160 --> 00:03:14,520
第二个是说

38
00:03:14,520 --> 00:03:18,000
有同学觉得我们这个注视不够

39
00:03:18,000 --> 00:03:20,440
那其实现在我们都已经加进去了

40
00:03:20,440 --> 00:03:22,480
比如说像这个

41
00:03:22,480 --> 00:03:23,840
这是Lab4的注视

42
00:03:23,840 --> 00:03:27,500
我们可以看到Lev4的Lev3也一样

43
00:03:27,500 --> 00:03:30,160
关于整个美式模块的一个讲解

44
00:03:30,160 --> 00:03:35,040
模块里面的一些重要组成部分的讲解都有都市

45
00:03:35,040 --> 00:03:37,040
C和Rust也是一样的

46
00:03:37,040 --> 00:03:38,720
只是Rust可以生成一个book

47
00:03:38,720 --> 00:03:42,020
而C就直接看代码也就OK

48
00:03:42,020 --> 00:03:45,120
所以都市这一块也应该是得到了加强

49
00:03:45,120 --> 00:03:46,480
第三个是答疑

50
00:03:47,040 --> 00:03:50,400
答疑我们每天都安排了一个同学在线答疑

51
00:03:50,400 --> 00:03:51,400
就是一个助教

52
00:03:51,400 --> 00:03:57,240
所以同学有问题,尽量再通过微信可以问。

53
00:03:57,520 --> 00:04:00,220
我看之前有个同学问了一个问题,觉得不好意思,觉得挺好。

54
00:04:01,040 --> 00:04:05,180
而且我发觉大量问问题的同学,非计判级专业,

55
00:04:06,120 --> 00:04:11,360
包括本周六咱们提供了很好的午餐会,大家可以吃披萨。

56
00:04:12,140 --> 00:04:15,540
然后来的同学以非计判级专业为主。

57
00:04:16,080 --> 00:04:23,360
他们问的问题很多种,上至当前超系统的最新的研究现状,下至一个基本

58
00:04:23,360 --> 00:04:29,760
概念的理解,他们是电子系的,他们做了很detail的CPU,他就想知道硬

59
00:04:29,760 --> 00:04:31,360
件这部分和软件问题怎么去对应。

60
00:04:31,980 --> 00:04:38,780
这些问题我觉得非常好,基本上是助教加老师的人数大于大于人数,所以他们得

61
00:04:38,780 --> 00:04:41,560
到的法会很充分,我觉得这是挺好的一个方式。

62
00:04:41,560 --> 00:04:48,700
我也觉得咱们同学其实没有必要觉得不好意思问了

63
00:04:48,700 --> 00:04:51,780
我还是一直在强调鼓励大家来问

64
00:04:51,780 --> 00:04:58,240
每周六中午就是一个吃饭吃披萨和答疑的一个时间

65
00:04:58,240 --> 00:05:02,280
所以我还是鼓励大家如果有问题

66
00:05:02,280 --> 00:05:04,460
尤其是接近期中考试的时候

67
00:05:04,460 --> 00:05:08,220
你们有些问题觉得不太清楚的可以来问一下

68
00:05:08,220 --> 00:05:10,560
我觉得应该来说对于

69
00:05:10,560 --> 00:05:12,400
如果觉得自己的技术掌握不是很好的同学

70
00:05:12,400 --> 00:05:14,440
那还是有一定帮助的

71
00:05:14,440 --> 00:05:15,120
这一个

72
00:05:15,120 --> 00:05:17,260
第二个需要注意的是

73
00:05:17,260 --> 00:05:18,240
我看了一下

74
00:05:18,240 --> 00:05:20,900
就是我已经把那个在两个课堂我都放了

75
00:05:22,120 --> 00:05:24,720
去年春季和秋季的期末考试

76
00:05:24,720 --> 00:05:26,980
和系统考试的考题都已经放上去了

77
00:05:26,980 --> 00:05:30,400
我看到取的人数大约在二十多个三十多个

78
00:05:30,400 --> 00:05:33,740
但咱们有加起来可能五十多个或者是六十多个

79
00:05:33,740 --> 00:05:37,360
就是咱们还是有一大半的同学没有去看这个考题

80
00:05:37,360 --> 00:05:40,340
也许大家汹涌成桌了 觉得还不到时间

81
00:05:40,880 --> 00:05:42,880
对 我知道 可能是没到时候

82
00:05:43,340 --> 00:05:45,860
下周可能你们问题会比较多一点

83
00:05:47,720 --> 00:05:49,280
我觉得大家有必要看一下

84
00:05:49,280 --> 00:05:54,060
虽然这个题不具有实际的参考性

85
00:05:54,060 --> 00:05:55,280
但是也有间接的参考性

86
00:05:55,280 --> 00:05:57,540
我们出的题肯定跟去年是不太一样

87
00:05:57,540 --> 00:06:00,560
今年有今年一些不同的特点

88
00:06:00,560 --> 00:06:03,200
但是鼓励大家看一下

89
00:06:03,680 --> 00:06:06,300
然后还有一个我觉得也要注意的

90
00:06:06,300 --> 00:06:13,540
这对职业行感觉是考题,但是我们为了减轻学生的负担,我们在课后

91
00:06:13,540 --> 00:06:16,220
并没有安排你们必须要去做课后习题。

92
00:06:16,900 --> 00:06:21,920
但其实我们给了非常多的课后习题,从边层题到问答题。

93
00:06:23,300 --> 00:06:29,860
那个我觉得我不是第一次说了,我觉得你们最好是不看答案的情况下自己尝试去做

94
00:06:29,860 --> 00:06:31,880
一下,这样你会有更好的收获。

95
00:06:33,080 --> 00:06:36,180
如果你觉得我只是去实际答案 其实没有意义

96
00:06:36,660 --> 00:06:42,060
我也再次强调说 我们考试其实和课后练习是有直接的关系的

97
00:06:42,060 --> 00:06:46,100
所以我希望大家能够重视课后练习

98
00:06:46,100 --> 00:06:50,020
虽然我没有给分 但是他们其实和你们的期中期末考试是有直接的关系

99
00:06:51,460 --> 00:06:56,640
关于练习题 这也是有评学抱怨的说 好像题不够 其实题挺多的

100
00:06:56,640 --> 00:06:57,900
只是你去不去做的问题

101
00:06:57,900 --> 00:07:01,160
如果你花时间去做的话 我想还是有一定收获的

102
00:07:02,940 --> 00:07:08,260
好 那这是在收集了学生的一些反馈之后

103
00:07:08,260 --> 00:07:11,180
我们给大家的一些改进和一些解答

104
00:07:11,180 --> 00:07:13,220
希望大家踊跃地提问

105
00:07:13,220 --> 00:07:15,460
不光是说具体的课程内容

106
00:07:15,460 --> 00:07:18,980
包括上课的觉得老师需要讲什么

107
00:07:18,980 --> 00:07:21,560
其实我们会 你看我们也是在做一些调整

108
00:07:21,560 --> 00:07:25,160
能够更好地让学生把这门课搞懂

109
00:07:29,600 --> 00:07:32,700
好 这个我就算讲了这一部分了

110
00:07:32,700 --> 00:07:37,260
然后再回到我们回顾一下

111
00:07:37,780 --> 00:07:40,000
我上堂课其实也有一定的回顾

112
00:07:40,000 --> 00:07:42,220
就是还没回顾够 就是讲到了

113
00:07:44,480 --> 00:07:46,220
Money for Guarantee这一块

114
00:07:46,220 --> 00:07:51,540
你会看到我觉得超级种其实原理非常少

115
00:07:51,540 --> 00:07:52,640
也不是非常少

116
00:07:52,640 --> 00:07:54,400
相对于大卡实现还是非常少

117
00:07:54,400 --> 00:07:56,540
但是实现非常detail

118
00:07:57,460 --> 00:07:59,040
所以很难你能够说

119
00:07:59,040 --> 00:08:02,460
我就一下就把这个实验或者是代码搞明白

120
00:08:02,460 --> 00:08:04,800
那我们的基本的一个思路什么意思呢

121
00:08:04,800 --> 00:08:06,240
就是自上而下

122
00:08:06,240 --> 00:08:07,780
这是我们编译课也都讲过

123
00:08:07,780 --> 00:08:08,940
自上而下的一种设计思路

124
00:08:08,940 --> 00:08:10,560
就是你需要知道大面的

125
00:08:10,560 --> 00:08:12,680
然后把大面的逐渐去细化

126
00:08:12,680 --> 00:08:14,900
这样才能够把这个整个问题搞清楚

127
00:08:14,900 --> 00:08:17,520
而不要一下集中就陷入细节了

128
00:08:18,040 --> 00:08:19,040
你首先有个overview

129
00:08:19,040 --> 00:08:20,720
你首先有个全局的把握

130
00:08:20,720 --> 00:08:22,300
你如果没有全局的把握的话

131
00:08:22,300 --> 00:08:23,720
你会碰到各种各样的小的问题

132
00:08:23,720 --> 00:08:27,900
但你按有权力把握之后,你发现那些小问题都是自然而然产生的,

133
00:08:27,940 --> 00:08:30,000
然后你会想到一些相应的方法去解决。

134
00:08:30,580 --> 00:08:32,940
这个我现在说得有点大,但是你可以看看。

135
00:08:34,300 --> 00:08:39,840
比如说,我们讲这个,讲那个逻辑程序,LibreOS。

136
00:08:41,580 --> 00:08:45,740
我要去理解它的话,首先要想想,它是一个程序,那它和我们正常应用程序

137
00:08:45,740 --> 00:08:46,200
有什么不同?

138
00:08:46,860 --> 00:08:50,740
逻辑程序需要处理的问题到底和我们一般应用程序处理的问题有什么样

139
00:08:50,740 --> 00:08:51,400
的不一样?

140
00:08:51,400 --> 00:08:52,920
就在前面的兔子化那一块

141
00:08:54,280 --> 00:08:56,460
所以你会关注兔子化它要干什么事情

142
00:08:56,460 --> 00:08:57,260
在进一步进行细化

143
00:08:57,260 --> 00:08:59,180
你会发现兔子化就要重点干这些事情

144
00:08:59,180 --> 00:09:00,120
就要把它占掉

145
00:09:00,960 --> 00:09:03,080
这个是我们写应用程序其实不用碰到的问题

146
00:09:03,080 --> 00:09:05,260
但是我们写逻辑程序的时候就需要搞到这个事情

147
00:09:05,260 --> 00:09:09,360
第二个 我们以前调一个函数 Print

148
00:09:09,360 --> 00:09:11,280
这里面也是调一个函数 Print

149
00:09:11,560 --> 00:09:14,300
最底下它其实都要靠一些东西来支撑

150
00:09:14,300 --> 00:09:16,380
那么逻辑程序的靠路是要不然自己写

151
00:09:16,380 --> 00:09:16,780
写个Draw

152
00:09:17,240 --> 00:09:18,480
要不然我现在没有Draw

153
00:09:18,480 --> 00:09:19,220
我就更简单一点

154
00:09:19,220 --> 00:09:22,580
你就直接向下面的SBI更底层的软件帮我去支持

155
00:09:22,580 --> 00:09:24,420
这一点和应用程序思路是一样的

156
00:09:24,420 --> 00:09:27,020
只是具体的底层是啥不一样而已

157
00:09:27,020 --> 00:09:28,880
这就是我觉得你把这个搞明白之后

158
00:09:28,880 --> 00:09:30,520
你再去看看你的程序

159
00:09:30,520 --> 00:09:32,540
和命运程序差不多 没啥区别

160
00:09:32,540 --> 00:09:36,980
这就是重点关注区别和它所需要描述的对象

161
00:09:36,980 --> 00:09:39,220
第二个我们再看P处理这一块

162
00:09:39,220 --> 00:09:41,920
P处理这一块 我觉得它最大的不同就是特权级

163
00:09:41,920 --> 00:09:43,240
一旦有了特权级之后

164
00:09:43,240 --> 00:09:45,120
你就会发现你要去理解特权级

165
00:09:45,120 --> 00:09:47,500
硬件到底是干了啥

166
00:09:47,500 --> 00:09:52,620
在你们都做过CPU,CPU上特效器怎么去应对的,然后对于我们的软件

167
00:09:52,620 --> 00:09:55,960
怎么去积极特效器来完成一种保护,这是一个。

168
00:09:56,060 --> 00:10:02,420
第二,有了这层保护之后,我的应用程序它就不能直接去访问内核那些

169
00:10:02,420 --> 00:10:06,800
东西了,那它就有一个所谓的切换的过程,就是特效器的切换。

170
00:10:07,000 --> 00:10:11,100
一旦说你要切换,你就会涉及到另一个新的问题,切换之后有一个状态的

171
00:10:11,100 --> 00:10:14,420
保存与恢复的问题,这就是所谓的context,就是我们说的线上相对。

172
00:10:15,140 --> 00:10:19,500
这些我觉得是和原理是紧密结合的,你要去理解这些东西。

173
00:10:19,660 --> 00:10:25,940
但是为了让OS和OPK跑起来,你还要去知道一些所谓的工程上的事情。

174
00:10:26,540 --> 00:10:33,700
比如说你怎么把应用和OS捆在一起,这个没有原理,这就是一个技术。

175
00:10:33,900 --> 00:10:37,900
你要能够把这个技术给搞定,通过某种方式变成一个image。

176
00:11:09,860 --> 00:11:14,600
所以比较难的就在于特定器切换以及怎么把第一个应用程序跑起来

177
00:11:15,320 --> 00:11:17,380
我们以前是前面是靠这个bootloader

178
00:11:17,380 --> 00:11:21,900
就是我们这一块是靠我们说靠QML加Rust SBI

179
00:11:21,900 --> 00:11:24,580
帮我们把OS和应用等都给撑起来了

180
00:11:24,580 --> 00:11:28,240
但这里面已经区分出来OS和应用是分开的

181
00:11:28,240 --> 00:11:31,220
那么应用的加载和执行是靠OS

182
00:11:31,660 --> 00:11:33,960
OS本身还有一个loader有一个很重要的事情

183
00:11:33,960 --> 00:11:39,360
它给应用创建相应的执行环境

184
00:11:39,360 --> 00:11:41,360
这里面提到一些概念执行环境

185
00:11:41,360 --> 00:11:43,200
在这里面执行环境包含的内容

186
00:11:43,200 --> 00:11:45,840
就会比这个里面要更加丰富

187
00:11:45,840 --> 00:11:49,360
对于这儿而言你提供的执行环境

188
00:11:49,360 --> 00:11:52,320
就是一个站 最核心是一个站

189
00:11:52,320 --> 00:11:53,740
但对于这里面而言

190
00:11:53,740 --> 00:11:57,900
你还要提供所谓的应用的

191
00:11:57,900 --> 00:12:00,100
应用的除了它用户空间的站之外

192
00:12:00,100 --> 00:12:02,900
还有一些在内核里面要回去的context

193
00:12:02,900 --> 00:12:07,840
以及对应的内核视频类似的一个放这个content的地方,比如说内核站,这都是

194
00:12:07,840 --> 00:12:12,080
需要去进一步考虑的细节了,P处理。

195
00:12:14,300 --> 00:12:19,900
到了Metroid 4的时候,你会发现它应对的问题又更加复杂一点,前面每次

196
00:12:19,900 --> 00:12:26,980
跑只有一个APP,现在你跑了之后是一堆APP,这一系列的APP都放在内存

197
00:12:26,980 --> 00:12:28,120
里面了,这是一个大的区域。

198
00:12:28,120 --> 00:12:30,520
但这个加载的过程没变

199
00:12:30,520 --> 00:12:32,680
它都是把那个img里面的APP找出来

200
00:12:32,680 --> 00:12:34,800
放到相应的内存地址空间而已

201
00:12:35,900 --> 00:12:37,560
这是一个放置这个没问题

202
00:12:37,940 --> 00:12:39,660
但是你既然有多个APP之后

203
00:12:40,700 --> 00:12:43,100
那么你还跟前面一点很不一样在哪

204
00:12:43,100 --> 00:12:44,740
这个APP的执行过程中间

205
00:12:44,740 --> 00:12:47,920
它就需要暂停下来

206
00:12:47,920 --> 00:12:49,400
换到另一个APP去执行

207
00:12:49,400 --> 00:12:52,040
这就我们说提到了很重要一点

208
00:12:52,040 --> 00:12:54,520
你就会引出一个新的东西叫任务

209
00:12:55,480 --> 00:13:04,360
这个用红色。这个任务意味着什么?任务是一个概念,我们虽然强调是概念,

210
00:13:04,460 --> 00:13:11,020
但是我一直在强调,我上课的时候从第一堂课开始讲,我们上正常课的目的是要

211
00:13:11,020 --> 00:13:15,840
去理解概念,理解计算机系统是第一个,然后第二个是理解概念和对

212
00:13:15,840 --> 00:13:17,760
应的直线之间的联系。

213
00:13:19,340 --> 00:13:23,820
我现在说这闹一句话 所有这些概念都在代码里面有直接的对应

214
00:13:24,700 --> 00:13:28,180
所以说你看到了 看明白了 你就应该知道这概念意味着什么

215
00:13:28,180 --> 00:13:31,820
而不是说只是知道这个概念是一个什么应用程序的执行过程

216
00:13:31,820 --> 00:13:34,260
这么一个很粗的解释

217
00:13:34,260 --> 00:13:36,880
对于这个来说 一旦设计到实现

218
00:13:36,880 --> 00:13:39,440
那意味着我们超级统计要把这个任务给管起来

219
00:13:39,440 --> 00:13:43,620
你要管这个任务的话 自然就有一个所谓的管任务的一个很重要的两点

220
00:13:43,620 --> 00:13:46,480
大家都学会一个数据结构 一个对应它的操作

221
00:13:46,480 --> 00:13:48,960
那这个数据结构是什么呢 跟Task相关数据结构

222
00:13:49,680 --> 00:13:53,080
它这里面有个Task Manager管了一堆的任务

223
00:13:53,080 --> 00:13:56,780
底下这个很重要的我们叫Task Manager

224
00:13:56,780 --> 00:13:58,340
这管了一堆的任务

225
00:13:58,340 --> 00:14:00,440
Loader呢 负责把这些APP给加了上去

226
00:14:00,440 --> 00:14:02,940
但是真正要去 谁执行谁不执行

227
00:14:02,940 --> 00:14:04,560
是由Task Manager才会去管

228
00:14:04,560 --> 00:14:06,260
那管了一堆任务 每一个任务什么呢

229
00:14:06,260 --> 00:14:08,600
每一个任务有TCB 就是任务控制框

230
00:14:08,940 --> 00:14:10,140
那这是数据结构

231
00:14:10,680 --> 00:14:11,740
我要去管这个任务

232
00:14:11,740 --> 00:14:13,960
就把相关它的什么状态 它的相关的信息

233
00:14:13,960 --> 00:14:15,320
全放在TCB里面去管起来

234
00:14:17,000 --> 00:14:19,580
一个任务执行 真正执行会发现

235
00:14:19,580 --> 00:14:22,020
它有它的执行环境 这个执行环境进一步复杂

236
00:14:22,020 --> 00:14:24,760
在哪呢 你看到这一块的执行环境

237
00:14:24,760 --> 00:14:27,640
用户空间的执行环境 跟之前的一样 没区别

238
00:14:27,640 --> 00:14:30,100
有它自己的代码 那个数据段 赞

239
00:14:30,940 --> 00:14:33,520
但是内核要管它 你会发现

240
00:14:33,520 --> 00:14:35,700
它有它的 trap context

241
00:14:37,080 --> 00:14:39,100
每一个任务有自己的 trap context

242
00:14:39,100 --> 00:14:41,440
这是一个 它多了一个东西

243
00:14:41,440 --> 00:14:44,100
第二个 每个任务在内核里面含有一个赞

244
00:14:45,280 --> 00:14:53,680
而且这个trap context是放在站里面的。这个也都属于TCB的一个整体的管

245
00:14:53,680 --> 00:15:01,120
理范围之内。有了trap context,有了内核站,还有一些TCB里面的那些

246
00:15:01,120 --> 00:15:06,500
叫做trap context,这些东西合在一起就构成了所谓的任务的设计实

247
00:15:06,500 --> 00:15:06,820
现。

248
00:15:08,680 --> 00:15:14,280
它和任务很detail的一个对应就出现了,因为你在执行过程中发现,它

249
00:15:14,280 --> 00:15:15,700
确实是这个程序的执行过程。

250
00:15:15,780 --> 00:15:23,360
在执行过程中,你发现这些用户站、内核站、用户的context或者task

251
00:15:23,360 --> 00:15:28,500
context都在变化,确实是一个变化的过程,让它更具体,更能够说我们真的

252
00:15:28,500 --> 00:15:29,440
把它管起来。

253
00:15:31,180 --> 00:15:33,540
然后再接下来这个multiple-grind怎么体会什么

254
00:15:33,540 --> 00:15:34,660
它要切换

255
00:15:34,660 --> 00:15:37,480
这个切换第一步是叫做协作式的

256
00:15:37,480 --> 00:15:38,900
所以它靠什么靠系统调用

257
00:15:38,900 --> 00:15:40,920
靠一个样来完成的

258
00:15:40,920 --> 00:15:43,900
系统调用就会涉及到说要有一个切换

259
00:15:43,900 --> 00:15:46,200
除了前面讲这个线路上下弯之外

260
00:15:46,200 --> 00:15:47,440
还有一个任务上下弯

261
00:15:49,800 --> 00:15:51,120
多了两个切换

262
00:15:51,120 --> 00:15:53,820
前面只有一个线路就是特别级的切换

263
00:15:53,820 --> 00:15:55,280
现在还多了任务级的切换

264
00:15:55,280 --> 00:15:55,960
两个切换

265
00:15:55,960 --> 00:15:58,800
而且任务的切换是在哪儿完成的

266
00:15:58,800 --> 00:16:00,640
是在内核里面完成的

267
00:16:00,640 --> 00:16:03,440
根据这个任务上下文来完成这个切换

268
00:16:03,440 --> 00:16:06,740
然后就在这里面你就要去理解

269
00:16:06,740 --> 00:16:08,680
这个为了能够让这个APP

270
00:16:08,680 --> 00:16:11,980
这个APP之间能够相互直接进行切换

271
00:16:11,980 --> 00:16:13,340
你要干什么 你要干很多事情

272
00:16:13,340 --> 00:16:16,440
你要干多了一个特定级的切换

273
00:16:16,440 --> 00:16:17,700
还要完成任务的切换

274
00:16:17,700 --> 00:16:21,900
才能够完成实实在在的两个应用运行的一个切换

275
00:16:21,900 --> 00:16:25,120
这个我觉得就是讲在解释里面

276
00:16:25,120 --> 00:16:27,600
我觉得需要理解和注意的

277
00:16:39,960 --> 00:16:53,960
所以你会发现我们也去对这个中断机制

278
00:16:53,960 --> 00:16:56,440
已经处置了 这里面涉及到了好几个层面

279
00:16:56,440 --> 00:16:58,780
你要enable中断 你要设置好设置 设置好设置

280
00:18:58,780 --> 00:19:03,420
需要看到他们的共行,共行是地址空间,这个是他们的共行

281
00:19:04,000 --> 00:19:07,800
什么叫地址空间呢?就是你的代码数据放在哪

282
00:19:07,800 --> 00:19:12,180
对于前面的实验来说,它都没有启动什么页机制,没有启动页表机制

283
00:19:12,180 --> 00:19:15,380
所以它看到了地址,全是物理地址,这是一个

284
00:19:15,380 --> 00:19:21,900
第二个,我们的OS和我们的APP其实都是一个program,都是我们编辑生成的

285
00:19:21,900 --> 00:19:26,280
它都有这么一个结构,它都是一个软件,所以都有这么一个结构

286
00:19:27,420 --> 00:19:37,100
在这个结构里面,我们的应用程序有Tax段、Data段、Basic段,但是没有

287
00:19:37,100 --> 00:19:37,680
HIP。

288
00:19:38,720 --> 00:19:39,960
我们的应用程序没有HIP。

289
00:19:40,300 --> 00:19:47,980
你看到为什么我们到现在为止,就是到过去Lecture 4讲那个OS为止,你还没法

290
00:19:47,980 --> 00:19:48,860
去动态申请内存。

291
00:19:49,460 --> 00:19:53,400
因为你没有建立这个HIP机制,这我们后面会建立,现在还建立不了。

292
00:20:24,000 --> 00:20:29,860
然后这些Stack,包括内核的这个,给每个应用建的内核站也都有了

293
00:20:29,860 --> 00:20:33,060
那为什么能建呢,是因为我建的全球变量,我全都放在这个Data段里面

294
00:20:33,640 --> 00:20:36,060
放在Data段里面,把这些全球变量都放到

295
00:20:36,720 --> 00:20:41,200
我假定我设一个最大值,就是比如说我现在支持十六个应用,就设一个十六

296
00:20:41,200 --> 00:20:42,460
个的速度

297
00:20:42,460 --> 00:20:45,900
放了十六个Trap Contacts,放了十六个Colon Stack

298
00:20:46,580 --> 00:20:51,060
这种方式就很不灵活,为什么后面会引入这种动态的方式

299
00:20:51,060 --> 00:20:57,340
但是有一点需要注意,大家内核和应用虽然它们有特权级和用户级的区

300
00:20:57,340 --> 00:21:02,660
分,但是它们看到的地址空间是一样的,都是物理地址空间,它们可以任

301
00:21:02,660 --> 00:21:04,860
意地访问各自的地址空间。

302
00:21:04,960 --> 00:21:10,380
这也是为什么没有保护业绩之后没有保护的一个很重要的问题,程序和程序之

303
00:21:10,380 --> 00:21:17,140
间没有保护,OS和DB之间也没有保护,这也是为什么我们要进一步去增强我们

304
00:21:17,140 --> 00:21:20,340
的地址空间。

305
00:21:21,440 --> 00:21:26,100
到了这一块之后,我们发现我们的OS又更加丰富了。为什么呢?

306
00:21:26,120 --> 00:21:31,540
因为我们有了各自的……它每一个APP都有一个框,你看,都有一个橙色的框的功能。

307
00:21:32,200 --> 00:21:37,240
每个APP有自己的地址空间,这是一个overview。内核有自己的地址空间,它们

308
00:21:37,240 --> 00:21:38,380
都隔开了。

309
00:21:38,520 --> 00:21:43,020
靠什么?靠我们的硬件的业绩值把它隔开了。

310
00:21:44,080 --> 00:21:47,920
这个更强大、更安全,但是更复杂。

311
00:21:47,920 --> 00:21:50,920
那么你隔拍之后你会发现

312
00:21:52,260 --> 00:21:55,880
我OS和应用地址空间不一样了这一个

313
00:21:55,880 --> 00:21:58,840
第二 应用看不到自己的paytable

314
00:21:58,840 --> 00:22:00,900
管理的部分都是内核来管

315
00:22:01,420 --> 00:22:03,860
所以虽然应用知道自己有一个地址很好

316
00:22:03,860 --> 00:22:05,180
一个很好用的地址空间

317
00:22:05,180 --> 00:22:07,260
但是它的所有的管理机制全在哪

318
00:22:07,260 --> 00:22:08,860
全在页表里面

319
00:22:08,860 --> 00:22:11,640
你看这里面有针对这个

320
00:22:12,560 --> 00:22:14,940
这页表对应的是这个空间

321
00:22:14,940 --> 00:22:17,300
这个页表对应的是内核自己

322
00:22:17,300 --> 00:22:24,080
这是内核自己 但前面这三个应用程序的地址空间 它怎么管起来

323
00:22:24,080 --> 00:22:26,380
这里面最大的部分是多了页表

324
00:22:26,380 --> 00:22:33,760
由于多了页表 使得你之前的很多的处理 都会发生一些微妙的变化

325
00:22:33,760 --> 00:22:36,500
比如说我们讲上下文切换的时候

326
00:22:37,360 --> 00:22:41,960
这个上下文有两种 线入和任务

327
00:22:41,960 --> 00:22:44,720
对于线入上下文而言 它是用过它到内核的切换

328
00:22:44,720 --> 00:22:49,720
那也意味着,其实按道理来说,这个地址空间也要发生变化,因为应用

329
00:22:49,720 --> 00:22:51,920
程序的地址空间和内核地址空间不一样。

330
00:22:52,340 --> 00:22:56,980
所以你这所谓的现有商业的话,你就不得不考虑这个地址空间的一个切

331
00:22:56,980 --> 00:22:57,700
换。

332
00:22:58,300 --> 00:23:06,000
任务需不需要考虑呢?这第二个问题,我们也需要去了解,第三,中断响应,或者说对

333
00:23:06,000 --> 00:23:07,300
系统的响应。

334
00:23:07,300 --> 00:23:14,280
那这个地址空间的引入会对这些处理带来什么样的影响,这个就要

335
00:23:14,280 --> 00:23:18,360
去考虑了,这个数据的传递问题,这实际上就是在于这种东西,triple

336
00:23:18,360 --> 00:23:24,000
line和这个地址空间的隔离,你这怎么去把这个通道给打通,使得我需要

337
00:23:24,000 --> 00:23:31,620
隔离之后,我需要共享之后,比如说至少内核需要取得应用地址空间

338
00:23:31,620 --> 00:23:35,560
的某些数据的时候,我还能爽到那些数据,怎么能做到这一步。

339
00:23:36,060 --> 00:23:40,460
这就是由于引入页板之后会带来一系列的问题,你在这过程中都需要

340
00:23:40,460 --> 00:23:42,560
去考虑怎么去解决。

341
00:23:49,700 --> 00:23:56,120
因为发现为了应对这个问题,我们把这个地址空间做了一个细化,对应用程

342
00:23:56,120 --> 00:24:03,300
序而言,我们编辑器,我们编辑器根据那个,我们说最后有个链接器啊,有

343
00:24:03,300 --> 00:24:08,740
个link.ld描述了那个应用程序的地址空间的布局,它会建好这一

344
00:24:08,740 --> 00:24:08,900
块。

345
00:24:09,460 --> 00:24:14,740
是我们传统的应用程序 用到什么用户站 用户堆

346
00:24:14,740 --> 00:24:16,900
还有什么数据段 代码段 这块用好了

347
00:24:18,560 --> 00:24:21,760
每一个建立的同样的一些设计

348
00:24:21,760 --> 00:24:24,940
比如代码段的其实例子 都是从某一个固定例子开始

349
00:24:24,940 --> 00:24:27,060
这方便了我们的应用程序的开发

350
00:24:27,940 --> 00:24:29,260
但是 光有这个不够

351
00:24:29,260 --> 00:24:31,980
因为我们需要在用户和内核之间

352
00:24:32,440 --> 00:24:37,580
要进行相应的一些互动和联系

353
00:24:37,580 --> 00:24:42,240
为此你看这里面它专门搞了一个跳板和一个Trap Context

354
00:24:42,240 --> 00:24:46,920
就在我们虚地址空间的高的一个地方放置了这些特殊的东西

355
00:24:46,920 --> 00:24:51,720
为了干什么 为了能够方便我们从用户态顺利地跳到内核态

356
00:24:51,720 --> 00:24:56,280
为了能够方便我们从内核态回得去用户态

357
00:24:56,280 --> 00:24:59,980
以及还有进一步的我要能够去把数据传递来传递去

358
00:24:59,980 --> 00:25:05,060
这些东西就使得我们在这里面的业表设置

359
00:25:05,060 --> 00:25:06,700
就有个特殊的一个设置

360
00:25:06,700 --> 00:25:08,980
特别是这个跳板 后面有专门讲跳板

361
00:25:08,980 --> 00:25:15,420
第二个 你会发现这里面的所有的这些对应的页表管理

362
00:25:15,420 --> 00:25:16,800
这都有个对应的页表管理

363
00:25:16,800 --> 00:25:21,060
还有相当于Task and Test 内核站等等这些依然存在

364
00:25:21,060 --> 00:25:24,540
只是它位于内核的地址空间

365
00:25:24,540 --> 00:25:28,220
而且不会出现像之前我们那些OS

366
00:25:28,220 --> 00:25:33,000
可以从用户的这个代码里面直接去防这些地址空间防不到

367
00:25:33,000 --> 00:25:34,980
因为我们靠页表隔开了

368
00:25:36,180 --> 00:25:44,840
这就是我们说你要理解它最大的不同就是这个业表带来了一系列的好处和一

369
00:25:44,840 --> 00:25:48,340
系列的复杂性,就所谓的challenge,你要去应对这个问题。

370
00:25:49,560 --> 00:25:59,040
这就是我简单地给大家讲,现在你们现在有一个全局的视角,你知道这些OI之

371
00:25:59,040 --> 00:26:02,040
间有什么样的不同,这些OI之间它们有什么样的特点。

372
00:26:02,040 --> 00:26:06,480
这其实是一特点就是我们讲的这些所谓的操作系统的一些关键的知

373
00:26:06,480 --> 00:26:06,900
识点

374
00:26:06,900 --> 00:26:10,000
只是我们希望通过一些具体的OS给它串起来

375
00:26:10,000 --> 00:26:12,600
你不是在思考一个一个孤立的点

376
00:26:12,600 --> 00:26:18,300
而是在看一个完整的系统中这些关键的知识点怎么起作用

377
00:26:18,300 --> 00:26:19,620
否则你只能背了

378
00:26:19,620 --> 00:26:21,140
我还是希望你能够理解

379
00:26:21,140 --> 00:26:26,760
就是你站在超级中启动应用程序启动和运行这么一个过程中

380
00:26:26,760 --> 00:26:30,700
你用到的一些东西来思考这些知识点怎么能够在里面发挥作用

381
00:26:30,700 --> 00:26:35,040
这样可能你我觉得捏起来会更加顺一点

382
00:26:35,040 --> 00:26:38,470
而不是单独的一个相对孤立的点

383
00:26:40,120 --> 00:26:44,120
好 那这一块我就大致说了之后

384
00:26:44,120 --> 00:26:48,120
我应该就这个讲完了

385
00:26:48,120 --> 00:26:48,900
我应该讲什么

386
00:26:52,960 --> 00:26:56,740
好 那等于前面稍微简单的一个总数

387
00:26:56,740 --> 00:26:59,000
那我们稍微再具体一点看看

388
00:26:59,480 --> 00:27:03,140
看看这一块就是关于

389
00:27:04,380 --> 00:27:05,740
把这个放大一点

390
00:27:08,500 --> 00:27:11,960
关于我们第五讲第三节的实践

391
00:27:11,960 --> 00:27:15,940
怎么建立有地址空间这么一个抽象的OS

392
00:27:18,680 --> 00:27:20,840
这里面总体的还是一个步骤

393
00:27:20,840 --> 00:27:22,840
你有一个你的目标是啥

394
00:27:22,840 --> 00:27:24,260
你做这一步的目标是啥

395
00:27:24,260 --> 00:27:25,640
第二你的总体思路是啥

396
00:27:25,640 --> 00:27:30,740
对应的以前的OS,谁第一个把这个虚纯的概念给提出来的

397
00:27:30,740 --> 00:27:33,700
然后我们具体的步骤,特别是相应的这个OS的设计

398
00:27:33,700 --> 00:27:35,240
这一块会逐一给大家讲解

399
00:27:35,240 --> 00:27:38,540
这里面会再涉及到一个我们的硬件扩展

400
00:27:38,540 --> 00:27:39,760
其实讲了很多遍了

401
00:27:39,760 --> 00:27:42,640
只是在这里面结合我们的OS,讲讲怎么去用这个硬件

402
00:27:43,620 --> 00:27:44,940
这个图刚才我已经提过

403
00:27:45,540 --> 00:27:47,760
就是管理建立好地址空间,为了管理地址空间

404
00:27:47,760 --> 00:27:50,920
你需要在内核里面建议相应的机制,特别是页表

405
00:27:50,920 --> 00:27:55,100
以及Wire的地址空间的一些隔离和传递 共享

406
00:27:55,100 --> 00:27:56,860
来做的一系列的一些调整

407
00:27:57,380 --> 00:28:00,380
这是这个OS的一个需要考虑的问题

408
00:28:01,100 --> 00:28:02,760
那它为什么要做这个事情

409
00:28:02,760 --> 00:28:05,760
你做这个事情 我们说做这个事情都是有一个原因的

410
00:28:05,760 --> 00:28:06,700
做这个事情就是

411
00:28:08,300 --> 00:28:11,740
其实我们这三点提高性能 减化 开发 加强安全

412
00:28:12,520 --> 00:28:14,980
我们OS这些共性的一个要求

413
00:28:14,980 --> 00:28:18,960
我们前面讲的几个在不同的点上

414
00:28:18,960 --> 00:28:22,460
再做这一步,比如第一个利波OS,就是简化开发的复杂性

415
00:28:22,460 --> 00:28:25,780
让APP跟具体的硬件操作隔开

416
00:28:25,780 --> 00:28:27,940
P处理让APP和OS隔开

417
00:28:27,940 --> 00:28:31,300
玛丽蓬佩奥和谭皮埃尔可以更有效地共享OS提高性能

418
00:28:31,700 --> 00:28:34,100
这是看到的之前的讲解

419
00:28:34,100 --> 00:28:35,840
那么对于这个技术空间抽象

420
00:28:36,960 --> 00:28:39,740
其实它的目的至少到目前为止

421
00:28:39,740 --> 00:28:41,240
并不是为了提高性能为主

422
00:28:41,240 --> 00:28:43,820
而是简化开发和加强安全

423
00:28:44,320 --> 00:28:46,200
这是它的目的,特别是加强安全

424
00:28:46,200 --> 00:28:53,400
它需要把APP和应用在内存这个层面要给它隔开

425
00:28:53,400 --> 00:28:57,200
所以它提出了所谓的地池空间 这是它的目标

426
00:28:57,720 --> 00:29:03,060
对我们同学来说 你要理解地池空间的概念和对应的设计实现

427
00:29:03,060 --> 00:29:05,940
地池空间到底在OS里面意味着什么

428
00:29:05,940 --> 00:29:10,600
掌握具体这个页操作的机制 包括页表的建立 页表的修改

429
00:29:10,600 --> 00:29:12,860
这个你要能够去知道

430
00:29:12,860 --> 00:29:15,220
第三个要求稍微更高一点

431
00:29:15,220 --> 00:29:19,980
这是我们后面讲的那个虚纯的时候需要涉及到的一点

432
00:29:19,980 --> 00:29:25,000
你还会灵活运用这个业访和异常来做所谓的虚纯的管理

433
00:29:25,000 --> 00:29:26,920
我们把这个异常变成一个好事

434
00:29:26,920 --> 00:29:29,760
不是说真正的超级统我们应用程序除了错

435
00:29:29,760 --> 00:29:36,220
而是我们超级统利用这种异常机制来给我们的APP提供一个非常大的一个

436
00:29:36,220 --> 00:29:37,140
虚拟的地址空间

437
00:29:38,100 --> 00:29:42,540
最后一个就是你要能够去掌握怎么去写一个有业机制的OS

438
00:29:43,720 --> 00:29:46,940
这是对我们同学的一个要求

439
00:29:48,500 --> 00:29:50,780
好 看看总理思路

440
00:29:50,780 --> 00:29:53,740
总理思路里发现在编译阶段我们更加简单了

441
00:29:53,740 --> 00:29:55,180
因为我们的link了由地铁砖

442
00:29:55,180 --> 00:29:56,760
不需要像我们前面一样

443
00:29:56,760 --> 00:29:58,980
给每一个应用配置一个它的骑士地址

444
00:29:58,980 --> 00:30:01,420
因为前面只有一个地址空间

445
00:30:01,420 --> 00:30:02,800
只有物理地址

446
00:30:02,800 --> 00:30:06,120
所以你要给每个应用放一个不同的骑士位置

447
00:30:06,120 --> 00:30:07,220
这里面又有虚储

448
00:30:07,220 --> 00:30:11,360
我们可以每一个应用放同样的一个骑士地址

449
00:30:11,360 --> 00:30:15,860
由于它可以映射到不同的物理粒子,所以它们之间不会重叠,可以正常运

450
00:30:15,860 --> 00:30:16,120
行。

451
00:30:16,440 --> 00:30:19,020
这就是对编译、对开发带来的好处。

452
00:30:19,380 --> 00:30:25,380
对于构造而言,你就知道了,构造稍微要扩展一下,重点是基于业机制

453
00:30:25,380 --> 00:30:27,760
的虚存空间。

454
00:30:28,220 --> 00:30:32,020
而这个业机制不光是影响到应用程序本身,还影响到什么?还影响

455
00:30:32,020 --> 00:30:32,620
到我们的 OS。

456
00:30:33,140 --> 00:30:37,220
我们的 OS 也需要在业机制的关系之下来运行。

457
00:30:37,220 --> 00:30:43,020
也意味着一旦enable了这个业绩之后,我们的OS和我们的应用都在各

458
00:30:43,020 --> 00:30:51,980
自的业表的管理范围之下来进行基于虚存的访问,但是OS看到的

459
00:30:51,980 --> 00:30:53,980
虚存和应用看到的虚存不一样。

460
00:30:53,980 --> 00:30:58,660
为什么这么说呢 因为OS 它其实虽然它在运行在虚立地质空间

461
00:30:58,660 --> 00:31:00,780
它也知道物理空间怎么回事

462
00:31:01,780 --> 00:31:03,920
而应用程序不知道物理空间怎么回事

463
00:31:03,920 --> 00:31:08,300
所以OS是更加强大

464
00:31:08,300 --> 00:31:12,580
因为它其实是知道物理空间的一个情况的具体细节

465
00:31:15,060 --> 00:31:16,980
然后在具体运行过程中

466
00:31:17,780 --> 00:31:20,540
当完成处置化过程 处置化就是说建立好业表

467
00:31:20,540 --> 00:31:24,860
给每一个应用程序也建立好地址空间业表之后

468
00:31:24,860 --> 00:31:27,980
在运行的时候你会碰到一系列的运行过程中的问题

469
00:31:27,980 --> 00:31:30,460
就是我们说的特限级的切换

470
00:31:30,460 --> 00:31:33,220
地址空间的切换 任务的切换等等

471
00:31:33,220 --> 00:31:35,820
所有的复杂性都来自于切换

472
00:31:35,820 --> 00:31:39,320
越界的地方 就是正常执行一点问题没有

473
00:31:39,320 --> 00:31:42,400
但一旦要做一些所谓的越界操作

474
00:31:42,400 --> 00:31:45,340
就会比较麻烦 你要去特殊处理

475
00:31:45,340 --> 00:31:47,640
通常是我们编辑搞不定 需要我们去

476
00:31:47,640 --> 00:31:49,620
很多情况我们要汇编来搞定

477
00:31:49,620 --> 00:31:50,560
高级语言搞定

478
00:31:50,560 --> 00:31:53,620
要用最底层的语言才能把这个事情搞定

479
00:31:53,620 --> 00:31:56,640
这个是需要大家去理解的

480
00:31:57,820 --> 00:32:00,880
好 再看看简单的历史背景

481
00:32:00,880 --> 00:32:05,000
那么这个其实很早以前我们都注意到一个问题就是

482
00:32:05,000 --> 00:32:06,300
存储设备有快有慢

483
00:32:07,020 --> 00:32:08,820
所以我们把快的地方用来放什么

484
00:32:08,820 --> 00:32:12,700
放所谓的Data 放程序执行

485
00:32:12,700 --> 00:32:15,680
然后把一些数据可以长久保存放在慢的地方

486
00:32:16,040 --> 00:32:18,680
那这一次很早前就有了

487
00:32:18,680 --> 00:32:20,800
基于磁设备还不是什么电子设备

488
00:32:20,800 --> 00:32:24,160
但是很重要的一个概念叫watch memory的概念

489
00:32:24,160 --> 00:32:26,240
就是提出实际上对于学生的一个博士的

490
00:32:26,700 --> 00:32:29,420
德国的一个博士生

491
00:32:29,420 --> 00:32:30,820
他提出这个watch memory

492
00:32:30,820 --> 00:32:32,880
为什么当时提出这个概念也很有意思

493
00:32:32,880 --> 00:32:35,060
在于当时的内存很小

494
00:32:35,060 --> 00:32:36,100
当时内存很小

495
00:32:36,100 --> 00:32:41,600
他希望能够把辅助的存储和所谓的快速的组成结合在一起

496
00:32:41,600 --> 00:32:44,860
形成一个更大的一个虚拟的内存

497
00:32:44,860 --> 00:32:46,680
给我们应用程序提供相应的支持

498
00:32:46,680 --> 00:32:52,680
这就是他在50年代提出来的一个概念

499
00:32:52,680 --> 00:32:55,520
很早 我们这里面可以看到历史很悠久

500
00:32:55,520 --> 00:32:57,760
但是现在还在有新的地步

501
00:32:57,760 --> 00:33:01,040
然后在59年的时候 英国

502
00:33:01,040 --> 00:33:04,620
你会发现我这里面介绍了大量的那些很多的一些计算机的知识

503
00:33:04,620 --> 00:33:08,080
我不知道跟你们以前上计算机的课讲的一不一样

504
00:33:08,080 --> 00:33:10,620
我讲的大部分在欧洲好像并不在美国

505
00:33:10,620 --> 00:33:15,060
很多的idea好像更早在欧洲就已经出现了

506
00:33:15,060 --> 00:33:18,380
英国的曼基斯特大学的一个教授

507
00:33:18,380 --> 00:33:21,740
展示了他们的ATLAS这个计算机

508
00:33:21,740 --> 00:33:24,440
然后对应了一个超级统叫ATLAS Supervisor

509
00:33:24,440 --> 00:33:26,700
那时候它不叫超级统 叫Supervisor

510
00:33:26,700 --> 00:33:28,840
管理者 监管

511
00:33:28,840 --> 00:33:32,380
然后在这边就基于这种idea提出了所谓的分页机制

512
00:33:33,160 --> 00:33:35,200
在这里面提出来的时候你会发现

513
00:33:35,200 --> 00:33:37,920
OS就是软件和硬件放在一起的

514
00:33:38,560 --> 00:33:39,720
它需要有硬件的支持

515
00:33:39,720 --> 00:33:41,860
所以光靠软件是不够的

516
00:33:41,860 --> 00:33:44,540
然后它提出了所谓的配信集体和对应

517
00:33:44,540 --> 00:33:46,400
Virtual Memory的一个具体的设计实现

518
00:33:46,400 --> 00:33:48,640
这就是我们看到的目前能了解到的

519
00:33:48,640 --> 00:33:54,500
最早的虚纯的一个概念和design

520
00:33:54,500 --> 00:33:55,900
这是历史

521
00:33:57,320 --> 00:33:59,320
最后再看看我们这个实践

522
00:33:59,320 --> 00:34:01,260
下一节就是实践这个步骤

523
00:34:01,260 --> 00:34:06,420
实践步骤我们一般是从应用到OS

524
00:34:07,040 --> 00:34:08,900
你会发现跟前面比起来我们要改什么

525
00:34:08,900 --> 00:34:10,100
改这个APP的链接脚本

526
00:34:11,160 --> 00:34:13,260
需要能够知道怎么去加载和执行程序

527
00:34:13,260 --> 00:34:14,480
怎么去切换任务

528
00:34:14,480 --> 00:34:15,960
因为这里面多了个地址空间

529
00:34:15,960 --> 00:34:16,760
所以切换任务的时候

530
00:34:16,760 --> 00:34:18,060
需要把地址空间切换

531
00:34:18,060 --> 00:34:19,980
这大致看着这么回事

532
00:34:20,460 --> 00:34:22,800
这个操作我觉得前面讲过很多次了

533
00:34:22,800 --> 00:34:26,140
取得DSTG4的这个branch

534
00:34:26,140 --> 00:34:28,900
然后make run就可以得到相应的一个处理过程

535
00:34:28,900 --> 00:34:30,820
而且会有一个小的策略

536
00:34:30,820 --> 00:34:33,620
是说你如果运件的话会有FigureForce

537
00:34:33,620 --> 00:34:36,120
就我们说的这是坏的处理

538
00:34:36,120 --> 00:34:38,440
就是说我们确实可以阻止应用程序

539
00:34:38,440 --> 00:34:41,480
随意地访问不盖他访问的地址空间

540
00:34:41,480 --> 00:34:44,040
这是有这么一个demo

541
00:34:46,240 --> 00:34:47,380
这是两个小的程序

542
00:34:47,380 --> 00:34:49,900
你看它都是专门是访问了一个所谓的

543
00:34:49,900 --> 00:34:50,600
好像是零地址

544
00:34:51,440 --> 00:34:52,920
就是一个load一个store

545
00:34:52,920 --> 00:34:54,000
就是一个读一个写

546
00:34:54,000 --> 00:34:56,760
这两个小程序分别做这种读写操作的时候

547
00:34:56,760 --> 00:34:57,840
就会产生异常

548
00:35:00,320 --> 00:35:01,880
这是简单的实践

549
00:35:03,300 --> 00:35:04,660
说到这我简单提醒一下

550
00:35:04,660 --> 00:35:07,040
我还是希望大家能够去试一试

551
00:35:07,040 --> 00:35:08,340
即使你没做实验

552
00:35:08,440 --> 00:35:11,660
你还是可以把这个code下下来跑一跑

553
00:35:12,100 --> 00:35:13,380
然后大致看一下代码

554
00:35:13,380 --> 00:35:16,880
这个代码现在也就才1000多行

555
00:35:17,300 --> 00:35:19,340
还是可以在一个可接受的范围之内

556
00:35:19,340 --> 00:35:22,080
像咱们同学写程序超过1000行

557
00:35:22,080 --> 00:35:23,540
应该还是挺多的

558
00:35:23,540 --> 00:35:25,780
我也知道软件工程课里面

559
00:35:25,780 --> 00:35:28,100
你们的代码量远超1000行

560
00:35:28,100 --> 00:35:28,720
是吧

561
00:35:29,260 --> 00:35:30,280
虽然这个是OS

562
00:35:30,280 --> 00:35:31,880
但是我觉得1000行代码

563
00:35:31,880 --> 00:35:32,980
还在你们的可碰范围之内

564
00:35:32,980 --> 00:35:36,280
无论是C还是RUST

565
00:35:36,280 --> 00:35:38,960
都应该是读一读应该是没什么问题的

566
00:35:38,960 --> 00:35:40,280
而且加了足够的注释

567
00:35:40,280 --> 00:35:41,840
我觉得大家应该能够看明白

568
00:35:41,840 --> 00:35:44,240
如果有不懂一样尽量问一下

569
00:35:46,580 --> 00:35:49,000
大家看这讲这个

570
00:35:49,880 --> 00:35:53,180
再接下来讲就是跟这个软件架构设计相关了

571
00:35:53,180 --> 00:35:55,680
这里面设计的内容可以稍微多一点

572
00:35:55,680 --> 00:35:57,440
为了能够支持所谓的页表

573
00:35:57,440 --> 00:35:59,200
就是所谓地址空间的隔离

574
00:35:59,200 --> 00:36:02,860
我们要看到有这么多相关的一些内容需要去了解

575
00:36:02,860 --> 00:36:04,220
比如应用程序怎么简化

576
00:36:04,220 --> 00:36:05,100
怎么建立Page

577
00:36:05,840 --> 00:36:09,180
然后针对内核和应用怎么建立各自的业表

578
00:36:09,820 --> 00:36:12,000
有了各自业表之后他们就隔离开了

579
00:36:12,000 --> 00:36:14,700
既然隔离开了之后我怎么能够去完成信息的传递

580
00:36:14,700 --> 00:36:16,900
我怎么把APP的数据传给内核

581
00:36:16,900 --> 00:36:18,780
内核的数据传回给APP

582
00:36:18,780 --> 00:36:21,460
这都需要去考虑

583
00:36:21,460 --> 00:36:23,480
然后为此 为了能够搞定这些事情

584
00:36:23,840 --> 00:36:26,860
他要搞了一个专门特殊的窍板设计

585
00:36:26,860 --> 00:36:31,240
使得应用内核可以比较方便的 平滑的进行切换

586
00:36:31,240 --> 00:36:34,080
和相应的数据传递 这是一个

587
00:36:34,080 --> 00:36:40,820
第二呢,对于我们前面讲的这个task管理来说,它管理东西更多了,它

588
00:36:40,820 --> 00:36:45,560
有一个所谓的一个地址空间这么一个资源需要它去管理,所以你要去扩展所

589
00:36:45,560 --> 00:36:47,300
谓的TCB这一块。

590
00:36:47,620 --> 00:36:54,800
最后还要扩展异常,因为你要去理解应用程序发出的一些异常跟内

591
00:36:54,800 --> 00:37:01,100
存跟业表相关的一些操作,做出相应的一些判断和后续的执行,所以

592
00:37:01,100 --> 00:37:02,380
你要知道异常怎么去处理。

593
00:37:02,380 --> 00:37:09,160
这次我们说 总体来说 为了能够在前面一个OS的基础之上

594
00:37:09,160 --> 00:37:10,840
实现一个所谓的有地址空间的OS

595
00:37:10,840 --> 00:37:12,540
你需要去考虑一些新的问题

596
00:37:15,200 --> 00:37:16,780
这里面大致列出来了

597
00:37:16,780 --> 00:37:19,780
就是你看在构建应用程序的时候

598
00:37:19,780 --> 00:37:21,520
你更加简单了

599
00:37:21,520 --> 00:37:25,100
这个所谓的给每个应用设置唯一的歧视地址

600
00:37:25,100 --> 00:37:27,640
脚本就没有用了 不需要了

601
00:37:27,640 --> 00:37:28,920
linker的LD里面

602
00:37:28,920 --> 00:37:31,560
会将所有应用放在各自的地址空间的固定位置

603
00:37:31,560 --> 00:37:33,560
给出一个统一的固定位置

604
00:37:33,560 --> 00:37:35,860
这样它的期时位置是确定的

605
00:37:35,860 --> 00:37:38,440
这就是我们应用程序要考虑的问题

606
00:37:38,440 --> 00:37:39,920
我再说一点

607
00:37:40,640 --> 00:37:42,620
这是一个同学在课后问的一个问题

608
00:37:42,620 --> 00:37:44,080
他在课后找老师问的问题

609
00:37:44,080 --> 00:37:46,560
他说编译系在

610
00:37:47,380 --> 00:37:48,500
就Minker也算是编译系

611
00:37:48,500 --> 00:37:50,520
编译系在生成这个地址空间的时候

612
00:37:50,820 --> 00:37:55,940
他知道它生成的是虚地址还是物理地址吗

613
00:37:55,940 --> 00:37:57,840
他认为编译系需要知道

614
00:37:57,840 --> 00:37:59,640
它到底是生成的是物理地址还是虚地址

615
00:38:00,440 --> 00:38:03,640
还是虚拟地址?大家觉得呢?

616
00:38:08,020 --> 00:38:12,980
其实编辑它只是生成地址,因为这个地址是物理地址、虚拟地址,那是我们

617
00:38:12,980 --> 00:38:13,960
OS决定的。

618
00:38:14,040 --> 00:38:17,260
我们S没写列表,它是物理地址,如果S写列表,它是虚拟地址。

619
00:38:18,360 --> 00:38:23,060
它只管地址,那个地址的信息来自于linker的邮寄,这里面指定了生

620
00:38:23,060 --> 00:38:25,260
成了很具体的地址是什么。

621
00:38:25,260 --> 00:38:30,260
所以编写根本不care它生成的那个地址是什么地址

622
00:38:31,080 --> 00:38:33,120
这个需要注意

623
00:38:34,260 --> 00:38:35,440
对于OS而言

624
00:38:37,420 --> 00:38:38,700
OS也是一个软件

625
00:38:38,700 --> 00:38:40,260
所以它也有一个邮递

626
00:38:41,100 --> 00:38:43,000
但这一点就不一样了

627
00:38:43,000 --> 00:38:43,820
虽然编写不知道

628
00:38:43,820 --> 00:38:48,360
但我写OS这个人你是要知道的

629
00:38:48,360 --> 00:38:51,820
你写的时候你这时候的这个linker

630
00:38:51,820 --> 00:38:53,180
就linker的cube这个邮递

631
00:38:54,080 --> 00:38:58,880
你认为设置的地址,因为这也是开发者写的,这个地址一定是虚地址,不是

632
00:38:58,880 --> 00:39:00,320
物理地址。

633
00:39:00,620 --> 00:39:05,260
这个你要知道,否则你要写一个物理地址,那可能就会有点问题。

634
00:39:06,280 --> 00:39:10,920
这是你要清楚,因为你这个程序最终是在一个,也许一开始是在物理的空间里

635
00:39:10,920 --> 00:39:11,260
面运行,

636
00:39:11,300 --> 00:39:14,180
但是一旦你内部液体之后,所有的地址变成虚地址。

637
00:39:15,080 --> 00:39:19,180
所以你写这个linker这个LD里面写的虚地址,这个需要注意。

638
00:40:19,280 --> 00:40:21,520
它的联系对称分配就用BodySystem

639
00:40:21,520 --> 00:40:22,660
就用Body算法

640
00:40:24,040 --> 00:40:25,360
也是我们的同学写的

641
00:40:25,360 --> 00:40:28,880
这个同学叫陈嘉洁同学

642
00:40:29,740 --> 00:40:31,100
可能有些同学认识

643
00:40:31,680 --> 00:40:34,340
我觉得他写得挺不错的

644
00:40:34,340 --> 00:40:37,380
然后最大的增加在哪里

645
00:40:37,380 --> 00:40:38,260
在MM的这个MV

646
00:40:38,820 --> 00:40:40,480
就是类统管理

647
00:40:40,480 --> 00:40:43,520
这个MMV里面你看它已经完成了所谓的

648
00:40:43,520 --> 00:40:46,420
我要去把这个地址给表示出来

649
00:40:46,420 --> 00:40:48,060
它有虚地址有物理地址

650
00:40:48,060 --> 00:40:53,480
对于C语言而言,我也顺道会讲一下C语言,这有点区别。C语言而

651
00:40:53,480 --> 00:40:58,400
言,它其实没有区分物理意识和虚立意识的类型,对于C语言而言,

652
00:40:58,440 --> 00:41:03,080
所有这些类型都是一个整形的树。

653
00:41:03,080 --> 00:41:08,440
但对于RUS的URL,它为了更好地去做安全检查和安全保证

654
00:41:08,940 --> 00:41:14,160
它的Virtual Address和Figure Address是不同的两种类型

655
00:41:14,160 --> 00:41:17,060
它做了个区分,这样子你写程序更不易出错

656
00:41:17,940 --> 00:41:20,060
这是一个类型的抽象

657
00:41:20,060 --> 00:41:23,360
第二个,它有两个叫Friend Allocator和Keep Allocator

658
00:41:23,360 --> 00:41:26,180
这是RUS,但其实对于Sale也有类似的

659
00:41:26,680 --> 00:41:32,200
你需要在我们这个内核里面提供一套连续内存分配的机制

660
00:41:32,820 --> 00:41:35,420
它能够完成我们前面说的对页表的分配

661
00:41:35,420 --> 00:41:37,100
对物理页针的分配

662
00:41:37,100 --> 00:41:38,900
这就靠这两个来搞定了

663
00:41:39,420 --> 00:41:41,200
对东三线存的分配 这是这一块

664
00:41:41,980 --> 00:41:45,420
再接下来就是一个很重要的概念叫memory set

665
00:41:45,860 --> 00:41:48,740
这个memory set就是我们前面讲抽象概念的时候

666
00:41:48,740 --> 00:41:50,940
讲了很多的一个词 就是三大抽象

667
00:41:50,940 --> 00:41:53,260
进程 地址空间和文件

668
00:41:53,260 --> 00:41:56,320
这个memory set就是针对地址空间

669
00:41:56,320 --> 00:41:58,860
抽象的一个具体的设计与实现

670
00:41:58,860 --> 00:42:00,900
这是code 那个是概念

671
00:42:00,900 --> 00:42:03,340
扣淘概念 我意思说这是有对应关系的

672
00:42:03,340 --> 00:42:07,920
在这里面会进一步看到这个地址空间

673
00:42:07,920 --> 00:42:10,340
就我们叫memory set它所包含的内容

674
00:42:10,340 --> 00:42:12,960
比如说各个段 我们前面看到代码段数据段

675
00:42:12,960 --> 00:42:14,920
这里面它有一个对应叫memory area

676
00:42:14,920 --> 00:42:17,360
就是逻辑段 它用逻辑段概念来表示

677
00:42:18,080 --> 00:42:20,340
这个就代表了说你这里面各种各样的段

678
00:42:20,340 --> 00:42:23,980
有代码段数据段都放在不同的这个area里面

679
00:42:23,980 --> 00:42:26,640
这个memory area可以连续也可以不连续

680
00:42:26,640 --> 00:42:28,300
但至少它们有各自不同的特点

681
00:42:28,300 --> 00:42:29,500
比如说代码段和数据段

682
00:42:29,500 --> 00:42:32,220
它们的显著特点是代码档可以去执行

683
00:42:32,220 --> 00:42:33,760
你数据档只能是读写

684
00:42:33,760 --> 00:42:36,600
你如果是RO data 那可能是纸读

685
00:42:37,300 --> 00:42:40,000
而且还有一些是在我们的编译过程中可能生成不了的

686
00:42:40,000 --> 00:42:41,760
比如说我们的堆空间的堆的一个段

687
00:42:41,760 --> 00:42:44,280
或者说是我们的那个站的那个段

688
00:42:44,280 --> 00:42:45,920
它会有个动态的变化

689
00:42:45,920 --> 00:42:46,840
不像前面的我们

690
00:42:46,840 --> 00:42:49,780
对于我们前面讲的那个静态内存分配

691
00:42:49,780 --> 00:42:52,200
在这里面会有静态有动态

692
00:42:52,200 --> 00:42:55,500
无论那种都是体验Memory Array这个里面的一个段

693
00:42:57,600 --> 00:43:01,180
然后其他的就是MODE-RS就是完成一个关于这个MM的促成化

694
00:43:01,180 --> 00:43:05,620
它会把前面的People的Creator、Fragment的Creator给它促成化完毕

695
00:43:05,620 --> 00:43:08,740
这个所谓的促成化其实最主要的一点就在于它要知道

696
00:43:09,340 --> 00:43:12,440
超级同样要知道这个现在的计算机里面

697
00:43:12,440 --> 00:43:14,020
就是你们用的KUMA这个模拟计算机里面

698
00:43:14,020 --> 00:43:17,320
到底还有多少物理空间可以用 可以管起来

699
00:43:17,320 --> 00:43:19,560
需要把这个空闲的有用的空间给管起来

700
00:43:19,560 --> 00:43:21,980
Available的Memory给管起来

701
00:43:21,980 --> 00:43:23,640
这是它要干的促成化很重要一点

702
00:43:23,640 --> 00:43:28,140
从而可以给后续的我们的OS去分配空间

703
00:43:28,140 --> 00:43:30,640
释放空间的时候 它就有一个base

704
00:43:31,580 --> 00:43:34,660
最后一个是PageTable的OS 就是建页表

705
00:43:34,660 --> 00:43:39,400
你会在这里面看到 它怎么去建立页表的

706
00:43:39,400 --> 00:43:40,960
我们的页表 后面有三级页表

707
00:43:40,960 --> 00:43:43,640
怎么一步步地把每一个页表搞出来

708
00:43:43,640 --> 00:43:45,540
把你们的页表项给它建好

709
00:43:45,540 --> 00:43:49,340
这就是PageTable里面的程序里面的一个实现

710
00:43:49,760 --> 00:43:54,340
对应的C源类似 只是函数名不同 干的事儿都是一样的

711
00:43:56,620 --> 00:44:01,100
这是对最大的更新 除了这个更新 我们还要做一系列的调整

712
00:44:01,100 --> 00:44:02,880
什么调整呢 比如Syscall

713
00:44:02,880 --> 00:44:07,400
Syscall调整什么呢 调整就是说我们从用户态 网络业态传数据的时候

714
00:44:07,400 --> 00:44:11,160
用户态里面用的是用户的地址空间 它有它自己的页表

715
00:44:11,160 --> 00:44:15,260
到内核态里面 比如Syswrite传一个buffer 是用户态的buffer

716
00:44:15,260 --> 00:44:17,580
那内核里面是内核的地址空间

717
00:44:17,580 --> 00:44:19,120
它们两个空间完全不一样

718
00:44:19,120 --> 00:44:20,380
对应的音色都不一样

719
00:44:21,820 --> 00:44:24,960
你那个用户空间里面的一个0x10000

720
00:44:24,960 --> 00:44:26,020
到内核里面的0x10000

721
00:44:26,020 --> 00:44:27,300
是完全是不同的地址了

722
00:44:27,300 --> 00:44:30,000
所以你需要把这个正确的

723
00:44:30,000 --> 00:44:31,460
把这个数据从用户空间

724
00:44:31,460 --> 00:44:33,020
给转到内核空间里面来

725
00:44:33,020 --> 00:44:34,240
你要做修改

726
00:44:41,100 --> 00:44:42,600
好 大家先休息一下

727
00:50:05,760 --> 00:50:09,060
所以你这个Task的相关的一个控制结构里面

728
00:50:09,060 --> 00:50:12,740
会有跟页表相关的一系列的一些处理

729
00:50:12,740 --> 00:50:14,020
比如我创建一个Task的时候

730
00:50:14,020 --> 00:50:15,240
需要把对应的页表

731
00:51:15,400 --> 00:51:19,180
然后和对应的修改给大家overview了一下

732
00:51:19,180 --> 00:51:23,040
那接下来看看这里面涉及到新的硬件是啥

733
00:51:23,040 --> 00:51:24,340
就所谓新的硬件就是说

734
00:51:24,340 --> 00:51:28,540
你要再去深入了解一下Risk 5里面硬件细节

735
00:51:28,540 --> 00:51:33,180
虽然我们的组成员里面的老师都给大家讲过

736
00:51:33,180 --> 00:51:35,380
但我这里面还不得不再讲一下

737
00:51:36,120 --> 00:51:38,500
我假定同学有基本的了解

738
00:51:38,500 --> 00:51:40,760
但可能有些细节稍微再回顾一下

739
00:51:40,760 --> 00:51:46,540
第一个 这是一个我们说这个SV39

740
00:51:46,540 --> 00:51:51,100
就是39位虚地址空间的一个页表极致的一个很重要的一个图

741
00:51:51,100 --> 00:51:54,120
而这个图来自于MIT 我觉得画的图非常漂亮

742
00:51:54,120 --> 00:51:56,900
所以我们就把它直接拿过来 没有写标注

743
00:51:56,900 --> 00:52:00,360
这点不太好 应该写个标注来自于MIT

744
00:52:00,360 --> 00:52:04,360
第一个SATP就指向了所谓的这页基子 页的基子

745
00:52:04,360 --> 00:52:06,880
但是SATP是一个计程器 你需要注意

746
00:52:06,880 --> 00:52:10,020
这个计程器它里面控制了分页的一些

747
00:52:10,020 --> 00:52:13,380
除了这个业积值的物理业增耗

748
00:52:14,380 --> 00:52:16,100
这个业目录的物理业增耗之外

749
00:52:16,100 --> 00:52:18,240
还有一些未代表的特殊的含义

750
00:52:18,240 --> 00:52:19,020
这个大家需要知道

751
00:52:19,680 --> 00:52:21,220
什么含义呢 第一个是mode

752
00:52:21,220 --> 00:52:24,400
你到底是enable的业表还是没enable的业表

753
00:52:24,400 --> 00:52:25,820
你是enable的哪种业表

754
00:52:25,820 --> 00:52:30,180
是SV39还是SV32还是SV56

755
00:52:30,180 --> 00:52:31,640
或者说更大的一个size

756
00:52:32,160 --> 00:52:34,040
那是取决于这个mode

757
00:52:35,060 --> 00:52:37,000
第二个就是ppn

758
00:52:37,000 --> 00:52:40,400
我们说这个批评,这个批评就是物理业增耗

759
00:52:40,400 --> 00:52:44,500
这两个合在一起形成了我们的SATP

760
00:52:44,500 --> 00:52:45,720
里面的集成器里面的主要内容

761
00:52:45,720 --> 00:52:48,200
我们把这两个设对了才行

762
00:52:48,200 --> 00:52:51,320
设完这个之后,一旦把它设成了比如说Mode等于8

763
00:52:51,320 --> 00:52:55,900
那意味着什么?意味着SV39就enable了

764
00:52:55,900 --> 00:52:58,540
这个业就是参与SV39这种模式

765
00:52:58,540 --> 00:53:00,200
而且它的基子就取这儿

766
00:53:00,200 --> 00:53:03,800
所以这里面,真正把还有一个bit设上之后

767
00:53:03,800 --> 00:53:07,980
还一个在一个叫S我忘了是Sdata是S哪个地方

768
00:53:07,980 --> 00:53:10,220
还有一个bit真正把这个起起来的话

769
00:53:10,880 --> 00:53:13,080
那么你这个设置就会起效果了

770
00:53:13,080 --> 00:53:14,960
这是这一块

771
00:53:15,940 --> 00:53:18,060
然后前面只是说了SATP这个计划器

772
00:53:18,060 --> 00:53:19,880
第二个很重要的是在于

773
00:53:19,880 --> 00:53:21,100
你这页表里面的

774
00:53:21,100 --> 00:53:24,800
一个页表是一个页的空间

775
00:53:24,800 --> 00:53:26,020
大约4K

776
00:53:26,020 --> 00:53:28,360
这4K里面它有一系列的项构成

777
00:53:28,900 --> 00:53:32,640
每一项大约64个

778
00:53:32,640 --> 00:53:36,960
我看应该是

779
00:53:36,960 --> 00:53:38,900
应该是占了64个字节

780
00:53:38,900 --> 00:53:40,380
64个bit

781
00:53:40,860 --> 00:53:42,660
64个bit里面呢

782
00:53:42,660 --> 00:53:44,580
其中的4位放的是VPN

783
00:53:44,980 --> 00:53:46,920
10位放的flags 各种flags

784
00:53:46,920 --> 00:53:49,380
证明是各种flags的一个

785
00:53:49,380 --> 00:53:50,180
一个标记

786
00:53:50,180 --> 00:53:52,640
最重要的几个大家需要了解的

787
00:53:55,700 --> 00:53:57,340
v 就是有效还是无效

788
00:53:57,340 --> 00:53:59,060
如果是无效意味着就是这个

789
00:53:59,060 --> 00:54:00,460
根本没有映射关系

790
00:54:00,460 --> 00:54:02,560
只有这个v等于1 它比较有映射关系

791
00:54:02,560 --> 00:54:05,580
第二个RWX 这意味着什么

792
00:54:05,580 --> 00:54:09,140
意味着是说 你这个页

793
00:54:10,120 --> 00:54:11,660
一个页表像对应的是一个页

794
00:54:11,660 --> 00:54:13,940
这个页所应该具有的属性是什么

795
00:54:13,940 --> 00:54:17,200
是可读可写还是可执行的 这是一个组合

796
00:54:17,200 --> 00:54:20,640
第三个这个U 这个U代表我们说

797
00:54:21,020 --> 00:54:24,220
我可以建一个 我可以在用户地址空间

798
00:54:24,220 --> 00:54:25,660
建好一个页表

799
00:54:25,660 --> 00:54:27,620
但这个页表里面的某一个页

800
00:54:27,620 --> 00:54:30,640
它的属性是U等于0的

801
00:54:30,640 --> 00:54:32,460
那用户模式也不能访问

802
00:54:32,460 --> 00:54:33,260
这用户不能访问

803
00:54:33,260 --> 00:54:34,280
虽然我借了这个地址空间

804
00:54:34,280 --> 00:54:35,740
但用户模式不能访问

805
00:54:35,740 --> 00:54:38,140
只有这个U等于1

806
00:54:38,940 --> 00:54:40,540
才意味着用户模式可以访问

807
00:54:40,540 --> 00:54:42,080
这是一块

808
00:54:42,080 --> 00:54:45,140
其他的像这个AD我们在后面会介绍

809
00:54:45,140 --> 00:54:47,840
会用于我们的虚存的页面质外算法

810
00:54:47,840 --> 00:54:51,940
给这些未来进行一个有效的

811
00:54:51,940 --> 00:54:53,180
去把哪些换入换出

812
00:54:53,180 --> 00:54:53,940
会用到这一点

813
00:54:53,940 --> 00:54:55,360
但至少它的含义就是说

814
00:54:55,360 --> 00:54:59,820
动态地展现了这个页表像对应的那个页

815
00:54:59,820 --> 00:55:01,260
是否被访问了

816
00:55:01,260 --> 00:55:04,220
以及是否被修改这些一些属性

817
00:55:04,220 --> 00:55:07,460
那么另外一个很重要的PPN就是这一块

818
00:55:07,460 --> 00:55:09,160
要不然只向下一级页表

819
00:55:09,160 --> 00:55:12,680
要不然只向最后的那个我们物理页的那个PPN

820
00:55:12,680 --> 00:55:13,880
这是一块

821
00:55:13,880 --> 00:55:16,480
那PPN你看到PPN多少位44位

822
00:55:16,480 --> 00:55:17,700
但是我们的区例子

823
00:55:17,700 --> 00:55:19,400
我们是SV39就是39位

824
00:55:21,160 --> 00:55:22,860
39位里面还把12位去掉

825
00:55:22,860 --> 00:55:24,960
那就是应该变成了27位

826
00:55:25,980 --> 00:55:31,820
27位的虚粒子的页号和44位的物粒子的页号

827
00:55:31,820 --> 00:55:37,580
这是一个经常同学有时候会想歪的地方或者没想够的地方

828
00:55:37,580 --> 00:55:42,260
就是我们通常说我们虚存四位轮廓形成一个更大粒子空间

829
00:55:42,260 --> 00:55:44,380
所以我们潜意识里面就会有个概念是说

830
00:55:44,380 --> 00:55:46,480
虚粒子空间会大于物粒子空间

831
00:55:47,040 --> 00:55:49,340
但这个RESPIRE给了一个很明显的法律

832
00:55:49,340 --> 00:55:51,540
它的虚粒子空间还没有物粒子空间大

833
00:55:51,540 --> 00:55:57,640
它物理值空间可以达到56位,但是我们的虚拟值空间只有39位。

834
00:55:59,080 --> 00:56:02,380
这种设计有它的一个考虑在里面。

835
00:56:02,640 --> 00:56:06,320
它是说,其实卸色39位的目的是,你现在还预保这么大,

836
00:56:06,440 --> 00:56:11,340
现在Risk 5还很年轻,你能把39位用满就已经很不错了,将来可以再

837
00:56:11,340 --> 00:56:11,760
扩大。

838
00:56:12,040 --> 00:56:14,760
将来如果真升级到所谓的storage的话,那再说。

839
00:56:15,160 --> 00:56:18,380
它这个扩大很容易,因为它的所有的硬件逻辑,

840
00:56:18,380 --> 00:56:22,840
它的硬件逻辑不会随着位数的增加而复杂化

841
00:56:22,840 --> 00:56:25,280
所以它只是把位数稍微调整一下

842
00:56:25,280 --> 00:56:27,880
就可以很容易支持到更大空间的虚极空间

843
00:56:27,880 --> 00:56:30,200
这是我觉得它设计的一个考虑

844
00:56:34,560 --> 00:56:36,960
硬件就这块就算讲完了

845
00:56:36,960 --> 00:56:39,000
那我们就也大致知道了硬件

846
00:56:39,000 --> 00:56:40,580
我们可以看看我们的成绩设计

847
00:56:41,300 --> 00:56:44,380
怎么来写支持地址空间的

848
00:56:44,380 --> 00:56:45,940
这里面又系列了两块

849
00:56:45,940 --> 00:56:47,080
一块是应用程序的编写

850
00:56:47,080 --> 00:56:50,660
一块是内核空间 内核代码的一个编辑

851
00:56:51,440 --> 00:56:56,000
这是这样 首先看应用程序 这个又再次重复

852
00:56:56,000 --> 00:56:58,000
我觉得大家可能听了我讲了太多遍了

853
00:56:58,000 --> 00:57:01,820
都觉得有点讲太多了 我就不讲了

854
00:57:01,820 --> 00:57:03,780
地址空间 我们理解是什么

855
00:57:03,780 --> 00:57:08,260
理解是 具体点应用程序地址空间

856
00:57:08,260 --> 00:57:11,540
和内核的地址空间有什么样的不同

857
00:57:12,140 --> 00:57:15,860
应用程序地址空间完全是靠编辑器来生成的

858
00:57:15,860 --> 00:57:18,600
通过编辑生成了整个地址空间之后

859
00:57:18,600 --> 00:57:22,540
它让我们的内核知道说编辑生成这么一个地址空间

860
00:57:22,540 --> 00:57:27,000
从而可以针对这个编辑生成的地址空间来建立相应的业绩

861
00:57:27,640 --> 00:57:29,980
OK 那我第一个问题就出来了

862
00:57:29,980 --> 00:57:31,200
我们的应用程序

863
00:57:31,200 --> 00:57:33,520
我们的内核为什么知道

864
00:57:33,520 --> 00:57:37,080
知道应用程序的什么代码和数据段在什么地方

865
00:57:37,080 --> 00:57:38,820
内核凭什么知道

866
00:58:16,240 --> 00:58:20,520
英文程序的执行程序是一个ARP格式的,对于英文程序ARP格

867
00:58:20,520 --> 00:58:20,900
式的执行程序,

868
00:58:20,960 --> 00:58:27,840
那里面会有很详细地描述它的代码段其实是在哪,Size是多少。

869
00:58:28,500 --> 00:58:33,820
然后我的超级种会去读这个ARP程序,把你们的信息给解析出来,从而我知道

870
00:58:33,820 --> 00:58:36,260
它的代码段在哪,开始,长度多少。

871
00:58:36,720 --> 00:58:41,020
基于这个信息,我就可以建立对应的页面,就这么一个过程。

872
00:58:41,020 --> 00:58:46,720
OK,大家需要了解,那Windows呢?那Windows没有F,它是PE格局,它PE对应着一些

873
00:58:46,720 --> 00:58:50,360
类似的东西,你换任何一个程序,它总要有这些信息,否则我们超级

874
00:58:50,360 --> 00:58:58,380
种并不知道大马上和数据链在哪,那第二个问题就来了,那前面我没有业余,

875
00:58:59,440 --> 00:59:05,500
我们前面的OS并没有GIF文件去基因解析,只是当这个OS它就做GIF

876
00:59:05,500 --> 00:59:08,480
的基因解析了,那前面的程序怎么知道大马上和数据链呢?

877
00:59:16,660 --> 00:59:19,760
對 它前面的程序根本就沒管代碼的數據 它整個一步一步的

878
00:59:19,760 --> 00:59:21,420
全放上去

879
00:59:21,420 --> 00:59:26,200
它代碼雖然合在一起 變成了一塊數據全導到一個地方

880
00:59:26,200 --> 00:59:28,680
它只要做到70例子和代碼就行了

881
00:59:28,680 --> 00:59:31,380
至於這個70例子和代碼中間包含著代碼數據上的區分

882
00:59:31,380 --> 00:59:34,420
它並沒有 區分不了 因為這個信息不存在

883
00:59:34,420 --> 00:59:36,520
我們也把它變成了bundary格式

884
00:59:36,520 --> 00:59:41,720
所以前面也没有必要 因为前面根本没有内核的保护

885
00:59:41,720 --> 00:59:44,000
所以它就简单处理了

886
00:59:44,000 --> 00:59:48,040
但对于我们的这个有地址空间的OS而言 比较稍微复杂一点

887
00:59:49,200 --> 00:59:50,560
再看这个内核

888
00:59:51,440 --> 00:59:55,200
内核呢 我们前面也说了 内核里面其实它有一个LD

889
00:59:55,200 --> 00:59:59,820
它有link.ld 这个文件描述了内核的地址空间 那是区地址空间

890
00:59:59,820 --> 01:00:02,660
但是内核不光仅仅是知道对系统东西

891
01:00:02,660 --> 01:00:04,840
它还需要知道物理地址空间怎么回事

892
01:00:04,840 --> 01:00:08,140
除了可以在这里面玩各种编辑器解决不了问题

893
01:00:08,720 --> 01:00:10,360
我觉得超级勇干的一个很多事情

894
01:00:10,360 --> 01:00:12,500
就是在干一些编辑器干不了的事情

895
01:00:13,060 --> 01:00:17,460
他就是在这里面通过内核里面创建业表来调整

896
01:00:17,460 --> 01:00:20,940
我觉得调整应用和内核地址空间

897
01:00:20,940 --> 01:00:25,000
它可以改变编辑器的一些约定的一些东西

898
01:00:25,000 --> 01:00:26,300
它很强大

899
01:00:26,300 --> 01:00:28,740
而且它可以管理整个物理空间

900
01:00:28,740 --> 01:00:30,720
包括你哪些用了哪些没用它很清楚

901
01:00:30,720 --> 01:00:33,900
这就是他为什么能够把整个计算机管起来的原因

902
01:00:33,900 --> 01:00:35,940
因为它掌控所有的物理资源

903
01:00:38,340 --> 01:00:41,560
好 第二个 在这里面

904
01:00:41,560 --> 01:00:43,360
我前面说了 编辑没搞定的事情

905
01:00:43,360 --> 01:00:44,900
就在这里已经体现了

906
01:00:46,360 --> 01:00:50,620
我们编辑并没有去生成这一块

907
01:00:50,620 --> 01:00:52,900
虚地址对应的代码数据 没有

908
01:00:53,800 --> 01:00:55,900
它生成的仅仅是下面这些东西

909
01:00:56,680 --> 01:00:58,680
就是我们应用程序上生成下面这些东西

910
01:00:58,680 --> 01:01:00,900
那为什么要有上面这个东西存在呢

911
01:01:01,480 --> 01:01:03,280
上面这些存在 我们就称之为跳板

912
01:01:03,280 --> 01:01:05,340
就是能够让我们的应用

913
01:01:05,340 --> 01:01:08,200
我们的内核在做特征机切换的时候

914
01:01:08,200 --> 01:01:09,940
能够平滑的过渡过去

915
01:01:09,940 --> 01:01:11,520
他们需要有一个平滑过渡

916
01:01:11,520 --> 01:01:16,840
什么叫平滑过渡 就是他们产生异常之后

917
01:01:16,840 --> 01:01:20,140
我们的应用程序会跳这个来

918
01:01:20,140 --> 01:01:25,280
跳这来 去进入内核带 去继续执行

919
01:01:25,880 --> 01:01:28,720
那段代码就是我们前面说的

920
01:01:29,260 --> 01:01:38,020
就是那个trapframe里面 产生特权级切换之后的

921
01:01:38,020 --> 01:01:40,340
要跳到那个第一条指令的地方

922
01:01:40,340 --> 01:01:43,040
那个地方就是放在这个跳板里面

923
01:01:43,040 --> 01:01:45,400
这里面全放的是那个叫trap

924
01:01:45,400 --> 01:01:52,060
这个字还好写trapframe.s

925
01:01:52,060 --> 01:01:56,200
就这个汇备代码里面的那个对应的位置

926
01:01:56,200 --> 01:01:58,160
而那个位置是哪指定的呢

927
01:01:58,160 --> 01:02:00,420
大家想一想 这里面其实我们说到了

928
01:02:00,420 --> 01:02:04,640
就是我们还有一个技能就是stvec

929
01:02:05,360 --> 01:02:06,640
还有vc吗

930
01:02:07,980 --> 01:02:08,320
t

931
01:02:10,220 --> 01:02:12,900
stvec反了

932
01:02:12,900 --> 01:02:14,640
stvec对

933
01:02:16,080 --> 01:02:17,120
vector

934
01:02:17,120 --> 01:02:19,440
trap vector就是这个地址

935
01:02:19,440 --> 01:02:21,000
其实会指向

936
01:02:21,000 --> 01:02:21,920
指向这个地方

937
01:02:21,920 --> 01:02:24,780
指向这个跳板中的某一个all traps的地址

938
01:02:25,160 --> 01:02:26,460
而这个过程

939
01:02:26,460 --> 01:02:30,920
这个页表的建立 代码的放置 全是超线组干的事

940
01:02:30,920 --> 01:02:32,320
不是编辑干的事

941
01:02:32,320 --> 01:02:35,560
这次编辑搞不定 它必须要跟超线组来搞定的事

942
01:02:36,440 --> 01:02:39,620
这是一个后面怎么具体去处理的

943
01:02:39,620 --> 01:02:40,500
我们再进一步看

944
01:02:40,500 --> 01:02:43,220
至少我们知道我们这边做了个特殊的设置

945
01:02:43,220 --> 01:02:46,260
所有的应用程序都有一个同样的虚地址

946
01:02:46,260 --> 01:02:49,460
就最高地址 放了一个跳板

947
01:02:50,380 --> 01:02:52,920
内核也放了一个 最高地址也放了一个跳板

948
01:02:52,920 --> 01:02:53,720
都放在这个地址

949
01:02:53,720 --> 01:03:00,200
所以他们的地址是一样的,对应的物理地址也是一样的,内容也是一样

950
01:03:00,200 --> 01:03:03,260
的,反正物理地址是一样的,这就证明它内容是一样的,这是一个特

951
01:03:03,260 --> 01:03:07,920
殊的design,目的是为了能够顺利地切换。

952
01:03:14,360 --> 01:03:21,140
我们来切换 它有两个切换 一个是特遣级过渡 一个是地址空间过渡

953
01:03:21,140 --> 01:03:24,500
特遣级过渡是产生异常路段是CPU会跳板页的ALTRAX的

954
01:03:24,500 --> 01:03:24,920
入口

955
01:03:25,960 --> 01:03:29,920
地址空间切换 在切换页表之后可以平滑地继续执行内核代码

956
01:03:30,480 --> 01:03:34,760
这里面需要注意的是我们用户空间这个地址空间

957
01:03:34,760 --> 01:03:39,320
需要注意,它根本没有任何对内核地址空间的映射

958
01:03:39,320 --> 01:03:41,420
所以这是一个

959
01:03:41,420 --> 01:03:45,480
第二个,产生特圈集那一次切换的时候

960
01:03:45,480 --> 01:03:49,600
就是我们说,比如我做了一个系统标用

961
01:03:49,600 --> 01:03:52,720
执行E-Code那条指令之后

962
01:03:52,720 --> 01:03:54,000
我们硬件会完成一些事情

963
01:03:54,000 --> 01:03:56,720
比如说保存它返回那个EPC

964
01:03:57,240 --> 01:04:00,960
SEPC那个寄存器里面会保存那个EPC的映射

965
01:04:00,960 --> 01:04:01,740
这是一个

966
01:04:01,740 --> 01:04:04,260
除了这个之外,它没有干很多事情

967
01:04:34,560 --> 01:04:37,560
线上上下轮 这个线上上下轮就是相关的计算器

968
01:04:37,560 --> 01:04:40,560
这是AutoApps里面的 还有一个对应的就是Restore

969
01:04:40,560 --> 01:04:42,960
会从线上上下轮恢复相关的计算器

970
01:04:42,960 --> 01:04:46,820
这里面的 我们说的那个计算器

971
01:04:46,820 --> 01:04:49,760
里面你会发现跟前面比起来

972
01:04:49,760 --> 01:04:52,280
稍微这点小 多点内容 我可以说出来

973
01:04:52,280 --> 01:04:55,620
除了我前面讲的那些通用计算器 0到31个通用计算器之外

974
01:04:55,620 --> 01:04:59,660
还有很重要的两个就是SSStater计算器

975
01:04:59,660 --> 01:05:02,440
保存了就是用户台的那些相关的那些状态信息

976
01:05:02,440 --> 01:05:05,920
比如说用它的那个中段你nebo没有啊等等

977
01:05:05,920 --> 01:05:08,580
这是一个 第二个保存了一个SEPC技能器

978
01:05:08,580 --> 01:05:11,420
就是回到哪去 回到用它哪个地址

979
01:05:11,420 --> 01:05:14,280
这是之前的很重要的三部分

980
01:05:14,280 --> 01:05:15,820
除了这三部分之外

981
01:05:15,820 --> 01:05:17,260
如果你加了页表机制之后

982
01:05:17,260 --> 01:05:19,020
很明显你还需要保存

983
01:05:19,020 --> 01:05:20,780
回去那个页表在哪

984
01:05:20,780 --> 01:05:24,720
就是回去你要换 你在内核里面用了内核页表

985
01:05:24,720 --> 01:05:26,060
你回去要用它页表

986
01:05:26,060 --> 01:05:27,720
所以用它页表那个机子在哪

987
01:05:27,720 --> 01:05:30,220
需要保存 就页表机制

988
01:05:30,220 --> 01:05:34,680
第2个 app 的内核站在哪 它需要保存

989
01:05:36,500 --> 01:05:38,900
因为每个 app 有不同的内核站

990
01:05:39,300 --> 01:05:41,540
第3个 不叫保存 要取出来

991
01:05:41,540 --> 01:05:43,740
就是有些是要保存 有些要取出来

992
01:05:43,740 --> 01:05:46,060
还有一个是 trap handler 入口点的取地址

993
01:05:48,860 --> 01:05:52,480
这个也需要去取出来

994
01:05:52,480 --> 01:05:53,280
这个 trap handler

995
01:05:54,120 --> 01:05:56,080
因为我们 all traps 执行完毕之后

996
01:05:56,080 --> 01:05:58,040
最终我要跳到内核的

997
01:06:58,280 --> 01:07:01,760
这物业是专门分的一块吗,还是说是在哪个地方?

998
01:07:03,380 --> 01:07:07,120
Outcrop是一段汇变代码,它会生成一个OS的image,

999
01:07:07,240 --> 01:07:10,720
那里面会有它的一个位置,知道在它的代码段里面。

1000
01:07:10,800 --> 01:07:15,240
单独我们拎出来变成一个页,然后把这个页映射到这个虚地址里面去。

1001
01:07:15,720 --> 01:07:18,720
所以它是位于一个很独特的代码段。

1002
01:07:19,640 --> 01:07:24,380
或者你还把它可以烤到一个页里面去,也可以实现。

1003
01:07:25,700 --> 01:07:31,360
如果说你在内核的代码道里面

1004
01:07:31,360 --> 01:07:32,760
里面有很好的一个隔离的话

1005
01:07:32,760 --> 01:07:34,800
就没有把它放在一个单独的页的话

1006
01:07:34,800 --> 01:07:36,940
我可以把它专门申请一个物理列存页

1007
01:07:36,940 --> 01:07:38,800
然后把代码段中的数据

1008
01:07:38,800 --> 01:07:40,260
烤到那个物理列存页里面去

1009
01:07:40,260 --> 01:07:42,680
然后再去做映射就OK

1010
01:07:42,680 --> 01:07:44,660
这是两种实验方式

1011
01:07:48,000 --> 01:07:50,200
然后假设我已经把这个

1012
01:07:57,460 --> 01:08:14,540
把所有的相关的信息全存到以战指针为基础的下面的一个空间里

1013
01:08:14,540 --> 01:08:14,620
面

1014
01:08:14,620 --> 01:08:17,500
就叫作Trap Contest 这是我们之前做的事情

1015
01:08:17,500 --> 01:08:18,940
但现在

1016
01:08:20,080 --> 01:08:22,580
这是我们之前做的事情 这样是没问题的

1017
01:08:22,580 --> 01:08:24,640
就压到这个内核站的站顶

1018
01:08:24,640 --> 01:08:31,000
但现在不一样了 不压在哪儿

1019
01:08:31,000 --> 01:08:35,100
这个sharp context是放在内核站的站顶

1020
01:08:35,100 --> 01:08:37,780
但是我们的硬件 我们前面说的硬件

1021
01:08:37,780 --> 01:08:41,660
从那个srs1扣两指令直接完之后

1022
01:08:42,020 --> 01:08:43,380
它有没有切换页表

1023
01:08:45,180 --> 01:08:47,760
没有切换页表 所以它内数的页板空间还在这

1024
01:08:47,760 --> 01:08:49,960
还是用这一块 这一块的空间

1025
01:08:53,120 --> 01:08:54,400
还基于这个来进行翻译的

1026
01:08:54,400 --> 01:08:56,160
CPUG这个 MMUG这个来翻译的

1027
01:08:57,000 --> 01:08:58,700
然后你的内核站指针

1028
01:08:58,700 --> 01:09:00,760
比如说在这里面 内核站指针这个地方

1029
01:09:01,780 --> 01:09:03,560
这是内核里面的虚地指空间

1030
01:09:04,180 --> 01:09:06,560
你能够直接去访问内核的空间吗

1031
01:09:07,280 --> 01:09:09,060
一旦访问会变成什么

1032
01:09:09,060 --> 01:09:09,760
异常

1033
01:09:12,540 --> 01:09:15,140
所以你感觉我要放在这上面的话

1034
01:09:15,140 --> 01:09:18,580
我必须先要完成切 切 切 切页表才行

1035
01:09:20,340 --> 01:09:22,680
但是你这个scratch里面放了啥东西

1036
01:09:23,160 --> 01:09:24,140
这很重要

1037
01:09:25,380 --> 01:09:29,480
这个我们有一种设计 我们给出了一种 一种设计

1038
01:09:29,480 --> 01:09:31,100
这是我再想强调一点

1039
01:09:31,100 --> 01:09:35,140
对于OS而言 你可以提出很多概念 比如说我们现在的任务

1040
01:09:35,140 --> 01:09:38,420
我们写出了shutdown test 所谓的上下文

1041
01:09:39,020 --> 01:09:44,340
但是你在design的时候 你可以有不同的design来完成这些对概念的应对

1042
01:09:44,340 --> 01:09:46,880
多对一的关系,不是一对一的关系

1043
01:09:46,880 --> 01:09:50,420
所以我这边只是给出了其中一种design的方式

1044
01:09:50,420 --> 01:09:53,100
并不是唯一的一种,还有很多种

1045
01:09:54,020 --> 01:09:55,380
我虽然只讲了一种

1046
01:09:56,200 --> 01:09:59,040
但我觉得我们的同学应该能够举一反三

1047
01:09:59,040 --> 01:10:01,020
你能够想出其他的种

1048
01:10:01,780 --> 01:10:04,620
才代表你把这轮课学明白了

1049
01:10:04,620 --> 01:10:06,700
如果你只是听了我讲的这一种

1050
01:10:06,700 --> 01:10:08,860
听明白了还不代表你明白了

1051
01:10:08,860 --> 01:10:11,120
可能还有很多同学听了之后还没明白

1052
01:10:11,740 --> 01:10:14,160
那你需要科后去明白,OK

1053
01:10:15,420 --> 01:10:18,340
或者当场提问,你哪没听懂,告诉我

1054
01:10:22,520 --> 01:10:25,340
这里面我们觉得前面的这种直接切换搞不定了

1055
01:10:27,400 --> 01:10:29,680
但是这里面我们另外一个需要这些问题

1056
01:10:29,680 --> 01:10:31,640
我们切换两个东西

1057
01:10:31,640 --> 01:10:35,460
一个是特限集,一个是地址空间

1058
01:10:35,460 --> 01:10:40,240
这两个东西至少需要两个关键的地方来放置它

1059
01:10:40,240 --> 01:10:43,120
这个地方我们之前选择的计算器,就是Scratch计算器

1060
01:11:13,120 --> 01:11:15,720
前面存的是应用的内核占占值

1061
01:11:16,100 --> 01:11:18,800
前面我们已经说了 这种方式会崩

1062
01:11:18,800 --> 01:11:20,760
因为地址同样不一样

1063
01:11:20,760 --> 01:11:22,860
那第二个 我这么放 我先换

1064
01:11:22,860 --> 01:11:27,020
你既然说 那我这样先切业表 行吗

1065
01:11:27,020 --> 01:11:31,440
那我就可以说 用Scratch存什么 存这个业表机子

1066
01:11:32,340 --> 01:11:35,900
那你这个 当时那个eCall执行完之后

1067
01:11:35,900 --> 01:11:38,480
那时候SP放的什么 用户占的占

1068
01:11:38,480 --> 01:11:40,500
用户占 那个指的SP

1069
01:11:40,500 --> 01:11:43,280
所以我把SP和页表机制给先切一下

1070
01:11:43,280 --> 01:11:46,200
切完之后我首先就要完成内核战的切换

1071
01:11:47,540 --> 01:11:49,360
完成内核页表的切换

1072
01:11:49,360 --> 01:11:51,380
然后可以做一些后面的工作

1073
01:11:51,380 --> 01:11:52,700
大家觉得这样行吗

1074
01:12:00,340 --> 01:12:01,620
人想明白了

1075
01:12:04,560 --> 01:12:06,500
也许可能觉得好像听起来是OK的

1076
01:12:10,680 --> 01:12:15,880
这个我已经说过了,你要签到内核站,它用的是内核的虚地址,

1077
01:12:16,780 --> 01:12:21,600
那就访问的物理地址根本就不是用户态的页表访问内核态的虚

1078
01:12:21,600 --> 01:12:22,160
地址,

1079
01:12:22,320 --> 01:12:27,840
得到的是用户态的物理地址,那是一个错误的地址,所以它会乱,会崩

1080
01:12:27,840 --> 01:12:28,000
溃。

1081
01:12:28,580 --> 01:12:31,860
第一种方法不行。第二种方法,那我先签页集址。

1082
01:12:31,860 --> 01:12:40,940
切了业绩之后,没错,这时候我得到了一个Scratch切换之后,我可以把物

1083
01:12:40,940 --> 01:12:45,600
理业的内核业表机子给得到,

1084
01:12:45,920 --> 01:12:54,340
然后我再设置那个SATP,设置为内核业的这个地址空间,那我就可以访

1085
01:12:54,340 --> 01:12:56,580
问内核地址空间,没错,这是可以做到的。

1086
01:12:56,580 --> 01:12:58,500
但接下来你要干的事情是什么呢

1087
01:12:58,500 --> 01:13:06,300
我们要把用户台当前的通用技能器存到线容上的文件

1088
01:13:06,300 --> 01:13:09,980
你会发现通过内核站指针需要修改通用技能器

1089
01:13:09,980 --> 01:13:13,460
才能够完成这个事情 无法正确保存

1090
01:13:14,460 --> 01:13:15,840
这个大家能不能理解

1091
01:13:15,840 --> 01:13:18,160
就是你如果这么来切了之后

1092
01:13:18,560 --> 01:13:22,120
你还需要去用某一个计算器

1093
01:13:22,120 --> 01:13:29,260
去来指向这款Test的一个机子,那你会用到一个计程器。而这个计程

1094
01:13:29,260 --> 01:13:32,840
器你一旦用了之后,就意味着破坏了用户态度,你本来要绑什么

1095
01:13:32,840 --> 01:13:33,520
计程器的内容。

1096
01:13:40,220 --> 01:13:51,260
你现在只有一个scratch和通用计程器,你怎么换?跟谁交换?站顶在哪里?

1097
01:13:51,580 --> 01:13:52,900
站顶也需要一个计程器来换。

1098
01:15:22,900 --> 01:15:27,900
我基于这个SP来完成通用计程器的保存

1099
01:15:27,900 --> 01:15:29,000
最后一步

1100
01:15:29,000 --> 01:15:31,920
再会把那个scratch在你们的内容

1101
01:15:31,920 --> 01:15:33,180
那是SP的内容

1102
01:15:33,180 --> 01:15:35,500
再存到通用的计程器里面某一位去

1103
01:15:35,500 --> 01:15:37,900
这样就会把所有的0到31个计程器全保存

1104
01:15:38,780 --> 01:15:39,880
这是一种技巧

1105
01:15:39,880 --> 01:15:44,260
就是通过这种方式来完成了我即使没用到

1106
01:15:44,260 --> 01:15:45,200
我在内核碳

1107
01:15:45,200 --> 01:15:47,200
但我用的是用不碳的地址空间

1108
01:15:47,200 --> 01:15:50,200
来完成了所有通用计程器的保存

1109
01:15:50,200 --> 01:15:54,120
保存完之后才去切页表

1110
01:15:54,120 --> 01:15:55,460
为什么能切呢

1111
01:15:55,460 --> 01:15:57,680
是在于这个trapcontest里面还存了

1112
01:15:57,680 --> 01:15:59,600
我还说还要读书三个内容

1113
01:15:59,600 --> 01:16:02,040
读出内核的页表机子

1114
01:16:02,040 --> 01:16:03,440
读出来之后就可以切了

1115
01:16:03,440 --> 01:16:05,060
因为这时候后面的技术就全保存起来了

1116
01:16:05,060 --> 01:16:08,040
我待后面的执行不会担心对它的破坏

1117
01:16:08,040 --> 01:16:10,800
不然之后最后恢复就OK了

1118
01:16:11,740 --> 01:16:12,820
大家这个听明白没有

1119
01:16:12,820 --> 01:16:14,770
如果这个听明白了 我就搞明白了

1120
01:16:15,460 --> 01:16:17,160
trapcontest的保存有恢复

1121
01:16:18,080 --> 01:16:18,880
有问题吗

1122
01:16:23,240 --> 01:16:32,140
我再回顾一下,第一步,我切的是通过scratch放的是应用的陷入上下纹,

1123
01:16:32,200 --> 01:16:34,000
就这个东西的地址。

1124
01:16:34,260 --> 01:16:41,200
那么我这么一切,那么用户的sp就变成了什么呢?就指向这个机子了,就指

1125
01:16:41,200 --> 01:16:42,120
向这个地方了。

1126
01:16:42,220 --> 01:16:49,360
然后scratch变成了sp,用它的sp,然后我就基于这个sp进行所有通用技能,其

1127
01:16:49,360 --> 01:16:50,180
他通用技能的保存。

1128
01:18:20,180 --> 01:18:22,460
这个为骑士地址来放大马丹数据段

1129
01:18:22,460 --> 01:18:24,120
这是它生成的

1130
01:18:24,120 --> 01:18:26,260
但这一块我强调这一块虚历史空间

1131
01:18:27,720 --> 01:18:31,120
是内核在创建任务的时候

1132
01:18:31,120 --> 01:18:35,020
会给这个APP对应的任务给它塞上这么一块

1133
01:18:35,020 --> 01:18:37,200
塞这一块之后才能够正常执行

1134
01:18:38,000 --> 01:18:41,820
这是两块内容

1135
01:18:41,820 --> 01:18:45,440
属于同一个应用程序的虚历史空间

1136
01:18:46,220 --> 01:18:49,100
应用程序讲完了 应用程序没什么变化

1137
01:19:20,180 --> 01:19:25,280
但是超勇在内部业务之前,他首先要对物理的空间作为一个管理。

1138
01:19:25,380 --> 01:19:37,000
我前面说到,他要建立好实际上的堆空间,就是我们的HIP,以及对物

1139
01:19:37,000 --> 01:19:38,000
理的业真。

1140
01:19:38,280 --> 01:19:42,200
因为他去动态的申请物理业真,主要以业为单位来进行申请。

1141
01:19:42,920 --> 01:19:45,620
同时我也可以以任意大小来申请这种动态的业真。

1142
01:19:45,620 --> 01:19:50,680
比如说对 RARs 而言,它的 Vector 的向量,那就是靠这种堆空间来申请

1143
01:19:50,680 --> 01:19:57,240
不管怎么说,反正我要建立一套动态的连续内存的管理机制,就是在这

1144
01:19:57,240 --> 01:19:58,760
边是要建好

1145
01:19:58,760 --> 01:20:02,600
建好这个之后,我就基于这个连续内存的管理机制来建立页表,先要

1146
01:20:02,600 --> 01:20:03,600
给自己建好页表

1147
01:20:03,600 --> 01:20:05,560
因为我自己要先运用它的蓄力指空间

1148
01:20:05,560 --> 01:20:12,900
所以这个页表里面就映射出来了,我作为内核,我应该看到的一个蓄力指

1149
01:20:12,900 --> 01:20:13,500
空间应该怎么样

1150
01:20:13,500 --> 01:20:16,580
它是内核自己去设定的

1151
01:20:16,580 --> 01:20:18,340
那这个业表机制在哪里

1152
01:20:19,600 --> 01:20:22,880
对 第一步 管理 这个业表就是第一要把物理的东西管好

1153
01:20:22,880 --> 01:20:24,920
然后建立内核和应用的业表

1154
01:20:24,920 --> 01:20:26,480
出刷的时候建立的是内核

1155
01:20:26,480 --> 01:20:28,140
后面你要让应用执行的时候

1156
01:20:28,140 --> 01:20:32,260
出刷应用的时候 出一刷应用的任务控制块的时候

1157
01:20:32,260 --> 01:20:37,100
你需要把这个每一个应用的任务控制块里面要把这个对应的业表给

1158
01:20:37,100 --> 01:20:37,500
建好

1159
01:20:37,500 --> 01:20:40,180
那个业表呢 属于我们说的地址空间的一部分

1160
01:20:40,180 --> 01:20:41,480
就是memory set的一部分

1161
01:20:43,120 --> 01:20:47,800
最后这些建立好内核对应的页表之后

1162
01:20:47,800 --> 01:20:51,180
我们可以使用页极值了

1163
01:20:51,180 --> 01:20:53,740
你看这里面很明确的指出来了

1164
01:20:53,740 --> 01:20:55,460
就是我们在跑这个内核的时候

1165
01:20:55,460 --> 01:20:56,820
我们其实有个假设

1166
01:20:56,820 --> 01:20:58,260
我们知道我们的物理内存多大

1167
01:20:58,260 --> 01:20:59,960
比如这里面设计8兆

1168
01:20:59,960 --> 01:21:01,880
然后我们也知道我们的物理内存

1169
01:21:01,880 --> 01:21:03,000
其实中断起始的

1170
01:21:03,640 --> 01:21:05,500
x8后面这么多个0 7个0

1171
01:21:05,500 --> 01:21:06,580
这是它起始的意思

1172
01:21:08,360 --> 01:21:09,960
所以可用的物理内存是什么呢

1173
01:22:39,960 --> 01:22:43,820
这看设计 对于 Rust 而言 它其实在处置化的时候

1174
01:22:43,820 --> 01:22:48,960
它已经把那个应用程序 应用程序的那个

1175
01:22:49,880 --> 01:22:52,740
占的内存也放在一个地方 放在一个对应的地方

1176
01:22:52,740 --> 01:22:55,760
内放是有一个全体的一个 Fast Manager 干的事情

1177
01:22:55,760 --> 01:22:58,540
那个是放的 如果对于 C 而言

1178
01:22:58,540 --> 01:23:00,980
它是在执行的时候才会把这个空间给放下去

1179
01:23:00,980 --> 01:23:03,280
那是不一样的 这是内核空间里面

1180
01:23:03,280 --> 01:23:06,000
至少你要 不叫内核空间 叫物理内存里面

1181
01:23:06,000 --> 01:23:08,720
至少知道有内核代码 有应用程序代码

1182
01:23:08,720 --> 01:23:11,420
有内核数据 应用程序数据 这是静态的内存

1183
01:23:11,420 --> 01:23:13,340
还有动态的 就这一块

1184
01:23:13,340 --> 01:23:17,160
可用的物理内存的这么一块区域 是动态的

1185
01:23:17,160 --> 01:23:19,840
它会为我们操作一种动态的申请和释放

1186
01:23:22,400 --> 01:23:25,400
这列出来了 给个答案 放在这儿

1187
01:23:25,400 --> 01:23:29,220
大家大致看一看 比较复杂的是内核

1188
01:23:29,220 --> 01:23:32,460
因为内核里面它会进一步建立各种各样的

1189
01:23:34,440 --> 01:23:36,760
后续会针对应用的任务控制化

1190
01:23:48,060 --> 01:23:51,120
所以物理内存里面东西还挺多

1191
01:23:51,120 --> 01:23:53,400
管理物理内存其实已经说到了

1192
01:23:54,400 --> 01:23:56,840
它的管理和我们前面讲的那个原理来说

1193
01:23:56,840 --> 01:23:57,620
就有一点区别

1194
01:23:57,620 --> 01:24:00,720
就在于它的单位是以业位单位来管理物理内存

1195
01:24:00,720 --> 01:24:04,000
这样来便于它申请和释放物理业证

1196
01:24:04,000 --> 01:24:05,180
来建立业表

1197
01:24:05,180 --> 01:24:06,740
来给我们应用程序分配这些物理业证

1198
01:24:37,840 --> 01:24:44,220
好,建立业表,这边前面已经说了SATP干啥了。

1199
01:24:44,260 --> 01:24:49,260
建立业表,虽然有SATP之后,但是怎么去映射取决于你的选择,有不同

1200
01:24:49,260 --> 01:24:49,700
的策略。

1201
01:24:50,200 --> 01:24:54,260
两种策略,一种策略称之为横等映射,又称之为随机映射。什么叫

1202
01:24:54,260 --> 01:24:54,860
横等映射?

1203
01:24:55,480 --> 01:24:59,300
横等映射就是物理秩序和虚立秩序一样,这是我们内核为了简化设

1204
01:24:59,300 --> 01:25:00,740
计采用简单的方法。

1205
01:25:02,680 --> 01:25:07,220
这样我可以在虚粒子空间里面,我也知道物理是什么,这有恒等映射的方

1206
01:25:07,220 --> 01:25:07,740
式。

1207
01:25:07,960 --> 01:25:12,360
那么随机映射什么意思呢?就好比说我那个高粒子,前面说的那个虚粒子

1208
01:25:12,360 --> 01:25:17,980
非常高粒子,它对那个物理粒子和它不是有任何一种关系。

1209
01:25:18,140 --> 01:25:21,940
我可能是动态申请了,前面动态申请了一个物理内存空间,然后把这个

1210
01:25:21,940 --> 01:25:25,620
动态物理内存空间映射到一个具体的虚的高粒子,这就所谓的

1211
01:25:25,620 --> 01:25:27,500
随机映射,基于真的一种mapping。

1212
01:25:27,500 --> 01:25:32,120
你申请到哪个物理征 那个征的地址有一定的随机性

1213
01:25:32,120 --> 01:25:35,680
那取决于我们的那个连续类征变成的那个算法

1214
01:25:35,680 --> 01:25:37,920
所以这里面是一个随机映射

1215
01:25:37,920 --> 01:25:40,740
这两个映射在文章里面都存在

1216
01:25:47,660 --> 01:25:50,260
这是这个讲建业表的一个过程

1217
01:25:50,260 --> 01:25:52,240
另外最后我还要提醒一点

1218
01:25:53,280 --> 01:25:55,660
对于应用程序而言 一个虚例子

1219
01:25:55,660 --> 01:25:59,700
至少目前我们这个设计,一个虚粒子对应到一个物理粒子,会不会存在两个

1220
01:25:59,700 --> 01:26:03,460
虚粒子对应到一个物理粒子,应用程序。

1221
01:26:06,380 --> 01:26:10,420
目前我们写的这些应用没有,很简单,它就是一个虚粒子对应到一个物理粒

1222
01:26:10,420 --> 01:26:10,500
子。

1223
01:26:10,580 --> 01:26:17,120
但对我们内核来说,我们现在这个内核,到这一章这个内核,它会存在两个

1224
01:26:17,120 --> 01:26:23,300
虚粒子对应到一个物理粒子的情况,对,跳百分之一个粒子,还有其他一些

1225
01:26:23,300 --> 01:26:24,920
情况,也会出现这种情况。

1226
01:26:24,920 --> 01:26:27,360
因为内核为了变异它的管理

1227
01:26:27,360 --> 01:26:30,880
它会有这种多个序列纸对应到一个位置的情况

1228
01:26:32,280 --> 01:26:34,160
这个是需要注意的

1229
01:26:36,420 --> 01:26:39,500
那怎么来建这个业表

1230
01:26:39,500 --> 01:26:40,820
其实挺简单的

1231
01:26:40,820 --> 01:26:45,120
就是首先你心中有这么一个业表的一个结构

1232
01:26:45,120 --> 01:26:47,320
每一个代表一个业

1233
01:26:47,320 --> 01:26:51,260
所以当我要创建

1234
01:26:51,260 --> 01:26:52,400
比如我给一个应用

1235
01:26:52,400 --> 01:26:56,180
然后创建应用的一个对应的这个任务的控制框的时候

1236
01:26:56,180 --> 01:26:57,980
我要给这个任务建立业表

1237
01:26:57,980 --> 01:27:00,560
那我第一步就要建好这么三个东西

1238
01:27:00,560 --> 01:27:02,160
你把它代码段映射过来

1239
01:27:02,160 --> 01:27:03,020
比如我得到一个代码段

1240
01:27:03,020 --> 01:27:04,900
BotLive格式的那个执行程序

1241
01:27:04,900 --> 01:27:08,780
说它代码段从LX1000到LX2000

1242
01:27:08,780 --> 01:27:10,140
这才代码段内容

1243
01:27:10,140 --> 01:27:12,140
那为了能够针对这个虚粒子

1244
01:27:12,140 --> 01:27:13,460
建好对应的物理粒子

1245
01:27:13,460 --> 01:27:16,260
建要为了物理粒子的映射关系

1246
01:27:16,260 --> 01:27:20,920
我就要把这个应用的业表给建好

1247
01:27:22,180 --> 01:27:27,260
首先我要申请一个,起码我可以申请空闲页了,就申请一个物理页针

1248
01:27:27,260 --> 01:27:30,920
这个第一个申请物理页针干什么呢?放这个页目录表

1249
01:27:31,320 --> 01:27:34,740
这是申请出来的,动态申请出来的,申请完之后

1250
01:27:34,740 --> 01:27:37,880
你就可以把SATP指向它,当然我现在不能指了

1251
01:27:37,880 --> 01:27:40,060
我一直就切到那个页板去了,可能出错了

1252
01:27:40,600 --> 01:27:44,440
我只是说我将来这个SATP的,针对这个应用的SATP呢

1253
01:27:44,440 --> 01:27:47,000
我会放一个地方,请问放哪

1254
01:28:20,920 --> 01:28:25,200
页表的目录之后 我会根据虚例纸

1255
01:28:25,200 --> 01:28:29,780
虚例纸把它拆成三块 把对应的L2这一块找着

1256
01:28:29,780 --> 01:28:32,180
在这儿 把这个ppn填出来

1257
01:28:32,180 --> 01:28:35,840
ppn在哪儿 没有 因为这个页表还没创建

1258
01:28:35,840 --> 01:28:39,280
所以我要把第二个页表 又要malloc出来一个

1259
01:28:39,280 --> 01:28:42,120
得到第二个页表 然后再把malloc完之后

1260
01:28:42,120 --> 01:28:43,860
再把这个ppn填成它的集子

1261
01:28:44,560 --> 01:28:48,740
然后flag设置对应的位 它是页目录像

1262
01:28:48,740 --> 01:28:51,280
它的设置和页表像设置是不一样的

1263
01:28:51,280 --> 01:28:53,200
你可以查一下它那个夜幕像怎么设置

1264
01:28:53,200 --> 01:28:54,620
要是没记错的话 设定3个0

1265
01:28:55,300 --> 01:28:56,740
RWX设定3个0

1266
01:28:57,600 --> 01:28:59,740
代表它是夜幕录像 但是ppn填好了

1267
01:29:00,860 --> 01:29:01,840
好 找到之后来之后

1268
01:29:01,840 --> 01:29:04,260
那么这里面应该找哪一项填呢

1269
01:29:04,260 --> 01:29:05,040
看它的L1

1270
01:29:05,660 --> 01:29:07,280
L1里面它这里这九位

1271
01:29:07,280 --> 01:29:09,280
决定了它这个ppn在什么位置

1272
01:29:09,280 --> 01:29:11,440
然后它这个ppn内容怎么办

1273
01:29:11,440 --> 01:29:12,620
我还要申请一个

1274
01:29:12,620 --> 01:29:14,660
它为了填这么一个虚丽的音色

1275
01:29:14,660 --> 01:29:16,620
要建立三个页表

1276
01:29:16,620 --> 01:29:17,800
谢谢三个页表

1277
01:29:17,800 --> 01:29:22,400
所以把这个页表申请了之后,得到它的PPN,塞到这儿来

1278
01:29:22,400 --> 01:29:25,480
才把这一级页表对应的页表项给填好了

1279
01:29:25,480 --> 01:29:29,640
Flex它也是一个页目录,所以它也是ArchiveX设成零

1280
01:29:30,220 --> 01:29:32,640
找到这儿来之后,那么这个PPN对应在哪儿?

1281
01:29:32,640 --> 01:29:36,160
对应在L0,这个9个bit

1282
01:29:36,920 --> 01:29:39,480
这个9个bit决定它的index

1283
01:29:42,520 --> 01:29:47,780
然后这个PPN指向一个物理验征

1284
01:31:47,840 --> 01:31:49,360
就放置這個信息

1285
01:31:49,360 --> 01:31:55,480
這樣使得我從內核態回到用戶態執行的時候

1286
01:31:55,480 --> 01:31:58,180
會從這個雀龐態裡面把這個信息讀出來

1287
01:31:58,180 --> 01:32:03,700
切換頁表 然後做個SIT回到用戶程序

1288
01:32:03,700 --> 01:32:05,600
用戶空間裡面去執行

1289
01:32:05,600 --> 01:32:07,300
從用戶空間回到內核裡面的時候

1290
01:32:07,300 --> 01:32:09,580
我會把這個信息頁也會讀出來

1291
01:32:09,580 --> 01:32:11,660
完成對內核的切換

1292
01:32:13,720 --> 01:32:15,880
你要知道就是這個信息

1293
01:32:15,880 --> 01:32:21,340
我既要能够从用户态切到内核态

1294
01:32:21,340 --> 01:32:22,100
完成页表的切换

1295
01:32:22,100 --> 01:32:24,740
也能从内核态回到用户态完成内核的

1296
01:32:25,340 --> 01:32:26,340
完成页表的切换

1297
01:32:26,340 --> 01:32:27,220
这两个都要切换

1298
01:32:27,220 --> 01:32:29,440
这个需要注意的

1299
01:32:35,100 --> 01:32:37,820
我前面讲的是说你创建应用程序

1300
01:32:37,820 --> 01:32:38,460
你要建页表

1301
01:32:38,460 --> 01:32:40,020
创建内核其实也要建页表

1302
01:32:40,020 --> 01:32:43,200
所以内核也要有相应的页表

1303
01:32:43,200 --> 01:32:44,380
这个我就不细讲了

1304
01:32:44,380 --> 01:32:45,440
只是内核有内核的页表

1305
01:33:15,880 --> 01:33:19,700
这个应用所对应的页表在什么地方

1306
01:33:22,680 --> 01:33:23,040
OK

1307
01:33:23,040 --> 01:33:25,280
地址空间这一块我好像已经给大家看过

1308
01:33:25,280 --> 01:33:26,440
这是应用地址空间

1309
01:33:37,580 --> 01:33:37,940
好

1310
01:33:37,940 --> 01:33:41,720
那我讲一下这个大致的一个想法

1311
01:33:41,720 --> 01:33:43,720
就是说我这边为什么说了一个

1312
01:33:43,720 --> 01:33:46,160
理想很丰满,现实很骨感。

1313
01:33:46,360 --> 01:33:47,500
这些想说明一点。

1314
01:33:48,340 --> 01:33:49,720
我们的业表是给谁用的?

1315
01:33:51,280 --> 01:33:52,200
谁会用这个业表?

1316
01:33:52,580 --> 01:33:54,120
曹永建好的业表给谁用?

1317
01:33:58,920 --> 01:34:01,560
有朋友发书,打哈欠的声音。

1318
01:34:02,960 --> 01:34:04,320
业表是给谁用的?

1319
01:34:04,660 --> 01:34:06,920
飞那么大镜,曹永飞那么大镜,建了个业表。

1320
01:34:07,320 --> 01:34:08,240
谁会用这个业表?

1321
01:34:10,840 --> 01:34:12,180
难道你们都

1322
01:34:12,180 --> 01:34:15,660
哎呀 我只能叹息康总给你们讲的这些东西都忘光了

1323
01:34:16,260 --> 01:34:17,340
对呀 MMU 用啊

1324
01:34:18,000 --> 01:34:20,500
MMU 在TLBF查不着的时候 总得查一遍

1325
01:34:21,200 --> 01:34:24,220
所以硬件 MMU 要用这个页表

1326
01:34:24,220 --> 01:34:25,980
我们应用会用这个页表吗

1327
01:34:27,580 --> 01:34:28,220
应用不会

1328
01:34:28,680 --> 01:34:30,500
OS 要管这个页表

1329
01:34:30,500 --> 01:34:32,480
CPU 要用这个页表

1330
01:34:32,480 --> 01:34:40,200
这两之间 它的应用和管理是不一样的

1331
01:34:40,200 --> 01:34:45,960
这样讲就可能三堂课讲一集了

1332
01:34:45,960 --> 01:34:46,880
好 大家先休息一下

1333
01:39:10,200 --> 01:39:40,180
你

1334
01:39:52,360 --> 01:40:00,840
好 我刚才已经提到了说 业表是给我们的处理器MMU用的

1335
01:40:00,840 --> 01:40:04,280
它完成虚粒子到物理粒子的一个转换

1336
01:40:04,940 --> 01:40:08,440
然后我同时也说了 地图中间包含了业表

1337
01:40:08,440 --> 01:40:10,180
也包含了另外一个很重要的结构

1338
01:40:10,720 --> 01:40:14,520
就是我们在编译器里面生成的各个段

1339
01:40:14,520 --> 01:40:19,700
代码段 数据段 还有用户站等等

1340
01:40:21,660 --> 01:40:24,140
其实这个应用的页表

1341
01:40:24,140 --> 01:40:27,440
它所映射出来的地址空间

1342
01:40:27,440 --> 01:40:32,240
和应用的编译器生成的地址空间

1343
01:40:32,240 --> 01:40:35,240
它们今天是完全一一对应的吗

1344
01:41:10,180 --> 01:41:13,420
根据我操线我是根据编辑的那个生成的App程序里面

1345
01:41:13,420 --> 01:41:15,980
那个代码代码里面建好那个地址空间

1346
01:41:15,980 --> 01:41:19,880
我是根据那个来建立的

1347
01:41:20,480 --> 01:41:21,780
谁 谁什么

1348
01:41:26,740 --> 01:41:30,180
那是堆啊 你说的是堆吧 是吧

1349
01:41:30,180 --> 01:41:31,220
对 我现在说的没有堆

1350
01:41:31,220 --> 01:41:33,420
咱们现在还把这个问题再简化一点

1351
01:41:33,420 --> 01:41:36,240
咱们现在不考虑应用程序还有堆的情况

1352
01:41:36,660 --> 01:41:38,800
就是应用程序有代码代码数据上的情况

1353
01:41:38,800 --> 01:41:40,760
把这个问题简化到这个程度

1354
01:41:40,760 --> 01:41:44,800
请问是不是完全对应的

1355
01:41:50,220 --> 01:41:54,140
其实大家对超级统的深入理解

1356
01:41:54,760 --> 01:41:56,480
就是从超级统而言

1357
01:41:56,480 --> 01:42:01,060
它需要管理的是应用程序的这么一个地址空间

1358
01:42:01,060 --> 01:42:04,040
应用程序生成的地址空间是编辑给它的

1359
01:42:04,040 --> 01:42:05,280
所以这个空间

1360
01:42:05,280 --> 01:42:07,100
比如说我定好了代码段

1361
01:42:07,100 --> 01:42:10,300
就应该代码段它应该是认为是存在的

1362
01:42:10,300 --> 01:42:18,440
但是具体这个代码段在内存中的内容是否存在

1363
01:42:18,440 --> 01:42:19,820
取决于我们超级统

1364
01:42:20,960 --> 01:42:23,380
那意味着超级统正常情况下

1365
01:42:23,380 --> 01:42:25,680
它确实应该是根据Alp程序里面

1366
01:42:25,680 --> 01:42:28,140
把这个代码段数据上的地址空间给印刷好

1367
01:42:28,140 --> 01:42:29,780
页表里面对印象全都印刷好

1368
01:42:29,780 --> 01:42:31,420
这样访问的时候可以正常访问

1369
01:42:33,520 --> 01:42:35,400
但是我们前面已经碰到一个问题

1370
01:43:05,400 --> 01:43:12,980
记录出来,因为超级统计的业表,所以哪些映射存在,哪些不存在,业表

1371
01:43:12,980 --> 01:43:13,960
里面表示的很清楚。

1372
01:43:14,600 --> 01:43:22,620
但是哪些东西应该存在,那超级统计也应该要清楚。这应不应该,那

1373
01:43:22,620 --> 01:43:28,760
取决于它的另外一个很重要的结构,就是我们叫做一个map area,

1374
01:43:29,200 --> 01:43:37,820
这个逻辑段是表述了这个应用程序它所用到的那些代码段数据

1375
01:43:37,820 --> 01:43:44,220
段应该存在的内容,应该在内存中什么地方,这个地址信息它应该存

1376
01:43:44,220 --> 01:43:44,660
在。

1377
01:43:44,780 --> 01:43:50,960
这样使得当对应的页表由于内存空间不够,我从某种方式把它换

1378
01:43:50,960 --> 01:43:51,820
出去了等等。

1379
01:43:52,380 --> 01:43:54,460
我访问那个地址,产生了异常,

1380
01:43:54,680 --> 01:43:58,180
那这个异常到底是我们应用程序的一种恶意行为呢?

1381
01:43:58,180 --> 01:43:59,900
还是一种正常行为?

1382
01:44:00,120 --> 01:44:02,540
取决于什么?取决于它看一下你在这里面

1383
01:44:02,860 --> 01:44:05,780
meta11记录的那个地址

1384
01:44:06,680 --> 01:44:07,600
是不是合法的地址。

1385
01:44:07,700 --> 01:44:09,920
如果这里面说,它本来就是应该是合法的地址。

1386
01:44:10,460 --> 01:44:12,480
你没印象,那是你超级懂事,

1387
01:44:12,920 --> 01:44:14,820
超级能够帮我映射过去,

1388
01:44:15,020 --> 01:44:17,300
就知道你到底是做了一个非法还是合法的事情。

1389
01:44:17,300 --> 01:44:22,580
所以说 我们说你这个里面的页表只是一个现实情况

1390
01:44:23,040 --> 01:44:25,540
但是理想情况下 我们也应该有一个保存

1391
01:44:25,540 --> 01:44:29,300
叫MapHero来保存理想情况 各个段到底应该发生什么地方

1392
01:44:30,240 --> 01:44:33,480
这也涉及到 这位同学如果再提到的更进一步的情况

1393
01:44:33,860 --> 01:44:36,780
编写也没碰到的 就是那个动态类似分配

1394
01:44:36,780 --> 01:44:38,780
那就是你动态申请一块

1395
01:44:38,780 --> 01:44:40,740
我就要专门针对这个动态申请的这一块

1396
01:44:40,740 --> 01:44:44,180
建立一个MapHero的一个区域 一个动态的一个段

1397
01:44:44,180 --> 01:44:45,300
也在这里面的建议

1398
01:44:46,520 --> 01:44:50,560
所以这个MapArea实际上是我们说地址空间里面很重要的组成部分

1399
01:44:51,120 --> 01:44:54,020
我们地址空间其实落到具体实际上来说

1400
01:44:54,020 --> 01:44:58,040
它包含了两块 一块是页饼给我们的CPU用的

1401
01:44:58,040 --> 01:45:03,760
一块是我们说逻辑段是给我们的应用呈现的

1402
01:45:03,760 --> 01:45:05,160
它应该看到什么地方

1403
01:45:05,160 --> 01:45:09,860
这两块合成了才是我们一个实实在在说地址空间的含义

1404
01:45:19,060 --> 01:45:22,020
所有的抽象的概念都对应到具体的代码

1405
01:45:22,020 --> 01:45:24,380
这个地质空间抽象概念对应到memory set

1406
01:45:24,380 --> 01:45:26,120
包含了一个现实的

1407
01:45:26,120 --> 01:45:28,160
包含了一个理想的

1408
01:45:28,160 --> 01:45:31,100
一个我们说的现实的就这一块

1409
01:45:31,100 --> 01:45:32,100
理想的这一块

1410
01:45:32,100 --> 01:45:34,480
它们合在一起形成了我们的地质空间

1411
01:45:34,480 --> 01:45:35,680
这是我们的design

1412
01:45:37,880 --> 01:45:39,540
这是你如果讲概念

1413
01:45:39,540 --> 01:45:39,840
你如果讲概念

1414
01:45:39,840 --> 01:45:41,220
不会涉及到这些内容

1415
01:45:41,220 --> 01:45:43,460
你只有讲到设计与实现才会到这些内容

1416
01:45:43,460 --> 01:45:44,840
然后你通过这种设计实现

1417
01:45:44,840 --> 01:45:47,020
你对它这个地重建的理解

1418
01:45:47,020 --> 01:45:49,000
和只听概念是不一样的

1419
01:45:49,000 --> 01:45:51,880
和没看代码是不一样的

1420
01:45:51,880 --> 01:45:53,940
如果你还能动动代码就更牛了

1421
01:45:53,940 --> 01:45:55,280
前提是你们要去动代码

1422
01:45:55,280 --> 01:45:57,440
而不是说只是听老师上课

1423
01:45:57,440 --> 01:45:59,660
老师上课只是给你们起了一个入门的作用

1424
01:45:59,660 --> 01:46:01,160
并不能解决你们考试的问题

1425
01:46:01,580 --> 01:46:04,680
所以你们为了能够把这门课学好

1426
01:46:04,680 --> 01:46:07,260
还需要去动代码

1427
01:46:07,260 --> 01:46:08,900
这是我的期望

1428
01:46:38,980 --> 01:46:41,440
就比如动态的分配的时候可能需要

1429
01:46:41,440 --> 01:46:44,740
第二个我还有一些切换

1430
01:46:44,740 --> 01:46:47,940
就是用户地址空间和内容地址空间切换

1431
01:46:47,940 --> 01:46:50,140
这个切换需要去做一些调整

1432
01:46:50,140 --> 01:46:54,460
这都是涉及到说去管理地址空间的时候会用到的地方

1433
01:46:56,220 --> 01:46:59,280
具体而言新建地址空间是创建业表创建逻辑段

1434
01:46:59,280 --> 01:47:02,040
对于一个应用而言就这些东西

1435
01:47:02,040 --> 01:47:04,860
你理解之后就是新建就干这个事情

1436
01:47:04,860 --> 01:47:08,060
修改就是插入删除逻辑段

1437
01:48:08,060 --> 01:48:09,940
从用户态切到内核态之后

1438
01:48:09,940 --> 01:48:14,060
能够在内核态去执行保存与回复的过程

1439
01:48:14,780 --> 01:48:17,500
包括对应的那个在用户地址空间的 context

1440
01:48:18,280 --> 01:48:20,800
第四五 要扩展一下任务控制框

1441
01:48:20,800 --> 01:48:25,600
因为控制框里面已经不仅仅是我们前面说到的那些通用技能器的

1442
01:48:25,600 --> 01:48:26,020
保存了

1443
01:48:26,020 --> 01:48:31,040
还包含了内核占地址空间等等一系列的东西

1444
01:48:31,040 --> 01:48:34,060
最后还有一个细节就是

1445
01:49:04,720 --> 01:49:12,060
Adjust Space这么一个OS的扩展,对之前的扩展做了这件事情就形成了所谓的

1446
01:49:12,060 --> 01:49:18,180
AOS,这一块在细讲就是创建内核粒子空间初始化内核子系统。

1447
01:49:20,180 --> 01:49:25,840
你可以看到,对于内核而言,它是用了一个全球变量来搞定的,并没有用动

1448
01:49:25,840 --> 01:49:26,360
态分配。

1449
01:50:26,560 --> 01:50:28,660
这一块是不一样的

1450
01:50:28,660 --> 01:50:31,720
这一块需要我们超级统计手工的去构建

1451
01:50:31,720 --> 01:50:33,480
这么一个虚实地址映射

1452
01:50:34,200 --> 01:50:38,580
把trapframe.s里面的汇变代码或者机器码

1453
01:50:38,580 --> 01:50:40,840
拷贝到这个跳板里面去

1454
01:50:40,840 --> 01:50:41,840
建立相应的虚地址

1455
01:50:41,840 --> 01:50:45,300
这个虚地址定好是最高地址的下面的一个页

1456
01:50:45,860 --> 01:50:49,260
以及跳板下面还有一个trapcontest这么一个页

1457
01:50:49,260 --> 01:50:50,900
来放置trapcontest

1458
01:50:50,900 --> 01:50:54,780
这两个建好之后才能干后续的事情

1459
01:50:57,300 --> 01:51:02,740
为什么要是虚粒子的最后一个地址空间,这种设置,你只要设置在中

1460
01:51:02,740 --> 01:51:05,920
间一个固定比较高的一个地址也行,固定就行。

1461
01:51:05,980 --> 01:51:09,680
固定的意思我能够直接地访问到这是一块。

1462
01:51:13,040 --> 01:51:17,620
然后它放在这儿还有一点就是迅速地完成地址切换,能够平滑过渡。

1463
01:51:18,040 --> 01:51:21,860
这个其实我们之前专门讲这个跳板,已经给大家讲过了。

1464
01:51:22,160 --> 01:51:25,200
它跳过来之后 其实地址空间并没有切换

1465
01:51:25,200 --> 01:51:29,940
所以它是属于在内核模式去执行用户虚地址空间的代码

1466
01:51:29,940 --> 01:51:31,820
这个代码就执行在这个跳板里面

1467
01:51:31,820 --> 01:51:35,400
所以这个执行完之后 就算你后面切到内核态去

1468
01:51:35,400 --> 01:51:40,880
由于内核态里面的这个地址空间映射是同样的

1469
01:51:40,880 --> 01:51:42,800
同样一块 物理地址和虚地址是一样的一块

1470
01:51:43,340 --> 01:51:46,120
所以切完页表之后 进入到内核空间

1471
01:51:46,120 --> 01:51:49,400
内空间的下一条指令

1472
01:51:49,400 --> 01:51:53,880
就是下一条指令依然是通过内核的页表

1473
01:51:53,880 --> 01:51:55,280
还是可以访问的

1474
01:51:55,280 --> 01:51:56,580
还是同样一个指令

1475
01:51:56,580 --> 01:51:58,880
所以它可以平滑的过渡就体验到这

1476
01:52:00,400 --> 01:52:03,360
那还有一点再往下执行之后

1477
01:52:03,360 --> 01:52:05,560
就不一样了

1478
01:52:05,560 --> 01:52:09,640
因为它的用户态的站和内核态的站是不一样的站

1479
01:52:09,640 --> 01:52:11,280
所以你还要完成切换站

1480
01:52:11,280 --> 01:52:16,760
才能去跳了那个我们说的那个TrapHandler能去执行

1481
01:52:21,820 --> 01:52:22,180
OK

1482
01:52:26,440 --> 01:52:28,860
这个是说的这个TrapContext的设置

1483
01:52:28,860 --> 01:52:30,860
也前面也讲到为什么要这么设置

1484
01:52:30,860 --> 01:52:32,940
因为你如果放在内核站其实有问题

1485
01:52:32,940 --> 01:52:34,080
它还没切过去

1486
01:52:35,460 --> 01:52:37,560
这个问题已经Q了

1487
01:52:37,560 --> 01:52:38,200
已经A了

1488
01:52:38,200 --> 01:52:39,080
这已经回来了

1489
01:53:47,420 --> 01:53:55,880
第一步切换是用户战指针和位于用户体质空间的trapcontest的

1490
01:53:55,880 --> 01:53:56,620
机子

1491
01:53:56,620 --> 01:54:01,840
然后基于这个机子来保存通用技能器和对应的那个ssstatus和sep

1492
01:54:01,840 --> 01:54:02,580
c

1493
01:54:02,580 --> 01:54:07,040
这个ssstatus和sepc是在我们硬件在做切换的一步

1494
01:54:07,040 --> 01:54:08,540
它会存的一个内容

1495
01:54:12,680 --> 01:54:17,680
然后再进一步读出 需要前面是写 这是读 读这三个信息

1496
01:54:17,680 --> 01:54:21,320
读这三个信息之后是为了能够完成后续的切类核地址中间

1497
01:54:21,320 --> 01:54:24,240
切类核站 跳到这地方去执行

1498
01:54:24,240 --> 01:54:27,760
这就是保存TrackHandTest的一个过程

1499
01:54:27,760 --> 01:54:31,300
接下来是恢复它的立过程 这个我觉得只是一个流程解释

1500
01:54:31,300 --> 01:54:34,880
大家更重要知道说为什么要这么做

1501
01:54:34,880 --> 01:54:38,520
这又来一个问题 为什么JR而不用call TrackHandler

1502
01:54:38,520 --> 01:54:43,520
这种更常见的方式,用的是集成器跳转

1503
01:54:45,960 --> 01:54:51,860
大家会觉得这是一个会编辑的设计,这跟C和RUS不关

1504
01:54:51,860 --> 01:54:54,160
这种设计是有它特殊的原因

1505
01:54:54,580 --> 01:55:04,700
这也是由于我把相应的Trapfrag.s的alltraps代码放到一个非常高

1506
01:55:04,700 --> 01:55:05,160
的地址

1507
01:55:06,160 --> 01:55:10,880
而我正常编译的时候其实是按照前面的link里面的一个正常地址来编

1508
01:55:10,880 --> 01:55:11,180
译的

1509
01:55:12,260 --> 01:55:15,000
我已经改变了它们之间的一个offset的关系

1510
01:55:15,000 --> 01:55:23,420
所以我直接基于通常的相对于当前PC的一个offset来进行跳转会出

1511
01:55:23,420 --> 01:55:23,880
错

1512
01:55:23,880 --> 01:55:25,860
我只能用绝对地址来跳转

1513
01:55:25,860 --> 01:55:31,460
所以这个jr里面乘这个t1实际上是这个trap handler的一个绝对地址这么

1514
01:55:31,460 --> 01:55:32,000
来搞

1515
01:55:32,000 --> 01:55:34,980
这也是为什么我们要回答一下这个跳转

1516
01:55:34,980 --> 01:55:38,740
就是编辑器其实它在生成正常的

1517
01:55:38,740 --> 01:55:40,940
比如我们正常的call这种指令 汇编指令的时候

1518
01:55:40,940 --> 01:55:43,280
它并不会用这种GR指令来生成

1519
01:55:43,280 --> 01:55:46,100
所以它是基于一个offset来生成的

1520
01:55:46,100 --> 01:55:47,800
这种得不到一个正确的地址

1521
01:55:47,800 --> 01:55:51,480
因为我们已经把我们那个跳那一步的那个地方

1522
01:55:51,480 --> 01:55:53,400
已经放在非常高的地址去了

1523
01:55:53,400 --> 01:55:56,000
而triple handler还在正常的一个

1524
01:55:56,000 --> 01:55:57,860
我们代码大区例子里面

1525
01:55:57,860 --> 01:55:59,440
它们那边隔得特别远

1526
01:55:59,440 --> 01:56:02,440
不足以再用以前的offset来表示

1527
01:56:02,440 --> 01:56:05,340
所以我们必须要用GR这种方式来进行跳转

1528
01:56:05,820 --> 01:56:07,320
这个给大家解释一下

1529
01:56:08,260 --> 01:56:10,720
这也是由于编译的不足来导致的

1530
01:56:11,980 --> 01:56:14,680
好 我们也知道怎么去建立所谓的

1531
01:56:14,680 --> 01:56:18,420
跳板和GemCast对应的业务之后

1532
01:56:18,420 --> 01:56:21,440
再干什么之前就要去加载和执行应用

1533
01:56:21,440 --> 01:56:23,020
为了能够加载执行应用

1534
01:56:23,020 --> 01:56:24,900
你要去扩展任务控制框

1535
01:56:24,900 --> 01:56:26,880
更新任务管理 主要是两个

1536
01:56:27,720 --> 01:56:31,880
任务控制化 你可以看到任务控制化里面的内容会大大的丰富

1537
01:56:32,700 --> 01:56:34,880
增加了什么呢 增加了我们的地址空间

1538
01:56:35,460 --> 01:56:39,120
增加了Trapcontest所在的物理业的物理业号

1539
01:56:39,120 --> 01:56:41,000
这个Trapcontest PPN

1540
01:56:41,000 --> 01:56:44,740
还有增加了一个应用数据的大小BaseSize

1541
01:56:44,740 --> 01:56:47,240
这个BaseSize实际上是什么东西呢

1542
01:56:47,240 --> 01:56:51,360
如果我们看前面这个图可以这么理解

1543
01:56:51,360 --> 01:56:53,420
BaseSize就是这个地方

1544
01:57:02,660 --> 01:57:09,300
从这个地方再往后,全是一些没有映射的地址,直到最顶上的那个超线桶

1545
01:57:09,300 --> 01:57:19,020
它构建的trip-line和trip-contest,对,没错。这两个东西。

1546
01:57:20,400 --> 01:57:27,020
所以有这些形成了所谓的我们的任务控制化内容

1547
01:57:33,060 --> 01:57:35,100
我们要创建一个任务控制化的话

1548
01:57:35,100 --> 01:57:36,880
就需要把相应内容给填满了

1549
01:57:36,880 --> 01:57:39,940
所以要给这个应用申请一个内核站

1550
01:57:40,300 --> 01:57:42,480
基于这个应用的Apps文件内容

1551
01:57:42,480 --> 01:57:43,980
生成应用的地址空间

1552
01:57:43,980 --> 01:57:45,380
用户台地址空间

1553
01:57:45,380 --> 01:57:49,160
建立页表 这等于是建立页表和建立对应的MapArial

1554
01:57:49,160 --> 01:57:50,920
对应的逻辑段的信息

1555
01:57:50,920 --> 01:57:56,460
然后第三步就是把其他一些相关的信息能够构造出来

1556
01:57:56,460 --> 01:57:58,380
TCB也是一个结构

1557
01:57:59,400 --> 01:58:02,740
我看看 应该最后还有一个就是这个

1558
01:58:02,740 --> 01:58:04,180
我们说的这个TrapContest

1559
01:58:04,180 --> 01:58:10,300
这一块是比较Special的一个内容

1560
01:58:10,300 --> 01:58:11,460
前面已经讲到TrapContest的内容

1561
01:58:11,460 --> 01:58:14,540
要把它填好 使它能够正确的返回到用户上去执行

1562
01:58:15,460 --> 01:58:22,580
这是一部分内容,然后这个小角是在,你就算填好了这trap contest,你会发现它有

1563
01:58:22,580 --> 01:58:24,720
些什么限制呢?

1564
01:58:24,760 --> 01:58:30,660
我们现在的设计里面,我们支持的只是从用户带到内核带的一个切换。

1565
01:58:31,800 --> 01:58:36,600
其实对于中断而言,我们认为其实在很早前进行设计的时钟工作了,对

1566
01:58:36,600 --> 01:58:40,540
于中断而言,我们在内核里面也应该也能够允许中断。

1567
02:00:10,540 --> 02:00:12,960
不就直接一个call 为什么就不行

1568
02:00:13,480 --> 02:00:15,140
你要给出一个合理的解释

1569
02:00:16,460 --> 02:00:18,640
好 最后一步就是改进SysWrite的实现

1570
02:00:18,640 --> 02:00:20,920
这个前面已经说到SysWrite在于

1571
02:00:20,920 --> 02:00:22,560
SysWrite里面它有8个的产品

1572
02:00:22,560 --> 02:00:23,800
8个在用户地里面

1573
02:00:24,260 --> 02:00:26,800
那你现在到内核里面 内核去要访问的话

1574
02:00:26,800 --> 02:00:31,060
必须要去访问应用程序的数据

1575
02:00:31,060 --> 02:00:32,940
这时候你必须要用内核的虚拟纸

1576
02:00:32,940 --> 02:00:36,180
来访问应用程序的一纸空间怎么来做

1577
02:00:36,180 --> 02:00:37,680
能想到办法也很值班了

1578
02:00:37,680 --> 02:00:39,560
既然你在内核空间 我是超系统

1579
02:00:39,560 --> 02:00:42,240
我们干很多事情,我可以看到应用程序的页表

1580
02:00:42,240 --> 02:00:44,700
基于应用程序的页表,我可以找到什么?

1581
02:00:44,840 --> 02:00:47,560
找到它那个虚粒子所对应的物理粒子在哪?

1582
02:00:48,780 --> 02:00:53,800
而我们的内核呢,又搞了一个很简化的事情

1583
02:00:53,800 --> 02:00:56,800
所有的物理粒子,有一个对应的叫做横等映射

1584
02:00:56,800 --> 02:00:58,060
它对应的虚粒子

1585
02:00:58,060 --> 02:00:59,460
所以我找到的物理粒子也意味着

1586
02:00:59,460 --> 02:01:01,620
我在内核里面可以以这个物理粒子作为虚粒子

1587
02:01:01,620 --> 02:01:04,940
来进行对内存的扫码

1588
02:01:04,940 --> 02:01:06,380
这句话挺明白的

1589
02:01:06,700 --> 02:01:07,980
反正我得到了

1590
02:01:08,460 --> 02:01:12,160
我查用户页表我可以查,我是内核,页表是我见的

1591
02:01:12,160 --> 02:01:15,940
然后我查这个页表,我知道这个虚粒子对应的物理地址是啥

1592
02:01:15,940 --> 02:01:19,420
而这个物理地址呢,我在内核的页表里面我也见好了

1593
02:01:19,420 --> 02:01:22,700
这个物理地址有一个很等的虚粒子,很大对应

1594
02:01:22,700 --> 02:01:27,540
所以我访问这个地址就可以得到相应的应用程序地址空间的数据

1595
02:01:27,540 --> 02:01:30,140
就找到了,对它读和写都ok

1596
02:01:30,140 --> 02:01:31,880
这就是它的一个处理过程

1597
02:01:31,880 --> 02:01:34,120
这个处理过程都反映在一个叫做

1598
02:03:34,360 --> 02:03:38,140
甚至去完成所谓的这个下一个实验

1599
02:03:38,140 --> 02:03:40,080
就应该比较轻松

1600
02:03:40,080 --> 02:03:42,640
而且对原理会有一个深刻的理解

1601
02:03:42,640 --> 02:03:45,260
这是我们上这一堂课

1602
02:03:45,260 --> 02:03:48,580
希望大家能够理解的内容

1603
02:03:48,580 --> 02:03:51,300
如果大家听不明白没关系

1604
02:03:51,300 --> 02:03:53,220
回去再看看回放

1605
02:03:53,220 --> 02:03:54,460
或者再问一下助教

1606
02:03:54,460 --> 02:03:55,580
或者再问一下老师

1607
02:03:55,580 --> 02:03:58,160
我觉得就应该能够比较清楚了

1608
02:03:59,660 --> 02:04:03,100
好 那这一节我就给大家讲完了

1609
02:04:06,660 --> 02:04:15,720
我觉得我已经不报希望大家能够在客户问我问题,之后我自问自答,好,我们讲

1610
02:04:15,720 --> 02:04:24,860
下一个,虚拟存储管理,这是一个overview概念,所以比较好理解,不像前面一

1611
02:04:24,860 --> 02:04:28,360
堂课,前面两节那么费劲。

1612
02:04:32,940 --> 02:04:39,520
虚拟存储的基本概念,首先来讲一下为什么需要虚拟存储,以及应对虚拟存储

1613
02:04:39,520 --> 02:04:45,460
所用到的一些技术,覆盖技术,交换技术,还有现在更加高级的所谓最

1614
02:04:45,460 --> 02:04:46,560
叫虚拟存储技术。

1615
02:04:46,560 --> 02:04:51,480
这里面距离到我们这里面,叫虚拟夜视存储。怎么能够实现虚拟夜视存

1616
02:04:51,480 --> 02:04:57,520
储,我们发现缺一长是我们重量的关注力。这是我们的一些基本的overview。

1617
02:04:58,320 --> 02:05:04,340
那么它的需求背景在哪里呢?就在于我们的应用程序对内存的消耗

1618
02:05:04,340 --> 02:05:09,520
没有止境。应用程序的规模增长远远大于存储容量的增长速度。

1619
02:05:09,520 --> 02:05:11,460
最典型的代表是游戏

1620
02:05:11,460 --> 02:05:13,180
大家可能玩游戏玩得不多

1621
02:05:13,180 --> 02:05:15,380
至少我当年玩游戏的时候是一张软盘

1622
02:05:15,380 --> 02:05:17,540
几百K就可以玩很好的游戏

1623
02:05:17,540 --> 02:05:19,440
但现在没有一个多少个G

1624
02:05:19,440 --> 02:05:21,080
是不足以达到的

1625
02:05:21,080 --> 02:05:23,520
比如现在的非法2021有50个G

1626
02:05:24,720 --> 02:05:25,640
这么大的容量

1627
02:05:26,440 --> 02:05:27,960
纵是有61个G

1628
02:05:27,960 --> 02:05:29,640
这个太大了

1629
02:05:30,280 --> 02:05:31,860
我们现在内存能达到吗?达不到

1630
02:05:31,860 --> 02:05:33,600
但它确实要有一些数据

1631
02:05:33,600 --> 02:05:36,220
或多或少在不同时刻放到内存里面

1632
02:05:36,220 --> 02:05:37,180
这就是问题

1633
02:05:38,540 --> 02:05:42,580
所以超级恐龙要帮助解决这个问题,所以我们需要在超级恐龙的帮助下建

1634
02:05:42,580 --> 02:05:44,780
立一个理想的存储空间。

1635
02:05:44,860 --> 02:05:51,080
这空间的容量够大,速度够快,价格够便宜,非意识性存储,数据

1636
02:05:51,080 --> 02:05:55,680
还不会丢,现在还不存在,只有靠我们虚拟出来一个东西。

1637
02:05:57,480 --> 02:06:03,320
所以本上来说还是在于内存不够用,我们需要通过某种方式来弥补,所以

1638
02:06:03,320 --> 02:06:05,700
内存不够用外存来补,就靠外存来补。

1639
02:06:06,740 --> 02:06:08,540
那这种补的方式有不同

1640
02:06:08,900 --> 02:06:11,920
从按照历史的发展来说我们有不同的方式

1641
02:06:11,920 --> 02:06:13,560
最开始靠应用程序自己

1642
02:06:13,560 --> 02:06:14,720
超级多还不够强大

1643
02:06:17,120 --> 02:06:18,880
所以是写应用程序的人

1644
02:06:18,880 --> 02:06:21,700
他直接在函数集来完成这个

1645
02:06:22,660 --> 02:06:24,540
手动的换入换出的一个工作

1646
02:06:24,540 --> 02:06:26,600
我不常用的函数就放到外头去

1647
02:06:26,600 --> 02:06:27,960
不常用的数据放到外头去

1648
02:06:27,960 --> 02:06:29,120
需要再调进来

1649
02:06:29,120 --> 02:06:30,240
那很明显

1650
02:06:30,240 --> 02:06:33,460
对应用程序的程序员的开发要求太高了

1651
02:06:33,460 --> 02:06:36,120
我们的目标是让应用程序员越傻瓜越好

1652
02:06:36,680 --> 02:06:38,720
复杂留给系统程序员

1653
02:06:39,320 --> 02:06:42,420
所以第二个系统程序员就开始接管这个事情

1654
02:06:42,420 --> 02:06:44,140
就产生了所谓的程序交换

1655
02:06:44,820 --> 02:06:46,840
每次我以一个程序为单位来进行交换

1656
02:06:46,840 --> 02:06:47,860
因为我可以放多个程序

1657
02:06:48,940 --> 02:06:51,060
以程序为交换力度太粗

1658
02:06:52,240 --> 02:06:53,860
每次交换的开交比较大

1659
02:06:53,860 --> 02:06:57,660
所以又进一步进化到说我能不能以更小的力度

1660
02:06:57,660 --> 02:06:59,300
以业为单位来进行交换

1661
02:06:59,300 --> 02:07:00,860
这我们现在虚拟存储

1662
02:07:00,860 --> 02:07:06,660
他们用的存储的概念 其实Storage是包含了内存和外存

1663
02:07:06,660 --> 02:07:10,220
把统称为所谓的Storage 也有可能叫虚拟内存

1664
02:07:10,220 --> 02:07:12,120
其实这个概念咱们没必要纠结

1665
02:07:12,120 --> 02:07:15,340
大致的意思就是内存和外存合在一起

1666
02:07:15,340 --> 02:07:17,980
来提供一个虚拟的大的内存空间

1667
02:07:17,980 --> 02:07:19,500
这是他要干的事情

1668
02:07:21,840 --> 02:07:23,960
这又扯到了我们的地址空间

1669
02:07:23,960 --> 02:07:26,280
我前面讲到的业表里面存的

1670
02:07:26,280 --> 02:07:28,960
就是一个实实在在的虚实意识的关系

1671
02:07:28,960 --> 02:07:31,900
就是所有的页表里面有合法映射的

1672
02:07:31,900 --> 02:07:34,920
那么一个虚粒子对一个物理粒子是存在的

1673
02:07:34,920 --> 02:07:38,960
但是我们也看到了我们需要把外存给用起来

1674
02:07:38,960 --> 02:07:41,280
就把这一块外存给用起来

1675
02:07:41,280 --> 02:07:42,440
你要把外存用起来

1676
02:07:42,440 --> 02:07:44,860
你这个页表

1677
02:07:44,860 --> 02:07:48,680
你所谓这个页表的映射关系就不应该存在

1678
02:07:48,680 --> 02:07:53,520
因为咱没法实现说把一个虚粒子直接映射到一个外存

1679
02:07:53,520 --> 02:08:01,440
让我们的CPU说,CPU找得着,找到这个物理地址,实际上是一个Disk

1680
02:08:01,440 --> 02:08:05,700
的地址,然后从Disk里面把这个数据给取回来,这我们的CPU要求太

1681
02:08:05,700 --> 02:08:11,760
高了,所以这一块就需要我们超级组的帮忙,能够去把这个外存给拥起

1682
02:08:11,760 --> 02:08:12,000
来。

1683
02:08:12,180 --> 02:08:17,120
那你需要一些软件的设计方式,就是软硬协同,硬件干硬件拿手的事情,

1684
02:08:17,280 --> 02:08:22,240
软件干软件拿手的事情,软件干什么,比硬件复杂比较多的一些事情。

1685
02:08:22,240 --> 02:08:24,640
比如说管理外层

1686
02:08:24,640 --> 02:08:26,840
这就是我们超级程序员要干的事情

1687
02:08:33,220 --> 02:08:36,520
好 那简单介绍一下已有的一些技术

1688
02:08:36,520 --> 02:08:38,280
第一个叫覆盖技术

1689
02:08:38,280 --> 02:08:40,280
它的目标可能就是程序员手动控制

1690
02:08:40,280 --> 02:08:43,220
在较小的可能位置中运行较大的程序

1691
02:08:43,220 --> 02:08:45,500
需要注意这单位就是一个程序

1692
02:08:45,500 --> 02:08:47,020
它不考虑多程序

1693
02:08:47,020 --> 02:08:49,380
我一个程序管我自己 管我自己就行了

1694
02:08:49,380 --> 02:08:52,700
基本思路,在一个时间当内执行的函数和谋划

1695
02:08:52,700 --> 02:08:55,980
不能共享一块有限的空间,这还没完呢

1696
02:08:56,760 --> 02:09:00,800
它这个基本思路就是说,如果存在在一个时间当内

1697
02:09:00,800 --> 02:09:04,360
函数或者谋划,不会都存在

1698
02:09:04,360 --> 02:09:06,960
那这样的话,我就可以把

1699
02:09:06,960 --> 02:09:09,560
不在这个时间当内用到的那些函数和数据给划出去

1700
02:09:09,560 --> 02:09:12,180
反正这个时间当内用不着,这就OK了

1701
02:09:12,180 --> 02:09:15,780
这基本思路,就是基于一个部分时间的执行

1702
02:09:15,780 --> 02:09:18,380
那么稍微再专业一点的说,就是在时间当内

1703
02:09:18,380 --> 02:09:21,640
函数和谋划不会在程序执行的一条控制流上

1704
02:09:21,640 --> 02:09:23,760
这个控制流是我们通常说的

1705
02:09:23,760 --> 02:09:26,880
程序执行的那个控制流

1706
02:09:26,880 --> 02:09:28,520
那怎么覆盖

1707
02:09:29,160 --> 02:09:31,160
一旦说有这种情况存在的话

1708
02:09:31,160 --> 02:09:33,060
那我们就把一个程序分为

1709
02:09:33,060 --> 02:09:35,360
一系列功能相对独立的程序段

1710
02:09:35,360 --> 02:09:37,660
所谓相对独立就是不在一个控制流上

1711
02:09:37,660 --> 02:09:38,860
在执行的时候

1712
02:09:39,820 --> 02:09:42,180
不用把这些程序放在一起

1713
02:09:42,180 --> 02:09:43,640
只是在需要的时候

1714
02:09:43,640 --> 02:09:46,360
必要的时候可以换进来

1715
02:09:46,360 --> 02:09:51,020
那么常用的就是必要的这些代码和数据比我经常使用的

1716
02:09:51,560 --> 02:09:53,900
每个时间段都用到的 那我就必须要长度内存

1717
02:09:53,900 --> 02:09:57,880
但是不常用的 在时间段A用不着的

1718
02:09:57,880 --> 02:10:03,000
那么在时间段A我就把所用不着的那些代码和数据全换到外存去

1719
02:10:04,380 --> 02:10:07,400
到时间段B的时候呢 用到了再把它换进来

1720
02:10:08,800 --> 02:10:13,500
那么时间段A的那些用到的那些内存 那些数据和代码

1721
02:10:13,500 --> 02:10:15,680
和实验站B用到内存和数学和代码

1722
02:10:15,680 --> 02:10:17,240
它们共享一块区域

1723
02:10:17,240 --> 02:10:18,500
这是共享的一个内存

1724
02:10:19,480 --> 02:10:20,480
共用一块内存

1725
02:10:20,480 --> 02:10:21,500
这是它大致思路

1726
02:10:22,080 --> 02:10:23,260
那这给了一个例子

1727
02:10:24,080 --> 02:10:25,740
我们以前也考过大家

1728
02:10:25,740 --> 02:10:27,940
就是看能不能把这个给算出来

1729
02:10:29,040 --> 02:10:30,800
对于这个程序而言

1730
02:10:30,800 --> 02:10:34,480
这个它A,B,C,D,E,F代表什么代表函数

1731
02:10:34,480 --> 02:10:35,800
和函数所用到的数据

1732
02:10:35,800 --> 02:10:36,960
简单这么理解

1733
02:10:36,960 --> 02:10:37,800
那按道理来说

1734
02:10:37,800 --> 02:10:40,100
它占的空间就应该是把它全部加起来

1735
02:10:40,100 --> 02:10:42,260
20 30 50

1736
02:11:43,220 --> 02:11:47,240
所以当到这一步的时候 它其实这还是放在下一个时间段

1737
02:11:47,240 --> 02:11:51,280
这两个时间段 这时间段里面放什么 放的是C

1738
02:11:51,280 --> 02:11:55,260
C里面呢 然后再看 C先执行E 所以放的是E

1739
02:11:56,200 --> 02:11:59,580
执行完之后 回退到C C再去执行F

1740
02:11:59,580 --> 02:12:03,180
所以在这里面 A C F

1741
02:12:03,180 --> 02:12:09,040
所以你看到在这里面 D E F可以共享一个覆盖区E

1742
02:12:09,040 --> 02:12:11,520
而B和C共享了一个负外区0

1743
02:12:12,640 --> 02:12:18,020
中间会有一些函数的模块的加载过程

1744
02:12:18,020 --> 02:12:20,260
从这种方式和放弃过程

1745
02:12:20,260 --> 02:12:27,500
它可以在110k的一个内存里面去实现一个对190k程序的一个知识

1746
02:12:27,500 --> 02:12:28,640
这是它基本思路

1747
02:12:29,420 --> 02:12:32,120
有的人可能好奇的是这里面最小应该是多少

1748
02:12:32,740 --> 02:12:34,440
所以它有不同的方案

1749
02:12:34,440 --> 02:12:35,820
这里给了另一种方案

1750
02:12:35,820 --> 02:12:38,180
100k不是110k

1751
02:12:38,180 --> 02:12:46,560
那有没有还有更小的情况,这就给大家去考虑,我想说这里面是不是最小,不是我们最

1752
02:12:46,560 --> 02:12:47,380
关注的问题。

1753
02:12:47,900 --> 02:12:52,140
你关注的问题是你可以做到这一步,在一个有限的空间里面能够去把

1754
02:12:52,140 --> 02:12:53,160
这个成绩跑起来。

1755
02:12:53,360 --> 02:12:59,920
为什么不是特别关注呢,是在于我们现在内存还是够用的,不是那么不够用,内存

1756
02:12:59,920 --> 02:13:06,920
相对来说还是相对越来越便宜,所以这个问题不是那么的要去追求这个极致。

1757
02:13:08,640 --> 02:13:11,040
好 那看它的不足 这个方式可以做到

1758
02:13:11,040 --> 02:13:13,040
它不足在哪呢 就是程序员介入太多

1759
02:13:13,680 --> 02:13:15,020
导致这个编程复杂

1760
02:13:16,080 --> 02:13:16,920
我们的程序员其实

1761
02:13:17,440 --> 02:13:19,020
应用程序员的水平是越来越低的

1762
02:13:19,020 --> 02:13:20,700
不是越来越高的

1763
02:13:20,700 --> 02:13:22,760
所以我们要为这些程序员考虑

1764
02:13:22,760 --> 02:13:24,860
不能给他增加太大的复杂性

1765
02:13:24,860 --> 02:13:26,140
但早期的时候

1766
02:13:27,160 --> 02:13:29,220
我在领这个时候 我们用的系统叫

1767
02:13:29,220 --> 02:13:30,020
Tubo Pascal

1768
02:13:30,020 --> 02:13:32,720
Tubo C 是C和Pascal

1769
02:13:32,720 --> 02:13:34,400
是一个波兰特公司造这个软件

1770
02:13:34,400 --> 02:13:40,260
当时它是和VRAM的VOC是竞争关系

1771
02:13:40,260 --> 02:13:41,940
他们做的比VRAM更好

1772
02:13:41,940 --> 02:13:44,760
他们当时就提供了什么OVERLAY这么一个模块

1773
02:13:44,760 --> 02:13:47,980
能够来在一定程度上帮助我们用成员

1774
02:13:47,980 --> 02:13:50,220
来减化这个覆盖的一个设计实现

1775
02:13:50,220 --> 02:13:51,500
这技术已经存在了

1776
02:13:51,960 --> 02:13:54,920
现在在一些比较专的场合一样存在

1777
02:13:54,920 --> 02:13:56,260
为什么当时超线我们不支持

1778
02:13:56,260 --> 02:13:57,900
一个当时超线我们是DOS

1779
02:13:58,240 --> 02:13:59,400
太弱了

1780
02:13:59,400 --> 02:14:01,320
DOS还不足以支持那么强的能力

1781
02:14:03,260 --> 02:14:04,340
这是覆盖技术

1782
02:14:05,720 --> 02:14:07,180
第二个讲 交换技术

1783
02:14:07,180 --> 02:14:11,100
交换技术是早期的Unix就这么做的

1784
02:14:11,100 --> 02:14:12,400
在没有业绩制enable之前

1785
02:14:13,240 --> 02:14:16,420
它就可以把一个程序

1786
02:14:16,420 --> 02:14:17,900
如果它当前不执行

1787
02:14:17,900 --> 02:14:19,960
比如这P本来在这

1788
02:14:19,960 --> 02:14:22,600
P在这 但它是一个Sleep的

1789
02:14:22,600 --> 02:14:24,540
它是Sleep

1790
02:14:25,020 --> 02:14:28,080
Sleep的话 我现在执行的是P2

1791
02:14:28,080 --> 02:14:30,000
但P2又放在外存里面

1792
02:14:30,000 --> 02:14:32,520
所以我要直接P2把它调到这里面来

1793
02:14:32,520 --> 02:14:33,320
P2去执行

1794
02:14:33,700 --> 02:14:37,260
但P2 P1呢 两个合在一起的话空间不够用

1795
02:14:37,780 --> 02:14:40,840
所以我首先干第一步事情要把P1给换出去

1796
02:14:40,840 --> 02:14:42,520
换到外头去 存到外头去

1797
02:14:42,520 --> 02:14:46,340
再把P2放进来 使得P2可以用更多的内存

1798
02:14:46,340 --> 02:14:48,680
这就是它的一个所谓的基本思路

1799
02:14:48,680 --> 02:14:53,320
它是以我们说一个运行的程序为单位进行执行的

1800
02:14:53,320 --> 02:14:55,540
这程序力度就很大了

1801
02:14:55,540 --> 02:14:58,000
所以它这个切换的过程 由于这个力度太粗

1802
02:14:58,000 --> 02:14:59,180
所以它的效率不高

1803
02:14:59,820 --> 02:15:05,180
这是我们的基于程序的交换技术,这个简单给大家说一下。

1804
02:15:09,660 --> 02:15:12,620
我们第一知道它的一些步骤,还是要知道它怎么去做的。

1805
02:15:12,880 --> 02:15:15,660
第一就是交换时机,只有内存不够的时候才去交换。

1806
02:15:15,880 --> 02:15:20,180
第二个交换区的大小,交换在哪?这个交换区放哪?这个放哪?

1807
02:15:21,800 --> 02:15:26,860
这个东西放哪?这实际上是Disk中的一个分区,或者Disk中的一个Special

1808
02:15:26,860 --> 02:15:28,460
的文件都可以来放。

1809
02:16:33,260 --> 02:16:40,660
好,这次讲交换和覆盖的一个区别,大家大致的理解还行吗?

1810
02:16:40,760 --> 02:16:45,660
对于覆盖而言,他考虑的更多的是针对一个程序,我怎么去有效利用

1811
02:16:45,660 --> 02:16:46,100
这个问题。

1812
02:16:46,580 --> 02:16:51,500
而对于交换而言,程序交换是对于多个程序已经交换,他考虑的是

1813
02:16:51,500 --> 02:16:51,840
多个程序。

1814
02:16:51,900 --> 02:16:55,880
所以说,也意味着我们的程序覆盖更多的是针对当程序自身,成员自己

1815
02:16:55,880 --> 02:16:56,420
要考虑。

1816
02:16:56,420 --> 02:16:58,540
但对于交换而言 还是要超线网来考

1817
02:16:58,540 --> 02:17:01,060
它要考虑多个程序的一个执行过程

1818
02:17:02,280 --> 02:17:04,380
这是不太一样的

1819
02:17:04,380 --> 02:17:07,700
好 但这两个在我们看来它还不够

1820
02:17:09,140 --> 02:17:10,500
高级或者不够先进

1821
02:17:10,500 --> 02:17:12,720
我们需要更高性能的一个设计

1822
02:17:12,720 --> 02:17:14,820
就把业绩值给映射进去了

1823
02:17:15,320 --> 02:17:18,580
我们每次交换的不是一个一个的程序

1824
02:17:18,580 --> 02:17:19,420
而是一个一个的业

1825
02:17:19,420 --> 02:17:21,020
这个业是4K

1826
02:17:21,020 --> 02:17:24,680
而整个换入办出哪个4K是我们超线网决定的

1827
02:18:24,680 --> 02:18:27,140
假设我们的应用程序有一定的举步性

1828
02:18:27,140 --> 02:18:30,060
那这样我们就可以把常用的放到内存里面来

1829
02:18:30,060 --> 02:18:31,320
不常用的换出去

1830
02:18:31,320 --> 02:18:33,720
那基本的规则就是装载程序之后

1831
02:18:33,720 --> 02:18:35,360
只将当前需要用到的

1832
02:18:35,980 --> 02:18:36,680
究竟用到的

1833
02:18:36,680 --> 02:18:37,780
不一定常用 可能究竟用到的

1834
02:18:37,780 --> 02:18:38,800
放到内存里面来

1835
02:18:40,100 --> 02:18:42,000
如果你需要的数据不在内存里面

1836
02:18:44,580 --> 02:18:46,260
我们的处理器会产生异常

1837
02:18:46,260 --> 02:18:47,820
因为它根据业表来的

1838
02:18:48,160 --> 02:18:51,660
它不管这个数据到底是不是合法的数据

1839
02:18:51,660 --> 02:18:53,980
但是我们超线用知道这是合法的

1840
02:18:53,980 --> 02:18:57,460
所以我会把相应在外存中的一些页面

1841
02:18:57,980 --> 02:18:59,060
无论是代码还是数据

1842
02:18:59,060 --> 02:19:00,640
可以存到里面来

1843
02:19:00,640 --> 02:19:02,240
这样可以实现一种有效的

1844
02:19:02,240 --> 02:19:04,100
一种虚存管理的机制

1845
02:19:04,100 --> 02:19:05,820
需要之后再把它放进来

1846
02:19:05,820 --> 02:19:08,160
这基本上是这么一个大致的思路

1847
02:19:08,160 --> 02:19:10,120
具体实现合理的意见相关

1848
02:19:10,120 --> 02:19:11,040
你那是断案的页

1849
02:19:11,040 --> 02:19:13,400
那实际上我们现在重点讲的是页模式

1850
02:19:13,400 --> 02:19:14,860
页式的虚拟存储

1851
02:19:16,120 --> 02:19:18,180
虚拟存储的一些基本特征

1852
02:19:18,620 --> 02:19:20,060
这个我觉得大家都好理解

1853
02:19:20,060 --> 02:19:21,080
不连续性

1854
02:19:21,080 --> 02:19:22,720
虚实地址映射是不连续的

1855
02:19:22,720 --> 02:19:23,840
就特别是物理地址

1856
02:19:53,980 --> 02:19:58,100
这是三个它的基本特征不连续大空间部分交换

1857
02:19:59,140 --> 02:20:03,260
底层支持就是要靠我们的NNM它有个页机制

1858
02:20:04,700 --> 02:20:06,580
第二要有个硬件异常机制

1859
02:20:06,580 --> 02:20:10,460
它能够对页表里面没有映射的那些

1860
02:20:11,280 --> 02:20:12,940
区地质要产生异常

1861
02:20:12,940 --> 02:20:15,800
然后软件你要能够建立这个页表

1862
02:20:15,800 --> 02:20:19,120
能够基于异常需要对它异常是它用到的非常重要的机制

1863
02:20:19,120 --> 02:20:21,940
基于异常来完成换入范畴操作

1864
02:20:21,940 --> 02:20:27,100
从而使得我们的应用程序的地址空间里面

1865
02:20:27,100 --> 02:20:30,080
始终放置的是最常用的一些代码数据

1866
02:20:30,080 --> 02:20:32,040
提高整个的指引效率

1867
02:20:32,040 --> 02:20:34,940
这是他的一个大致的想法

1868
02:20:36,180 --> 02:20:38,760
好 那在这个夜市存储关系书上

1869
02:20:38,760 --> 02:20:39,780
我们到底要做什么事情

1870
02:20:39,780 --> 02:20:43,120
其实做两个 请求调验和页面置换

1871
02:20:43,900 --> 02:20:45,520
把这两个事情做好之后

1872
02:20:45,520 --> 02:20:48,540
你就可以实现提供一个虚的地址空间了

1873
02:20:48,540 --> 02:20:49,780
什么叫请求调验

1874
02:20:49,780 --> 02:20:55,000
真正需要的时候,究竟需要的时候,才把这个页掉进来,你不是究竟需要的,不常用的,

1875
02:20:55,080 --> 02:20:55,720
我就不掉了。

1876
02:20:55,860 --> 02:20:59,660
这属于按需要,实际上是一种惰性的一种思想。

1877
02:21:00,660 --> 02:21:04,540
第二个,页面置换,到底它去把应该的哪些换出去。

1878
02:21:05,160 --> 02:21:07,680
我说了常用不常用,但是什么叫常用,什么叫不常用?

1879
02:21:09,600 --> 02:21:15,260
需要对这个概念进行进一步的定义,那我们后面的不同的置换算法就是

1880
02:21:15,260 --> 02:21:19,020
在于它对这个常用不常用有自己的定义,所以才有不同的算法。

1881
02:21:50,400 --> 02:21:52,760
我们的CPU已经足够了

1882
02:21:52,760 --> 02:21:53,800
它给了我们足够的支持

1883
02:21:53,800 --> 02:21:55,520
这样全是我们软件要干的事情

1884
02:21:55,900 --> 02:21:59,820
软件会在现有的特权异常

1885
02:21:59,820 --> 02:22:03,060
业表这些基本的知识之上

1886
02:22:03,060 --> 02:22:04,940
再去做进步的改进和优化

1887
02:22:07,680 --> 02:22:08,700
处理流程

1888
02:22:08,700 --> 02:22:09,960
我们要大致知道一下

1889
02:22:09,960 --> 02:22:11,900
这个真正缺业异常之后

1890
02:22:11,900 --> 02:22:13,320
这里我们开始强调缺业异常了

1891
02:22:13,320 --> 02:22:14,360
我上堂课讲的时候

1892
02:22:14,360 --> 02:22:16,100
还没有涉及到缺业异常

1893
02:22:16,100 --> 02:22:18,040
在这里面你们需要

1894
02:22:18,040 --> 02:22:23,540
虽然这写的这个步骤1235这些步骤能看明白

1895
02:22:23,540 --> 02:22:24,580
但我还希望大家能够

1896
02:22:24,580 --> 02:22:26,620
如果说我要让大家design一个OS

1897
02:22:26,620 --> 02:22:27,300
测试它的话

1898
02:22:27,300 --> 02:22:29,240
你也能够大致知道怎么去改成一个OS

1899
02:22:30,000 --> 02:22:32,800
而且这段OS现在我们的代码都不存在

1900
02:22:32,800 --> 02:22:35,440
所以也意味着你需要去独立思考

1901
02:22:37,200 --> 02:22:40,020
第一步我们假订是CPU发出一个补请求

1902
02:22:40,020 --> 02:22:43,780
那么在TOB中它会去匹配TOB是MMB的一部分

1903
02:22:43,780 --> 02:22:45,740
去匹配这个虚粒子有没有对应的物理粒子

1904
02:22:45,740 --> 02:22:46,560
没有命中

1905
02:23:16,580 --> 02:23:20,700
CPU就会产生异常,它搞不定,它会产生异常

1906
02:23:20,700 --> 02:23:23,280
把这个异常铺里交给OS处理

1907
02:23:23,280 --> 02:23:26,420
所以这时候软件接管,到第三步的时候是软件案的时候

1908
02:23:26,420 --> 02:23:29,560
前一两步是硬件做的,第三步软件

1909
02:23:30,320 --> 02:23:36,360
软件处理异常会查找保存在外存中对应的应用的页面内容

1910
02:23:36,360 --> 02:23:40,460
它怎么知道保存在外存中对应的应用

1911
02:23:40,460 --> 02:23:42,560
而不是说是一个非法的异常

1912
02:23:57,920 --> 02:24:03,000
这一步留了个问题 大家再想一想

1913
02:24:03,000 --> 02:24:05,640
我其实之前已经讲过

1914
02:24:05,640 --> 02:24:08,240
好 找到之后还存在两种情况

1915
02:24:08,240 --> 02:24:10,380
第一种情况 我还有空闲空间

1916
02:24:10,380 --> 02:24:12,060
我有空闲的物理验证

1917
02:24:12,060 --> 02:24:12,540
我也讲了两种情况

1918
02:24:14,600 --> 02:24:19,960
到现在为止 我们的超级统能够管理它的空闲的物理业真

1919
02:24:20,560 --> 02:24:24,200
如果有空闲物理业真 那就会申请一块空闲物理业真

1920
02:24:24,200 --> 02:24:28,260
然后把外存中的页面人物读进来 写到这边去

1921
02:24:28,260 --> 02:24:31,320
就干这么一个事情 那么这个读是读外存

1922
02:24:31,320 --> 02:24:35,580
意味着要读一个device 这里面细节我们也没有讲

1923
02:24:42,460 --> 02:24:45,620
好 我们简单的说我下段课会把这个讲完

1924
02:24:45,620 --> 02:24:47,600
那我们考试内容就是到这为止

1925
02:24:48,060 --> 02:24:51,080
就是到课程六为止

1926
02:24:51,080 --> 02:24:54,040
课程七我们不会作为考试内容

1927
02:24:54,040 --> 02:24:56,100
你们的内容局限在这个之前

1928
02:24:56,960 --> 02:24:58,540
OK 好 下课

